
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model AccessRights
 * 
 */
export type AccessRights = {
  Id: string
  Name: string | null
  AccessRightKey: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
  Status: string | null
}

/**
 * Model AppIdentityRoles
 * 
 */
export type AppIdentityRoles = {
  Id: string
  Name: string | null
  NormalizedName: string | null
  ConcurrencyStamp: string | null
}

/**
 * Model AppStreamConfigurations
 * 
 */
export type AppStreamConfigurations = {
  Id: string
  RegionEndPoint: number
  FleetName: string
  StackName: string
  ApplicationID: string
  AuthenticationType: number
  URLValidityTime: number | null
  AWSConfigurationsId: string
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model AppStreamUserConnectors
 * 
 */
export type AppStreamUserConnectors = {
  Id: string
  AppStreamARN: string
  AppStreamUserName: string | null
  AppStreamEmailId: string
  AppStreamConfiguration_Id: string
  User_Id: string
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model AuditEntities
 * 
 */
export type AuditEntities = {
  Id: string
  Type: string | null
  ActionBy: string | null
  Details: string | null
  CreatedDate: Date | null
  UserAgent: string | null
  IPAddress: string | null
}

/**
 * Model AuditLogs
 * 
 */
export type AuditLogs = {
  Id: string
  Resource: string | null
  Resource_Id: string | null
  UserAction_Actionkey: string | null
  UserType: string | null
  Repository_Id: string | null
  ActionBy: string | null
  Details: string | null
  CreatedDate: Date | null
  UserAgent: string | null
  IPAddress: string | null
}

/**
 * Model AWSConfigurations
 * 
 */
export type AWSConfigurations = {
  Id: string
  AccessKey: string
  Secretkey: string
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model CreateElementNotifications
 * 
 */
export type CreateElementNotifications = {
  Id: string
  Repository_Id: string
  EnableNotification: number | null
  User_Id: string | null
  UserGroup_Id: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model DashboardReviewUserRoles
 * 
 */
export type DashboardReviewUserRoles = {
  Id: string
  DashboardId: string
  UserRole: string
}

/**
 * Model Dashboards
 * 
 */
export type Dashboards = {
  Id: string
  RepositoryId: string
  Name: string
  Notes: string | null
  Logo: string | null
  IsEnabled: number
  CreatedBy: string
  Created: Date
  Modified: Date
  IsDefault: number | null
  DisplayDescription: number
  Type: string | null
  UserType: string | null
  DashboardSettings: string | null
  Template: number
}

/**
 * Model DashboardUserDefault
 * 
 */
export type DashboardUserDefault = {
  Id: string
  UserId: string
  RepositoryId: string
  DashboardId: string
  Type: string | null
}

/**
 * Model DashboardUserGroups
 * 
 */
export type DashboardUserGroups = {
  Id: string
  DashboardId: string
  UserGroupId: string
}

/**
 * Model DashboardUsers
 * 
 */
export type DashboardUsers = {
  Id: string
  DashboardId: string
  UserId: string
}

/**
 * Model DashboardWidgetBlocks
 * 
 */
export type DashboardWidgetBlocks = {
  Id: string
  DashboardWidgetId: string
  DashboardWidgetBlockTypeId: string
  Title: string | null
  Notes: string | null
  EAArtifactGuid: string | null
  IsConfigured: number
  Position: number | null
}

/**
 * Model DashboardWidgetBlockTypes
 * 
 */
export type DashboardWidgetBlockTypes = {
  Id: string
  Name: string
  Notes: string | null
  Category: string | null
  Position: number
  NotSetText: string
  ConfigurationRequired: number
  IsEnabled: number
  Icon: string | null
}

/**
 * Model DashboardWidgets
 * 
 */
export type DashboardWidgets = {
  Id: string
  DashboardId: string
  Name: string
  Notes: string | null
  RowId: number
  ColumnId: number
  ConfigData: string | null
  SizeX: number
  SizeY: number
  WidgetSettings: string | null
  Template: number
  X: number | null
  Y: number | null
  Rows: number | null
  Cols: number | null
}

/**
 * Model DocumentationRequests
 * 
 */
export type DocumentationRequests = {
  Id: string
  Repository_Id: string
  User_Id: string
  UserDefinedTemplate: number
  InclusionList: string | null
  ExclusionList: string | null
  FileName: string | null
  IsCancelled: number
  IsProcessed: number
  Created: Date
  Modified: Date
}

/**
 * Model DomainRestrictions
 * 
 */
export type DomainRestrictions = {
  Id: string
  Domain: string | null
  IsEnabled: number | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model EAChangelogAttributes
 * 
 */
export type EAChangelogAttributes = {
  Id: string
  EAChangelogId: string
  PropertyGuid: string | null
  Name: string | null
  CurrentValue: string | null
  PreviousValue: string | null
  ActionType: string | null
  AttributeType: string | null
  CreatedDate: Date | null
}

/**
 * Model EAChangelogs
 * 
 */
export type EAChangelogs = {
  Id: string
  Repository_Id: string | null
  ArtifactGuid: string
  ArtifactType: string
  ActionType: string
  Revision: bigint | null
  CreatedDate: Date
  ModifiedDate: Date
}

/**
 * Model ElementConnectors
 * 
 */
export type ElementConnectors = {
  Id: string
  ElementGuid: string | null
  ElementType: string | null
  Repository_Id: string | null
  User_Id: string | null
  UserGroup_Id: string | null
  AccessRight_AccessRightKey: string | null
  InheritRight: number | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
  Status: string | null
  CreatedBy: string | null
  FeatureId: string | null
  OtherInfo: string | null
}

/**
 * Model ExternalAppAttributeMaster
 * 
 */
export type ExternalAppAttributeMaster = {
  Id: string
  ExternalAppTypeId: string
  ExternalAppId: string
  RepositoryId: string
  Name: string
  InternalName: string
  ExternalName: string
  HelpText: string | null
  MultiSelect: number
  Filters: string | null
  ConfigData: string | null
  IsEnabled: number
  Created: Date
  Modified: Date
  Description: string | null
}

/**
 * Model ExternalAppAttributes
 * 
 */
export type ExternalAppAttributes = {
  Id: string
  ExternalAppAttributeMasterId: string
  ExternalAppProjectId: string
  ArtifactId: string
  InternalValue: string
  ExternalValue: string
  ConfigData: string
  IsDeleted: number
  RemoteLinkId: string | null
  Created: Date
  Modified: Date
}

/**
 * Model ExternalApps
 * 
 */
export type ExternalApps = {
  Id: string
  ExternalAppTypeId: string | null
  ExternalAppEnvironment: string | null
  RepositoryId: string | null
  Name: string | null
  Description: string | null
  EndPointURL: string | null
  IsExternal: number | null
  ExternalPath: string | null
  Username: string | null
  Password: string | null
  ProjectId: string | null
  ProjectName: string | null
  ConfigData: string | null
  IsEnabled: number
  Created: Date
  Modified: Date | null
}

/**
 * Model ExternalAppTypes
 * 
 */
export type ExternalAppTypes = {
  Id: string
  Name: string | null
  Description: string | null
  IsExternal: number | null
  ExternalPath: string | null
  Logo: string | null
  Position: number
  IsEnabled: number
  AppContent: string | null
}

/**
 * Model Features
 * 
 */
export type Features = {
  Id: string
  Name: string | null
  Status: string | null
  CreatedDate: Date | null
  FeatureKey: string | null
}

/**
 * Model FilterProfileConnectors
 * 
 */
export type FilterProfileConnectors = {
  Id: string
  RepositoryId: string
  ProfileId: string
  CreatedDate: Date | null
  ModifiedDate: Date | null
  CreatedBy: string | null
  ModifiedBy: string | null
}

/**
 * Model FilterProfiles
 * 
 */
export type FilterProfiles = {
  Id: string
  Name: string | null
  Type: string | null
  Status: number
  Configuration: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
  CreatedBy: string | null
  ModifiedBy: string | null
  IsCacheEnabled: number | null
}

/**
 * Model GlobalRepositoryConfigurations
 * 
 */
export type GlobalRepositoryConfigurations = {
  Id: string
  Name: string
  IsReadOnly: number
  RepositoryConfiguration: string | null
  AllowAllRepository: number
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model GroupFeatures
 * 
 */
export type GroupFeatures = {
  Id: string
  UserGroup_Id: string | null
  Feature_Id: string | null
  CreatedDate: Date | null
  Status: string | null
}

/**
 * Model GuestSignupSettings
 * 
 */
export type GuestSignupSettings = {
  Id: string
  GlobalRepoConfigId: string | null
  AllowAllRepository: number | null
  RepositoryPermissions: string | null
  Status: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model IdPConnections
 * 
 */
export type IdPConnections = {
  Id: string
  Name: string | null
  SigninUrl: string | null
  CertificatePath: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
  Status: string | null
  AllowAllRepository: number | null
  RepositoryPermissions: string | null
  RepositoryPermissionId: string | null
  IdPSource: string | null
  LogoutUrl: string | null
  IDPCertificateEncrypted: string | null
  SPCertificateEncrypted: string | null
  SPCertificatePath: string | null
  SPCertificatePassword: string | null
  GlobalRepoConfigId: string | null
  AttributesMapping: string | null
}

/**
 * Model LDAPConnections
 * 
 */
export type LDAPConnections = {
  Id: string
  Name: string | null
  Server: string | null
  Port: number | null
  Domain: string | null
  UserName: string | null
  Password: string | null
  SSL: number | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
  Status: string | null
}

/**
 * Model MDGProfileConnectors
 * 
 */
export type MDGProfileConnectors = {
  Id: string
  UserGroupId: string | null
  ProfileId: string | null
  MdgId: string | null
  RepositoryId: string | null
  Status: number | null
  CreatedDate: Date | null
}

/**
 * Model MDGTechnologies
 * 
 */
export type MDGTechnologies = {
  Id: string
  Repository_Id: string
  Name: string
  InternalName: string | null
  Description: string | null
  XmlContent: string | null
  BuiltIn: number
  IsEnabled: number
  Created: Date
  Modified: Date
}

/**
 * Model MenuItemProfileConnectors
 * 
 */
export type MenuItemProfileConnectors = {
  Id: string
  Repository_Id: string | null
  User_Id: string | null
  UserGroup_Id: string | null
  Profile_Id: string | null
  Default_Profile_Id: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model MenuItemProfiles
 * 
 */
export type MenuItemProfiles = {
  Id: string
  Repository_Id: string | null
  Name: string | null
  Type: string | null
  Status: number
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model MenuItemProfileSettings
 * 
 */
export type MenuItemProfileSettings = {
  Id: string
  Profile_Id: string | null
  MenuItemKey: string | null
  IsVisible: number | null
  IfShowOnlyContent: number | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model MenuViewHistory
 * 
 */
export type MenuViewHistory = {
  Id: string
  RepositoryId: string | null
  UserId: string | null
  PageKeys: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model OIDCApplications
 * 
 */
export type OIDCApplications = {
  Id: string
  ClientId: string | null
  ClientSecret: string | null
  ConcurrencyToken: string | null
  ConsentType: string | null
  DisplayName: string | null
  DisplayNames: string | null
  Permissions: string | null
  PostLogoutRedirectUris: string | null
  Properties: string | null
  RedirectUris: string | null
  Requirements: string | null
  Type: string | null
}

/**
 * Model OIDCAuthorizations
 * 
 */
export type OIDCAuthorizations = {
  Id: string
  ApplicationId: string | null
  ConcurrencyToken: string | null
  CreationDate: Date | null
  Properties: string | null
  Scopes: string | null
  Status: string | null
  Subject: string | null
  Type: string | null
}

/**
 * Model OIDCScopes
 * 
 */
export type OIDCScopes = {
  Id: string
  ConcurrencyToken: string | null
  Description: string | null
  Descriptions: string | null
  DisplayName: string | null
  DisplayNames: string | null
  Name: string | null
  Properties: string | null
  Resources: string | null
}

/**
 * Model OIDCTokens
 * 
 */
export type OIDCTokens = {
  Id: string
  ApplicationId: string | null
  AuthorizationId: string | null
  ConcurrencyToken: string | null
  CreationDate: Date | null
  ExpirationDate: Date | null
  Payload: string | null
  Properties: string | null
  RedemptionDate: Date | null
  ReferenceId: string | null
  Status: string | null
  Subject: string | null
  Type: string | null
}

/**
 * Model Profiles
 * 
 */
export type Profiles = {
  Id: string
  MDGTechnology_Id: string
  Name: string
  Description: string | null
  ProfileContent: string | null
  IsDefault: number
  IsEnabled: number
  Created: Date
  Modified: Date
  EnableTechnologyGroup: number
  EnableInheritedGroup: number
  IncludeBaseAttributes: number
}

/**
 * Model PropertyMenuItemConnectors
 * 
 */
export type PropertyMenuItemConnectors = {
  Id: string
  MenuItemKey: string | null
  PageType: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model PropertyMenuItems
 * 
 */
export type PropertyMenuItems = {
  Id: string
  MenuItemKey: string | null
  Name: string | null
  Description: string | null
  IconClass: string
  Position: number
  Status: number
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model Repositories
 * 
 */
export type Repositories = {
  Id: string
  Name: string | null
  Alias: string | null
  Description: string | null
  EAPFile: string | null
  IsCacheEnabled: number | null
  AuthRequired: number | null
  UserName: string | null
  Password: string | null
  IsEnabled: number | null
  InstanceCount: number | null
  Created: Date
  Modified: Date
  Status: string | null
  Protocol: string | null
  Server: string | null
  Port: string | null
  Model: string | null
  OslcAccessCode: string | null
  EAUserAuth: number | null
  UserIdentifier: string | null
  DBType: number | null
}

/**
 * Model RepositoryConnectors
 * 
 */
export type RepositoryConnectors = {
  Id: string
  Repository_Id: string
  User_Id: string | null
  UserGroup_Id: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
  Status: string | null
  Dashboard_Id: string | null
  EAUserAuth: number | null
  IsUserDefault: number | null
}

/**
 * Model RepositoryDBConnections
 * 
 */
export type RepositoryDBConnections = {
  Id: string
  Repository_Id: string | null
  CreateElement: number | null
  ConnectionType: string | null
  ConnectionDetail: string | null
  DBType: string | null
  Server: string | null
  Port: string | null
  DBName: string | null
  Username: string | null
  Password: string | null
  DsnName: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model RequestLogs
 * 
 */
export type RequestLogs = {
  Id: string
  RequestedUserId: string | null
  DesignatedUserId: string | null
  Url: string | null
  UrlType: string | null
  RequestedUserAgent: string | null
  RequestedUserIpAddress: string | null
  DesignatedUserAgent: string | null
  DesignatedUserIpAddress: string | null
  Created: Date | null
  Modified: Date | null
  LastVisited: Date | null
  Status: number | null
  Validity: Date | null
}

/**
 * Model ReservedUsers
 * 
 */
export type ReservedUsers = {
  Id: string
  User_Id: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model ResourceFiles
 * 
 */
export type ResourceFiles = {
  Id: string
  MapItemId: string | null
  FileContent: Buffer | null
  FilePath: string | null
  Extension: string | null
  Name: string | null
  ModifiedDate: Date
  CreatedDate: Date
}

/**
 * Model Resources
 * 
 */
export type Resources = {
  Id: string
  ResourceName: string | null
}

/**
 * Model ReviewProcesses
 * 
 */
export type ReviewProcesses = {
  Id: string
  Name: string | null
  Notes: string | null
  ReviewStartDate: Date | null
  ReviewEndDate: Date | null
  ApproveStartDate: Date | null
  ApproveEndDate: Date | null
  WorkFlow: number | null
  AutoStatusUpdate: number | null
  ReviewStartType: number | null
  ElementRecursiveSelection: number | null
  ExternalUsersInvite: number | null
  EnableShare: number | null
  EmailNotification: number | null
  Mode: string | null
  Repository_Id: string | null
  User_Id: string | null
  Status: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model TaggedValues
 * 
 */
export type TaggedValues = {
  Id: string
  RepositoryId: string
  Name: string
  Description: string | null
  Type: string
  DefaultValue: string | null
  AttributeValues: string | null
  LowerBound: number | null
  UpperBound: number | null
  Stereotypes: string | null
  AppliesTo: string | null
  BaseStereotype: string | null
}

/**
 * Model TraceabilityTreeProfiles
 * 
 */
export type TraceabilityTreeProfiles = {
  Id: string
  ProfileName: string | null
  RepositoryId: string | null
  ElementGuid: string | null
  Type: string | null
  SteroType: string | null
  FQName: string | null
  Technology: string | null
  TemplateOptions: string | null
  User_Id: string | null
  Status: number | null
  IsApplytoAll: number | null
  IsApplytoType: number | null
  IsApplytoSteroType: number | null
  Created: Date | null
  Modified: Date | null
  ElementTypeList: string | null
  ConnectorTypeList: string | null
  FlowDirectionTypeList: string | null
  TreeType: string | null
}

/**
 * Model TraceabilityTreeViews
 * 
 */
export type TraceabilityTreeViews = {
  Id: string
  RepositoryId: string | null
  ElementGuid: string | null
  TreeViewData: string | null
  User_Id: string | null
  Created: Date | null
  Modified: Date | null
  FilterItems: string | null
  Tittle: string | null
  Revision: string | null
  ViewId: string | null
  TemplateOptions: string | null
  Description: string | null
  NlFilterItems: string | null
  NlTreeData: string | null
  NlFilterItemStatus: string | null
  FilterAppliedNodeList: string | null
  TotForceLinks: string | null
}

/**
 * Model URLMap
 * 
 */
export type URLMap = {
  Id: bigint
  URL: string
  URLType: string | null
  HashCode: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
  Repository_Id: string | null
  LinkType: string | null
  MapurlId: string | null
}

/**
 * Model UserActions
 * 
 */
export type UserActions = {
  Id: string
  ActionName: string | null
  Actionkey: string | null
  Resource_id: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
  Status: string | null
}

/**
 * Model UserGroupConnectors
 * 
 */
export type UserGroupConnectors = {
  Id: string
  UserGroup_Id: string | null
  User_Id: string | null
  Status: string | null
  CreatedDate: Date | null
}

/**
 * Model UserGroups
 * 
 */
export type UserGroups = {
  Id: string
  GroupName: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
  EditFeatures: number | null
  Status: string | null
  UserGroups_Role_Id: string | null
  IsReadOnly: number
}

/**
 * Model UserIdentityClaims
 * 
 */
export type UserIdentityClaims = {
  Id: number
  UserId: string
  ClaimType: string | null
  ClaimValue: string | null
}

/**
 * Model UserIdentityLogins
 * 
 */
export type UserIdentityLogins = {
  LoginProvider: string
  ProviderKey: string
  ProviderDisplayName: string | null
  UserId: string
}

/**
 * Model UserIdentityRoleClaims
 * 
 */
export type UserIdentityRoleClaims = {
  Id: number
  RoleId: string
  ClaimType: string | null
  ClaimValue: string | null
}

/**
 * Model UserIdentityRoles
 * 
 */
export type UserIdentityRoles = {
  UserId: string
  RoleId: string
}

/**
 * Model UserIdentityTokens
 * 
 */
export type UserIdentityTokens = {
  UserId: string
  LoginProvider: string
  Name: string
  Value: string | null
}

/**
 * Model UserProfileSetting
 * 
 */
export type UserProfileSetting = {
  Id: string
  UserId: string | null
  RepositoryTechnologyConfiguration: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
}

/**
 * Model UserRoleProfiles
 * 
 */
export type UserRoleProfiles = {
  Id: string
  UserRole_Id: string
  Profile_Id: string
  Created: Date
  Modified: Date
}

/**
 * Model UserRoles
 * 
 */
export type UserRoles = {
  Id: string
  Name: string
  Description: string | null
  UIEnabled: number
}

/**
 * Model Users
 * 
 */
export type Users = {
  Id: string
  LDAPConnection_Id: string | null
  FirstName: string | null
  LastName: string | null
  UserRole_Id: string | null
  Status: string | null
  EmailId: string | null
  Password: string | null
  CreatedDate: Date | null
  ModifiedDate: Date | null
  Description: string | null
  ProfileImage: string | null
  CreatedBy: string | null
  ModifiedBy: string | null
  RegistrationMode: string | null
  Timezone: string | null
  IsPasswordSet: number | null
  IsAdmin: number | null
  ShowHelpText: number | null
  IdentityProvider_Id: string | null
  SecPhrase: string | null
  IsReadOnly: number
  UserIdentityRole: string | null
  UserName: string | null
  NormalizedUserName: string | null
  Email: string | null
  NormalizedEmail: string | null
  EmailConfirmed: boolean | null
  SecurityStamp: string | null
  ConcurrencyStamp: string | null
  PhoneNumber: string | null
  PhoneNumberConfirmed: boolean | null
  PasswordHash: string | null
  TwoFactorEnabled: boolean | null
  LockoutEnd: Date | null
  LockoutEnabled: boolean | null
  AccessFailedCount: number | null
}

/**
 * Model UserSessions
 * 
 */
export type UserSessions = {
  Id: string
  UserId: string
  IsReservedUser: number
  AccessMode: string
  IPAddress: string
  UserAgent: string
  IsActive: number
  LastRequest: Date
  Created: Date
  Modified: Date
  UserDisplayName: string | null
  UserType: string | null
}

/**
 * Model UserSessionsArchive
 * 
 */
export type UserSessionsArchive = {
  Id: string
  UserId: string
  IsReservedUser: number
  AccessMode: string
  IPAddress: string
  UserAgent: string
  IsActive: number
  LastRequest: Date
  Created: Date
  Modified: Date
  UserDisplayName: string | null
  UserType: string | null
}

/**
 * Model UserTokens
 * 
 */
export type UserTokens = {
  Id: string
  UserId: string | null
  RefreshToken: string | null
  CreatedDate: Date | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AccessRights
 * const accessRights = await prisma.accessRights.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AccessRights
   * const accessRights = await prisma.accessRights.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


      /**
   * `prisma.accessRights`: Exposes CRUD operations for the **AccessRights** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccessRights
    * const accessRights = await prisma.accessRights.findMany()
    * ```
    */
  get accessRights(): Prisma.AccessRightsDelegate<GlobalReject>;

  /**
   * `prisma.appIdentityRoles`: Exposes CRUD operations for the **AppIdentityRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppIdentityRoles
    * const appIdentityRoles = await prisma.appIdentityRoles.findMany()
    * ```
    */
  get appIdentityRoles(): Prisma.AppIdentityRolesDelegate<GlobalReject>;

  /**
   * `prisma.appStreamConfigurations`: Exposes CRUD operations for the **AppStreamConfigurations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppStreamConfigurations
    * const appStreamConfigurations = await prisma.appStreamConfigurations.findMany()
    * ```
    */
  get appStreamConfigurations(): Prisma.AppStreamConfigurationsDelegate<GlobalReject>;

  /**
   * `prisma.appStreamUserConnectors`: Exposes CRUD operations for the **AppStreamUserConnectors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppStreamUserConnectors
    * const appStreamUserConnectors = await prisma.appStreamUserConnectors.findMany()
    * ```
    */
  get appStreamUserConnectors(): Prisma.AppStreamUserConnectorsDelegate<GlobalReject>;

  /**
   * `prisma.auditEntities`: Exposes CRUD operations for the **AuditEntities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditEntities
    * const auditEntities = await prisma.auditEntities.findMany()
    * ```
    */
  get auditEntities(): Prisma.AuditEntitiesDelegate<GlobalReject>;

  /**
   * `prisma.auditLogs`: Exposes CRUD operations for the **AuditLogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLogs.findMany()
    * ```
    */
  get auditLogs(): Prisma.AuditLogsDelegate<GlobalReject>;

  /**
   * `prisma.aWSConfigurations`: Exposes CRUD operations for the **AWSConfigurations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AWSConfigurations
    * const aWSConfigurations = await prisma.aWSConfigurations.findMany()
    * ```
    */
  get aWSConfigurations(): Prisma.AWSConfigurationsDelegate<GlobalReject>;

  /**
   * `prisma.createElementNotifications`: Exposes CRUD operations for the **CreateElementNotifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreateElementNotifications
    * const createElementNotifications = await prisma.createElementNotifications.findMany()
    * ```
    */
  get createElementNotifications(): Prisma.CreateElementNotificationsDelegate<GlobalReject>;

  /**
   * `prisma.dashboardReviewUserRoles`: Exposes CRUD operations for the **DashboardReviewUserRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardReviewUserRoles
    * const dashboardReviewUserRoles = await prisma.dashboardReviewUserRoles.findMany()
    * ```
    */
  get dashboardReviewUserRoles(): Prisma.DashboardReviewUserRolesDelegate<GlobalReject>;

  /**
   * `prisma.dashboards`: Exposes CRUD operations for the **Dashboards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dashboards
    * const dashboards = await prisma.dashboards.findMany()
    * ```
    */
  get dashboards(): Prisma.DashboardsDelegate<GlobalReject>;

  /**
   * `prisma.dashboardUserDefault`: Exposes CRUD operations for the **DashboardUserDefault** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardUserDefaults
    * const dashboardUserDefaults = await prisma.dashboardUserDefault.findMany()
    * ```
    */
  get dashboardUserDefault(): Prisma.DashboardUserDefaultDelegate<GlobalReject>;

  /**
   * `prisma.dashboardUserGroups`: Exposes CRUD operations for the **DashboardUserGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardUserGroups
    * const dashboardUserGroups = await prisma.dashboardUserGroups.findMany()
    * ```
    */
  get dashboardUserGroups(): Prisma.DashboardUserGroupsDelegate<GlobalReject>;

  /**
   * `prisma.dashboardUsers`: Exposes CRUD operations for the **DashboardUsers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardUsers
    * const dashboardUsers = await prisma.dashboardUsers.findMany()
    * ```
    */
  get dashboardUsers(): Prisma.DashboardUsersDelegate<GlobalReject>;

  /**
   * `prisma.dashboardWidgetBlocks`: Exposes CRUD operations for the **DashboardWidgetBlocks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardWidgetBlocks
    * const dashboardWidgetBlocks = await prisma.dashboardWidgetBlocks.findMany()
    * ```
    */
  get dashboardWidgetBlocks(): Prisma.DashboardWidgetBlocksDelegate<GlobalReject>;

  /**
   * `prisma.dashboardWidgetBlockTypes`: Exposes CRUD operations for the **DashboardWidgetBlockTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardWidgetBlockTypes
    * const dashboardWidgetBlockTypes = await prisma.dashboardWidgetBlockTypes.findMany()
    * ```
    */
  get dashboardWidgetBlockTypes(): Prisma.DashboardWidgetBlockTypesDelegate<GlobalReject>;

  /**
   * `prisma.dashboardWidgets`: Exposes CRUD operations for the **DashboardWidgets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardWidgets
    * const dashboardWidgets = await prisma.dashboardWidgets.findMany()
    * ```
    */
  get dashboardWidgets(): Prisma.DashboardWidgetsDelegate<GlobalReject>;

  /**
   * `prisma.documentationRequests`: Exposes CRUD operations for the **DocumentationRequests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentationRequests
    * const documentationRequests = await prisma.documentationRequests.findMany()
    * ```
    */
  get documentationRequests(): Prisma.DocumentationRequestsDelegate<GlobalReject>;

  /**
   * `prisma.domainRestrictions`: Exposes CRUD operations for the **DomainRestrictions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainRestrictions
    * const domainRestrictions = await prisma.domainRestrictions.findMany()
    * ```
    */
  get domainRestrictions(): Prisma.DomainRestrictionsDelegate<GlobalReject>;

  /**
   * `prisma.eAChangelogAttributes`: Exposes CRUD operations for the **EAChangelogAttributes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EAChangelogAttributes
    * const eAChangelogAttributes = await prisma.eAChangelogAttributes.findMany()
    * ```
    */
  get eAChangelogAttributes(): Prisma.EAChangelogAttributesDelegate<GlobalReject>;

  /**
   * `prisma.eAChangelogs`: Exposes CRUD operations for the **EAChangelogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EAChangelogs
    * const eAChangelogs = await prisma.eAChangelogs.findMany()
    * ```
    */
  get eAChangelogs(): Prisma.EAChangelogsDelegate<GlobalReject>;

  /**
   * `prisma.elementConnectors`: Exposes CRUD operations for the **ElementConnectors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ElementConnectors
    * const elementConnectors = await prisma.elementConnectors.findMany()
    * ```
    */
  get elementConnectors(): Prisma.ElementConnectorsDelegate<GlobalReject>;

  /**
   * `prisma.externalAppAttributeMaster`: Exposes CRUD operations for the **ExternalAppAttributeMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalAppAttributeMasters
    * const externalAppAttributeMasters = await prisma.externalAppAttributeMaster.findMany()
    * ```
    */
  get externalAppAttributeMaster(): Prisma.ExternalAppAttributeMasterDelegate<GlobalReject>;

  /**
   * `prisma.externalAppAttributes`: Exposes CRUD operations for the **ExternalAppAttributes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalAppAttributes
    * const externalAppAttributes = await prisma.externalAppAttributes.findMany()
    * ```
    */
  get externalAppAttributes(): Prisma.ExternalAppAttributesDelegate<GlobalReject>;

  /**
   * `prisma.externalApps`: Exposes CRUD operations for the **ExternalApps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalApps
    * const externalApps = await prisma.externalApps.findMany()
    * ```
    */
  get externalApps(): Prisma.ExternalAppsDelegate<GlobalReject>;

  /**
   * `prisma.externalAppTypes`: Exposes CRUD operations for the **ExternalAppTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalAppTypes
    * const externalAppTypes = await prisma.externalAppTypes.findMany()
    * ```
    */
  get externalAppTypes(): Prisma.ExternalAppTypesDelegate<GlobalReject>;

  /**
   * `prisma.features`: Exposes CRUD operations for the **Features** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Features
    * const features = await prisma.features.findMany()
    * ```
    */
  get features(): Prisma.FeaturesDelegate<GlobalReject>;

  /**
   * `prisma.filterProfileConnectors`: Exposes CRUD operations for the **FilterProfileConnectors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FilterProfileConnectors
    * const filterProfileConnectors = await prisma.filterProfileConnectors.findMany()
    * ```
    */
  get filterProfileConnectors(): Prisma.FilterProfileConnectorsDelegate<GlobalReject>;

  /**
   * `prisma.filterProfiles`: Exposes CRUD operations for the **FilterProfiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FilterProfiles
    * const filterProfiles = await prisma.filterProfiles.findMany()
    * ```
    */
  get filterProfiles(): Prisma.FilterProfilesDelegate<GlobalReject>;

  /**
   * `prisma.globalRepositoryConfigurations`: Exposes CRUD operations for the **GlobalRepositoryConfigurations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GlobalRepositoryConfigurations
    * const globalRepositoryConfigurations = await prisma.globalRepositoryConfigurations.findMany()
    * ```
    */
  get globalRepositoryConfigurations(): Prisma.GlobalRepositoryConfigurationsDelegate<GlobalReject>;

  /**
   * `prisma.groupFeatures`: Exposes CRUD operations for the **GroupFeatures** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupFeatures
    * const groupFeatures = await prisma.groupFeatures.findMany()
    * ```
    */
  get groupFeatures(): Prisma.GroupFeaturesDelegate<GlobalReject>;

  /**
   * `prisma.guestSignupSettings`: Exposes CRUD operations for the **GuestSignupSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuestSignupSettings
    * const guestSignupSettings = await prisma.guestSignupSettings.findMany()
    * ```
    */
  get guestSignupSettings(): Prisma.GuestSignupSettingsDelegate<GlobalReject>;

  /**
   * `prisma.idPConnections`: Exposes CRUD operations for the **IdPConnections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IdPConnections
    * const idPConnections = await prisma.idPConnections.findMany()
    * ```
    */
  get idPConnections(): Prisma.IdPConnectionsDelegate<GlobalReject>;

  /**
   * `prisma.lDAPConnections`: Exposes CRUD operations for the **LDAPConnections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LDAPConnections
    * const lDAPConnections = await prisma.lDAPConnections.findMany()
    * ```
    */
  get lDAPConnections(): Prisma.LDAPConnectionsDelegate<GlobalReject>;

  /**
   * `prisma.mDGProfileConnectors`: Exposes CRUD operations for the **MDGProfileConnectors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MDGProfileConnectors
    * const mDGProfileConnectors = await prisma.mDGProfileConnectors.findMany()
    * ```
    */
  get mDGProfileConnectors(): Prisma.MDGProfileConnectorsDelegate<GlobalReject>;

  /**
   * `prisma.mDGTechnologies`: Exposes CRUD operations for the **MDGTechnologies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MDGTechnologies
    * const mDGTechnologies = await prisma.mDGTechnologies.findMany()
    * ```
    */
  get mDGTechnologies(): Prisma.MDGTechnologiesDelegate<GlobalReject>;

  /**
   * `prisma.menuItemProfileConnectors`: Exposes CRUD operations for the **MenuItemProfileConnectors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuItemProfileConnectors
    * const menuItemProfileConnectors = await prisma.menuItemProfileConnectors.findMany()
    * ```
    */
  get menuItemProfileConnectors(): Prisma.MenuItemProfileConnectorsDelegate<GlobalReject>;

  /**
   * `prisma.menuItemProfiles`: Exposes CRUD operations for the **MenuItemProfiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuItemProfiles
    * const menuItemProfiles = await prisma.menuItemProfiles.findMany()
    * ```
    */
  get menuItemProfiles(): Prisma.MenuItemProfilesDelegate<GlobalReject>;

  /**
   * `prisma.menuItemProfileSettings`: Exposes CRUD operations for the **MenuItemProfileSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuItemProfileSettings
    * const menuItemProfileSettings = await prisma.menuItemProfileSettings.findMany()
    * ```
    */
  get menuItemProfileSettings(): Prisma.MenuItemProfileSettingsDelegate<GlobalReject>;

  /**
   * `prisma.menuViewHistory`: Exposes CRUD operations for the **MenuViewHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuViewHistories
    * const menuViewHistories = await prisma.menuViewHistory.findMany()
    * ```
    */
  get menuViewHistory(): Prisma.MenuViewHistoryDelegate<GlobalReject>;

  /**
   * `prisma.oIDCApplications`: Exposes CRUD operations for the **OIDCApplications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OIDCApplications
    * const oIDCApplications = await prisma.oIDCApplications.findMany()
    * ```
    */
  get oIDCApplications(): Prisma.OIDCApplicationsDelegate<GlobalReject>;

  /**
   * `prisma.oIDCAuthorizations`: Exposes CRUD operations for the **OIDCAuthorizations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OIDCAuthorizations
    * const oIDCAuthorizations = await prisma.oIDCAuthorizations.findMany()
    * ```
    */
  get oIDCAuthorizations(): Prisma.OIDCAuthorizationsDelegate<GlobalReject>;

  /**
   * `prisma.oIDCScopes`: Exposes CRUD operations for the **OIDCScopes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OIDCScopes
    * const oIDCScopes = await prisma.oIDCScopes.findMany()
    * ```
    */
  get oIDCScopes(): Prisma.OIDCScopesDelegate<GlobalReject>;

  /**
   * `prisma.oIDCTokens`: Exposes CRUD operations for the **OIDCTokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OIDCTokens
    * const oIDCTokens = await prisma.oIDCTokens.findMany()
    * ```
    */
  get oIDCTokens(): Prisma.OIDCTokensDelegate<GlobalReject>;

  /**
   * `prisma.profiles`: Exposes CRUD operations for the **Profiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profiles.findMany()
    * ```
    */
  get profiles(): Prisma.ProfilesDelegate<GlobalReject>;

  /**
   * `prisma.propertyMenuItemConnectors`: Exposes CRUD operations for the **PropertyMenuItemConnectors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyMenuItemConnectors
    * const propertyMenuItemConnectors = await prisma.propertyMenuItemConnectors.findMany()
    * ```
    */
  get propertyMenuItemConnectors(): Prisma.PropertyMenuItemConnectorsDelegate<GlobalReject>;

  /**
   * `prisma.propertyMenuItems`: Exposes CRUD operations for the **PropertyMenuItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyMenuItems
    * const propertyMenuItems = await prisma.propertyMenuItems.findMany()
    * ```
    */
  get propertyMenuItems(): Prisma.PropertyMenuItemsDelegate<GlobalReject>;

  /**
   * `prisma.repositories`: Exposes CRUD operations for the **Repositories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Repositories
    * const repositories = await prisma.repositories.findMany()
    * ```
    */
  get repositories(): Prisma.RepositoriesDelegate<GlobalReject>;

  /**
   * `prisma.repositoryConnectors`: Exposes CRUD operations for the **RepositoryConnectors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepositoryConnectors
    * const repositoryConnectors = await prisma.repositoryConnectors.findMany()
    * ```
    */
  get repositoryConnectors(): Prisma.RepositoryConnectorsDelegate<GlobalReject>;

  /**
   * `prisma.repositoryDBConnections`: Exposes CRUD operations for the **RepositoryDBConnections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepositoryDBConnections
    * const repositoryDBConnections = await prisma.repositoryDBConnections.findMany()
    * ```
    */
  get repositoryDBConnections(): Prisma.RepositoryDBConnectionsDelegate<GlobalReject>;

  /**
   * `prisma.requestLogs`: Exposes CRUD operations for the **RequestLogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestLogs
    * const requestLogs = await prisma.requestLogs.findMany()
    * ```
    */
  get requestLogs(): Prisma.RequestLogsDelegate<GlobalReject>;

  /**
   * `prisma.reservedUsers`: Exposes CRUD operations for the **ReservedUsers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReservedUsers
    * const reservedUsers = await prisma.reservedUsers.findMany()
    * ```
    */
  get reservedUsers(): Prisma.ReservedUsersDelegate<GlobalReject>;

  /**
   * `prisma.resourceFiles`: Exposes CRUD operations for the **ResourceFiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResourceFiles
    * const resourceFiles = await prisma.resourceFiles.findMany()
    * ```
    */
  get resourceFiles(): Prisma.ResourceFilesDelegate<GlobalReject>;

  /**
   * `prisma.resources`: Exposes CRUD operations for the **Resources** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resources.findMany()
    * ```
    */
  get resources(): Prisma.ResourcesDelegate<GlobalReject>;

  /**
   * `prisma.reviewProcesses`: Exposes CRUD operations for the **ReviewProcesses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewProcesses
    * const reviewProcesses = await prisma.reviewProcesses.findMany()
    * ```
    */
  get reviewProcesses(): Prisma.ReviewProcessesDelegate<GlobalReject>;

  /**
   * `prisma.taggedValues`: Exposes CRUD operations for the **TaggedValues** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaggedValues
    * const taggedValues = await prisma.taggedValues.findMany()
    * ```
    */
  get taggedValues(): Prisma.TaggedValuesDelegate<GlobalReject>;

  /**
   * `prisma.traceabilityTreeProfiles`: Exposes CRUD operations for the **TraceabilityTreeProfiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TraceabilityTreeProfiles
    * const traceabilityTreeProfiles = await prisma.traceabilityTreeProfiles.findMany()
    * ```
    */
  get traceabilityTreeProfiles(): Prisma.TraceabilityTreeProfilesDelegate<GlobalReject>;

  /**
   * `prisma.traceabilityTreeViews`: Exposes CRUD operations for the **TraceabilityTreeViews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TraceabilityTreeViews
    * const traceabilityTreeViews = await prisma.traceabilityTreeViews.findMany()
    * ```
    */
  get traceabilityTreeViews(): Prisma.TraceabilityTreeViewsDelegate<GlobalReject>;

  /**
   * `prisma.uRLMap`: Exposes CRUD operations for the **URLMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more URLMaps
    * const uRLMaps = await prisma.uRLMap.findMany()
    * ```
    */
  get uRLMap(): Prisma.URLMapDelegate<GlobalReject>;

  /**
   * `prisma.userActions`: Exposes CRUD operations for the **UserActions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserActions
    * const userActions = await prisma.userActions.findMany()
    * ```
    */
  get userActions(): Prisma.UserActionsDelegate<GlobalReject>;

  /**
   * `prisma.userGroupConnectors`: Exposes CRUD operations for the **UserGroupConnectors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGroupConnectors
    * const userGroupConnectors = await prisma.userGroupConnectors.findMany()
    * ```
    */
  get userGroupConnectors(): Prisma.UserGroupConnectorsDelegate<GlobalReject>;

  /**
   * `prisma.userGroups`: Exposes CRUD operations for the **UserGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGroups
    * const userGroups = await prisma.userGroups.findMany()
    * ```
    */
  get userGroups(): Prisma.UserGroupsDelegate<GlobalReject>;

  /**
   * `prisma.userIdentityClaims`: Exposes CRUD operations for the **UserIdentityClaims** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserIdentityClaims
    * const userIdentityClaims = await prisma.userIdentityClaims.findMany()
    * ```
    */
  get userIdentityClaims(): Prisma.UserIdentityClaimsDelegate<GlobalReject>;

  /**
   * `prisma.userIdentityLogins`: Exposes CRUD operations for the **UserIdentityLogins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserIdentityLogins
    * const userIdentityLogins = await prisma.userIdentityLogins.findMany()
    * ```
    */
  get userIdentityLogins(): Prisma.UserIdentityLoginsDelegate<GlobalReject>;

  /**
   * `prisma.userIdentityRoleClaims`: Exposes CRUD operations for the **UserIdentityRoleClaims** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserIdentityRoleClaims
    * const userIdentityRoleClaims = await prisma.userIdentityRoleClaims.findMany()
    * ```
    */
  get userIdentityRoleClaims(): Prisma.UserIdentityRoleClaimsDelegate<GlobalReject>;

  /**
   * `prisma.userIdentityRoles`: Exposes CRUD operations for the **UserIdentityRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserIdentityRoles
    * const userIdentityRoles = await prisma.userIdentityRoles.findMany()
    * ```
    */
  get userIdentityRoles(): Prisma.UserIdentityRolesDelegate<GlobalReject>;

  /**
   * `prisma.userIdentityTokens`: Exposes CRUD operations for the **UserIdentityTokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserIdentityTokens
    * const userIdentityTokens = await prisma.userIdentityTokens.findMany()
    * ```
    */
  get userIdentityTokens(): Prisma.UserIdentityTokensDelegate<GlobalReject>;

  /**
   * `prisma.userProfileSetting`: Exposes CRUD operations for the **UserProfileSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfileSettings
    * const userProfileSettings = await prisma.userProfileSetting.findMany()
    * ```
    */
  get userProfileSetting(): Prisma.UserProfileSettingDelegate<GlobalReject>;

  /**
   * `prisma.userRoleProfiles`: Exposes CRUD operations for the **UserRoleProfiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoleProfiles
    * const userRoleProfiles = await prisma.userRoleProfiles.findMany()
    * ```
    */
  get userRoleProfiles(): Prisma.UserRoleProfilesDelegate<GlobalReject>;

  /**
   * `prisma.userRoles`: Exposes CRUD operations for the **UserRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRoles.findMany()
    * ```
    */
  get userRoles(): Prisma.UserRolesDelegate<GlobalReject>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<GlobalReject>;

  /**
   * `prisma.userSessions`: Exposes CRUD operations for the **UserSessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSessions.findMany()
    * ```
    */
  get userSessions(): Prisma.UserSessionsDelegate<GlobalReject>;

  /**
   * `prisma.userSessionsArchive`: Exposes CRUD operations for the **UserSessionsArchive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessionsArchives
    * const userSessionsArchives = await prisma.userSessionsArchive.findMany()
    * ```
    */
  get userSessionsArchive(): Prisma.UserSessionsArchiveDelegate<GlobalReject>;

  /**
   * `prisma.userTokens`: Exposes CRUD operations for the **UserTokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTokens
    * const userTokens = await prisma.userTokens.findMany()
    * ```
    */
  get userTokens(): Prisma.UserTokensDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.6.0
   * Query Engine version: dc520b92b1ebb2d28dc3161f9f82e875bd35d727
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    AccessRights: 'AccessRights',
    AppIdentityRoles: 'AppIdentityRoles',
    AppStreamConfigurations: 'AppStreamConfigurations',
    AppStreamUserConnectors: 'AppStreamUserConnectors',
    AuditEntities: 'AuditEntities',
    AuditLogs: 'AuditLogs',
    AWSConfigurations: 'AWSConfigurations',
    CreateElementNotifications: 'CreateElementNotifications',
    DashboardReviewUserRoles: 'DashboardReviewUserRoles',
    Dashboards: 'Dashboards',
    DashboardUserDefault: 'DashboardUserDefault',
    DashboardUserGroups: 'DashboardUserGroups',
    DashboardUsers: 'DashboardUsers',
    DashboardWidgetBlocks: 'DashboardWidgetBlocks',
    DashboardWidgetBlockTypes: 'DashboardWidgetBlockTypes',
    DashboardWidgets: 'DashboardWidgets',
    DocumentationRequests: 'DocumentationRequests',
    DomainRestrictions: 'DomainRestrictions',
    EAChangelogAttributes: 'EAChangelogAttributes',
    EAChangelogs: 'EAChangelogs',
    ElementConnectors: 'ElementConnectors',
    ExternalAppAttributeMaster: 'ExternalAppAttributeMaster',
    ExternalAppAttributes: 'ExternalAppAttributes',
    ExternalApps: 'ExternalApps',
    ExternalAppTypes: 'ExternalAppTypes',
    Features: 'Features',
    FilterProfileConnectors: 'FilterProfileConnectors',
    FilterProfiles: 'FilterProfiles',
    GlobalRepositoryConfigurations: 'GlobalRepositoryConfigurations',
    GroupFeatures: 'GroupFeatures',
    GuestSignupSettings: 'GuestSignupSettings',
    IdPConnections: 'IdPConnections',
    LDAPConnections: 'LDAPConnections',
    MDGProfileConnectors: 'MDGProfileConnectors',
    MDGTechnologies: 'MDGTechnologies',
    MenuItemProfileConnectors: 'MenuItemProfileConnectors',
    MenuItemProfiles: 'MenuItemProfiles',
    MenuItemProfileSettings: 'MenuItemProfileSettings',
    MenuViewHistory: 'MenuViewHistory',
    OIDCApplications: 'OIDCApplications',
    OIDCAuthorizations: 'OIDCAuthorizations',
    OIDCScopes: 'OIDCScopes',
    OIDCTokens: 'OIDCTokens',
    Profiles: 'Profiles',
    PropertyMenuItemConnectors: 'PropertyMenuItemConnectors',
    PropertyMenuItems: 'PropertyMenuItems',
    Repositories: 'Repositories',
    RepositoryConnectors: 'RepositoryConnectors',
    RepositoryDBConnections: 'RepositoryDBConnections',
    RequestLogs: 'RequestLogs',
    ReservedUsers: 'ReservedUsers',
    ResourceFiles: 'ResourceFiles',
    Resources: 'Resources',
    ReviewProcesses: 'ReviewProcesses',
    TaggedValues: 'TaggedValues',
    TraceabilityTreeProfiles: 'TraceabilityTreeProfiles',
    TraceabilityTreeViews: 'TraceabilityTreeViews',
    URLMap: 'URLMap',
    UserActions: 'UserActions',
    UserGroupConnectors: 'UserGroupConnectors',
    UserGroups: 'UserGroups',
    UserIdentityClaims: 'UserIdentityClaims',
    UserIdentityLogins: 'UserIdentityLogins',
    UserIdentityRoleClaims: 'UserIdentityRoleClaims',
    UserIdentityRoles: 'UserIdentityRoles',
    UserIdentityTokens: 'UserIdentityTokens',
    UserProfileSetting: 'UserProfileSetting',
    UserRoleProfiles: 'UserRoleProfiles',
    UserRoles: 'UserRoles',
    Users: 'Users',
    UserSessions: 'UserSessions',
    UserSessionsArchive: 'UserSessionsArchive',
    UserTokens: 'UserTokens'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AppIdentityRolesCountOutputType
   */


  export type AppIdentityRolesCountOutputType = {
    UserIdentityRoleClaims: number
    UserIdentityRoles: number
  }

  export type AppIdentityRolesCountOutputTypeSelect = {
    UserIdentityRoleClaims?: boolean
    UserIdentityRoles?: boolean
  }

  export type AppIdentityRolesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | AppIdentityRolesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? AppIdentityRolesCountOutputType
    : S extends undefined
    ? never
    : S extends AppIdentityRolesCountOutputTypeArgs
    ?'include' extends U
    ? AppIdentityRolesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AppIdentityRolesCountOutputType ?AppIdentityRolesCountOutputType [P]
  : 
     never
  } 
    : AppIdentityRolesCountOutputType
  : AppIdentityRolesCountOutputType




  // Custom InputTypes

  /**
   * AppIdentityRolesCountOutputType without action
   */
  export type AppIdentityRolesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AppIdentityRolesCountOutputType
     * 
    **/
    select?: AppIdentityRolesCountOutputTypeSelect | null
  }



  /**
   * Count Type OIDCApplicationsCountOutputType
   */


  export type OIDCApplicationsCountOutputType = {
    OIDCAuthorizations: number
    OIDCTokens: number
  }

  export type OIDCApplicationsCountOutputTypeSelect = {
    OIDCAuthorizations?: boolean
    OIDCTokens?: boolean
  }

  export type OIDCApplicationsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OIDCApplicationsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OIDCApplicationsCountOutputType
    : S extends undefined
    ? never
    : S extends OIDCApplicationsCountOutputTypeArgs
    ?'include' extends U
    ? OIDCApplicationsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof OIDCApplicationsCountOutputType ?OIDCApplicationsCountOutputType [P]
  : 
     never
  } 
    : OIDCApplicationsCountOutputType
  : OIDCApplicationsCountOutputType




  // Custom InputTypes

  /**
   * OIDCApplicationsCountOutputType without action
   */
  export type OIDCApplicationsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OIDCApplicationsCountOutputType
     * 
    **/
    select?: OIDCApplicationsCountOutputTypeSelect | null
  }



  /**
   * Count Type OIDCAuthorizationsCountOutputType
   */


  export type OIDCAuthorizationsCountOutputType = {
    OIDCTokens: number
  }

  export type OIDCAuthorizationsCountOutputTypeSelect = {
    OIDCTokens?: boolean
  }

  export type OIDCAuthorizationsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OIDCAuthorizationsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OIDCAuthorizationsCountOutputType
    : S extends undefined
    ? never
    : S extends OIDCAuthorizationsCountOutputTypeArgs
    ?'include' extends U
    ? OIDCAuthorizationsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof OIDCAuthorizationsCountOutputType ?OIDCAuthorizationsCountOutputType [P]
  : 
     never
  } 
    : OIDCAuthorizationsCountOutputType
  : OIDCAuthorizationsCountOutputType




  // Custom InputTypes

  /**
   * OIDCAuthorizationsCountOutputType without action
   */
  export type OIDCAuthorizationsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OIDCAuthorizationsCountOutputType
     * 
    **/
    select?: OIDCAuthorizationsCountOutputTypeSelect | null
  }



  /**
   * Count Type UsersCountOutputType
   */


  export type UsersCountOutputType = {
    UserIdentityClaims: number
    UserIdentityLogins: number
    UserIdentityRoles: number
    UserIdentityTokens: number
  }

  export type UsersCountOutputTypeSelect = {
    UserIdentityClaims?: boolean
    UserIdentityLogins?: boolean
    UserIdentityRoles?: boolean
    UserIdentityTokens?: boolean
  }

  export type UsersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UsersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UsersCountOutputType
    : S extends undefined
    ? never
    : S extends UsersCountOutputTypeArgs
    ?'include' extends U
    ? UsersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UsersCountOutputType ?UsersCountOutputType [P]
  : 
     never
  } 
    : UsersCountOutputType
  : UsersCountOutputType




  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     * 
    **/
    select?: UsersCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model AccessRights
   */


  export type AggregateAccessRights = {
    _count: AccessRightsCountAggregateOutputType | null
    _min: AccessRightsMinAggregateOutputType | null
    _max: AccessRightsMaxAggregateOutputType | null
  }

  export type AccessRightsMinAggregateOutputType = {
    Id: string | null
    Name: string | null
    AccessRightKey: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
  }

  export type AccessRightsMaxAggregateOutputType = {
    Id: string | null
    Name: string | null
    AccessRightKey: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
  }

  export type AccessRightsCountAggregateOutputType = {
    Id: number
    Name: number
    AccessRightKey: number
    CreatedDate: number
    ModifiedDate: number
    Status: number
    _all: number
  }


  export type AccessRightsMinAggregateInputType = {
    Id?: true
    Name?: true
    AccessRightKey?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
  }

  export type AccessRightsMaxAggregateInputType = {
    Id?: true
    Name?: true
    AccessRightKey?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
  }

  export type AccessRightsCountAggregateInputType = {
    Id?: true
    Name?: true
    AccessRightKey?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
    _all?: true
  }

  export type AccessRightsAggregateArgs = {
    /**
     * Filter which AccessRights to aggregate.
     * 
    **/
    where?: AccessRightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessRights to fetch.
     * 
    **/
    orderBy?: Enumerable<AccessRightsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccessRightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessRights from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessRights.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccessRights
    **/
    _count?: true | AccessRightsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessRightsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessRightsMaxAggregateInputType
  }

  export type GetAccessRightsAggregateType<T extends AccessRightsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessRights]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessRights[P]>
      : GetScalarType<T[P], AggregateAccessRights[P]>
  }




  export type AccessRightsGroupByArgs = {
    where?: AccessRightsWhereInput
    orderBy?: Enumerable<AccessRightsOrderByWithAggregationInput>
    by: Array<AccessRightsScalarFieldEnum>
    having?: AccessRightsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessRightsCountAggregateInputType | true
    _min?: AccessRightsMinAggregateInputType
    _max?: AccessRightsMaxAggregateInputType
  }


  export type AccessRightsGroupByOutputType = {
    Id: string
    Name: string | null
    AccessRightKey: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
    _count: AccessRightsCountAggregateOutputType | null
    _min: AccessRightsMinAggregateOutputType | null
    _max: AccessRightsMaxAggregateOutputType | null
  }

  type GetAccessRightsGroupByPayload<T extends AccessRightsGroupByArgs> = Promise<
    Array<
      PickArray<AccessRightsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessRightsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessRightsGroupByOutputType[P]>
            : GetScalarType<T[P], AccessRightsGroupByOutputType[P]>
        }
      >
    >


  export type AccessRightsSelect = {
    Id?: boolean
    Name?: boolean
    AccessRightKey?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
    Status?: boolean
  }

  export type AccessRightsGetPayload<
    S extends boolean | null | undefined | AccessRightsArgs,
    U = keyof S
      > = S extends true
        ? AccessRights
    : S extends undefined
    ? never
    : S extends AccessRightsArgs | AccessRightsFindManyArgs
    ?'include' extends U
    ? AccessRights 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AccessRights ?AccessRights [P]
  : 
     never
  } 
    : AccessRights
  : AccessRights


  type AccessRightsCountArgs = Merge<
    Omit<AccessRightsFindManyArgs, 'select' | 'include'> & {
      select?: AccessRightsCountAggregateInputType | true
    }
  >

  export interface AccessRightsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AccessRights that matches the filter.
     * @param {AccessRightsFindUniqueArgs} args - Arguments to find a AccessRights
     * @example
     * // Get one AccessRights
     * const accessRights = await prisma.accessRights.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccessRightsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccessRightsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AccessRights'> extends True ? CheckSelect<T, Prisma__AccessRightsClient<AccessRights>, Prisma__AccessRightsClient<AccessRightsGetPayload<T>>> : CheckSelect<T, Prisma__AccessRightsClient<AccessRights | null >, Prisma__AccessRightsClient<AccessRightsGetPayload<T> | null >>

    /**
     * Find the first AccessRights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessRightsFindFirstArgs} args - Arguments to find a AccessRights
     * @example
     * // Get one AccessRights
     * const accessRights = await prisma.accessRights.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccessRightsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccessRightsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AccessRights'> extends True ? CheckSelect<T, Prisma__AccessRightsClient<AccessRights>, Prisma__AccessRightsClient<AccessRightsGetPayload<T>>> : CheckSelect<T, Prisma__AccessRightsClient<AccessRights | null >, Prisma__AccessRightsClient<AccessRightsGetPayload<T> | null >>

    /**
     * Find zero or more AccessRights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessRightsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccessRights
     * const accessRights = await prisma.accessRights.findMany()
     * 
     * // Get first 10 AccessRights
     * const accessRights = await prisma.accessRights.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const accessRightsWithIdOnly = await prisma.accessRights.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends AccessRightsFindManyArgs>(
      args?: SelectSubset<T, AccessRightsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AccessRights>>, PrismaPromise<Array<AccessRightsGetPayload<T>>>>

    /**
     * Create a AccessRights.
     * @param {AccessRightsCreateArgs} args - Arguments to create a AccessRights.
     * @example
     * // Create one AccessRights
     * const AccessRights = await prisma.accessRights.create({
     *   data: {
     *     // ... data to create a AccessRights
     *   }
     * })
     * 
    **/
    create<T extends AccessRightsCreateArgs>(
      args: SelectSubset<T, AccessRightsCreateArgs>
    ): CheckSelect<T, Prisma__AccessRightsClient<AccessRights>, Prisma__AccessRightsClient<AccessRightsGetPayload<T>>>

    /**
     * Create many AccessRights.
     *     @param {AccessRightsCreateManyArgs} args - Arguments to create many AccessRights.
     *     @example
     *     // Create many AccessRights
     *     const accessRights = await prisma.accessRights.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccessRightsCreateManyArgs>(
      args?: SelectSubset<T, AccessRightsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AccessRights.
     * @param {AccessRightsDeleteArgs} args - Arguments to delete one AccessRights.
     * @example
     * // Delete one AccessRights
     * const AccessRights = await prisma.accessRights.delete({
     *   where: {
     *     // ... filter to delete one AccessRights
     *   }
     * })
     * 
    **/
    delete<T extends AccessRightsDeleteArgs>(
      args: SelectSubset<T, AccessRightsDeleteArgs>
    ): CheckSelect<T, Prisma__AccessRightsClient<AccessRights>, Prisma__AccessRightsClient<AccessRightsGetPayload<T>>>

    /**
     * Update one AccessRights.
     * @param {AccessRightsUpdateArgs} args - Arguments to update one AccessRights.
     * @example
     * // Update one AccessRights
     * const accessRights = await prisma.accessRights.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccessRightsUpdateArgs>(
      args: SelectSubset<T, AccessRightsUpdateArgs>
    ): CheckSelect<T, Prisma__AccessRightsClient<AccessRights>, Prisma__AccessRightsClient<AccessRightsGetPayload<T>>>

    /**
     * Delete zero or more AccessRights.
     * @param {AccessRightsDeleteManyArgs} args - Arguments to filter AccessRights to delete.
     * @example
     * // Delete a few AccessRights
     * const { count } = await prisma.accessRights.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccessRightsDeleteManyArgs>(
      args?: SelectSubset<T, AccessRightsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessRights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessRightsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccessRights
     * const accessRights = await prisma.accessRights.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccessRightsUpdateManyArgs>(
      args: SelectSubset<T, AccessRightsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AccessRights.
     * @param {AccessRightsUpsertArgs} args - Arguments to update or create a AccessRights.
     * @example
     * // Update or create a AccessRights
     * const accessRights = await prisma.accessRights.upsert({
     *   create: {
     *     // ... data to create a AccessRights
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccessRights we want to update
     *   }
     * })
    **/
    upsert<T extends AccessRightsUpsertArgs>(
      args: SelectSubset<T, AccessRightsUpsertArgs>
    ): CheckSelect<T, Prisma__AccessRightsClient<AccessRights>, Prisma__AccessRightsClient<AccessRightsGetPayload<T>>>

    /**
     * Count the number of AccessRights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessRightsCountArgs} args - Arguments to filter AccessRights to count.
     * @example
     * // Count the number of AccessRights
     * const count = await prisma.accessRights.count({
     *   where: {
     *     // ... the filter for the AccessRights we want to count
     *   }
     * })
    **/
    count<T extends AccessRightsCountArgs>(
      args?: Subset<T, AccessRightsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessRightsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccessRights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessRightsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessRightsAggregateArgs>(args: Subset<T, AccessRightsAggregateArgs>): PrismaPromise<GetAccessRightsAggregateType<T>>

    /**
     * Group by AccessRights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessRightsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessRightsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessRightsGroupByArgs['orderBy'] }
        : { orderBy?: AccessRightsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessRightsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessRightsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccessRights.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccessRightsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AccessRights findUnique
   */
  export type AccessRightsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AccessRights
     * 
    **/
    select?: AccessRightsSelect | null
    /**
     * Throw an Error if a AccessRights can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AccessRights to fetch.
     * 
    **/
    where: AccessRightsWhereUniqueInput
  }


  /**
   * AccessRights findFirst
   */
  export type AccessRightsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AccessRights
     * 
    **/
    select?: AccessRightsSelect | null
    /**
     * Throw an Error if a AccessRights can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AccessRights to fetch.
     * 
    **/
    where?: AccessRightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessRights to fetch.
     * 
    **/
    orderBy?: Enumerable<AccessRightsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessRights.
     * 
    **/
    cursor?: AccessRightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessRights from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessRights.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessRights.
     * 
    **/
    distinct?: Enumerable<AccessRightsScalarFieldEnum>
  }


  /**
   * AccessRights findMany
   */
  export type AccessRightsFindManyArgs = {
    /**
     * Select specific fields to fetch from the AccessRights
     * 
    **/
    select?: AccessRightsSelect | null
    /**
     * Filter, which AccessRights to fetch.
     * 
    **/
    where?: AccessRightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessRights to fetch.
     * 
    **/
    orderBy?: Enumerable<AccessRightsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccessRights.
     * 
    **/
    cursor?: AccessRightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessRights from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessRights.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccessRightsScalarFieldEnum>
  }


  /**
   * AccessRights create
   */
  export type AccessRightsCreateArgs = {
    /**
     * Select specific fields to fetch from the AccessRights
     * 
    **/
    select?: AccessRightsSelect | null
    /**
     * The data needed to create a AccessRights.
     * 
    **/
    data: XOR<AccessRightsCreateInput, AccessRightsUncheckedCreateInput>
  }


  /**
   * AccessRights createMany
   */
  export type AccessRightsCreateManyArgs = {
    data: Enumerable<AccessRightsCreateManyInput>
  }


  /**
   * AccessRights update
   */
  export type AccessRightsUpdateArgs = {
    /**
     * Select specific fields to fetch from the AccessRights
     * 
    **/
    select?: AccessRightsSelect | null
    /**
     * The data needed to update a AccessRights.
     * 
    **/
    data: XOR<AccessRightsUpdateInput, AccessRightsUncheckedUpdateInput>
    /**
     * Choose, which AccessRights to update.
     * 
    **/
    where: AccessRightsWhereUniqueInput
  }


  /**
   * AccessRights updateMany
   */
  export type AccessRightsUpdateManyArgs = {
    data: XOR<AccessRightsUpdateManyMutationInput, AccessRightsUncheckedUpdateManyInput>
    where?: AccessRightsWhereInput
  }


  /**
   * AccessRights upsert
   */
  export type AccessRightsUpsertArgs = {
    /**
     * Select specific fields to fetch from the AccessRights
     * 
    **/
    select?: AccessRightsSelect | null
    /**
     * The filter to search for the AccessRights to update in case it exists.
     * 
    **/
    where: AccessRightsWhereUniqueInput
    /**
     * In case the AccessRights found by the `where` argument doesn't exist, create a new AccessRights with this data.
     * 
    **/
    create: XOR<AccessRightsCreateInput, AccessRightsUncheckedCreateInput>
    /**
     * In case the AccessRights was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccessRightsUpdateInput, AccessRightsUncheckedUpdateInput>
  }


  /**
   * AccessRights delete
   */
  export type AccessRightsDeleteArgs = {
    /**
     * Select specific fields to fetch from the AccessRights
     * 
    **/
    select?: AccessRightsSelect | null
    /**
     * Filter which AccessRights to delete.
     * 
    **/
    where: AccessRightsWhereUniqueInput
  }


  /**
   * AccessRights deleteMany
   */
  export type AccessRightsDeleteManyArgs = {
    where?: AccessRightsWhereInput
  }


  /**
   * AccessRights without action
   */
  export type AccessRightsArgs = {
    /**
     * Select specific fields to fetch from the AccessRights
     * 
    **/
    select?: AccessRightsSelect | null
  }



  /**
   * Model AppIdentityRoles
   */


  export type AggregateAppIdentityRoles = {
    _count: AppIdentityRolesCountAggregateOutputType | null
    _min: AppIdentityRolesMinAggregateOutputType | null
    _max: AppIdentityRolesMaxAggregateOutputType | null
  }

  export type AppIdentityRolesMinAggregateOutputType = {
    Id: string | null
    Name: string | null
    NormalizedName: string | null
    ConcurrencyStamp: string | null
  }

  export type AppIdentityRolesMaxAggregateOutputType = {
    Id: string | null
    Name: string | null
    NormalizedName: string | null
    ConcurrencyStamp: string | null
  }

  export type AppIdentityRolesCountAggregateOutputType = {
    Id: number
    Name: number
    NormalizedName: number
    ConcurrencyStamp: number
    _all: number
  }


  export type AppIdentityRolesMinAggregateInputType = {
    Id?: true
    Name?: true
    NormalizedName?: true
    ConcurrencyStamp?: true
  }

  export type AppIdentityRolesMaxAggregateInputType = {
    Id?: true
    Name?: true
    NormalizedName?: true
    ConcurrencyStamp?: true
  }

  export type AppIdentityRolesCountAggregateInputType = {
    Id?: true
    Name?: true
    NormalizedName?: true
    ConcurrencyStamp?: true
    _all?: true
  }

  export type AppIdentityRolesAggregateArgs = {
    /**
     * Filter which AppIdentityRoles to aggregate.
     * 
    **/
    where?: AppIdentityRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIdentityRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<AppIdentityRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AppIdentityRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIdentityRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIdentityRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppIdentityRoles
    **/
    _count?: true | AppIdentityRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppIdentityRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppIdentityRolesMaxAggregateInputType
  }

  export type GetAppIdentityRolesAggregateType<T extends AppIdentityRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateAppIdentityRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppIdentityRoles[P]>
      : GetScalarType<T[P], AggregateAppIdentityRoles[P]>
  }




  export type AppIdentityRolesGroupByArgs = {
    where?: AppIdentityRolesWhereInput
    orderBy?: Enumerable<AppIdentityRolesOrderByWithAggregationInput>
    by: Array<AppIdentityRolesScalarFieldEnum>
    having?: AppIdentityRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppIdentityRolesCountAggregateInputType | true
    _min?: AppIdentityRolesMinAggregateInputType
    _max?: AppIdentityRolesMaxAggregateInputType
  }


  export type AppIdentityRolesGroupByOutputType = {
    Id: string
    Name: string | null
    NormalizedName: string | null
    ConcurrencyStamp: string | null
    _count: AppIdentityRolesCountAggregateOutputType | null
    _min: AppIdentityRolesMinAggregateOutputType | null
    _max: AppIdentityRolesMaxAggregateOutputType | null
  }

  type GetAppIdentityRolesGroupByPayload<T extends AppIdentityRolesGroupByArgs> = Promise<
    Array<
      PickArray<AppIdentityRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppIdentityRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppIdentityRolesGroupByOutputType[P]>
            : GetScalarType<T[P], AppIdentityRolesGroupByOutputType[P]>
        }
      >
    >


  export type AppIdentityRolesSelect = {
    Id?: boolean
    Name?: boolean
    NormalizedName?: boolean
    ConcurrencyStamp?: boolean
    UserIdentityRoleClaims?: boolean | UserIdentityRoleClaimsFindManyArgs
    UserIdentityRoles?: boolean | UserIdentityRolesFindManyArgs
    _count?: boolean | AppIdentityRolesCountOutputTypeArgs
  }

  export type AppIdentityRolesInclude = {
    UserIdentityRoleClaims?: boolean | UserIdentityRoleClaimsFindManyArgs
    UserIdentityRoles?: boolean | UserIdentityRolesFindManyArgs
    _count?: boolean | AppIdentityRolesCountOutputTypeArgs
  }

  export type AppIdentityRolesGetPayload<
    S extends boolean | null | undefined | AppIdentityRolesArgs,
    U = keyof S
      > = S extends true
        ? AppIdentityRoles
    : S extends undefined
    ? never
    : S extends AppIdentityRolesArgs | AppIdentityRolesFindManyArgs
    ?'include' extends U
    ? AppIdentityRoles  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'UserIdentityRoleClaims'
        ? Array < UserIdentityRoleClaimsGetPayload<S['include'][P]>>  :
        P extends 'UserIdentityRoles'
        ? Array < UserIdentityRolesGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? AppIdentityRolesCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AppIdentityRoles ?AppIdentityRoles [P]
  : 
          P extends 'UserIdentityRoleClaims'
        ? Array < UserIdentityRoleClaimsGetPayload<S['select'][P]>>  :
        P extends 'UserIdentityRoles'
        ? Array < UserIdentityRolesGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? AppIdentityRolesCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : AppIdentityRoles
  : AppIdentityRoles


  type AppIdentityRolesCountArgs = Merge<
    Omit<AppIdentityRolesFindManyArgs, 'select' | 'include'> & {
      select?: AppIdentityRolesCountAggregateInputType | true
    }
  >

  export interface AppIdentityRolesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AppIdentityRoles that matches the filter.
     * @param {AppIdentityRolesFindUniqueArgs} args - Arguments to find a AppIdentityRoles
     * @example
     * // Get one AppIdentityRoles
     * const appIdentityRoles = await prisma.appIdentityRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppIdentityRolesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AppIdentityRolesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AppIdentityRoles'> extends True ? CheckSelect<T, Prisma__AppIdentityRolesClient<AppIdentityRoles>, Prisma__AppIdentityRolesClient<AppIdentityRolesGetPayload<T>>> : CheckSelect<T, Prisma__AppIdentityRolesClient<AppIdentityRoles | null >, Prisma__AppIdentityRolesClient<AppIdentityRolesGetPayload<T> | null >>

    /**
     * Find the first AppIdentityRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIdentityRolesFindFirstArgs} args - Arguments to find a AppIdentityRoles
     * @example
     * // Get one AppIdentityRoles
     * const appIdentityRoles = await prisma.appIdentityRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppIdentityRolesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AppIdentityRolesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AppIdentityRoles'> extends True ? CheckSelect<T, Prisma__AppIdentityRolesClient<AppIdentityRoles>, Prisma__AppIdentityRolesClient<AppIdentityRolesGetPayload<T>>> : CheckSelect<T, Prisma__AppIdentityRolesClient<AppIdentityRoles | null >, Prisma__AppIdentityRolesClient<AppIdentityRolesGetPayload<T> | null >>

    /**
     * Find zero or more AppIdentityRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIdentityRolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppIdentityRoles
     * const appIdentityRoles = await prisma.appIdentityRoles.findMany()
     * 
     * // Get first 10 AppIdentityRoles
     * const appIdentityRoles = await prisma.appIdentityRoles.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const appIdentityRolesWithIdOnly = await prisma.appIdentityRoles.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends AppIdentityRolesFindManyArgs>(
      args?: SelectSubset<T, AppIdentityRolesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AppIdentityRoles>>, PrismaPromise<Array<AppIdentityRolesGetPayload<T>>>>

    /**
     * Create a AppIdentityRoles.
     * @param {AppIdentityRolesCreateArgs} args - Arguments to create a AppIdentityRoles.
     * @example
     * // Create one AppIdentityRoles
     * const AppIdentityRoles = await prisma.appIdentityRoles.create({
     *   data: {
     *     // ... data to create a AppIdentityRoles
     *   }
     * })
     * 
    **/
    create<T extends AppIdentityRolesCreateArgs>(
      args: SelectSubset<T, AppIdentityRolesCreateArgs>
    ): CheckSelect<T, Prisma__AppIdentityRolesClient<AppIdentityRoles>, Prisma__AppIdentityRolesClient<AppIdentityRolesGetPayload<T>>>

    /**
     * Create many AppIdentityRoles.
     *     @param {AppIdentityRolesCreateManyArgs} args - Arguments to create many AppIdentityRoles.
     *     @example
     *     // Create many AppIdentityRoles
     *     const appIdentityRoles = await prisma.appIdentityRoles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppIdentityRolesCreateManyArgs>(
      args?: SelectSubset<T, AppIdentityRolesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AppIdentityRoles.
     * @param {AppIdentityRolesDeleteArgs} args - Arguments to delete one AppIdentityRoles.
     * @example
     * // Delete one AppIdentityRoles
     * const AppIdentityRoles = await prisma.appIdentityRoles.delete({
     *   where: {
     *     // ... filter to delete one AppIdentityRoles
     *   }
     * })
     * 
    **/
    delete<T extends AppIdentityRolesDeleteArgs>(
      args: SelectSubset<T, AppIdentityRolesDeleteArgs>
    ): CheckSelect<T, Prisma__AppIdentityRolesClient<AppIdentityRoles>, Prisma__AppIdentityRolesClient<AppIdentityRolesGetPayload<T>>>

    /**
     * Update one AppIdentityRoles.
     * @param {AppIdentityRolesUpdateArgs} args - Arguments to update one AppIdentityRoles.
     * @example
     * // Update one AppIdentityRoles
     * const appIdentityRoles = await prisma.appIdentityRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppIdentityRolesUpdateArgs>(
      args: SelectSubset<T, AppIdentityRolesUpdateArgs>
    ): CheckSelect<T, Prisma__AppIdentityRolesClient<AppIdentityRoles>, Prisma__AppIdentityRolesClient<AppIdentityRolesGetPayload<T>>>

    /**
     * Delete zero or more AppIdentityRoles.
     * @param {AppIdentityRolesDeleteManyArgs} args - Arguments to filter AppIdentityRoles to delete.
     * @example
     * // Delete a few AppIdentityRoles
     * const { count } = await prisma.appIdentityRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppIdentityRolesDeleteManyArgs>(
      args?: SelectSubset<T, AppIdentityRolesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppIdentityRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIdentityRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppIdentityRoles
     * const appIdentityRoles = await prisma.appIdentityRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppIdentityRolesUpdateManyArgs>(
      args: SelectSubset<T, AppIdentityRolesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AppIdentityRoles.
     * @param {AppIdentityRolesUpsertArgs} args - Arguments to update or create a AppIdentityRoles.
     * @example
     * // Update or create a AppIdentityRoles
     * const appIdentityRoles = await prisma.appIdentityRoles.upsert({
     *   create: {
     *     // ... data to create a AppIdentityRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppIdentityRoles we want to update
     *   }
     * })
    **/
    upsert<T extends AppIdentityRolesUpsertArgs>(
      args: SelectSubset<T, AppIdentityRolesUpsertArgs>
    ): CheckSelect<T, Prisma__AppIdentityRolesClient<AppIdentityRoles>, Prisma__AppIdentityRolesClient<AppIdentityRolesGetPayload<T>>>

    /**
     * Count the number of AppIdentityRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIdentityRolesCountArgs} args - Arguments to filter AppIdentityRoles to count.
     * @example
     * // Count the number of AppIdentityRoles
     * const count = await prisma.appIdentityRoles.count({
     *   where: {
     *     // ... the filter for the AppIdentityRoles we want to count
     *   }
     * })
    **/
    count<T extends AppIdentityRolesCountArgs>(
      args?: Subset<T, AppIdentityRolesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppIdentityRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppIdentityRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIdentityRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppIdentityRolesAggregateArgs>(args: Subset<T, AppIdentityRolesAggregateArgs>): PrismaPromise<GetAppIdentityRolesAggregateType<T>>

    /**
     * Group by AppIdentityRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIdentityRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppIdentityRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppIdentityRolesGroupByArgs['orderBy'] }
        : { orderBy?: AppIdentityRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppIdentityRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppIdentityRolesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppIdentityRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AppIdentityRolesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    UserIdentityRoleClaims<T extends UserIdentityRoleClaimsFindManyArgs = {}>(args?: Subset<T, UserIdentityRoleClaimsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserIdentityRoleClaims>>, PrismaPromise<Array<UserIdentityRoleClaimsGetPayload<T>>>>;

    UserIdentityRoles<T extends UserIdentityRolesFindManyArgs = {}>(args?: Subset<T, UserIdentityRolesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserIdentityRoles>>, PrismaPromise<Array<UserIdentityRolesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AppIdentityRoles findUnique
   */
  export type AppIdentityRolesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AppIdentityRoles
     * 
    **/
    select?: AppIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppIdentityRolesInclude | null
    /**
     * Throw an Error if a AppIdentityRoles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AppIdentityRoles to fetch.
     * 
    **/
    where: AppIdentityRolesWhereUniqueInput
  }


  /**
   * AppIdentityRoles findFirst
   */
  export type AppIdentityRolesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AppIdentityRoles
     * 
    **/
    select?: AppIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppIdentityRolesInclude | null
    /**
     * Throw an Error if a AppIdentityRoles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AppIdentityRoles to fetch.
     * 
    **/
    where?: AppIdentityRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIdentityRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<AppIdentityRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppIdentityRoles.
     * 
    **/
    cursor?: AppIdentityRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIdentityRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIdentityRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppIdentityRoles.
     * 
    **/
    distinct?: Enumerable<AppIdentityRolesScalarFieldEnum>
  }


  /**
   * AppIdentityRoles findMany
   */
  export type AppIdentityRolesFindManyArgs = {
    /**
     * Select specific fields to fetch from the AppIdentityRoles
     * 
    **/
    select?: AppIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppIdentityRolesInclude | null
    /**
     * Filter, which AppIdentityRoles to fetch.
     * 
    **/
    where?: AppIdentityRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIdentityRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<AppIdentityRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppIdentityRoles.
     * 
    **/
    cursor?: AppIdentityRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIdentityRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIdentityRoles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AppIdentityRolesScalarFieldEnum>
  }


  /**
   * AppIdentityRoles create
   */
  export type AppIdentityRolesCreateArgs = {
    /**
     * Select specific fields to fetch from the AppIdentityRoles
     * 
    **/
    select?: AppIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppIdentityRolesInclude | null
    /**
     * The data needed to create a AppIdentityRoles.
     * 
    **/
    data: XOR<AppIdentityRolesCreateInput, AppIdentityRolesUncheckedCreateInput>
  }


  /**
   * AppIdentityRoles createMany
   */
  export type AppIdentityRolesCreateManyArgs = {
    data: Enumerable<AppIdentityRolesCreateManyInput>
  }


  /**
   * AppIdentityRoles update
   */
  export type AppIdentityRolesUpdateArgs = {
    /**
     * Select specific fields to fetch from the AppIdentityRoles
     * 
    **/
    select?: AppIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppIdentityRolesInclude | null
    /**
     * The data needed to update a AppIdentityRoles.
     * 
    **/
    data: XOR<AppIdentityRolesUpdateInput, AppIdentityRolesUncheckedUpdateInput>
    /**
     * Choose, which AppIdentityRoles to update.
     * 
    **/
    where: AppIdentityRolesWhereUniqueInput
  }


  /**
   * AppIdentityRoles updateMany
   */
  export type AppIdentityRolesUpdateManyArgs = {
    data: XOR<AppIdentityRolesUpdateManyMutationInput, AppIdentityRolesUncheckedUpdateManyInput>
    where?: AppIdentityRolesWhereInput
  }


  /**
   * AppIdentityRoles upsert
   */
  export type AppIdentityRolesUpsertArgs = {
    /**
     * Select specific fields to fetch from the AppIdentityRoles
     * 
    **/
    select?: AppIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppIdentityRolesInclude | null
    /**
     * The filter to search for the AppIdentityRoles to update in case it exists.
     * 
    **/
    where: AppIdentityRolesWhereUniqueInput
    /**
     * In case the AppIdentityRoles found by the `where` argument doesn't exist, create a new AppIdentityRoles with this data.
     * 
    **/
    create: XOR<AppIdentityRolesCreateInput, AppIdentityRolesUncheckedCreateInput>
    /**
     * In case the AppIdentityRoles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AppIdentityRolesUpdateInput, AppIdentityRolesUncheckedUpdateInput>
  }


  /**
   * AppIdentityRoles delete
   */
  export type AppIdentityRolesDeleteArgs = {
    /**
     * Select specific fields to fetch from the AppIdentityRoles
     * 
    **/
    select?: AppIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppIdentityRolesInclude | null
    /**
     * Filter which AppIdentityRoles to delete.
     * 
    **/
    where: AppIdentityRolesWhereUniqueInput
  }


  /**
   * AppIdentityRoles deleteMany
   */
  export type AppIdentityRolesDeleteManyArgs = {
    where?: AppIdentityRolesWhereInput
  }


  /**
   * AppIdentityRoles without action
   */
  export type AppIdentityRolesArgs = {
    /**
     * Select specific fields to fetch from the AppIdentityRoles
     * 
    **/
    select?: AppIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppIdentityRolesInclude | null
  }



  /**
   * Model AppStreamConfigurations
   */


  export type AggregateAppStreamConfigurations = {
    _count: AppStreamConfigurationsCountAggregateOutputType | null
    _avg: AppStreamConfigurationsAvgAggregateOutputType | null
    _sum: AppStreamConfigurationsSumAggregateOutputType | null
    _min: AppStreamConfigurationsMinAggregateOutputType | null
    _max: AppStreamConfigurationsMaxAggregateOutputType | null
  }

  export type AppStreamConfigurationsAvgAggregateOutputType = {
    RegionEndPoint: number | null
    AuthenticationType: number | null
    URLValidityTime: number | null
  }

  export type AppStreamConfigurationsSumAggregateOutputType = {
    RegionEndPoint: number | null
    AuthenticationType: number | null
    URLValidityTime: number | null
  }

  export type AppStreamConfigurationsMinAggregateOutputType = {
    Id: string | null
    RegionEndPoint: number | null
    FleetName: string | null
    StackName: string | null
    ApplicationID: string | null
    AuthenticationType: number | null
    URLValidityTime: number | null
    AWSConfigurationsId: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type AppStreamConfigurationsMaxAggregateOutputType = {
    Id: string | null
    RegionEndPoint: number | null
    FleetName: string | null
    StackName: string | null
    ApplicationID: string | null
    AuthenticationType: number | null
    URLValidityTime: number | null
    AWSConfigurationsId: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type AppStreamConfigurationsCountAggregateOutputType = {
    Id: number
    RegionEndPoint: number
    FleetName: number
    StackName: number
    ApplicationID: number
    AuthenticationType: number
    URLValidityTime: number
    AWSConfigurationsId: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type AppStreamConfigurationsAvgAggregateInputType = {
    RegionEndPoint?: true
    AuthenticationType?: true
    URLValidityTime?: true
  }

  export type AppStreamConfigurationsSumAggregateInputType = {
    RegionEndPoint?: true
    AuthenticationType?: true
    URLValidityTime?: true
  }

  export type AppStreamConfigurationsMinAggregateInputType = {
    Id?: true
    RegionEndPoint?: true
    FleetName?: true
    StackName?: true
    ApplicationID?: true
    AuthenticationType?: true
    URLValidityTime?: true
    AWSConfigurationsId?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type AppStreamConfigurationsMaxAggregateInputType = {
    Id?: true
    RegionEndPoint?: true
    FleetName?: true
    StackName?: true
    ApplicationID?: true
    AuthenticationType?: true
    URLValidityTime?: true
    AWSConfigurationsId?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type AppStreamConfigurationsCountAggregateInputType = {
    Id?: true
    RegionEndPoint?: true
    FleetName?: true
    StackName?: true
    ApplicationID?: true
    AuthenticationType?: true
    URLValidityTime?: true
    AWSConfigurationsId?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type AppStreamConfigurationsAggregateArgs = {
    /**
     * Filter which AppStreamConfigurations to aggregate.
     * 
    **/
    where?: AppStreamConfigurationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppStreamConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AppStreamConfigurationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AppStreamConfigurationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppStreamConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppStreamConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppStreamConfigurations
    **/
    _count?: true | AppStreamConfigurationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppStreamConfigurationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppStreamConfigurationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppStreamConfigurationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppStreamConfigurationsMaxAggregateInputType
  }

  export type GetAppStreamConfigurationsAggregateType<T extends AppStreamConfigurationsAggregateArgs> = {
        [P in keyof T & keyof AggregateAppStreamConfigurations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppStreamConfigurations[P]>
      : GetScalarType<T[P], AggregateAppStreamConfigurations[P]>
  }




  export type AppStreamConfigurationsGroupByArgs = {
    where?: AppStreamConfigurationsWhereInput
    orderBy?: Enumerable<AppStreamConfigurationsOrderByWithAggregationInput>
    by: Array<AppStreamConfigurationsScalarFieldEnum>
    having?: AppStreamConfigurationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppStreamConfigurationsCountAggregateInputType | true
    _avg?: AppStreamConfigurationsAvgAggregateInputType
    _sum?: AppStreamConfigurationsSumAggregateInputType
    _min?: AppStreamConfigurationsMinAggregateInputType
    _max?: AppStreamConfigurationsMaxAggregateInputType
  }


  export type AppStreamConfigurationsGroupByOutputType = {
    Id: string
    RegionEndPoint: number
    FleetName: string
    StackName: string
    ApplicationID: string
    AuthenticationType: number
    URLValidityTime: number | null
    AWSConfigurationsId: string
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: AppStreamConfigurationsCountAggregateOutputType | null
    _avg: AppStreamConfigurationsAvgAggregateOutputType | null
    _sum: AppStreamConfigurationsSumAggregateOutputType | null
    _min: AppStreamConfigurationsMinAggregateOutputType | null
    _max: AppStreamConfigurationsMaxAggregateOutputType | null
  }

  type GetAppStreamConfigurationsGroupByPayload<T extends AppStreamConfigurationsGroupByArgs> = Promise<
    Array<
      PickArray<AppStreamConfigurationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppStreamConfigurationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppStreamConfigurationsGroupByOutputType[P]>
            : GetScalarType<T[P], AppStreamConfigurationsGroupByOutputType[P]>
        }
      >
    >


  export type AppStreamConfigurationsSelect = {
    Id?: boolean
    RegionEndPoint?: boolean
    FleetName?: boolean
    StackName?: boolean
    ApplicationID?: boolean
    AuthenticationType?: boolean
    URLValidityTime?: boolean
    AWSConfigurationsId?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type AppStreamConfigurationsGetPayload<
    S extends boolean | null | undefined | AppStreamConfigurationsArgs,
    U = keyof S
      > = S extends true
        ? AppStreamConfigurations
    : S extends undefined
    ? never
    : S extends AppStreamConfigurationsArgs | AppStreamConfigurationsFindManyArgs
    ?'include' extends U
    ? AppStreamConfigurations 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AppStreamConfigurations ?AppStreamConfigurations [P]
  : 
     never
  } 
    : AppStreamConfigurations
  : AppStreamConfigurations


  type AppStreamConfigurationsCountArgs = Merge<
    Omit<AppStreamConfigurationsFindManyArgs, 'select' | 'include'> & {
      select?: AppStreamConfigurationsCountAggregateInputType | true
    }
  >

  export interface AppStreamConfigurationsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AppStreamConfigurations that matches the filter.
     * @param {AppStreamConfigurationsFindUniqueArgs} args - Arguments to find a AppStreamConfigurations
     * @example
     * // Get one AppStreamConfigurations
     * const appStreamConfigurations = await prisma.appStreamConfigurations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppStreamConfigurationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AppStreamConfigurationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AppStreamConfigurations'> extends True ? CheckSelect<T, Prisma__AppStreamConfigurationsClient<AppStreamConfigurations>, Prisma__AppStreamConfigurationsClient<AppStreamConfigurationsGetPayload<T>>> : CheckSelect<T, Prisma__AppStreamConfigurationsClient<AppStreamConfigurations | null >, Prisma__AppStreamConfigurationsClient<AppStreamConfigurationsGetPayload<T> | null >>

    /**
     * Find the first AppStreamConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppStreamConfigurationsFindFirstArgs} args - Arguments to find a AppStreamConfigurations
     * @example
     * // Get one AppStreamConfigurations
     * const appStreamConfigurations = await prisma.appStreamConfigurations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppStreamConfigurationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AppStreamConfigurationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AppStreamConfigurations'> extends True ? CheckSelect<T, Prisma__AppStreamConfigurationsClient<AppStreamConfigurations>, Prisma__AppStreamConfigurationsClient<AppStreamConfigurationsGetPayload<T>>> : CheckSelect<T, Prisma__AppStreamConfigurationsClient<AppStreamConfigurations | null >, Prisma__AppStreamConfigurationsClient<AppStreamConfigurationsGetPayload<T> | null >>

    /**
     * Find zero or more AppStreamConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppStreamConfigurationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppStreamConfigurations
     * const appStreamConfigurations = await prisma.appStreamConfigurations.findMany()
     * 
     * // Get first 10 AppStreamConfigurations
     * const appStreamConfigurations = await prisma.appStreamConfigurations.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const appStreamConfigurationsWithIdOnly = await prisma.appStreamConfigurations.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends AppStreamConfigurationsFindManyArgs>(
      args?: SelectSubset<T, AppStreamConfigurationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AppStreamConfigurations>>, PrismaPromise<Array<AppStreamConfigurationsGetPayload<T>>>>

    /**
     * Create a AppStreamConfigurations.
     * @param {AppStreamConfigurationsCreateArgs} args - Arguments to create a AppStreamConfigurations.
     * @example
     * // Create one AppStreamConfigurations
     * const AppStreamConfigurations = await prisma.appStreamConfigurations.create({
     *   data: {
     *     // ... data to create a AppStreamConfigurations
     *   }
     * })
     * 
    **/
    create<T extends AppStreamConfigurationsCreateArgs>(
      args: SelectSubset<T, AppStreamConfigurationsCreateArgs>
    ): CheckSelect<T, Prisma__AppStreamConfigurationsClient<AppStreamConfigurations>, Prisma__AppStreamConfigurationsClient<AppStreamConfigurationsGetPayload<T>>>

    /**
     * Create many AppStreamConfigurations.
     *     @param {AppStreamConfigurationsCreateManyArgs} args - Arguments to create many AppStreamConfigurations.
     *     @example
     *     // Create many AppStreamConfigurations
     *     const appStreamConfigurations = await prisma.appStreamConfigurations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppStreamConfigurationsCreateManyArgs>(
      args?: SelectSubset<T, AppStreamConfigurationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AppStreamConfigurations.
     * @param {AppStreamConfigurationsDeleteArgs} args - Arguments to delete one AppStreamConfigurations.
     * @example
     * // Delete one AppStreamConfigurations
     * const AppStreamConfigurations = await prisma.appStreamConfigurations.delete({
     *   where: {
     *     // ... filter to delete one AppStreamConfigurations
     *   }
     * })
     * 
    **/
    delete<T extends AppStreamConfigurationsDeleteArgs>(
      args: SelectSubset<T, AppStreamConfigurationsDeleteArgs>
    ): CheckSelect<T, Prisma__AppStreamConfigurationsClient<AppStreamConfigurations>, Prisma__AppStreamConfigurationsClient<AppStreamConfigurationsGetPayload<T>>>

    /**
     * Update one AppStreamConfigurations.
     * @param {AppStreamConfigurationsUpdateArgs} args - Arguments to update one AppStreamConfigurations.
     * @example
     * // Update one AppStreamConfigurations
     * const appStreamConfigurations = await prisma.appStreamConfigurations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppStreamConfigurationsUpdateArgs>(
      args: SelectSubset<T, AppStreamConfigurationsUpdateArgs>
    ): CheckSelect<T, Prisma__AppStreamConfigurationsClient<AppStreamConfigurations>, Prisma__AppStreamConfigurationsClient<AppStreamConfigurationsGetPayload<T>>>

    /**
     * Delete zero or more AppStreamConfigurations.
     * @param {AppStreamConfigurationsDeleteManyArgs} args - Arguments to filter AppStreamConfigurations to delete.
     * @example
     * // Delete a few AppStreamConfigurations
     * const { count } = await prisma.appStreamConfigurations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppStreamConfigurationsDeleteManyArgs>(
      args?: SelectSubset<T, AppStreamConfigurationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppStreamConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppStreamConfigurationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppStreamConfigurations
     * const appStreamConfigurations = await prisma.appStreamConfigurations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppStreamConfigurationsUpdateManyArgs>(
      args: SelectSubset<T, AppStreamConfigurationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AppStreamConfigurations.
     * @param {AppStreamConfigurationsUpsertArgs} args - Arguments to update or create a AppStreamConfigurations.
     * @example
     * // Update or create a AppStreamConfigurations
     * const appStreamConfigurations = await prisma.appStreamConfigurations.upsert({
     *   create: {
     *     // ... data to create a AppStreamConfigurations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppStreamConfigurations we want to update
     *   }
     * })
    **/
    upsert<T extends AppStreamConfigurationsUpsertArgs>(
      args: SelectSubset<T, AppStreamConfigurationsUpsertArgs>
    ): CheckSelect<T, Prisma__AppStreamConfigurationsClient<AppStreamConfigurations>, Prisma__AppStreamConfigurationsClient<AppStreamConfigurationsGetPayload<T>>>

    /**
     * Count the number of AppStreamConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppStreamConfigurationsCountArgs} args - Arguments to filter AppStreamConfigurations to count.
     * @example
     * // Count the number of AppStreamConfigurations
     * const count = await prisma.appStreamConfigurations.count({
     *   where: {
     *     // ... the filter for the AppStreamConfigurations we want to count
     *   }
     * })
    **/
    count<T extends AppStreamConfigurationsCountArgs>(
      args?: Subset<T, AppStreamConfigurationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppStreamConfigurationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppStreamConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppStreamConfigurationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppStreamConfigurationsAggregateArgs>(args: Subset<T, AppStreamConfigurationsAggregateArgs>): PrismaPromise<GetAppStreamConfigurationsAggregateType<T>>

    /**
     * Group by AppStreamConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppStreamConfigurationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppStreamConfigurationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppStreamConfigurationsGroupByArgs['orderBy'] }
        : { orderBy?: AppStreamConfigurationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppStreamConfigurationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppStreamConfigurationsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppStreamConfigurations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AppStreamConfigurationsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AppStreamConfigurations findUnique
   */
  export type AppStreamConfigurationsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AppStreamConfigurations
     * 
    **/
    select?: AppStreamConfigurationsSelect | null
    /**
     * Throw an Error if a AppStreamConfigurations can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AppStreamConfigurations to fetch.
     * 
    **/
    where: AppStreamConfigurationsWhereUniqueInput
  }


  /**
   * AppStreamConfigurations findFirst
   */
  export type AppStreamConfigurationsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AppStreamConfigurations
     * 
    **/
    select?: AppStreamConfigurationsSelect | null
    /**
     * Throw an Error if a AppStreamConfigurations can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AppStreamConfigurations to fetch.
     * 
    **/
    where?: AppStreamConfigurationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppStreamConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AppStreamConfigurationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppStreamConfigurations.
     * 
    **/
    cursor?: AppStreamConfigurationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppStreamConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppStreamConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppStreamConfigurations.
     * 
    **/
    distinct?: Enumerable<AppStreamConfigurationsScalarFieldEnum>
  }


  /**
   * AppStreamConfigurations findMany
   */
  export type AppStreamConfigurationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the AppStreamConfigurations
     * 
    **/
    select?: AppStreamConfigurationsSelect | null
    /**
     * Filter, which AppStreamConfigurations to fetch.
     * 
    **/
    where?: AppStreamConfigurationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppStreamConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AppStreamConfigurationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppStreamConfigurations.
     * 
    **/
    cursor?: AppStreamConfigurationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppStreamConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppStreamConfigurations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AppStreamConfigurationsScalarFieldEnum>
  }


  /**
   * AppStreamConfigurations create
   */
  export type AppStreamConfigurationsCreateArgs = {
    /**
     * Select specific fields to fetch from the AppStreamConfigurations
     * 
    **/
    select?: AppStreamConfigurationsSelect | null
    /**
     * The data needed to create a AppStreamConfigurations.
     * 
    **/
    data: XOR<AppStreamConfigurationsCreateInput, AppStreamConfigurationsUncheckedCreateInput>
  }


  /**
   * AppStreamConfigurations createMany
   */
  export type AppStreamConfigurationsCreateManyArgs = {
    data: Enumerable<AppStreamConfigurationsCreateManyInput>
  }


  /**
   * AppStreamConfigurations update
   */
  export type AppStreamConfigurationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the AppStreamConfigurations
     * 
    **/
    select?: AppStreamConfigurationsSelect | null
    /**
     * The data needed to update a AppStreamConfigurations.
     * 
    **/
    data: XOR<AppStreamConfigurationsUpdateInput, AppStreamConfigurationsUncheckedUpdateInput>
    /**
     * Choose, which AppStreamConfigurations to update.
     * 
    **/
    where: AppStreamConfigurationsWhereUniqueInput
  }


  /**
   * AppStreamConfigurations updateMany
   */
  export type AppStreamConfigurationsUpdateManyArgs = {
    data: XOR<AppStreamConfigurationsUpdateManyMutationInput, AppStreamConfigurationsUncheckedUpdateManyInput>
    where?: AppStreamConfigurationsWhereInput
  }


  /**
   * AppStreamConfigurations upsert
   */
  export type AppStreamConfigurationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the AppStreamConfigurations
     * 
    **/
    select?: AppStreamConfigurationsSelect | null
    /**
     * The filter to search for the AppStreamConfigurations to update in case it exists.
     * 
    **/
    where: AppStreamConfigurationsWhereUniqueInput
    /**
     * In case the AppStreamConfigurations found by the `where` argument doesn't exist, create a new AppStreamConfigurations with this data.
     * 
    **/
    create: XOR<AppStreamConfigurationsCreateInput, AppStreamConfigurationsUncheckedCreateInput>
    /**
     * In case the AppStreamConfigurations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AppStreamConfigurationsUpdateInput, AppStreamConfigurationsUncheckedUpdateInput>
  }


  /**
   * AppStreamConfigurations delete
   */
  export type AppStreamConfigurationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the AppStreamConfigurations
     * 
    **/
    select?: AppStreamConfigurationsSelect | null
    /**
     * Filter which AppStreamConfigurations to delete.
     * 
    **/
    where: AppStreamConfigurationsWhereUniqueInput
  }


  /**
   * AppStreamConfigurations deleteMany
   */
  export type AppStreamConfigurationsDeleteManyArgs = {
    where?: AppStreamConfigurationsWhereInput
  }


  /**
   * AppStreamConfigurations without action
   */
  export type AppStreamConfigurationsArgs = {
    /**
     * Select specific fields to fetch from the AppStreamConfigurations
     * 
    **/
    select?: AppStreamConfigurationsSelect | null
  }



  /**
   * Model AppStreamUserConnectors
   */


  export type AggregateAppStreamUserConnectors = {
    _count: AppStreamUserConnectorsCountAggregateOutputType | null
    _min: AppStreamUserConnectorsMinAggregateOutputType | null
    _max: AppStreamUserConnectorsMaxAggregateOutputType | null
  }

  export type AppStreamUserConnectorsMinAggregateOutputType = {
    Id: string | null
    AppStreamARN: string | null
    AppStreamUserName: string | null
    AppStreamEmailId: string | null
    AppStreamConfiguration_Id: string | null
    User_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type AppStreamUserConnectorsMaxAggregateOutputType = {
    Id: string | null
    AppStreamARN: string | null
    AppStreamUserName: string | null
    AppStreamEmailId: string | null
    AppStreamConfiguration_Id: string | null
    User_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type AppStreamUserConnectorsCountAggregateOutputType = {
    Id: number
    AppStreamARN: number
    AppStreamUserName: number
    AppStreamEmailId: number
    AppStreamConfiguration_Id: number
    User_Id: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type AppStreamUserConnectorsMinAggregateInputType = {
    Id?: true
    AppStreamARN?: true
    AppStreamUserName?: true
    AppStreamEmailId?: true
    AppStreamConfiguration_Id?: true
    User_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type AppStreamUserConnectorsMaxAggregateInputType = {
    Id?: true
    AppStreamARN?: true
    AppStreamUserName?: true
    AppStreamEmailId?: true
    AppStreamConfiguration_Id?: true
    User_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type AppStreamUserConnectorsCountAggregateInputType = {
    Id?: true
    AppStreamARN?: true
    AppStreamUserName?: true
    AppStreamEmailId?: true
    AppStreamConfiguration_Id?: true
    User_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type AppStreamUserConnectorsAggregateArgs = {
    /**
     * Filter which AppStreamUserConnectors to aggregate.
     * 
    **/
    where?: AppStreamUserConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppStreamUserConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<AppStreamUserConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AppStreamUserConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppStreamUserConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppStreamUserConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppStreamUserConnectors
    **/
    _count?: true | AppStreamUserConnectorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppStreamUserConnectorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppStreamUserConnectorsMaxAggregateInputType
  }

  export type GetAppStreamUserConnectorsAggregateType<T extends AppStreamUserConnectorsAggregateArgs> = {
        [P in keyof T & keyof AggregateAppStreamUserConnectors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppStreamUserConnectors[P]>
      : GetScalarType<T[P], AggregateAppStreamUserConnectors[P]>
  }




  export type AppStreamUserConnectorsGroupByArgs = {
    where?: AppStreamUserConnectorsWhereInput
    orderBy?: Enumerable<AppStreamUserConnectorsOrderByWithAggregationInput>
    by: Array<AppStreamUserConnectorsScalarFieldEnum>
    having?: AppStreamUserConnectorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppStreamUserConnectorsCountAggregateInputType | true
    _min?: AppStreamUserConnectorsMinAggregateInputType
    _max?: AppStreamUserConnectorsMaxAggregateInputType
  }


  export type AppStreamUserConnectorsGroupByOutputType = {
    Id: string
    AppStreamARN: string
    AppStreamUserName: string | null
    AppStreamEmailId: string
    AppStreamConfiguration_Id: string
    User_Id: string
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: AppStreamUserConnectorsCountAggregateOutputType | null
    _min: AppStreamUserConnectorsMinAggregateOutputType | null
    _max: AppStreamUserConnectorsMaxAggregateOutputType | null
  }

  type GetAppStreamUserConnectorsGroupByPayload<T extends AppStreamUserConnectorsGroupByArgs> = Promise<
    Array<
      PickArray<AppStreamUserConnectorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppStreamUserConnectorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppStreamUserConnectorsGroupByOutputType[P]>
            : GetScalarType<T[P], AppStreamUserConnectorsGroupByOutputType[P]>
        }
      >
    >


  export type AppStreamUserConnectorsSelect = {
    Id?: boolean
    AppStreamARN?: boolean
    AppStreamUserName?: boolean
    AppStreamEmailId?: boolean
    AppStreamConfiguration_Id?: boolean
    User_Id?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type AppStreamUserConnectorsGetPayload<
    S extends boolean | null | undefined | AppStreamUserConnectorsArgs,
    U = keyof S
      > = S extends true
        ? AppStreamUserConnectors
    : S extends undefined
    ? never
    : S extends AppStreamUserConnectorsArgs | AppStreamUserConnectorsFindManyArgs
    ?'include' extends U
    ? AppStreamUserConnectors 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AppStreamUserConnectors ?AppStreamUserConnectors [P]
  : 
     never
  } 
    : AppStreamUserConnectors
  : AppStreamUserConnectors


  type AppStreamUserConnectorsCountArgs = Merge<
    Omit<AppStreamUserConnectorsFindManyArgs, 'select' | 'include'> & {
      select?: AppStreamUserConnectorsCountAggregateInputType | true
    }
  >

  export interface AppStreamUserConnectorsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AppStreamUserConnectors that matches the filter.
     * @param {AppStreamUserConnectorsFindUniqueArgs} args - Arguments to find a AppStreamUserConnectors
     * @example
     * // Get one AppStreamUserConnectors
     * const appStreamUserConnectors = await prisma.appStreamUserConnectors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppStreamUserConnectorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AppStreamUserConnectorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AppStreamUserConnectors'> extends True ? CheckSelect<T, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectors>, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectors | null >, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectorsGetPayload<T> | null >>

    /**
     * Find the first AppStreamUserConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppStreamUserConnectorsFindFirstArgs} args - Arguments to find a AppStreamUserConnectors
     * @example
     * // Get one AppStreamUserConnectors
     * const appStreamUserConnectors = await prisma.appStreamUserConnectors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppStreamUserConnectorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AppStreamUserConnectorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AppStreamUserConnectors'> extends True ? CheckSelect<T, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectors>, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectors | null >, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectorsGetPayload<T> | null >>

    /**
     * Find zero or more AppStreamUserConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppStreamUserConnectorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppStreamUserConnectors
     * const appStreamUserConnectors = await prisma.appStreamUserConnectors.findMany()
     * 
     * // Get first 10 AppStreamUserConnectors
     * const appStreamUserConnectors = await prisma.appStreamUserConnectors.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const appStreamUserConnectorsWithIdOnly = await prisma.appStreamUserConnectors.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends AppStreamUserConnectorsFindManyArgs>(
      args?: SelectSubset<T, AppStreamUserConnectorsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AppStreamUserConnectors>>, PrismaPromise<Array<AppStreamUserConnectorsGetPayload<T>>>>

    /**
     * Create a AppStreamUserConnectors.
     * @param {AppStreamUserConnectorsCreateArgs} args - Arguments to create a AppStreamUserConnectors.
     * @example
     * // Create one AppStreamUserConnectors
     * const AppStreamUserConnectors = await prisma.appStreamUserConnectors.create({
     *   data: {
     *     // ... data to create a AppStreamUserConnectors
     *   }
     * })
     * 
    **/
    create<T extends AppStreamUserConnectorsCreateArgs>(
      args: SelectSubset<T, AppStreamUserConnectorsCreateArgs>
    ): CheckSelect<T, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectors>, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectorsGetPayload<T>>>

    /**
     * Create many AppStreamUserConnectors.
     *     @param {AppStreamUserConnectorsCreateManyArgs} args - Arguments to create many AppStreamUserConnectors.
     *     @example
     *     // Create many AppStreamUserConnectors
     *     const appStreamUserConnectors = await prisma.appStreamUserConnectors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppStreamUserConnectorsCreateManyArgs>(
      args?: SelectSubset<T, AppStreamUserConnectorsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AppStreamUserConnectors.
     * @param {AppStreamUserConnectorsDeleteArgs} args - Arguments to delete one AppStreamUserConnectors.
     * @example
     * // Delete one AppStreamUserConnectors
     * const AppStreamUserConnectors = await prisma.appStreamUserConnectors.delete({
     *   where: {
     *     // ... filter to delete one AppStreamUserConnectors
     *   }
     * })
     * 
    **/
    delete<T extends AppStreamUserConnectorsDeleteArgs>(
      args: SelectSubset<T, AppStreamUserConnectorsDeleteArgs>
    ): CheckSelect<T, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectors>, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectorsGetPayload<T>>>

    /**
     * Update one AppStreamUserConnectors.
     * @param {AppStreamUserConnectorsUpdateArgs} args - Arguments to update one AppStreamUserConnectors.
     * @example
     * // Update one AppStreamUserConnectors
     * const appStreamUserConnectors = await prisma.appStreamUserConnectors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppStreamUserConnectorsUpdateArgs>(
      args: SelectSubset<T, AppStreamUserConnectorsUpdateArgs>
    ): CheckSelect<T, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectors>, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectorsGetPayload<T>>>

    /**
     * Delete zero or more AppStreamUserConnectors.
     * @param {AppStreamUserConnectorsDeleteManyArgs} args - Arguments to filter AppStreamUserConnectors to delete.
     * @example
     * // Delete a few AppStreamUserConnectors
     * const { count } = await prisma.appStreamUserConnectors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppStreamUserConnectorsDeleteManyArgs>(
      args?: SelectSubset<T, AppStreamUserConnectorsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppStreamUserConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppStreamUserConnectorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppStreamUserConnectors
     * const appStreamUserConnectors = await prisma.appStreamUserConnectors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppStreamUserConnectorsUpdateManyArgs>(
      args: SelectSubset<T, AppStreamUserConnectorsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AppStreamUserConnectors.
     * @param {AppStreamUserConnectorsUpsertArgs} args - Arguments to update or create a AppStreamUserConnectors.
     * @example
     * // Update or create a AppStreamUserConnectors
     * const appStreamUserConnectors = await prisma.appStreamUserConnectors.upsert({
     *   create: {
     *     // ... data to create a AppStreamUserConnectors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppStreamUserConnectors we want to update
     *   }
     * })
    **/
    upsert<T extends AppStreamUserConnectorsUpsertArgs>(
      args: SelectSubset<T, AppStreamUserConnectorsUpsertArgs>
    ): CheckSelect<T, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectors>, Prisma__AppStreamUserConnectorsClient<AppStreamUserConnectorsGetPayload<T>>>

    /**
     * Count the number of AppStreamUserConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppStreamUserConnectorsCountArgs} args - Arguments to filter AppStreamUserConnectors to count.
     * @example
     * // Count the number of AppStreamUserConnectors
     * const count = await prisma.appStreamUserConnectors.count({
     *   where: {
     *     // ... the filter for the AppStreamUserConnectors we want to count
     *   }
     * })
    **/
    count<T extends AppStreamUserConnectorsCountArgs>(
      args?: Subset<T, AppStreamUserConnectorsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppStreamUserConnectorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppStreamUserConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppStreamUserConnectorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppStreamUserConnectorsAggregateArgs>(args: Subset<T, AppStreamUserConnectorsAggregateArgs>): PrismaPromise<GetAppStreamUserConnectorsAggregateType<T>>

    /**
     * Group by AppStreamUserConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppStreamUserConnectorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppStreamUserConnectorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppStreamUserConnectorsGroupByArgs['orderBy'] }
        : { orderBy?: AppStreamUserConnectorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppStreamUserConnectorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppStreamUserConnectorsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppStreamUserConnectors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AppStreamUserConnectorsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AppStreamUserConnectors findUnique
   */
  export type AppStreamUserConnectorsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AppStreamUserConnectors
     * 
    **/
    select?: AppStreamUserConnectorsSelect | null
    /**
     * Throw an Error if a AppStreamUserConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AppStreamUserConnectors to fetch.
     * 
    **/
    where: AppStreamUserConnectorsWhereUniqueInput
  }


  /**
   * AppStreamUserConnectors findFirst
   */
  export type AppStreamUserConnectorsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AppStreamUserConnectors
     * 
    **/
    select?: AppStreamUserConnectorsSelect | null
    /**
     * Throw an Error if a AppStreamUserConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AppStreamUserConnectors to fetch.
     * 
    **/
    where?: AppStreamUserConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppStreamUserConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<AppStreamUserConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppStreamUserConnectors.
     * 
    **/
    cursor?: AppStreamUserConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppStreamUserConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppStreamUserConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppStreamUserConnectors.
     * 
    **/
    distinct?: Enumerable<AppStreamUserConnectorsScalarFieldEnum>
  }


  /**
   * AppStreamUserConnectors findMany
   */
  export type AppStreamUserConnectorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the AppStreamUserConnectors
     * 
    **/
    select?: AppStreamUserConnectorsSelect | null
    /**
     * Filter, which AppStreamUserConnectors to fetch.
     * 
    **/
    where?: AppStreamUserConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppStreamUserConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<AppStreamUserConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppStreamUserConnectors.
     * 
    **/
    cursor?: AppStreamUserConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppStreamUserConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppStreamUserConnectors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AppStreamUserConnectorsScalarFieldEnum>
  }


  /**
   * AppStreamUserConnectors create
   */
  export type AppStreamUserConnectorsCreateArgs = {
    /**
     * Select specific fields to fetch from the AppStreamUserConnectors
     * 
    **/
    select?: AppStreamUserConnectorsSelect | null
    /**
     * The data needed to create a AppStreamUserConnectors.
     * 
    **/
    data: XOR<AppStreamUserConnectorsCreateInput, AppStreamUserConnectorsUncheckedCreateInput>
  }


  /**
   * AppStreamUserConnectors createMany
   */
  export type AppStreamUserConnectorsCreateManyArgs = {
    data: Enumerable<AppStreamUserConnectorsCreateManyInput>
  }


  /**
   * AppStreamUserConnectors update
   */
  export type AppStreamUserConnectorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the AppStreamUserConnectors
     * 
    **/
    select?: AppStreamUserConnectorsSelect | null
    /**
     * The data needed to update a AppStreamUserConnectors.
     * 
    **/
    data: XOR<AppStreamUserConnectorsUpdateInput, AppStreamUserConnectorsUncheckedUpdateInput>
    /**
     * Choose, which AppStreamUserConnectors to update.
     * 
    **/
    where: AppStreamUserConnectorsWhereUniqueInput
  }


  /**
   * AppStreamUserConnectors updateMany
   */
  export type AppStreamUserConnectorsUpdateManyArgs = {
    data: XOR<AppStreamUserConnectorsUpdateManyMutationInput, AppStreamUserConnectorsUncheckedUpdateManyInput>
    where?: AppStreamUserConnectorsWhereInput
  }


  /**
   * AppStreamUserConnectors upsert
   */
  export type AppStreamUserConnectorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the AppStreamUserConnectors
     * 
    **/
    select?: AppStreamUserConnectorsSelect | null
    /**
     * The filter to search for the AppStreamUserConnectors to update in case it exists.
     * 
    **/
    where: AppStreamUserConnectorsWhereUniqueInput
    /**
     * In case the AppStreamUserConnectors found by the `where` argument doesn't exist, create a new AppStreamUserConnectors with this data.
     * 
    **/
    create: XOR<AppStreamUserConnectorsCreateInput, AppStreamUserConnectorsUncheckedCreateInput>
    /**
     * In case the AppStreamUserConnectors was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AppStreamUserConnectorsUpdateInput, AppStreamUserConnectorsUncheckedUpdateInput>
  }


  /**
   * AppStreamUserConnectors delete
   */
  export type AppStreamUserConnectorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the AppStreamUserConnectors
     * 
    **/
    select?: AppStreamUserConnectorsSelect | null
    /**
     * Filter which AppStreamUserConnectors to delete.
     * 
    **/
    where: AppStreamUserConnectorsWhereUniqueInput
  }


  /**
   * AppStreamUserConnectors deleteMany
   */
  export type AppStreamUserConnectorsDeleteManyArgs = {
    where?: AppStreamUserConnectorsWhereInput
  }


  /**
   * AppStreamUserConnectors without action
   */
  export type AppStreamUserConnectorsArgs = {
    /**
     * Select specific fields to fetch from the AppStreamUserConnectors
     * 
    **/
    select?: AppStreamUserConnectorsSelect | null
  }



  /**
   * Model AuditEntities
   */


  export type AggregateAuditEntities = {
    _count: AuditEntitiesCountAggregateOutputType | null
    _min: AuditEntitiesMinAggregateOutputType | null
    _max: AuditEntitiesMaxAggregateOutputType | null
  }

  export type AuditEntitiesMinAggregateOutputType = {
    Id: string | null
    Type: string | null
    ActionBy: string | null
    Details: string | null
    CreatedDate: Date | null
    UserAgent: string | null
    IPAddress: string | null
  }

  export type AuditEntitiesMaxAggregateOutputType = {
    Id: string | null
    Type: string | null
    ActionBy: string | null
    Details: string | null
    CreatedDate: Date | null
    UserAgent: string | null
    IPAddress: string | null
  }

  export type AuditEntitiesCountAggregateOutputType = {
    Id: number
    Type: number
    ActionBy: number
    Details: number
    CreatedDate: number
    UserAgent: number
    IPAddress: number
    _all: number
  }


  export type AuditEntitiesMinAggregateInputType = {
    Id?: true
    Type?: true
    ActionBy?: true
    Details?: true
    CreatedDate?: true
    UserAgent?: true
    IPAddress?: true
  }

  export type AuditEntitiesMaxAggregateInputType = {
    Id?: true
    Type?: true
    ActionBy?: true
    Details?: true
    CreatedDate?: true
    UserAgent?: true
    IPAddress?: true
  }

  export type AuditEntitiesCountAggregateInputType = {
    Id?: true
    Type?: true
    ActionBy?: true
    Details?: true
    CreatedDate?: true
    UserAgent?: true
    IPAddress?: true
    _all?: true
  }

  export type AuditEntitiesAggregateArgs = {
    /**
     * Filter which AuditEntities to aggregate.
     * 
    **/
    where?: AuditEntitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEntities to fetch.
     * 
    **/
    orderBy?: Enumerable<AuditEntitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AuditEntitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEntities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEntities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditEntities
    **/
    _count?: true | AuditEntitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditEntitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditEntitiesMaxAggregateInputType
  }

  export type GetAuditEntitiesAggregateType<T extends AuditEntitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditEntities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditEntities[P]>
      : GetScalarType<T[P], AggregateAuditEntities[P]>
  }




  export type AuditEntitiesGroupByArgs = {
    where?: AuditEntitiesWhereInput
    orderBy?: Enumerable<AuditEntitiesOrderByWithAggregationInput>
    by: Array<AuditEntitiesScalarFieldEnum>
    having?: AuditEntitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditEntitiesCountAggregateInputType | true
    _min?: AuditEntitiesMinAggregateInputType
    _max?: AuditEntitiesMaxAggregateInputType
  }


  export type AuditEntitiesGroupByOutputType = {
    Id: string
    Type: string | null
    ActionBy: string | null
    Details: string | null
    CreatedDate: Date | null
    UserAgent: string | null
    IPAddress: string | null
    _count: AuditEntitiesCountAggregateOutputType | null
    _min: AuditEntitiesMinAggregateOutputType | null
    _max: AuditEntitiesMaxAggregateOutputType | null
  }

  type GetAuditEntitiesGroupByPayload<T extends AuditEntitiesGroupByArgs> = Promise<
    Array<
      PickArray<AuditEntitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditEntitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditEntitiesGroupByOutputType[P]>
            : GetScalarType<T[P], AuditEntitiesGroupByOutputType[P]>
        }
      >
    >


  export type AuditEntitiesSelect = {
    Id?: boolean
    Type?: boolean
    ActionBy?: boolean
    Details?: boolean
    CreatedDate?: boolean
    UserAgent?: boolean
    IPAddress?: boolean
  }

  export type AuditEntitiesGetPayload<
    S extends boolean | null | undefined | AuditEntitiesArgs,
    U = keyof S
      > = S extends true
        ? AuditEntities
    : S extends undefined
    ? never
    : S extends AuditEntitiesArgs | AuditEntitiesFindManyArgs
    ?'include' extends U
    ? AuditEntities 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AuditEntities ?AuditEntities [P]
  : 
     never
  } 
    : AuditEntities
  : AuditEntities


  type AuditEntitiesCountArgs = Merge<
    Omit<AuditEntitiesFindManyArgs, 'select' | 'include'> & {
      select?: AuditEntitiesCountAggregateInputType | true
    }
  >

  export interface AuditEntitiesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AuditEntities that matches the filter.
     * @param {AuditEntitiesFindUniqueArgs} args - Arguments to find a AuditEntities
     * @example
     * // Get one AuditEntities
     * const auditEntities = await prisma.auditEntities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuditEntitiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AuditEntitiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AuditEntities'> extends True ? CheckSelect<T, Prisma__AuditEntitiesClient<AuditEntities>, Prisma__AuditEntitiesClient<AuditEntitiesGetPayload<T>>> : CheckSelect<T, Prisma__AuditEntitiesClient<AuditEntities | null >, Prisma__AuditEntitiesClient<AuditEntitiesGetPayload<T> | null >>

    /**
     * Find the first AuditEntities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEntitiesFindFirstArgs} args - Arguments to find a AuditEntities
     * @example
     * // Get one AuditEntities
     * const auditEntities = await prisma.auditEntities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuditEntitiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AuditEntitiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AuditEntities'> extends True ? CheckSelect<T, Prisma__AuditEntitiesClient<AuditEntities>, Prisma__AuditEntitiesClient<AuditEntitiesGetPayload<T>>> : CheckSelect<T, Prisma__AuditEntitiesClient<AuditEntities | null >, Prisma__AuditEntitiesClient<AuditEntitiesGetPayload<T> | null >>

    /**
     * Find zero or more AuditEntities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEntitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditEntities
     * const auditEntities = await prisma.auditEntities.findMany()
     * 
     * // Get first 10 AuditEntities
     * const auditEntities = await prisma.auditEntities.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const auditEntitiesWithIdOnly = await prisma.auditEntities.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends AuditEntitiesFindManyArgs>(
      args?: SelectSubset<T, AuditEntitiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AuditEntities>>, PrismaPromise<Array<AuditEntitiesGetPayload<T>>>>

    /**
     * Create a AuditEntities.
     * @param {AuditEntitiesCreateArgs} args - Arguments to create a AuditEntities.
     * @example
     * // Create one AuditEntities
     * const AuditEntities = await prisma.auditEntities.create({
     *   data: {
     *     // ... data to create a AuditEntities
     *   }
     * })
     * 
    **/
    create<T extends AuditEntitiesCreateArgs>(
      args: SelectSubset<T, AuditEntitiesCreateArgs>
    ): CheckSelect<T, Prisma__AuditEntitiesClient<AuditEntities>, Prisma__AuditEntitiesClient<AuditEntitiesGetPayload<T>>>

    /**
     * Create many AuditEntities.
     *     @param {AuditEntitiesCreateManyArgs} args - Arguments to create many AuditEntities.
     *     @example
     *     // Create many AuditEntities
     *     const auditEntities = await prisma.auditEntities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuditEntitiesCreateManyArgs>(
      args?: SelectSubset<T, AuditEntitiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AuditEntities.
     * @param {AuditEntitiesDeleteArgs} args - Arguments to delete one AuditEntities.
     * @example
     * // Delete one AuditEntities
     * const AuditEntities = await prisma.auditEntities.delete({
     *   where: {
     *     // ... filter to delete one AuditEntities
     *   }
     * })
     * 
    **/
    delete<T extends AuditEntitiesDeleteArgs>(
      args: SelectSubset<T, AuditEntitiesDeleteArgs>
    ): CheckSelect<T, Prisma__AuditEntitiesClient<AuditEntities>, Prisma__AuditEntitiesClient<AuditEntitiesGetPayload<T>>>

    /**
     * Update one AuditEntities.
     * @param {AuditEntitiesUpdateArgs} args - Arguments to update one AuditEntities.
     * @example
     * // Update one AuditEntities
     * const auditEntities = await prisma.auditEntities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuditEntitiesUpdateArgs>(
      args: SelectSubset<T, AuditEntitiesUpdateArgs>
    ): CheckSelect<T, Prisma__AuditEntitiesClient<AuditEntities>, Prisma__AuditEntitiesClient<AuditEntitiesGetPayload<T>>>

    /**
     * Delete zero or more AuditEntities.
     * @param {AuditEntitiesDeleteManyArgs} args - Arguments to filter AuditEntities to delete.
     * @example
     * // Delete a few AuditEntities
     * const { count } = await prisma.auditEntities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuditEntitiesDeleteManyArgs>(
      args?: SelectSubset<T, AuditEntitiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEntitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditEntities
     * const auditEntities = await prisma.auditEntities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuditEntitiesUpdateManyArgs>(
      args: SelectSubset<T, AuditEntitiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditEntities.
     * @param {AuditEntitiesUpsertArgs} args - Arguments to update or create a AuditEntities.
     * @example
     * // Update or create a AuditEntities
     * const auditEntities = await prisma.auditEntities.upsert({
     *   create: {
     *     // ... data to create a AuditEntities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditEntities we want to update
     *   }
     * })
    **/
    upsert<T extends AuditEntitiesUpsertArgs>(
      args: SelectSubset<T, AuditEntitiesUpsertArgs>
    ): CheckSelect<T, Prisma__AuditEntitiesClient<AuditEntities>, Prisma__AuditEntitiesClient<AuditEntitiesGetPayload<T>>>

    /**
     * Count the number of AuditEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEntitiesCountArgs} args - Arguments to filter AuditEntities to count.
     * @example
     * // Count the number of AuditEntities
     * const count = await prisma.auditEntities.count({
     *   where: {
     *     // ... the filter for the AuditEntities we want to count
     *   }
     * })
    **/
    count<T extends AuditEntitiesCountArgs>(
      args?: Subset<T, AuditEntitiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditEntitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEntitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditEntitiesAggregateArgs>(args: Subset<T, AuditEntitiesAggregateArgs>): PrismaPromise<GetAuditEntitiesAggregateType<T>>

    /**
     * Group by AuditEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEntitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditEntitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditEntitiesGroupByArgs['orderBy'] }
        : { orderBy?: AuditEntitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditEntitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditEntitiesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditEntities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AuditEntitiesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AuditEntities findUnique
   */
  export type AuditEntitiesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AuditEntities
     * 
    **/
    select?: AuditEntitiesSelect | null
    /**
     * Throw an Error if a AuditEntities can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AuditEntities to fetch.
     * 
    **/
    where: AuditEntitiesWhereUniqueInput
  }


  /**
   * AuditEntities findFirst
   */
  export type AuditEntitiesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AuditEntities
     * 
    **/
    select?: AuditEntitiesSelect | null
    /**
     * Throw an Error if a AuditEntities can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AuditEntities to fetch.
     * 
    **/
    where?: AuditEntitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEntities to fetch.
     * 
    **/
    orderBy?: Enumerable<AuditEntitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEntities.
     * 
    **/
    cursor?: AuditEntitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEntities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEntities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEntities.
     * 
    **/
    distinct?: Enumerable<AuditEntitiesScalarFieldEnum>
  }


  /**
   * AuditEntities findMany
   */
  export type AuditEntitiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the AuditEntities
     * 
    **/
    select?: AuditEntitiesSelect | null
    /**
     * Filter, which AuditEntities to fetch.
     * 
    **/
    where?: AuditEntitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEntities to fetch.
     * 
    **/
    orderBy?: Enumerable<AuditEntitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditEntities.
     * 
    **/
    cursor?: AuditEntitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEntities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEntities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AuditEntitiesScalarFieldEnum>
  }


  /**
   * AuditEntities create
   */
  export type AuditEntitiesCreateArgs = {
    /**
     * Select specific fields to fetch from the AuditEntities
     * 
    **/
    select?: AuditEntitiesSelect | null
    /**
     * The data needed to create a AuditEntities.
     * 
    **/
    data: XOR<AuditEntitiesCreateInput, AuditEntitiesUncheckedCreateInput>
  }


  /**
   * AuditEntities createMany
   */
  export type AuditEntitiesCreateManyArgs = {
    data: Enumerable<AuditEntitiesCreateManyInput>
  }


  /**
   * AuditEntities update
   */
  export type AuditEntitiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the AuditEntities
     * 
    **/
    select?: AuditEntitiesSelect | null
    /**
     * The data needed to update a AuditEntities.
     * 
    **/
    data: XOR<AuditEntitiesUpdateInput, AuditEntitiesUncheckedUpdateInput>
    /**
     * Choose, which AuditEntities to update.
     * 
    **/
    where: AuditEntitiesWhereUniqueInput
  }


  /**
   * AuditEntities updateMany
   */
  export type AuditEntitiesUpdateManyArgs = {
    data: XOR<AuditEntitiesUpdateManyMutationInput, AuditEntitiesUncheckedUpdateManyInput>
    where?: AuditEntitiesWhereInput
  }


  /**
   * AuditEntities upsert
   */
  export type AuditEntitiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the AuditEntities
     * 
    **/
    select?: AuditEntitiesSelect | null
    /**
     * The filter to search for the AuditEntities to update in case it exists.
     * 
    **/
    where: AuditEntitiesWhereUniqueInput
    /**
     * In case the AuditEntities found by the `where` argument doesn't exist, create a new AuditEntities with this data.
     * 
    **/
    create: XOR<AuditEntitiesCreateInput, AuditEntitiesUncheckedCreateInput>
    /**
     * In case the AuditEntities was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AuditEntitiesUpdateInput, AuditEntitiesUncheckedUpdateInput>
  }


  /**
   * AuditEntities delete
   */
  export type AuditEntitiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the AuditEntities
     * 
    **/
    select?: AuditEntitiesSelect | null
    /**
     * Filter which AuditEntities to delete.
     * 
    **/
    where: AuditEntitiesWhereUniqueInput
  }


  /**
   * AuditEntities deleteMany
   */
  export type AuditEntitiesDeleteManyArgs = {
    where?: AuditEntitiesWhereInput
  }


  /**
   * AuditEntities without action
   */
  export type AuditEntitiesArgs = {
    /**
     * Select specific fields to fetch from the AuditEntities
     * 
    **/
    select?: AuditEntitiesSelect | null
  }



  /**
   * Model AuditLogs
   */


  export type AggregateAuditLogs = {
    _count: AuditLogsCountAggregateOutputType | null
    _min: AuditLogsMinAggregateOutputType | null
    _max: AuditLogsMaxAggregateOutputType | null
  }

  export type AuditLogsMinAggregateOutputType = {
    Id: string | null
    Resource: string | null
    Resource_Id: string | null
    UserAction_Actionkey: string | null
    UserType: string | null
    Repository_Id: string | null
    ActionBy: string | null
    Details: string | null
    CreatedDate: Date | null
    UserAgent: string | null
    IPAddress: string | null
  }

  export type AuditLogsMaxAggregateOutputType = {
    Id: string | null
    Resource: string | null
    Resource_Id: string | null
    UserAction_Actionkey: string | null
    UserType: string | null
    Repository_Id: string | null
    ActionBy: string | null
    Details: string | null
    CreatedDate: Date | null
    UserAgent: string | null
    IPAddress: string | null
  }

  export type AuditLogsCountAggregateOutputType = {
    Id: number
    Resource: number
    Resource_Id: number
    UserAction_Actionkey: number
    UserType: number
    Repository_Id: number
    ActionBy: number
    Details: number
    CreatedDate: number
    UserAgent: number
    IPAddress: number
    _all: number
  }


  export type AuditLogsMinAggregateInputType = {
    Id?: true
    Resource?: true
    Resource_Id?: true
    UserAction_Actionkey?: true
    UserType?: true
    Repository_Id?: true
    ActionBy?: true
    Details?: true
    CreatedDate?: true
    UserAgent?: true
    IPAddress?: true
  }

  export type AuditLogsMaxAggregateInputType = {
    Id?: true
    Resource?: true
    Resource_Id?: true
    UserAction_Actionkey?: true
    UserType?: true
    Repository_Id?: true
    ActionBy?: true
    Details?: true
    CreatedDate?: true
    UserAgent?: true
    IPAddress?: true
  }

  export type AuditLogsCountAggregateInputType = {
    Id?: true
    Resource?: true
    Resource_Id?: true
    UserAction_Actionkey?: true
    UserType?: true
    Repository_Id?: true
    ActionBy?: true
    Details?: true
    CreatedDate?: true
    UserAgent?: true
    IPAddress?: true
    _all?: true
  }

  export type AuditLogsAggregateArgs = {
    /**
     * Filter which AuditLogs to aggregate.
     * 
    **/
    where?: AuditLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<AuditLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AuditLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogsMaxAggregateInputType
  }

  export type GetAuditLogsAggregateType<T extends AuditLogsAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLogs[P]>
      : GetScalarType<T[P], AggregateAuditLogs[P]>
  }




  export type AuditLogsGroupByArgs = {
    where?: AuditLogsWhereInput
    orderBy?: Enumerable<AuditLogsOrderByWithAggregationInput>
    by: Array<AuditLogsScalarFieldEnum>
    having?: AuditLogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogsCountAggregateInputType | true
    _min?: AuditLogsMinAggregateInputType
    _max?: AuditLogsMaxAggregateInputType
  }


  export type AuditLogsGroupByOutputType = {
    Id: string
    Resource: string | null
    Resource_Id: string | null
    UserAction_Actionkey: string | null
    UserType: string | null
    Repository_Id: string | null
    ActionBy: string | null
    Details: string | null
    CreatedDate: Date | null
    UserAgent: string | null
    IPAddress: string | null
    _count: AuditLogsCountAggregateOutputType | null
    _min: AuditLogsMinAggregateOutputType | null
    _max: AuditLogsMaxAggregateOutputType | null
  }

  type GetAuditLogsGroupByPayload<T extends AuditLogsGroupByArgs> = Promise<
    Array<
      PickArray<AuditLogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogsGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogsGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogsSelect = {
    Id?: boolean
    Resource?: boolean
    Resource_Id?: boolean
    UserAction_Actionkey?: boolean
    UserType?: boolean
    Repository_Id?: boolean
    ActionBy?: boolean
    Details?: boolean
    CreatedDate?: boolean
    UserAgent?: boolean
    IPAddress?: boolean
  }

  export type AuditLogsGetPayload<
    S extends boolean | null | undefined | AuditLogsArgs,
    U = keyof S
      > = S extends true
        ? AuditLogs
    : S extends undefined
    ? never
    : S extends AuditLogsArgs | AuditLogsFindManyArgs
    ?'include' extends U
    ? AuditLogs 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AuditLogs ?AuditLogs [P]
  : 
     never
  } 
    : AuditLogs
  : AuditLogs


  type AuditLogsCountArgs = Merge<
    Omit<AuditLogsFindManyArgs, 'select' | 'include'> & {
      select?: AuditLogsCountAggregateInputType | true
    }
  >

  export interface AuditLogsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AuditLogs that matches the filter.
     * @param {AuditLogsFindUniqueArgs} args - Arguments to find a AuditLogs
     * @example
     * // Get one AuditLogs
     * const auditLogs = await prisma.auditLogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuditLogsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AuditLogsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AuditLogs'> extends True ? CheckSelect<T, Prisma__AuditLogsClient<AuditLogs>, Prisma__AuditLogsClient<AuditLogsGetPayload<T>>> : CheckSelect<T, Prisma__AuditLogsClient<AuditLogs | null >, Prisma__AuditLogsClient<AuditLogsGetPayload<T> | null >>

    /**
     * Find the first AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogsFindFirstArgs} args - Arguments to find a AuditLogs
     * @example
     * // Get one AuditLogs
     * const auditLogs = await prisma.auditLogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuditLogsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AuditLogsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AuditLogs'> extends True ? CheckSelect<T, Prisma__AuditLogsClient<AuditLogs>, Prisma__AuditLogsClient<AuditLogsGetPayload<T>>> : CheckSelect<T, Prisma__AuditLogsClient<AuditLogs | null >, Prisma__AuditLogsClient<AuditLogsGetPayload<T> | null >>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLogs.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLogs.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const auditLogsWithIdOnly = await prisma.auditLogs.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends AuditLogsFindManyArgs>(
      args?: SelectSubset<T, AuditLogsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AuditLogs>>, PrismaPromise<Array<AuditLogsGetPayload<T>>>>

    /**
     * Create a AuditLogs.
     * @param {AuditLogsCreateArgs} args - Arguments to create a AuditLogs.
     * @example
     * // Create one AuditLogs
     * const AuditLogs = await prisma.auditLogs.create({
     *   data: {
     *     // ... data to create a AuditLogs
     *   }
     * })
     * 
    **/
    create<T extends AuditLogsCreateArgs>(
      args: SelectSubset<T, AuditLogsCreateArgs>
    ): CheckSelect<T, Prisma__AuditLogsClient<AuditLogs>, Prisma__AuditLogsClient<AuditLogsGetPayload<T>>>

    /**
     * Create many AuditLogs.
     *     @param {AuditLogsCreateManyArgs} args - Arguments to create many AuditLogs.
     *     @example
     *     // Create many AuditLogs
     *     const auditLogs = await prisma.auditLogs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuditLogsCreateManyArgs>(
      args?: SelectSubset<T, AuditLogsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLogs.
     * @param {AuditLogsDeleteArgs} args - Arguments to delete one AuditLogs.
     * @example
     * // Delete one AuditLogs
     * const AuditLogs = await prisma.auditLogs.delete({
     *   where: {
     *     // ... filter to delete one AuditLogs
     *   }
     * })
     * 
    **/
    delete<T extends AuditLogsDeleteArgs>(
      args: SelectSubset<T, AuditLogsDeleteArgs>
    ): CheckSelect<T, Prisma__AuditLogsClient<AuditLogs>, Prisma__AuditLogsClient<AuditLogsGetPayload<T>>>

    /**
     * Update one AuditLogs.
     * @param {AuditLogsUpdateArgs} args - Arguments to update one AuditLogs.
     * @example
     * // Update one AuditLogs
     * const auditLogs = await prisma.auditLogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuditLogsUpdateArgs>(
      args: SelectSubset<T, AuditLogsUpdateArgs>
    ): CheckSelect<T, Prisma__AuditLogsClient<AuditLogs>, Prisma__AuditLogsClient<AuditLogsGetPayload<T>>>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogsDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuditLogsDeleteManyArgs>(
      args?: SelectSubset<T, AuditLogsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLogs = await prisma.auditLogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuditLogsUpdateManyArgs>(
      args: SelectSubset<T, AuditLogsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLogs.
     * @param {AuditLogsUpsertArgs} args - Arguments to update or create a AuditLogs.
     * @example
     * // Update or create a AuditLogs
     * const auditLogs = await prisma.auditLogs.upsert({
     *   create: {
     *     // ... data to create a AuditLogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLogs we want to update
     *   }
     * })
    **/
    upsert<T extends AuditLogsUpsertArgs>(
      args: SelectSubset<T, AuditLogsUpsertArgs>
    ): CheckSelect<T, Prisma__AuditLogsClient<AuditLogs>, Prisma__AuditLogsClient<AuditLogsGetPayload<T>>>

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogsCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLogs.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogsCountArgs>(
      args?: Subset<T, AuditLogsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogsAggregateArgs>(args: Subset<T, AuditLogsAggregateArgs>): PrismaPromise<GetAuditLogsAggregateType<T>>

    /**
     * Group by AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogsGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AuditLogsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AuditLogs findUnique
   */
  export type AuditLogsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AuditLogs
     * 
    **/
    select?: AuditLogsSelect | null
    /**
     * Throw an Error if a AuditLogs can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AuditLogs to fetch.
     * 
    **/
    where: AuditLogsWhereUniqueInput
  }


  /**
   * AuditLogs findFirst
   */
  export type AuditLogsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AuditLogs
     * 
    **/
    select?: AuditLogsSelect | null
    /**
     * Throw an Error if a AuditLogs can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AuditLogs to fetch.
     * 
    **/
    where?: AuditLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<AuditLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     * 
    **/
    cursor?: AuditLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     * 
    **/
    distinct?: Enumerable<AuditLogsScalarFieldEnum>
  }


  /**
   * AuditLogs findMany
   */
  export type AuditLogsFindManyArgs = {
    /**
     * Select specific fields to fetch from the AuditLogs
     * 
    **/
    select?: AuditLogsSelect | null
    /**
     * Filter, which AuditLogs to fetch.
     * 
    **/
    where?: AuditLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<AuditLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     * 
    **/
    cursor?: AuditLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AuditLogsScalarFieldEnum>
  }


  /**
   * AuditLogs create
   */
  export type AuditLogsCreateArgs = {
    /**
     * Select specific fields to fetch from the AuditLogs
     * 
    **/
    select?: AuditLogsSelect | null
    /**
     * The data needed to create a AuditLogs.
     * 
    **/
    data: XOR<AuditLogsCreateInput, AuditLogsUncheckedCreateInput>
  }


  /**
   * AuditLogs createMany
   */
  export type AuditLogsCreateManyArgs = {
    data: Enumerable<AuditLogsCreateManyInput>
  }


  /**
   * AuditLogs update
   */
  export type AuditLogsUpdateArgs = {
    /**
     * Select specific fields to fetch from the AuditLogs
     * 
    **/
    select?: AuditLogsSelect | null
    /**
     * The data needed to update a AuditLogs.
     * 
    **/
    data: XOR<AuditLogsUpdateInput, AuditLogsUncheckedUpdateInput>
    /**
     * Choose, which AuditLogs to update.
     * 
    **/
    where: AuditLogsWhereUniqueInput
  }


  /**
   * AuditLogs updateMany
   */
  export type AuditLogsUpdateManyArgs = {
    data: XOR<AuditLogsUpdateManyMutationInput, AuditLogsUncheckedUpdateManyInput>
    where?: AuditLogsWhereInput
  }


  /**
   * AuditLogs upsert
   */
  export type AuditLogsUpsertArgs = {
    /**
     * Select specific fields to fetch from the AuditLogs
     * 
    **/
    select?: AuditLogsSelect | null
    /**
     * The filter to search for the AuditLogs to update in case it exists.
     * 
    **/
    where: AuditLogsWhereUniqueInput
    /**
     * In case the AuditLogs found by the `where` argument doesn't exist, create a new AuditLogs with this data.
     * 
    **/
    create: XOR<AuditLogsCreateInput, AuditLogsUncheckedCreateInput>
    /**
     * In case the AuditLogs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AuditLogsUpdateInput, AuditLogsUncheckedUpdateInput>
  }


  /**
   * AuditLogs delete
   */
  export type AuditLogsDeleteArgs = {
    /**
     * Select specific fields to fetch from the AuditLogs
     * 
    **/
    select?: AuditLogsSelect | null
    /**
     * Filter which AuditLogs to delete.
     * 
    **/
    where: AuditLogsWhereUniqueInput
  }


  /**
   * AuditLogs deleteMany
   */
  export type AuditLogsDeleteManyArgs = {
    where?: AuditLogsWhereInput
  }


  /**
   * AuditLogs without action
   */
  export type AuditLogsArgs = {
    /**
     * Select specific fields to fetch from the AuditLogs
     * 
    **/
    select?: AuditLogsSelect | null
  }



  /**
   * Model AWSConfigurations
   */


  export type AggregateAWSConfigurations = {
    _count: AWSConfigurationsCountAggregateOutputType | null
    _min: AWSConfigurationsMinAggregateOutputType | null
    _max: AWSConfigurationsMaxAggregateOutputType | null
  }

  export type AWSConfigurationsMinAggregateOutputType = {
    Id: string | null
    AccessKey: string | null
    Secretkey: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type AWSConfigurationsMaxAggregateOutputType = {
    Id: string | null
    AccessKey: string | null
    Secretkey: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type AWSConfigurationsCountAggregateOutputType = {
    Id: number
    AccessKey: number
    Secretkey: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type AWSConfigurationsMinAggregateInputType = {
    Id?: true
    AccessKey?: true
    Secretkey?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type AWSConfigurationsMaxAggregateInputType = {
    Id?: true
    AccessKey?: true
    Secretkey?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type AWSConfigurationsCountAggregateInputType = {
    Id?: true
    AccessKey?: true
    Secretkey?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type AWSConfigurationsAggregateArgs = {
    /**
     * Filter which AWSConfigurations to aggregate.
     * 
    **/
    where?: AWSConfigurationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AWSConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AWSConfigurationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AWSConfigurationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AWSConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AWSConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AWSConfigurations
    **/
    _count?: true | AWSConfigurationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AWSConfigurationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AWSConfigurationsMaxAggregateInputType
  }

  export type GetAWSConfigurationsAggregateType<T extends AWSConfigurationsAggregateArgs> = {
        [P in keyof T & keyof AggregateAWSConfigurations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAWSConfigurations[P]>
      : GetScalarType<T[P], AggregateAWSConfigurations[P]>
  }




  export type AWSConfigurationsGroupByArgs = {
    where?: AWSConfigurationsWhereInput
    orderBy?: Enumerable<AWSConfigurationsOrderByWithAggregationInput>
    by: Array<AWSConfigurationsScalarFieldEnum>
    having?: AWSConfigurationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AWSConfigurationsCountAggregateInputType | true
    _min?: AWSConfigurationsMinAggregateInputType
    _max?: AWSConfigurationsMaxAggregateInputType
  }


  export type AWSConfigurationsGroupByOutputType = {
    Id: string
    AccessKey: string
    Secretkey: string
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: AWSConfigurationsCountAggregateOutputType | null
    _min: AWSConfigurationsMinAggregateOutputType | null
    _max: AWSConfigurationsMaxAggregateOutputType | null
  }

  type GetAWSConfigurationsGroupByPayload<T extends AWSConfigurationsGroupByArgs> = Promise<
    Array<
      PickArray<AWSConfigurationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AWSConfigurationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AWSConfigurationsGroupByOutputType[P]>
            : GetScalarType<T[P], AWSConfigurationsGroupByOutputType[P]>
        }
      >
    >


  export type AWSConfigurationsSelect = {
    Id?: boolean
    AccessKey?: boolean
    Secretkey?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type AWSConfigurationsGetPayload<
    S extends boolean | null | undefined | AWSConfigurationsArgs,
    U = keyof S
      > = S extends true
        ? AWSConfigurations
    : S extends undefined
    ? never
    : S extends AWSConfigurationsArgs | AWSConfigurationsFindManyArgs
    ?'include' extends U
    ? AWSConfigurations 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AWSConfigurations ?AWSConfigurations [P]
  : 
     never
  } 
    : AWSConfigurations
  : AWSConfigurations


  type AWSConfigurationsCountArgs = Merge<
    Omit<AWSConfigurationsFindManyArgs, 'select' | 'include'> & {
      select?: AWSConfigurationsCountAggregateInputType | true
    }
  >

  export interface AWSConfigurationsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AWSConfigurations that matches the filter.
     * @param {AWSConfigurationsFindUniqueArgs} args - Arguments to find a AWSConfigurations
     * @example
     * // Get one AWSConfigurations
     * const aWSConfigurations = await prisma.aWSConfigurations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AWSConfigurationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AWSConfigurationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AWSConfigurations'> extends True ? CheckSelect<T, Prisma__AWSConfigurationsClient<AWSConfigurations>, Prisma__AWSConfigurationsClient<AWSConfigurationsGetPayload<T>>> : CheckSelect<T, Prisma__AWSConfigurationsClient<AWSConfigurations | null >, Prisma__AWSConfigurationsClient<AWSConfigurationsGetPayload<T> | null >>

    /**
     * Find the first AWSConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AWSConfigurationsFindFirstArgs} args - Arguments to find a AWSConfigurations
     * @example
     * // Get one AWSConfigurations
     * const aWSConfigurations = await prisma.aWSConfigurations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AWSConfigurationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AWSConfigurationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AWSConfigurations'> extends True ? CheckSelect<T, Prisma__AWSConfigurationsClient<AWSConfigurations>, Prisma__AWSConfigurationsClient<AWSConfigurationsGetPayload<T>>> : CheckSelect<T, Prisma__AWSConfigurationsClient<AWSConfigurations | null >, Prisma__AWSConfigurationsClient<AWSConfigurationsGetPayload<T> | null >>

    /**
     * Find zero or more AWSConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AWSConfigurationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AWSConfigurations
     * const aWSConfigurations = await prisma.aWSConfigurations.findMany()
     * 
     * // Get first 10 AWSConfigurations
     * const aWSConfigurations = await prisma.aWSConfigurations.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const aWSConfigurationsWithIdOnly = await prisma.aWSConfigurations.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends AWSConfigurationsFindManyArgs>(
      args?: SelectSubset<T, AWSConfigurationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AWSConfigurations>>, PrismaPromise<Array<AWSConfigurationsGetPayload<T>>>>

    /**
     * Create a AWSConfigurations.
     * @param {AWSConfigurationsCreateArgs} args - Arguments to create a AWSConfigurations.
     * @example
     * // Create one AWSConfigurations
     * const AWSConfigurations = await prisma.aWSConfigurations.create({
     *   data: {
     *     // ... data to create a AWSConfigurations
     *   }
     * })
     * 
    **/
    create<T extends AWSConfigurationsCreateArgs>(
      args: SelectSubset<T, AWSConfigurationsCreateArgs>
    ): CheckSelect<T, Prisma__AWSConfigurationsClient<AWSConfigurations>, Prisma__AWSConfigurationsClient<AWSConfigurationsGetPayload<T>>>

    /**
     * Create many AWSConfigurations.
     *     @param {AWSConfigurationsCreateManyArgs} args - Arguments to create many AWSConfigurations.
     *     @example
     *     // Create many AWSConfigurations
     *     const aWSConfigurations = await prisma.aWSConfigurations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AWSConfigurationsCreateManyArgs>(
      args?: SelectSubset<T, AWSConfigurationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AWSConfigurations.
     * @param {AWSConfigurationsDeleteArgs} args - Arguments to delete one AWSConfigurations.
     * @example
     * // Delete one AWSConfigurations
     * const AWSConfigurations = await prisma.aWSConfigurations.delete({
     *   where: {
     *     // ... filter to delete one AWSConfigurations
     *   }
     * })
     * 
    **/
    delete<T extends AWSConfigurationsDeleteArgs>(
      args: SelectSubset<T, AWSConfigurationsDeleteArgs>
    ): CheckSelect<T, Prisma__AWSConfigurationsClient<AWSConfigurations>, Prisma__AWSConfigurationsClient<AWSConfigurationsGetPayload<T>>>

    /**
     * Update one AWSConfigurations.
     * @param {AWSConfigurationsUpdateArgs} args - Arguments to update one AWSConfigurations.
     * @example
     * // Update one AWSConfigurations
     * const aWSConfigurations = await prisma.aWSConfigurations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AWSConfigurationsUpdateArgs>(
      args: SelectSubset<T, AWSConfigurationsUpdateArgs>
    ): CheckSelect<T, Prisma__AWSConfigurationsClient<AWSConfigurations>, Prisma__AWSConfigurationsClient<AWSConfigurationsGetPayload<T>>>

    /**
     * Delete zero or more AWSConfigurations.
     * @param {AWSConfigurationsDeleteManyArgs} args - Arguments to filter AWSConfigurations to delete.
     * @example
     * // Delete a few AWSConfigurations
     * const { count } = await prisma.aWSConfigurations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AWSConfigurationsDeleteManyArgs>(
      args?: SelectSubset<T, AWSConfigurationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AWSConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AWSConfigurationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AWSConfigurations
     * const aWSConfigurations = await prisma.aWSConfigurations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AWSConfigurationsUpdateManyArgs>(
      args: SelectSubset<T, AWSConfigurationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AWSConfigurations.
     * @param {AWSConfigurationsUpsertArgs} args - Arguments to update or create a AWSConfigurations.
     * @example
     * // Update or create a AWSConfigurations
     * const aWSConfigurations = await prisma.aWSConfigurations.upsert({
     *   create: {
     *     // ... data to create a AWSConfigurations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AWSConfigurations we want to update
     *   }
     * })
    **/
    upsert<T extends AWSConfigurationsUpsertArgs>(
      args: SelectSubset<T, AWSConfigurationsUpsertArgs>
    ): CheckSelect<T, Prisma__AWSConfigurationsClient<AWSConfigurations>, Prisma__AWSConfigurationsClient<AWSConfigurationsGetPayload<T>>>

    /**
     * Count the number of AWSConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AWSConfigurationsCountArgs} args - Arguments to filter AWSConfigurations to count.
     * @example
     * // Count the number of AWSConfigurations
     * const count = await prisma.aWSConfigurations.count({
     *   where: {
     *     // ... the filter for the AWSConfigurations we want to count
     *   }
     * })
    **/
    count<T extends AWSConfigurationsCountArgs>(
      args?: Subset<T, AWSConfigurationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AWSConfigurationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AWSConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AWSConfigurationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AWSConfigurationsAggregateArgs>(args: Subset<T, AWSConfigurationsAggregateArgs>): PrismaPromise<GetAWSConfigurationsAggregateType<T>>

    /**
     * Group by AWSConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AWSConfigurationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AWSConfigurationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AWSConfigurationsGroupByArgs['orderBy'] }
        : { orderBy?: AWSConfigurationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AWSConfigurationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAWSConfigurationsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AWSConfigurations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AWSConfigurationsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AWSConfigurations findUnique
   */
  export type AWSConfigurationsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AWSConfigurations
     * 
    **/
    select?: AWSConfigurationsSelect | null
    /**
     * Throw an Error if a AWSConfigurations can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AWSConfigurations to fetch.
     * 
    **/
    where: AWSConfigurationsWhereUniqueInput
  }


  /**
   * AWSConfigurations findFirst
   */
  export type AWSConfigurationsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AWSConfigurations
     * 
    **/
    select?: AWSConfigurationsSelect | null
    /**
     * Throw an Error if a AWSConfigurations can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AWSConfigurations to fetch.
     * 
    **/
    where?: AWSConfigurationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AWSConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AWSConfigurationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AWSConfigurations.
     * 
    **/
    cursor?: AWSConfigurationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AWSConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AWSConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AWSConfigurations.
     * 
    **/
    distinct?: Enumerable<AWSConfigurationsScalarFieldEnum>
  }


  /**
   * AWSConfigurations findMany
   */
  export type AWSConfigurationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the AWSConfigurations
     * 
    **/
    select?: AWSConfigurationsSelect | null
    /**
     * Filter, which AWSConfigurations to fetch.
     * 
    **/
    where?: AWSConfigurationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AWSConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AWSConfigurationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AWSConfigurations.
     * 
    **/
    cursor?: AWSConfigurationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AWSConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AWSConfigurations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AWSConfigurationsScalarFieldEnum>
  }


  /**
   * AWSConfigurations create
   */
  export type AWSConfigurationsCreateArgs = {
    /**
     * Select specific fields to fetch from the AWSConfigurations
     * 
    **/
    select?: AWSConfigurationsSelect | null
    /**
     * The data needed to create a AWSConfigurations.
     * 
    **/
    data: XOR<AWSConfigurationsCreateInput, AWSConfigurationsUncheckedCreateInput>
  }


  /**
   * AWSConfigurations createMany
   */
  export type AWSConfigurationsCreateManyArgs = {
    data: Enumerable<AWSConfigurationsCreateManyInput>
  }


  /**
   * AWSConfigurations update
   */
  export type AWSConfigurationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the AWSConfigurations
     * 
    **/
    select?: AWSConfigurationsSelect | null
    /**
     * The data needed to update a AWSConfigurations.
     * 
    **/
    data: XOR<AWSConfigurationsUpdateInput, AWSConfigurationsUncheckedUpdateInput>
    /**
     * Choose, which AWSConfigurations to update.
     * 
    **/
    where: AWSConfigurationsWhereUniqueInput
  }


  /**
   * AWSConfigurations updateMany
   */
  export type AWSConfigurationsUpdateManyArgs = {
    data: XOR<AWSConfigurationsUpdateManyMutationInput, AWSConfigurationsUncheckedUpdateManyInput>
    where?: AWSConfigurationsWhereInput
  }


  /**
   * AWSConfigurations upsert
   */
  export type AWSConfigurationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the AWSConfigurations
     * 
    **/
    select?: AWSConfigurationsSelect | null
    /**
     * The filter to search for the AWSConfigurations to update in case it exists.
     * 
    **/
    where: AWSConfigurationsWhereUniqueInput
    /**
     * In case the AWSConfigurations found by the `where` argument doesn't exist, create a new AWSConfigurations with this data.
     * 
    **/
    create: XOR<AWSConfigurationsCreateInput, AWSConfigurationsUncheckedCreateInput>
    /**
     * In case the AWSConfigurations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AWSConfigurationsUpdateInput, AWSConfigurationsUncheckedUpdateInput>
  }


  /**
   * AWSConfigurations delete
   */
  export type AWSConfigurationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the AWSConfigurations
     * 
    **/
    select?: AWSConfigurationsSelect | null
    /**
     * Filter which AWSConfigurations to delete.
     * 
    **/
    where: AWSConfigurationsWhereUniqueInput
  }


  /**
   * AWSConfigurations deleteMany
   */
  export type AWSConfigurationsDeleteManyArgs = {
    where?: AWSConfigurationsWhereInput
  }


  /**
   * AWSConfigurations without action
   */
  export type AWSConfigurationsArgs = {
    /**
     * Select specific fields to fetch from the AWSConfigurations
     * 
    **/
    select?: AWSConfigurationsSelect | null
  }



  /**
   * Model CreateElementNotifications
   */


  export type AggregateCreateElementNotifications = {
    _count: CreateElementNotificationsCountAggregateOutputType | null
    _avg: CreateElementNotificationsAvgAggregateOutputType | null
    _sum: CreateElementNotificationsSumAggregateOutputType | null
    _min: CreateElementNotificationsMinAggregateOutputType | null
    _max: CreateElementNotificationsMaxAggregateOutputType | null
  }

  export type CreateElementNotificationsAvgAggregateOutputType = {
    EnableNotification: number | null
  }

  export type CreateElementNotificationsSumAggregateOutputType = {
    EnableNotification: number | null
  }

  export type CreateElementNotificationsMinAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    EnableNotification: number | null
    User_Id: string | null
    UserGroup_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type CreateElementNotificationsMaxAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    EnableNotification: number | null
    User_Id: string | null
    UserGroup_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type CreateElementNotificationsCountAggregateOutputType = {
    Id: number
    Repository_Id: number
    EnableNotification: number
    User_Id: number
    UserGroup_Id: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type CreateElementNotificationsAvgAggregateInputType = {
    EnableNotification?: true
  }

  export type CreateElementNotificationsSumAggregateInputType = {
    EnableNotification?: true
  }

  export type CreateElementNotificationsMinAggregateInputType = {
    Id?: true
    Repository_Id?: true
    EnableNotification?: true
    User_Id?: true
    UserGroup_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type CreateElementNotificationsMaxAggregateInputType = {
    Id?: true
    Repository_Id?: true
    EnableNotification?: true
    User_Id?: true
    UserGroup_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type CreateElementNotificationsCountAggregateInputType = {
    Id?: true
    Repository_Id?: true
    EnableNotification?: true
    User_Id?: true
    UserGroup_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type CreateElementNotificationsAggregateArgs = {
    /**
     * Filter which CreateElementNotifications to aggregate.
     * 
    **/
    where?: CreateElementNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreateElementNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<CreateElementNotificationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CreateElementNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreateElementNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreateElementNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreateElementNotifications
    **/
    _count?: true | CreateElementNotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreateElementNotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreateElementNotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreateElementNotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreateElementNotificationsMaxAggregateInputType
  }

  export type GetCreateElementNotificationsAggregateType<T extends CreateElementNotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCreateElementNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreateElementNotifications[P]>
      : GetScalarType<T[P], AggregateCreateElementNotifications[P]>
  }




  export type CreateElementNotificationsGroupByArgs = {
    where?: CreateElementNotificationsWhereInput
    orderBy?: Enumerable<CreateElementNotificationsOrderByWithAggregationInput>
    by: Array<CreateElementNotificationsScalarFieldEnum>
    having?: CreateElementNotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreateElementNotificationsCountAggregateInputType | true
    _avg?: CreateElementNotificationsAvgAggregateInputType
    _sum?: CreateElementNotificationsSumAggregateInputType
    _min?: CreateElementNotificationsMinAggregateInputType
    _max?: CreateElementNotificationsMaxAggregateInputType
  }


  export type CreateElementNotificationsGroupByOutputType = {
    Id: string
    Repository_Id: string
    EnableNotification: number | null
    User_Id: string | null
    UserGroup_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: CreateElementNotificationsCountAggregateOutputType | null
    _avg: CreateElementNotificationsAvgAggregateOutputType | null
    _sum: CreateElementNotificationsSumAggregateOutputType | null
    _min: CreateElementNotificationsMinAggregateOutputType | null
    _max: CreateElementNotificationsMaxAggregateOutputType | null
  }

  type GetCreateElementNotificationsGroupByPayload<T extends CreateElementNotificationsGroupByArgs> = Promise<
    Array<
      PickArray<CreateElementNotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreateElementNotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreateElementNotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], CreateElementNotificationsGroupByOutputType[P]>
        }
      >
    >


  export type CreateElementNotificationsSelect = {
    Id?: boolean
    Repository_Id?: boolean
    EnableNotification?: boolean
    User_Id?: boolean
    UserGroup_Id?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type CreateElementNotificationsGetPayload<
    S extends boolean | null | undefined | CreateElementNotificationsArgs,
    U = keyof S
      > = S extends true
        ? CreateElementNotifications
    : S extends undefined
    ? never
    : S extends CreateElementNotificationsArgs | CreateElementNotificationsFindManyArgs
    ?'include' extends U
    ? CreateElementNotifications 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CreateElementNotifications ?CreateElementNotifications [P]
  : 
     never
  } 
    : CreateElementNotifications
  : CreateElementNotifications


  type CreateElementNotificationsCountArgs = Merge<
    Omit<CreateElementNotificationsFindManyArgs, 'select' | 'include'> & {
      select?: CreateElementNotificationsCountAggregateInputType | true
    }
  >

  export interface CreateElementNotificationsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CreateElementNotifications that matches the filter.
     * @param {CreateElementNotificationsFindUniqueArgs} args - Arguments to find a CreateElementNotifications
     * @example
     * // Get one CreateElementNotifications
     * const createElementNotifications = await prisma.createElementNotifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CreateElementNotificationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CreateElementNotificationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CreateElementNotifications'> extends True ? CheckSelect<T, Prisma__CreateElementNotificationsClient<CreateElementNotifications>, Prisma__CreateElementNotificationsClient<CreateElementNotificationsGetPayload<T>>> : CheckSelect<T, Prisma__CreateElementNotificationsClient<CreateElementNotifications | null >, Prisma__CreateElementNotificationsClient<CreateElementNotificationsGetPayload<T> | null >>

    /**
     * Find the first CreateElementNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreateElementNotificationsFindFirstArgs} args - Arguments to find a CreateElementNotifications
     * @example
     * // Get one CreateElementNotifications
     * const createElementNotifications = await prisma.createElementNotifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CreateElementNotificationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CreateElementNotificationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CreateElementNotifications'> extends True ? CheckSelect<T, Prisma__CreateElementNotificationsClient<CreateElementNotifications>, Prisma__CreateElementNotificationsClient<CreateElementNotificationsGetPayload<T>>> : CheckSelect<T, Prisma__CreateElementNotificationsClient<CreateElementNotifications | null >, Prisma__CreateElementNotificationsClient<CreateElementNotificationsGetPayload<T> | null >>

    /**
     * Find zero or more CreateElementNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreateElementNotificationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreateElementNotifications
     * const createElementNotifications = await prisma.createElementNotifications.findMany()
     * 
     * // Get first 10 CreateElementNotifications
     * const createElementNotifications = await prisma.createElementNotifications.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const createElementNotificationsWithIdOnly = await prisma.createElementNotifications.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends CreateElementNotificationsFindManyArgs>(
      args?: SelectSubset<T, CreateElementNotificationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CreateElementNotifications>>, PrismaPromise<Array<CreateElementNotificationsGetPayload<T>>>>

    /**
     * Create a CreateElementNotifications.
     * @param {CreateElementNotificationsCreateArgs} args - Arguments to create a CreateElementNotifications.
     * @example
     * // Create one CreateElementNotifications
     * const CreateElementNotifications = await prisma.createElementNotifications.create({
     *   data: {
     *     // ... data to create a CreateElementNotifications
     *   }
     * })
     * 
    **/
    create<T extends CreateElementNotificationsCreateArgs>(
      args: SelectSubset<T, CreateElementNotificationsCreateArgs>
    ): CheckSelect<T, Prisma__CreateElementNotificationsClient<CreateElementNotifications>, Prisma__CreateElementNotificationsClient<CreateElementNotificationsGetPayload<T>>>

    /**
     * Create many CreateElementNotifications.
     *     @param {CreateElementNotificationsCreateManyArgs} args - Arguments to create many CreateElementNotifications.
     *     @example
     *     // Create many CreateElementNotifications
     *     const createElementNotifications = await prisma.createElementNotifications.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CreateElementNotificationsCreateManyArgs>(
      args?: SelectSubset<T, CreateElementNotificationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CreateElementNotifications.
     * @param {CreateElementNotificationsDeleteArgs} args - Arguments to delete one CreateElementNotifications.
     * @example
     * // Delete one CreateElementNotifications
     * const CreateElementNotifications = await prisma.createElementNotifications.delete({
     *   where: {
     *     // ... filter to delete one CreateElementNotifications
     *   }
     * })
     * 
    **/
    delete<T extends CreateElementNotificationsDeleteArgs>(
      args: SelectSubset<T, CreateElementNotificationsDeleteArgs>
    ): CheckSelect<T, Prisma__CreateElementNotificationsClient<CreateElementNotifications>, Prisma__CreateElementNotificationsClient<CreateElementNotificationsGetPayload<T>>>

    /**
     * Update one CreateElementNotifications.
     * @param {CreateElementNotificationsUpdateArgs} args - Arguments to update one CreateElementNotifications.
     * @example
     * // Update one CreateElementNotifications
     * const createElementNotifications = await prisma.createElementNotifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CreateElementNotificationsUpdateArgs>(
      args: SelectSubset<T, CreateElementNotificationsUpdateArgs>
    ): CheckSelect<T, Prisma__CreateElementNotificationsClient<CreateElementNotifications>, Prisma__CreateElementNotificationsClient<CreateElementNotificationsGetPayload<T>>>

    /**
     * Delete zero or more CreateElementNotifications.
     * @param {CreateElementNotificationsDeleteManyArgs} args - Arguments to filter CreateElementNotifications to delete.
     * @example
     * // Delete a few CreateElementNotifications
     * const { count } = await prisma.createElementNotifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CreateElementNotificationsDeleteManyArgs>(
      args?: SelectSubset<T, CreateElementNotificationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreateElementNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreateElementNotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreateElementNotifications
     * const createElementNotifications = await prisma.createElementNotifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CreateElementNotificationsUpdateManyArgs>(
      args: SelectSubset<T, CreateElementNotificationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CreateElementNotifications.
     * @param {CreateElementNotificationsUpsertArgs} args - Arguments to update or create a CreateElementNotifications.
     * @example
     * // Update or create a CreateElementNotifications
     * const createElementNotifications = await prisma.createElementNotifications.upsert({
     *   create: {
     *     // ... data to create a CreateElementNotifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreateElementNotifications we want to update
     *   }
     * })
    **/
    upsert<T extends CreateElementNotificationsUpsertArgs>(
      args: SelectSubset<T, CreateElementNotificationsUpsertArgs>
    ): CheckSelect<T, Prisma__CreateElementNotificationsClient<CreateElementNotifications>, Prisma__CreateElementNotificationsClient<CreateElementNotificationsGetPayload<T>>>

    /**
     * Count the number of CreateElementNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreateElementNotificationsCountArgs} args - Arguments to filter CreateElementNotifications to count.
     * @example
     * // Count the number of CreateElementNotifications
     * const count = await prisma.createElementNotifications.count({
     *   where: {
     *     // ... the filter for the CreateElementNotifications we want to count
     *   }
     * })
    **/
    count<T extends CreateElementNotificationsCountArgs>(
      args?: Subset<T, CreateElementNotificationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreateElementNotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreateElementNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreateElementNotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreateElementNotificationsAggregateArgs>(args: Subset<T, CreateElementNotificationsAggregateArgs>): PrismaPromise<GetCreateElementNotificationsAggregateType<T>>

    /**
     * Group by CreateElementNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreateElementNotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreateElementNotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreateElementNotificationsGroupByArgs['orderBy'] }
        : { orderBy?: CreateElementNotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreateElementNotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreateElementNotificationsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreateElementNotifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CreateElementNotificationsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CreateElementNotifications findUnique
   */
  export type CreateElementNotificationsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CreateElementNotifications
     * 
    **/
    select?: CreateElementNotificationsSelect | null
    /**
     * Throw an Error if a CreateElementNotifications can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CreateElementNotifications to fetch.
     * 
    **/
    where: CreateElementNotificationsWhereUniqueInput
  }


  /**
   * CreateElementNotifications findFirst
   */
  export type CreateElementNotificationsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CreateElementNotifications
     * 
    **/
    select?: CreateElementNotificationsSelect | null
    /**
     * Throw an Error if a CreateElementNotifications can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CreateElementNotifications to fetch.
     * 
    **/
    where?: CreateElementNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreateElementNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<CreateElementNotificationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreateElementNotifications.
     * 
    **/
    cursor?: CreateElementNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreateElementNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreateElementNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreateElementNotifications.
     * 
    **/
    distinct?: Enumerable<CreateElementNotificationsScalarFieldEnum>
  }


  /**
   * CreateElementNotifications findMany
   */
  export type CreateElementNotificationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the CreateElementNotifications
     * 
    **/
    select?: CreateElementNotificationsSelect | null
    /**
     * Filter, which CreateElementNotifications to fetch.
     * 
    **/
    where?: CreateElementNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreateElementNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<CreateElementNotificationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreateElementNotifications.
     * 
    **/
    cursor?: CreateElementNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreateElementNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreateElementNotifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CreateElementNotificationsScalarFieldEnum>
  }


  /**
   * CreateElementNotifications create
   */
  export type CreateElementNotificationsCreateArgs = {
    /**
     * Select specific fields to fetch from the CreateElementNotifications
     * 
    **/
    select?: CreateElementNotificationsSelect | null
    /**
     * The data needed to create a CreateElementNotifications.
     * 
    **/
    data: XOR<CreateElementNotificationsCreateInput, CreateElementNotificationsUncheckedCreateInput>
  }


  /**
   * CreateElementNotifications createMany
   */
  export type CreateElementNotificationsCreateManyArgs = {
    data: Enumerable<CreateElementNotificationsCreateManyInput>
  }


  /**
   * CreateElementNotifications update
   */
  export type CreateElementNotificationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the CreateElementNotifications
     * 
    **/
    select?: CreateElementNotificationsSelect | null
    /**
     * The data needed to update a CreateElementNotifications.
     * 
    **/
    data: XOR<CreateElementNotificationsUpdateInput, CreateElementNotificationsUncheckedUpdateInput>
    /**
     * Choose, which CreateElementNotifications to update.
     * 
    **/
    where: CreateElementNotificationsWhereUniqueInput
  }


  /**
   * CreateElementNotifications updateMany
   */
  export type CreateElementNotificationsUpdateManyArgs = {
    data: XOR<CreateElementNotificationsUpdateManyMutationInput, CreateElementNotificationsUncheckedUpdateManyInput>
    where?: CreateElementNotificationsWhereInput
  }


  /**
   * CreateElementNotifications upsert
   */
  export type CreateElementNotificationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the CreateElementNotifications
     * 
    **/
    select?: CreateElementNotificationsSelect | null
    /**
     * The filter to search for the CreateElementNotifications to update in case it exists.
     * 
    **/
    where: CreateElementNotificationsWhereUniqueInput
    /**
     * In case the CreateElementNotifications found by the `where` argument doesn't exist, create a new CreateElementNotifications with this data.
     * 
    **/
    create: XOR<CreateElementNotificationsCreateInput, CreateElementNotificationsUncheckedCreateInput>
    /**
     * In case the CreateElementNotifications was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CreateElementNotificationsUpdateInput, CreateElementNotificationsUncheckedUpdateInput>
  }


  /**
   * CreateElementNotifications delete
   */
  export type CreateElementNotificationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the CreateElementNotifications
     * 
    **/
    select?: CreateElementNotificationsSelect | null
    /**
     * Filter which CreateElementNotifications to delete.
     * 
    **/
    where: CreateElementNotificationsWhereUniqueInput
  }


  /**
   * CreateElementNotifications deleteMany
   */
  export type CreateElementNotificationsDeleteManyArgs = {
    where?: CreateElementNotificationsWhereInput
  }


  /**
   * CreateElementNotifications without action
   */
  export type CreateElementNotificationsArgs = {
    /**
     * Select specific fields to fetch from the CreateElementNotifications
     * 
    **/
    select?: CreateElementNotificationsSelect | null
  }



  /**
   * Model DashboardReviewUserRoles
   */


  export type AggregateDashboardReviewUserRoles = {
    _count: DashboardReviewUserRolesCountAggregateOutputType | null
    _min: DashboardReviewUserRolesMinAggregateOutputType | null
    _max: DashboardReviewUserRolesMaxAggregateOutputType | null
  }

  export type DashboardReviewUserRolesMinAggregateOutputType = {
    Id: string | null
    DashboardId: string | null
    UserRole: string | null
  }

  export type DashboardReviewUserRolesMaxAggregateOutputType = {
    Id: string | null
    DashboardId: string | null
    UserRole: string | null
  }

  export type DashboardReviewUserRolesCountAggregateOutputType = {
    Id: number
    DashboardId: number
    UserRole: number
    _all: number
  }


  export type DashboardReviewUserRolesMinAggregateInputType = {
    Id?: true
    DashboardId?: true
    UserRole?: true
  }

  export type DashboardReviewUserRolesMaxAggregateInputType = {
    Id?: true
    DashboardId?: true
    UserRole?: true
  }

  export type DashboardReviewUserRolesCountAggregateInputType = {
    Id?: true
    DashboardId?: true
    UserRole?: true
    _all?: true
  }

  export type DashboardReviewUserRolesAggregateArgs = {
    /**
     * Filter which DashboardReviewUserRoles to aggregate.
     * 
    **/
    where?: DashboardReviewUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardReviewUserRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardReviewUserRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DashboardReviewUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardReviewUserRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardReviewUserRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardReviewUserRoles
    **/
    _count?: true | DashboardReviewUserRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardReviewUserRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardReviewUserRolesMaxAggregateInputType
  }

  export type GetDashboardReviewUserRolesAggregateType<T extends DashboardReviewUserRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardReviewUserRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardReviewUserRoles[P]>
      : GetScalarType<T[P], AggregateDashboardReviewUserRoles[P]>
  }




  export type DashboardReviewUserRolesGroupByArgs = {
    where?: DashboardReviewUserRolesWhereInput
    orderBy?: Enumerable<DashboardReviewUserRolesOrderByWithAggregationInput>
    by: Array<DashboardReviewUserRolesScalarFieldEnum>
    having?: DashboardReviewUserRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardReviewUserRolesCountAggregateInputType | true
    _min?: DashboardReviewUserRolesMinAggregateInputType
    _max?: DashboardReviewUserRolesMaxAggregateInputType
  }


  export type DashboardReviewUserRolesGroupByOutputType = {
    Id: string
    DashboardId: string
    UserRole: string
    _count: DashboardReviewUserRolesCountAggregateOutputType | null
    _min: DashboardReviewUserRolesMinAggregateOutputType | null
    _max: DashboardReviewUserRolesMaxAggregateOutputType | null
  }

  type GetDashboardReviewUserRolesGroupByPayload<T extends DashboardReviewUserRolesGroupByArgs> = Promise<
    Array<
      PickArray<DashboardReviewUserRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardReviewUserRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardReviewUserRolesGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardReviewUserRolesGroupByOutputType[P]>
        }
      >
    >


  export type DashboardReviewUserRolesSelect = {
    Id?: boolean
    DashboardId?: boolean
    UserRole?: boolean
  }

  export type DashboardReviewUserRolesGetPayload<
    S extends boolean | null | undefined | DashboardReviewUserRolesArgs,
    U = keyof S
      > = S extends true
        ? DashboardReviewUserRoles
    : S extends undefined
    ? never
    : S extends DashboardReviewUserRolesArgs | DashboardReviewUserRolesFindManyArgs
    ?'include' extends U
    ? DashboardReviewUserRoles 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DashboardReviewUserRoles ?DashboardReviewUserRoles [P]
  : 
     never
  } 
    : DashboardReviewUserRoles
  : DashboardReviewUserRoles


  type DashboardReviewUserRolesCountArgs = Merge<
    Omit<DashboardReviewUserRolesFindManyArgs, 'select' | 'include'> & {
      select?: DashboardReviewUserRolesCountAggregateInputType | true
    }
  >

  export interface DashboardReviewUserRolesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DashboardReviewUserRoles that matches the filter.
     * @param {DashboardReviewUserRolesFindUniqueArgs} args - Arguments to find a DashboardReviewUserRoles
     * @example
     * // Get one DashboardReviewUserRoles
     * const dashboardReviewUserRoles = await prisma.dashboardReviewUserRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DashboardReviewUserRolesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DashboardReviewUserRolesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DashboardReviewUserRoles'> extends True ? CheckSelect<T, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRoles>, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRolesGetPayload<T>>> : CheckSelect<T, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRoles | null >, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRolesGetPayload<T> | null >>

    /**
     * Find the first DashboardReviewUserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardReviewUserRolesFindFirstArgs} args - Arguments to find a DashboardReviewUserRoles
     * @example
     * // Get one DashboardReviewUserRoles
     * const dashboardReviewUserRoles = await prisma.dashboardReviewUserRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DashboardReviewUserRolesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DashboardReviewUserRolesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DashboardReviewUserRoles'> extends True ? CheckSelect<T, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRoles>, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRolesGetPayload<T>>> : CheckSelect<T, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRoles | null >, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRolesGetPayload<T> | null >>

    /**
     * Find zero or more DashboardReviewUserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardReviewUserRolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardReviewUserRoles
     * const dashboardReviewUserRoles = await prisma.dashboardReviewUserRoles.findMany()
     * 
     * // Get first 10 DashboardReviewUserRoles
     * const dashboardReviewUserRoles = await prisma.dashboardReviewUserRoles.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const dashboardReviewUserRolesWithIdOnly = await prisma.dashboardReviewUserRoles.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends DashboardReviewUserRolesFindManyArgs>(
      args?: SelectSubset<T, DashboardReviewUserRolesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DashboardReviewUserRoles>>, PrismaPromise<Array<DashboardReviewUserRolesGetPayload<T>>>>

    /**
     * Create a DashboardReviewUserRoles.
     * @param {DashboardReviewUserRolesCreateArgs} args - Arguments to create a DashboardReviewUserRoles.
     * @example
     * // Create one DashboardReviewUserRoles
     * const DashboardReviewUserRoles = await prisma.dashboardReviewUserRoles.create({
     *   data: {
     *     // ... data to create a DashboardReviewUserRoles
     *   }
     * })
     * 
    **/
    create<T extends DashboardReviewUserRolesCreateArgs>(
      args: SelectSubset<T, DashboardReviewUserRolesCreateArgs>
    ): CheckSelect<T, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRoles>, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRolesGetPayload<T>>>

    /**
     * Create many DashboardReviewUserRoles.
     *     @param {DashboardReviewUserRolesCreateManyArgs} args - Arguments to create many DashboardReviewUserRoles.
     *     @example
     *     // Create many DashboardReviewUserRoles
     *     const dashboardReviewUserRoles = await prisma.dashboardReviewUserRoles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DashboardReviewUserRolesCreateManyArgs>(
      args?: SelectSubset<T, DashboardReviewUserRolesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DashboardReviewUserRoles.
     * @param {DashboardReviewUserRolesDeleteArgs} args - Arguments to delete one DashboardReviewUserRoles.
     * @example
     * // Delete one DashboardReviewUserRoles
     * const DashboardReviewUserRoles = await prisma.dashboardReviewUserRoles.delete({
     *   where: {
     *     // ... filter to delete one DashboardReviewUserRoles
     *   }
     * })
     * 
    **/
    delete<T extends DashboardReviewUserRolesDeleteArgs>(
      args: SelectSubset<T, DashboardReviewUserRolesDeleteArgs>
    ): CheckSelect<T, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRoles>, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRolesGetPayload<T>>>

    /**
     * Update one DashboardReviewUserRoles.
     * @param {DashboardReviewUserRolesUpdateArgs} args - Arguments to update one DashboardReviewUserRoles.
     * @example
     * // Update one DashboardReviewUserRoles
     * const dashboardReviewUserRoles = await prisma.dashboardReviewUserRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DashboardReviewUserRolesUpdateArgs>(
      args: SelectSubset<T, DashboardReviewUserRolesUpdateArgs>
    ): CheckSelect<T, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRoles>, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRolesGetPayload<T>>>

    /**
     * Delete zero or more DashboardReviewUserRoles.
     * @param {DashboardReviewUserRolesDeleteManyArgs} args - Arguments to filter DashboardReviewUserRoles to delete.
     * @example
     * // Delete a few DashboardReviewUserRoles
     * const { count } = await prisma.dashboardReviewUserRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DashboardReviewUserRolesDeleteManyArgs>(
      args?: SelectSubset<T, DashboardReviewUserRolesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardReviewUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardReviewUserRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardReviewUserRoles
     * const dashboardReviewUserRoles = await prisma.dashboardReviewUserRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DashboardReviewUserRolesUpdateManyArgs>(
      args: SelectSubset<T, DashboardReviewUserRolesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DashboardReviewUserRoles.
     * @param {DashboardReviewUserRolesUpsertArgs} args - Arguments to update or create a DashboardReviewUserRoles.
     * @example
     * // Update or create a DashboardReviewUserRoles
     * const dashboardReviewUserRoles = await prisma.dashboardReviewUserRoles.upsert({
     *   create: {
     *     // ... data to create a DashboardReviewUserRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardReviewUserRoles we want to update
     *   }
     * })
    **/
    upsert<T extends DashboardReviewUserRolesUpsertArgs>(
      args: SelectSubset<T, DashboardReviewUserRolesUpsertArgs>
    ): CheckSelect<T, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRoles>, Prisma__DashboardReviewUserRolesClient<DashboardReviewUserRolesGetPayload<T>>>

    /**
     * Count the number of DashboardReviewUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardReviewUserRolesCountArgs} args - Arguments to filter DashboardReviewUserRoles to count.
     * @example
     * // Count the number of DashboardReviewUserRoles
     * const count = await prisma.dashboardReviewUserRoles.count({
     *   where: {
     *     // ... the filter for the DashboardReviewUserRoles we want to count
     *   }
     * })
    **/
    count<T extends DashboardReviewUserRolesCountArgs>(
      args?: Subset<T, DashboardReviewUserRolesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardReviewUserRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardReviewUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardReviewUserRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardReviewUserRolesAggregateArgs>(args: Subset<T, DashboardReviewUserRolesAggregateArgs>): PrismaPromise<GetDashboardReviewUserRolesAggregateType<T>>

    /**
     * Group by DashboardReviewUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardReviewUserRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardReviewUserRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardReviewUserRolesGroupByArgs['orderBy'] }
        : { orderBy?: DashboardReviewUserRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardReviewUserRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardReviewUserRolesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardReviewUserRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DashboardReviewUserRolesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DashboardReviewUserRoles findUnique
   */
  export type DashboardReviewUserRolesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DashboardReviewUserRoles
     * 
    **/
    select?: DashboardReviewUserRolesSelect | null
    /**
     * Throw an Error if a DashboardReviewUserRoles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardReviewUserRoles to fetch.
     * 
    **/
    where: DashboardReviewUserRolesWhereUniqueInput
  }


  /**
   * DashboardReviewUserRoles findFirst
   */
  export type DashboardReviewUserRolesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DashboardReviewUserRoles
     * 
    **/
    select?: DashboardReviewUserRolesSelect | null
    /**
     * Throw an Error if a DashboardReviewUserRoles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardReviewUserRoles to fetch.
     * 
    **/
    where?: DashboardReviewUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardReviewUserRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardReviewUserRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardReviewUserRoles.
     * 
    **/
    cursor?: DashboardReviewUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardReviewUserRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardReviewUserRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardReviewUserRoles.
     * 
    **/
    distinct?: Enumerable<DashboardReviewUserRolesScalarFieldEnum>
  }


  /**
   * DashboardReviewUserRoles findMany
   */
  export type DashboardReviewUserRolesFindManyArgs = {
    /**
     * Select specific fields to fetch from the DashboardReviewUserRoles
     * 
    **/
    select?: DashboardReviewUserRolesSelect | null
    /**
     * Filter, which DashboardReviewUserRoles to fetch.
     * 
    **/
    where?: DashboardReviewUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardReviewUserRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardReviewUserRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardReviewUserRoles.
     * 
    **/
    cursor?: DashboardReviewUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardReviewUserRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardReviewUserRoles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DashboardReviewUserRolesScalarFieldEnum>
  }


  /**
   * DashboardReviewUserRoles create
   */
  export type DashboardReviewUserRolesCreateArgs = {
    /**
     * Select specific fields to fetch from the DashboardReviewUserRoles
     * 
    **/
    select?: DashboardReviewUserRolesSelect | null
    /**
     * The data needed to create a DashboardReviewUserRoles.
     * 
    **/
    data: XOR<DashboardReviewUserRolesCreateInput, DashboardReviewUserRolesUncheckedCreateInput>
  }


  /**
   * DashboardReviewUserRoles createMany
   */
  export type DashboardReviewUserRolesCreateManyArgs = {
    data: Enumerable<DashboardReviewUserRolesCreateManyInput>
  }


  /**
   * DashboardReviewUserRoles update
   */
  export type DashboardReviewUserRolesUpdateArgs = {
    /**
     * Select specific fields to fetch from the DashboardReviewUserRoles
     * 
    **/
    select?: DashboardReviewUserRolesSelect | null
    /**
     * The data needed to update a DashboardReviewUserRoles.
     * 
    **/
    data: XOR<DashboardReviewUserRolesUpdateInput, DashboardReviewUserRolesUncheckedUpdateInput>
    /**
     * Choose, which DashboardReviewUserRoles to update.
     * 
    **/
    where: DashboardReviewUserRolesWhereUniqueInput
  }


  /**
   * DashboardReviewUserRoles updateMany
   */
  export type DashboardReviewUserRolesUpdateManyArgs = {
    data: XOR<DashboardReviewUserRolesUpdateManyMutationInput, DashboardReviewUserRolesUncheckedUpdateManyInput>
    where?: DashboardReviewUserRolesWhereInput
  }


  /**
   * DashboardReviewUserRoles upsert
   */
  export type DashboardReviewUserRolesUpsertArgs = {
    /**
     * Select specific fields to fetch from the DashboardReviewUserRoles
     * 
    **/
    select?: DashboardReviewUserRolesSelect | null
    /**
     * The filter to search for the DashboardReviewUserRoles to update in case it exists.
     * 
    **/
    where: DashboardReviewUserRolesWhereUniqueInput
    /**
     * In case the DashboardReviewUserRoles found by the `where` argument doesn't exist, create a new DashboardReviewUserRoles with this data.
     * 
    **/
    create: XOR<DashboardReviewUserRolesCreateInput, DashboardReviewUserRolesUncheckedCreateInput>
    /**
     * In case the DashboardReviewUserRoles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DashboardReviewUserRolesUpdateInput, DashboardReviewUserRolesUncheckedUpdateInput>
  }


  /**
   * DashboardReviewUserRoles delete
   */
  export type DashboardReviewUserRolesDeleteArgs = {
    /**
     * Select specific fields to fetch from the DashboardReviewUserRoles
     * 
    **/
    select?: DashboardReviewUserRolesSelect | null
    /**
     * Filter which DashboardReviewUserRoles to delete.
     * 
    **/
    where: DashboardReviewUserRolesWhereUniqueInput
  }


  /**
   * DashboardReviewUserRoles deleteMany
   */
  export type DashboardReviewUserRolesDeleteManyArgs = {
    where?: DashboardReviewUserRolesWhereInput
  }


  /**
   * DashboardReviewUserRoles without action
   */
  export type DashboardReviewUserRolesArgs = {
    /**
     * Select specific fields to fetch from the DashboardReviewUserRoles
     * 
    **/
    select?: DashboardReviewUserRolesSelect | null
  }



  /**
   * Model Dashboards
   */


  export type AggregateDashboards = {
    _count: DashboardsCountAggregateOutputType | null
    _avg: DashboardsAvgAggregateOutputType | null
    _sum: DashboardsSumAggregateOutputType | null
    _min: DashboardsMinAggregateOutputType | null
    _max: DashboardsMaxAggregateOutputType | null
  }

  export type DashboardsAvgAggregateOutputType = {
    IsEnabled: number | null
    IsDefault: number | null
    DisplayDescription: number | null
    Template: number | null
  }

  export type DashboardsSumAggregateOutputType = {
    IsEnabled: number | null
    IsDefault: number | null
    DisplayDescription: number | null
    Template: number | null
  }

  export type DashboardsMinAggregateOutputType = {
    Id: string | null
    RepositoryId: string | null
    Name: string | null
    Notes: string | null
    Logo: string | null
    IsEnabled: number | null
    CreatedBy: string | null
    Created: Date | null
    Modified: Date | null
    IsDefault: number | null
    DisplayDescription: number | null
    Type: string | null
    UserType: string | null
    DashboardSettings: string | null
    Template: number | null
  }

  export type DashboardsMaxAggregateOutputType = {
    Id: string | null
    RepositoryId: string | null
    Name: string | null
    Notes: string | null
    Logo: string | null
    IsEnabled: number | null
    CreatedBy: string | null
    Created: Date | null
    Modified: Date | null
    IsDefault: number | null
    DisplayDescription: number | null
    Type: string | null
    UserType: string | null
    DashboardSettings: string | null
    Template: number | null
  }

  export type DashboardsCountAggregateOutputType = {
    Id: number
    RepositoryId: number
    Name: number
    Notes: number
    Logo: number
    IsEnabled: number
    CreatedBy: number
    Created: number
    Modified: number
    IsDefault: number
    DisplayDescription: number
    Type: number
    UserType: number
    DashboardSettings: number
    Template: number
    _all: number
  }


  export type DashboardsAvgAggregateInputType = {
    IsEnabled?: true
    IsDefault?: true
    DisplayDescription?: true
    Template?: true
  }

  export type DashboardsSumAggregateInputType = {
    IsEnabled?: true
    IsDefault?: true
    DisplayDescription?: true
    Template?: true
  }

  export type DashboardsMinAggregateInputType = {
    Id?: true
    RepositoryId?: true
    Name?: true
    Notes?: true
    Logo?: true
    IsEnabled?: true
    CreatedBy?: true
    Created?: true
    Modified?: true
    IsDefault?: true
    DisplayDescription?: true
    Type?: true
    UserType?: true
    DashboardSettings?: true
    Template?: true
  }

  export type DashboardsMaxAggregateInputType = {
    Id?: true
    RepositoryId?: true
    Name?: true
    Notes?: true
    Logo?: true
    IsEnabled?: true
    CreatedBy?: true
    Created?: true
    Modified?: true
    IsDefault?: true
    DisplayDescription?: true
    Type?: true
    UserType?: true
    DashboardSettings?: true
    Template?: true
  }

  export type DashboardsCountAggregateInputType = {
    Id?: true
    RepositoryId?: true
    Name?: true
    Notes?: true
    Logo?: true
    IsEnabled?: true
    CreatedBy?: true
    Created?: true
    Modified?: true
    IsDefault?: true
    DisplayDescription?: true
    Type?: true
    UserType?: true
    DashboardSettings?: true
    Template?: true
    _all?: true
  }

  export type DashboardsAggregateArgs = {
    /**
     * Filter which Dashboards to aggregate.
     * 
    **/
    where?: DashboardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DashboardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dashboards
    **/
    _count?: true | DashboardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardsMaxAggregateInputType
  }

  export type GetDashboardsAggregateType<T extends DashboardsAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboards[P]>
      : GetScalarType<T[P], AggregateDashboards[P]>
  }




  export type DashboardsGroupByArgs = {
    where?: DashboardsWhereInput
    orderBy?: Enumerable<DashboardsOrderByWithAggregationInput>
    by: Array<DashboardsScalarFieldEnum>
    having?: DashboardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardsCountAggregateInputType | true
    _avg?: DashboardsAvgAggregateInputType
    _sum?: DashboardsSumAggregateInputType
    _min?: DashboardsMinAggregateInputType
    _max?: DashboardsMaxAggregateInputType
  }


  export type DashboardsGroupByOutputType = {
    Id: string
    RepositoryId: string
    Name: string
    Notes: string | null
    Logo: string | null
    IsEnabled: number
    CreatedBy: string
    Created: Date
    Modified: Date
    IsDefault: number | null
    DisplayDescription: number
    Type: string | null
    UserType: string | null
    DashboardSettings: string | null
    Template: number
    _count: DashboardsCountAggregateOutputType | null
    _avg: DashboardsAvgAggregateOutputType | null
    _sum: DashboardsSumAggregateOutputType | null
    _min: DashboardsMinAggregateOutputType | null
    _max: DashboardsMaxAggregateOutputType | null
  }

  type GetDashboardsGroupByPayload<T extends DashboardsGroupByArgs> = Promise<
    Array<
      PickArray<DashboardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardsGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardsGroupByOutputType[P]>
        }
      >
    >


  export type DashboardsSelect = {
    Id?: boolean
    RepositoryId?: boolean
    Name?: boolean
    Notes?: boolean
    Logo?: boolean
    IsEnabled?: boolean
    CreatedBy?: boolean
    Created?: boolean
    Modified?: boolean
    IsDefault?: boolean
    DisplayDescription?: boolean
    Type?: boolean
    UserType?: boolean
    DashboardSettings?: boolean
    Template?: boolean
  }

  export type DashboardsGetPayload<
    S extends boolean | null | undefined | DashboardsArgs,
    U = keyof S
      > = S extends true
        ? Dashboards
    : S extends undefined
    ? never
    : S extends DashboardsArgs | DashboardsFindManyArgs
    ?'include' extends U
    ? Dashboards 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Dashboards ?Dashboards [P]
  : 
     never
  } 
    : Dashboards
  : Dashboards


  type DashboardsCountArgs = Merge<
    Omit<DashboardsFindManyArgs, 'select' | 'include'> & {
      select?: DashboardsCountAggregateInputType | true
    }
  >

  export interface DashboardsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Dashboards that matches the filter.
     * @param {DashboardsFindUniqueArgs} args - Arguments to find a Dashboards
     * @example
     * // Get one Dashboards
     * const dashboards = await prisma.dashboards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DashboardsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DashboardsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Dashboards'> extends True ? CheckSelect<T, Prisma__DashboardsClient<Dashboards>, Prisma__DashboardsClient<DashboardsGetPayload<T>>> : CheckSelect<T, Prisma__DashboardsClient<Dashboards | null >, Prisma__DashboardsClient<DashboardsGetPayload<T> | null >>

    /**
     * Find the first Dashboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardsFindFirstArgs} args - Arguments to find a Dashboards
     * @example
     * // Get one Dashboards
     * const dashboards = await prisma.dashboards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DashboardsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DashboardsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Dashboards'> extends True ? CheckSelect<T, Prisma__DashboardsClient<Dashboards>, Prisma__DashboardsClient<DashboardsGetPayload<T>>> : CheckSelect<T, Prisma__DashboardsClient<Dashboards | null >, Prisma__DashboardsClient<DashboardsGetPayload<T> | null >>

    /**
     * Find zero or more Dashboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dashboards
     * const dashboards = await prisma.dashboards.findMany()
     * 
     * // Get first 10 Dashboards
     * const dashboards = await prisma.dashboards.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const dashboardsWithIdOnly = await prisma.dashboards.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends DashboardsFindManyArgs>(
      args?: SelectSubset<T, DashboardsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Dashboards>>, PrismaPromise<Array<DashboardsGetPayload<T>>>>

    /**
     * Create a Dashboards.
     * @param {DashboardsCreateArgs} args - Arguments to create a Dashboards.
     * @example
     * // Create one Dashboards
     * const Dashboards = await prisma.dashboards.create({
     *   data: {
     *     // ... data to create a Dashboards
     *   }
     * })
     * 
    **/
    create<T extends DashboardsCreateArgs>(
      args: SelectSubset<T, DashboardsCreateArgs>
    ): CheckSelect<T, Prisma__DashboardsClient<Dashboards>, Prisma__DashboardsClient<DashboardsGetPayload<T>>>

    /**
     * Create many Dashboards.
     *     @param {DashboardsCreateManyArgs} args - Arguments to create many Dashboards.
     *     @example
     *     // Create many Dashboards
     *     const dashboards = await prisma.dashboards.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DashboardsCreateManyArgs>(
      args?: SelectSubset<T, DashboardsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Dashboards.
     * @param {DashboardsDeleteArgs} args - Arguments to delete one Dashboards.
     * @example
     * // Delete one Dashboards
     * const Dashboards = await prisma.dashboards.delete({
     *   where: {
     *     // ... filter to delete one Dashboards
     *   }
     * })
     * 
    **/
    delete<T extends DashboardsDeleteArgs>(
      args: SelectSubset<T, DashboardsDeleteArgs>
    ): CheckSelect<T, Prisma__DashboardsClient<Dashboards>, Prisma__DashboardsClient<DashboardsGetPayload<T>>>

    /**
     * Update one Dashboards.
     * @param {DashboardsUpdateArgs} args - Arguments to update one Dashboards.
     * @example
     * // Update one Dashboards
     * const dashboards = await prisma.dashboards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DashboardsUpdateArgs>(
      args: SelectSubset<T, DashboardsUpdateArgs>
    ): CheckSelect<T, Prisma__DashboardsClient<Dashboards>, Prisma__DashboardsClient<DashboardsGetPayload<T>>>

    /**
     * Delete zero or more Dashboards.
     * @param {DashboardsDeleteManyArgs} args - Arguments to filter Dashboards to delete.
     * @example
     * // Delete a few Dashboards
     * const { count } = await prisma.dashboards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DashboardsDeleteManyArgs>(
      args?: SelectSubset<T, DashboardsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dashboards
     * const dashboards = await prisma.dashboards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DashboardsUpdateManyArgs>(
      args: SelectSubset<T, DashboardsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Dashboards.
     * @param {DashboardsUpsertArgs} args - Arguments to update or create a Dashboards.
     * @example
     * // Update or create a Dashboards
     * const dashboards = await prisma.dashboards.upsert({
     *   create: {
     *     // ... data to create a Dashboards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dashboards we want to update
     *   }
     * })
    **/
    upsert<T extends DashboardsUpsertArgs>(
      args: SelectSubset<T, DashboardsUpsertArgs>
    ): CheckSelect<T, Prisma__DashboardsClient<Dashboards>, Prisma__DashboardsClient<DashboardsGetPayload<T>>>

    /**
     * Count the number of Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardsCountArgs} args - Arguments to filter Dashboards to count.
     * @example
     * // Count the number of Dashboards
     * const count = await prisma.dashboards.count({
     *   where: {
     *     // ... the filter for the Dashboards we want to count
     *   }
     * })
    **/
    count<T extends DashboardsCountArgs>(
      args?: Subset<T, DashboardsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardsAggregateArgs>(args: Subset<T, DashboardsAggregateArgs>): PrismaPromise<GetDashboardsAggregateType<T>>

    /**
     * Group by Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardsGroupByArgs['orderBy'] }
        : { orderBy?: DashboardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dashboards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DashboardsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Dashboards findUnique
   */
  export type DashboardsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Dashboards
     * 
    **/
    select?: DashboardsSelect | null
    /**
     * Throw an Error if a Dashboards can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Dashboards to fetch.
     * 
    **/
    where: DashboardsWhereUniqueInput
  }


  /**
   * Dashboards findFirst
   */
  export type DashboardsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Dashboards
     * 
    **/
    select?: DashboardsSelect | null
    /**
     * Throw an Error if a Dashboards can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Dashboards to fetch.
     * 
    **/
    where?: DashboardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dashboards.
     * 
    **/
    cursor?: DashboardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dashboards.
     * 
    **/
    distinct?: Enumerable<DashboardsScalarFieldEnum>
  }


  /**
   * Dashboards findMany
   */
  export type DashboardsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Dashboards
     * 
    **/
    select?: DashboardsSelect | null
    /**
     * Filter, which Dashboards to fetch.
     * 
    **/
    where?: DashboardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dashboards.
     * 
    **/
    cursor?: DashboardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DashboardsScalarFieldEnum>
  }


  /**
   * Dashboards create
   */
  export type DashboardsCreateArgs = {
    /**
     * Select specific fields to fetch from the Dashboards
     * 
    **/
    select?: DashboardsSelect | null
    /**
     * The data needed to create a Dashboards.
     * 
    **/
    data: XOR<DashboardsCreateInput, DashboardsUncheckedCreateInput>
  }


  /**
   * Dashboards createMany
   */
  export type DashboardsCreateManyArgs = {
    data: Enumerable<DashboardsCreateManyInput>
  }


  /**
   * Dashboards update
   */
  export type DashboardsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Dashboards
     * 
    **/
    select?: DashboardsSelect | null
    /**
     * The data needed to update a Dashboards.
     * 
    **/
    data: XOR<DashboardsUpdateInput, DashboardsUncheckedUpdateInput>
    /**
     * Choose, which Dashboards to update.
     * 
    **/
    where: DashboardsWhereUniqueInput
  }


  /**
   * Dashboards updateMany
   */
  export type DashboardsUpdateManyArgs = {
    data: XOR<DashboardsUpdateManyMutationInput, DashboardsUncheckedUpdateManyInput>
    where?: DashboardsWhereInput
  }


  /**
   * Dashboards upsert
   */
  export type DashboardsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Dashboards
     * 
    **/
    select?: DashboardsSelect | null
    /**
     * The filter to search for the Dashboards to update in case it exists.
     * 
    **/
    where: DashboardsWhereUniqueInput
    /**
     * In case the Dashboards found by the `where` argument doesn't exist, create a new Dashboards with this data.
     * 
    **/
    create: XOR<DashboardsCreateInput, DashboardsUncheckedCreateInput>
    /**
     * In case the Dashboards was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DashboardsUpdateInput, DashboardsUncheckedUpdateInput>
  }


  /**
   * Dashboards delete
   */
  export type DashboardsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Dashboards
     * 
    **/
    select?: DashboardsSelect | null
    /**
     * Filter which Dashboards to delete.
     * 
    **/
    where: DashboardsWhereUniqueInput
  }


  /**
   * Dashboards deleteMany
   */
  export type DashboardsDeleteManyArgs = {
    where?: DashboardsWhereInput
  }


  /**
   * Dashboards without action
   */
  export type DashboardsArgs = {
    /**
     * Select specific fields to fetch from the Dashboards
     * 
    **/
    select?: DashboardsSelect | null
  }



  /**
   * Model DashboardUserDefault
   */


  export type AggregateDashboardUserDefault = {
    _count: DashboardUserDefaultCountAggregateOutputType | null
    _min: DashboardUserDefaultMinAggregateOutputType | null
    _max: DashboardUserDefaultMaxAggregateOutputType | null
  }

  export type DashboardUserDefaultMinAggregateOutputType = {
    Id: string | null
    UserId: string | null
    RepositoryId: string | null
    DashboardId: string | null
    Type: string | null
  }

  export type DashboardUserDefaultMaxAggregateOutputType = {
    Id: string | null
    UserId: string | null
    RepositoryId: string | null
    DashboardId: string | null
    Type: string | null
  }

  export type DashboardUserDefaultCountAggregateOutputType = {
    Id: number
    UserId: number
    RepositoryId: number
    DashboardId: number
    Type: number
    _all: number
  }


  export type DashboardUserDefaultMinAggregateInputType = {
    Id?: true
    UserId?: true
    RepositoryId?: true
    DashboardId?: true
    Type?: true
  }

  export type DashboardUserDefaultMaxAggregateInputType = {
    Id?: true
    UserId?: true
    RepositoryId?: true
    DashboardId?: true
    Type?: true
  }

  export type DashboardUserDefaultCountAggregateInputType = {
    Id?: true
    UserId?: true
    RepositoryId?: true
    DashboardId?: true
    Type?: true
    _all?: true
  }

  export type DashboardUserDefaultAggregateArgs = {
    /**
     * Filter which DashboardUserDefault to aggregate.
     * 
    **/
    where?: DashboardUserDefaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardUserDefaults to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardUserDefaultOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DashboardUserDefaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardUserDefaults from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardUserDefaults.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardUserDefaults
    **/
    _count?: true | DashboardUserDefaultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardUserDefaultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardUserDefaultMaxAggregateInputType
  }

  export type GetDashboardUserDefaultAggregateType<T extends DashboardUserDefaultAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardUserDefault]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardUserDefault[P]>
      : GetScalarType<T[P], AggregateDashboardUserDefault[P]>
  }




  export type DashboardUserDefaultGroupByArgs = {
    where?: DashboardUserDefaultWhereInput
    orderBy?: Enumerable<DashboardUserDefaultOrderByWithAggregationInput>
    by: Array<DashboardUserDefaultScalarFieldEnum>
    having?: DashboardUserDefaultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardUserDefaultCountAggregateInputType | true
    _min?: DashboardUserDefaultMinAggregateInputType
    _max?: DashboardUserDefaultMaxAggregateInputType
  }


  export type DashboardUserDefaultGroupByOutputType = {
    Id: string
    UserId: string
    RepositoryId: string
    DashboardId: string
    Type: string | null
    _count: DashboardUserDefaultCountAggregateOutputType | null
    _min: DashboardUserDefaultMinAggregateOutputType | null
    _max: DashboardUserDefaultMaxAggregateOutputType | null
  }

  type GetDashboardUserDefaultGroupByPayload<T extends DashboardUserDefaultGroupByArgs> = Promise<
    Array<
      PickArray<DashboardUserDefaultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardUserDefaultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardUserDefaultGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardUserDefaultGroupByOutputType[P]>
        }
      >
    >


  export type DashboardUserDefaultSelect = {
    Id?: boolean
    UserId?: boolean
    RepositoryId?: boolean
    DashboardId?: boolean
    Type?: boolean
  }

  export type DashboardUserDefaultGetPayload<
    S extends boolean | null | undefined | DashboardUserDefaultArgs,
    U = keyof S
      > = S extends true
        ? DashboardUserDefault
    : S extends undefined
    ? never
    : S extends DashboardUserDefaultArgs | DashboardUserDefaultFindManyArgs
    ?'include' extends U
    ? DashboardUserDefault 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DashboardUserDefault ?DashboardUserDefault [P]
  : 
     never
  } 
    : DashboardUserDefault
  : DashboardUserDefault


  type DashboardUserDefaultCountArgs = Merge<
    Omit<DashboardUserDefaultFindManyArgs, 'select' | 'include'> & {
      select?: DashboardUserDefaultCountAggregateInputType | true
    }
  >

  export interface DashboardUserDefaultDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DashboardUserDefault that matches the filter.
     * @param {DashboardUserDefaultFindUniqueArgs} args - Arguments to find a DashboardUserDefault
     * @example
     * // Get one DashboardUserDefault
     * const dashboardUserDefault = await prisma.dashboardUserDefault.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DashboardUserDefaultFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DashboardUserDefaultFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DashboardUserDefault'> extends True ? CheckSelect<T, Prisma__DashboardUserDefaultClient<DashboardUserDefault>, Prisma__DashboardUserDefaultClient<DashboardUserDefaultGetPayload<T>>> : CheckSelect<T, Prisma__DashboardUserDefaultClient<DashboardUserDefault | null >, Prisma__DashboardUserDefaultClient<DashboardUserDefaultGetPayload<T> | null >>

    /**
     * Find the first DashboardUserDefault that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUserDefaultFindFirstArgs} args - Arguments to find a DashboardUserDefault
     * @example
     * // Get one DashboardUserDefault
     * const dashboardUserDefault = await prisma.dashboardUserDefault.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DashboardUserDefaultFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DashboardUserDefaultFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DashboardUserDefault'> extends True ? CheckSelect<T, Prisma__DashboardUserDefaultClient<DashboardUserDefault>, Prisma__DashboardUserDefaultClient<DashboardUserDefaultGetPayload<T>>> : CheckSelect<T, Prisma__DashboardUserDefaultClient<DashboardUserDefault | null >, Prisma__DashboardUserDefaultClient<DashboardUserDefaultGetPayload<T> | null >>

    /**
     * Find zero or more DashboardUserDefaults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUserDefaultFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardUserDefaults
     * const dashboardUserDefaults = await prisma.dashboardUserDefault.findMany()
     * 
     * // Get first 10 DashboardUserDefaults
     * const dashboardUserDefaults = await prisma.dashboardUserDefault.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const dashboardUserDefaultWithIdOnly = await prisma.dashboardUserDefault.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends DashboardUserDefaultFindManyArgs>(
      args?: SelectSubset<T, DashboardUserDefaultFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DashboardUserDefault>>, PrismaPromise<Array<DashboardUserDefaultGetPayload<T>>>>

    /**
     * Create a DashboardUserDefault.
     * @param {DashboardUserDefaultCreateArgs} args - Arguments to create a DashboardUserDefault.
     * @example
     * // Create one DashboardUserDefault
     * const DashboardUserDefault = await prisma.dashboardUserDefault.create({
     *   data: {
     *     // ... data to create a DashboardUserDefault
     *   }
     * })
     * 
    **/
    create<T extends DashboardUserDefaultCreateArgs>(
      args: SelectSubset<T, DashboardUserDefaultCreateArgs>
    ): CheckSelect<T, Prisma__DashboardUserDefaultClient<DashboardUserDefault>, Prisma__DashboardUserDefaultClient<DashboardUserDefaultGetPayload<T>>>

    /**
     * Create many DashboardUserDefaults.
     *     @param {DashboardUserDefaultCreateManyArgs} args - Arguments to create many DashboardUserDefaults.
     *     @example
     *     // Create many DashboardUserDefaults
     *     const dashboardUserDefault = await prisma.dashboardUserDefault.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DashboardUserDefaultCreateManyArgs>(
      args?: SelectSubset<T, DashboardUserDefaultCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DashboardUserDefault.
     * @param {DashboardUserDefaultDeleteArgs} args - Arguments to delete one DashboardUserDefault.
     * @example
     * // Delete one DashboardUserDefault
     * const DashboardUserDefault = await prisma.dashboardUserDefault.delete({
     *   where: {
     *     // ... filter to delete one DashboardUserDefault
     *   }
     * })
     * 
    **/
    delete<T extends DashboardUserDefaultDeleteArgs>(
      args: SelectSubset<T, DashboardUserDefaultDeleteArgs>
    ): CheckSelect<T, Prisma__DashboardUserDefaultClient<DashboardUserDefault>, Prisma__DashboardUserDefaultClient<DashboardUserDefaultGetPayload<T>>>

    /**
     * Update one DashboardUserDefault.
     * @param {DashboardUserDefaultUpdateArgs} args - Arguments to update one DashboardUserDefault.
     * @example
     * // Update one DashboardUserDefault
     * const dashboardUserDefault = await prisma.dashboardUserDefault.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DashboardUserDefaultUpdateArgs>(
      args: SelectSubset<T, DashboardUserDefaultUpdateArgs>
    ): CheckSelect<T, Prisma__DashboardUserDefaultClient<DashboardUserDefault>, Prisma__DashboardUserDefaultClient<DashboardUserDefaultGetPayload<T>>>

    /**
     * Delete zero or more DashboardUserDefaults.
     * @param {DashboardUserDefaultDeleteManyArgs} args - Arguments to filter DashboardUserDefaults to delete.
     * @example
     * // Delete a few DashboardUserDefaults
     * const { count } = await prisma.dashboardUserDefault.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DashboardUserDefaultDeleteManyArgs>(
      args?: SelectSubset<T, DashboardUserDefaultDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardUserDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUserDefaultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardUserDefaults
     * const dashboardUserDefault = await prisma.dashboardUserDefault.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DashboardUserDefaultUpdateManyArgs>(
      args: SelectSubset<T, DashboardUserDefaultUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DashboardUserDefault.
     * @param {DashboardUserDefaultUpsertArgs} args - Arguments to update or create a DashboardUserDefault.
     * @example
     * // Update or create a DashboardUserDefault
     * const dashboardUserDefault = await prisma.dashboardUserDefault.upsert({
     *   create: {
     *     // ... data to create a DashboardUserDefault
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardUserDefault we want to update
     *   }
     * })
    **/
    upsert<T extends DashboardUserDefaultUpsertArgs>(
      args: SelectSubset<T, DashboardUserDefaultUpsertArgs>
    ): CheckSelect<T, Prisma__DashboardUserDefaultClient<DashboardUserDefault>, Prisma__DashboardUserDefaultClient<DashboardUserDefaultGetPayload<T>>>

    /**
     * Count the number of DashboardUserDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUserDefaultCountArgs} args - Arguments to filter DashboardUserDefaults to count.
     * @example
     * // Count the number of DashboardUserDefaults
     * const count = await prisma.dashboardUserDefault.count({
     *   where: {
     *     // ... the filter for the DashboardUserDefaults we want to count
     *   }
     * })
    **/
    count<T extends DashboardUserDefaultCountArgs>(
      args?: Subset<T, DashboardUserDefaultCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardUserDefaultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardUserDefault.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUserDefaultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardUserDefaultAggregateArgs>(args: Subset<T, DashboardUserDefaultAggregateArgs>): PrismaPromise<GetDashboardUserDefaultAggregateType<T>>

    /**
     * Group by DashboardUserDefault.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUserDefaultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardUserDefaultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardUserDefaultGroupByArgs['orderBy'] }
        : { orderBy?: DashboardUserDefaultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardUserDefaultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardUserDefaultGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardUserDefault.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DashboardUserDefaultClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DashboardUserDefault findUnique
   */
  export type DashboardUserDefaultFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserDefault
     * 
    **/
    select?: DashboardUserDefaultSelect | null
    /**
     * Throw an Error if a DashboardUserDefault can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardUserDefault to fetch.
     * 
    **/
    where: DashboardUserDefaultWhereUniqueInput
  }


  /**
   * DashboardUserDefault findFirst
   */
  export type DashboardUserDefaultFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserDefault
     * 
    **/
    select?: DashboardUserDefaultSelect | null
    /**
     * Throw an Error if a DashboardUserDefault can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardUserDefault to fetch.
     * 
    **/
    where?: DashboardUserDefaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardUserDefaults to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardUserDefaultOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardUserDefaults.
     * 
    **/
    cursor?: DashboardUserDefaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardUserDefaults from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardUserDefaults.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardUserDefaults.
     * 
    **/
    distinct?: Enumerable<DashboardUserDefaultScalarFieldEnum>
  }


  /**
   * DashboardUserDefault findMany
   */
  export type DashboardUserDefaultFindManyArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserDefault
     * 
    **/
    select?: DashboardUserDefaultSelect | null
    /**
     * Filter, which DashboardUserDefaults to fetch.
     * 
    **/
    where?: DashboardUserDefaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardUserDefaults to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardUserDefaultOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardUserDefaults.
     * 
    **/
    cursor?: DashboardUserDefaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardUserDefaults from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardUserDefaults.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DashboardUserDefaultScalarFieldEnum>
  }


  /**
   * DashboardUserDefault create
   */
  export type DashboardUserDefaultCreateArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserDefault
     * 
    **/
    select?: DashboardUserDefaultSelect | null
    /**
     * The data needed to create a DashboardUserDefault.
     * 
    **/
    data: XOR<DashboardUserDefaultCreateInput, DashboardUserDefaultUncheckedCreateInput>
  }


  /**
   * DashboardUserDefault createMany
   */
  export type DashboardUserDefaultCreateManyArgs = {
    data: Enumerable<DashboardUserDefaultCreateManyInput>
  }


  /**
   * DashboardUserDefault update
   */
  export type DashboardUserDefaultUpdateArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserDefault
     * 
    **/
    select?: DashboardUserDefaultSelect | null
    /**
     * The data needed to update a DashboardUserDefault.
     * 
    **/
    data: XOR<DashboardUserDefaultUpdateInput, DashboardUserDefaultUncheckedUpdateInput>
    /**
     * Choose, which DashboardUserDefault to update.
     * 
    **/
    where: DashboardUserDefaultWhereUniqueInput
  }


  /**
   * DashboardUserDefault updateMany
   */
  export type DashboardUserDefaultUpdateManyArgs = {
    data: XOR<DashboardUserDefaultUpdateManyMutationInput, DashboardUserDefaultUncheckedUpdateManyInput>
    where?: DashboardUserDefaultWhereInput
  }


  /**
   * DashboardUserDefault upsert
   */
  export type DashboardUserDefaultUpsertArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserDefault
     * 
    **/
    select?: DashboardUserDefaultSelect | null
    /**
     * The filter to search for the DashboardUserDefault to update in case it exists.
     * 
    **/
    where: DashboardUserDefaultWhereUniqueInput
    /**
     * In case the DashboardUserDefault found by the `where` argument doesn't exist, create a new DashboardUserDefault with this data.
     * 
    **/
    create: XOR<DashboardUserDefaultCreateInput, DashboardUserDefaultUncheckedCreateInput>
    /**
     * In case the DashboardUserDefault was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DashboardUserDefaultUpdateInput, DashboardUserDefaultUncheckedUpdateInput>
  }


  /**
   * DashboardUserDefault delete
   */
  export type DashboardUserDefaultDeleteArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserDefault
     * 
    **/
    select?: DashboardUserDefaultSelect | null
    /**
     * Filter which DashboardUserDefault to delete.
     * 
    **/
    where: DashboardUserDefaultWhereUniqueInput
  }


  /**
   * DashboardUserDefault deleteMany
   */
  export type DashboardUserDefaultDeleteManyArgs = {
    where?: DashboardUserDefaultWhereInput
  }


  /**
   * DashboardUserDefault without action
   */
  export type DashboardUserDefaultArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserDefault
     * 
    **/
    select?: DashboardUserDefaultSelect | null
  }



  /**
   * Model DashboardUserGroups
   */


  export type AggregateDashboardUserGroups = {
    _count: DashboardUserGroupsCountAggregateOutputType | null
    _min: DashboardUserGroupsMinAggregateOutputType | null
    _max: DashboardUserGroupsMaxAggregateOutputType | null
  }

  export type DashboardUserGroupsMinAggregateOutputType = {
    Id: string | null
    DashboardId: string | null
    UserGroupId: string | null
  }

  export type DashboardUserGroupsMaxAggregateOutputType = {
    Id: string | null
    DashboardId: string | null
    UserGroupId: string | null
  }

  export type DashboardUserGroupsCountAggregateOutputType = {
    Id: number
    DashboardId: number
    UserGroupId: number
    _all: number
  }


  export type DashboardUserGroupsMinAggregateInputType = {
    Id?: true
    DashboardId?: true
    UserGroupId?: true
  }

  export type DashboardUserGroupsMaxAggregateInputType = {
    Id?: true
    DashboardId?: true
    UserGroupId?: true
  }

  export type DashboardUserGroupsCountAggregateInputType = {
    Id?: true
    DashboardId?: true
    UserGroupId?: true
    _all?: true
  }

  export type DashboardUserGroupsAggregateArgs = {
    /**
     * Filter which DashboardUserGroups to aggregate.
     * 
    **/
    where?: DashboardUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardUserGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardUserGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DashboardUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardUserGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardUserGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardUserGroups
    **/
    _count?: true | DashboardUserGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardUserGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardUserGroupsMaxAggregateInputType
  }

  export type GetDashboardUserGroupsAggregateType<T extends DashboardUserGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardUserGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardUserGroups[P]>
      : GetScalarType<T[P], AggregateDashboardUserGroups[P]>
  }




  export type DashboardUserGroupsGroupByArgs = {
    where?: DashboardUserGroupsWhereInput
    orderBy?: Enumerable<DashboardUserGroupsOrderByWithAggregationInput>
    by: Array<DashboardUserGroupsScalarFieldEnum>
    having?: DashboardUserGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardUserGroupsCountAggregateInputType | true
    _min?: DashboardUserGroupsMinAggregateInputType
    _max?: DashboardUserGroupsMaxAggregateInputType
  }


  export type DashboardUserGroupsGroupByOutputType = {
    Id: string
    DashboardId: string
    UserGroupId: string
    _count: DashboardUserGroupsCountAggregateOutputType | null
    _min: DashboardUserGroupsMinAggregateOutputType | null
    _max: DashboardUserGroupsMaxAggregateOutputType | null
  }

  type GetDashboardUserGroupsGroupByPayload<T extends DashboardUserGroupsGroupByArgs> = Promise<
    Array<
      PickArray<DashboardUserGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardUserGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardUserGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardUserGroupsGroupByOutputType[P]>
        }
      >
    >


  export type DashboardUserGroupsSelect = {
    Id?: boolean
    DashboardId?: boolean
    UserGroupId?: boolean
  }

  export type DashboardUserGroupsGetPayload<
    S extends boolean | null | undefined | DashboardUserGroupsArgs,
    U = keyof S
      > = S extends true
        ? DashboardUserGroups
    : S extends undefined
    ? never
    : S extends DashboardUserGroupsArgs | DashboardUserGroupsFindManyArgs
    ?'include' extends U
    ? DashboardUserGroups 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DashboardUserGroups ?DashboardUserGroups [P]
  : 
     never
  } 
    : DashboardUserGroups
  : DashboardUserGroups


  type DashboardUserGroupsCountArgs = Merge<
    Omit<DashboardUserGroupsFindManyArgs, 'select' | 'include'> & {
      select?: DashboardUserGroupsCountAggregateInputType | true
    }
  >

  export interface DashboardUserGroupsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DashboardUserGroups that matches the filter.
     * @param {DashboardUserGroupsFindUniqueArgs} args - Arguments to find a DashboardUserGroups
     * @example
     * // Get one DashboardUserGroups
     * const dashboardUserGroups = await prisma.dashboardUserGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DashboardUserGroupsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DashboardUserGroupsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DashboardUserGroups'> extends True ? CheckSelect<T, Prisma__DashboardUserGroupsClient<DashboardUserGroups>, Prisma__DashboardUserGroupsClient<DashboardUserGroupsGetPayload<T>>> : CheckSelect<T, Prisma__DashboardUserGroupsClient<DashboardUserGroups | null >, Prisma__DashboardUserGroupsClient<DashboardUserGroupsGetPayload<T> | null >>

    /**
     * Find the first DashboardUserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUserGroupsFindFirstArgs} args - Arguments to find a DashboardUserGroups
     * @example
     * // Get one DashboardUserGroups
     * const dashboardUserGroups = await prisma.dashboardUserGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DashboardUserGroupsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DashboardUserGroupsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DashboardUserGroups'> extends True ? CheckSelect<T, Prisma__DashboardUserGroupsClient<DashboardUserGroups>, Prisma__DashboardUserGroupsClient<DashboardUserGroupsGetPayload<T>>> : CheckSelect<T, Prisma__DashboardUserGroupsClient<DashboardUserGroups | null >, Prisma__DashboardUserGroupsClient<DashboardUserGroupsGetPayload<T> | null >>

    /**
     * Find zero or more DashboardUserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUserGroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardUserGroups
     * const dashboardUserGroups = await prisma.dashboardUserGroups.findMany()
     * 
     * // Get first 10 DashboardUserGroups
     * const dashboardUserGroups = await prisma.dashboardUserGroups.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const dashboardUserGroupsWithIdOnly = await prisma.dashboardUserGroups.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends DashboardUserGroupsFindManyArgs>(
      args?: SelectSubset<T, DashboardUserGroupsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DashboardUserGroups>>, PrismaPromise<Array<DashboardUserGroupsGetPayload<T>>>>

    /**
     * Create a DashboardUserGroups.
     * @param {DashboardUserGroupsCreateArgs} args - Arguments to create a DashboardUserGroups.
     * @example
     * // Create one DashboardUserGroups
     * const DashboardUserGroups = await prisma.dashboardUserGroups.create({
     *   data: {
     *     // ... data to create a DashboardUserGroups
     *   }
     * })
     * 
    **/
    create<T extends DashboardUserGroupsCreateArgs>(
      args: SelectSubset<T, DashboardUserGroupsCreateArgs>
    ): CheckSelect<T, Prisma__DashboardUserGroupsClient<DashboardUserGroups>, Prisma__DashboardUserGroupsClient<DashboardUserGroupsGetPayload<T>>>

    /**
     * Create many DashboardUserGroups.
     *     @param {DashboardUserGroupsCreateManyArgs} args - Arguments to create many DashboardUserGroups.
     *     @example
     *     // Create many DashboardUserGroups
     *     const dashboardUserGroups = await prisma.dashboardUserGroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DashboardUserGroupsCreateManyArgs>(
      args?: SelectSubset<T, DashboardUserGroupsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DashboardUserGroups.
     * @param {DashboardUserGroupsDeleteArgs} args - Arguments to delete one DashboardUserGroups.
     * @example
     * // Delete one DashboardUserGroups
     * const DashboardUserGroups = await prisma.dashboardUserGroups.delete({
     *   where: {
     *     // ... filter to delete one DashboardUserGroups
     *   }
     * })
     * 
    **/
    delete<T extends DashboardUserGroupsDeleteArgs>(
      args: SelectSubset<T, DashboardUserGroupsDeleteArgs>
    ): CheckSelect<T, Prisma__DashboardUserGroupsClient<DashboardUserGroups>, Prisma__DashboardUserGroupsClient<DashboardUserGroupsGetPayload<T>>>

    /**
     * Update one DashboardUserGroups.
     * @param {DashboardUserGroupsUpdateArgs} args - Arguments to update one DashboardUserGroups.
     * @example
     * // Update one DashboardUserGroups
     * const dashboardUserGroups = await prisma.dashboardUserGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DashboardUserGroupsUpdateArgs>(
      args: SelectSubset<T, DashboardUserGroupsUpdateArgs>
    ): CheckSelect<T, Prisma__DashboardUserGroupsClient<DashboardUserGroups>, Prisma__DashboardUserGroupsClient<DashboardUserGroupsGetPayload<T>>>

    /**
     * Delete zero or more DashboardUserGroups.
     * @param {DashboardUserGroupsDeleteManyArgs} args - Arguments to filter DashboardUserGroups to delete.
     * @example
     * // Delete a few DashboardUserGroups
     * const { count } = await prisma.dashboardUserGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DashboardUserGroupsDeleteManyArgs>(
      args?: SelectSubset<T, DashboardUserGroupsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUserGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardUserGroups
     * const dashboardUserGroups = await prisma.dashboardUserGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DashboardUserGroupsUpdateManyArgs>(
      args: SelectSubset<T, DashboardUserGroupsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DashboardUserGroups.
     * @param {DashboardUserGroupsUpsertArgs} args - Arguments to update or create a DashboardUserGroups.
     * @example
     * // Update or create a DashboardUserGroups
     * const dashboardUserGroups = await prisma.dashboardUserGroups.upsert({
     *   create: {
     *     // ... data to create a DashboardUserGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardUserGroups we want to update
     *   }
     * })
    **/
    upsert<T extends DashboardUserGroupsUpsertArgs>(
      args: SelectSubset<T, DashboardUserGroupsUpsertArgs>
    ): CheckSelect<T, Prisma__DashboardUserGroupsClient<DashboardUserGroups>, Prisma__DashboardUserGroupsClient<DashboardUserGroupsGetPayload<T>>>

    /**
     * Count the number of DashboardUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUserGroupsCountArgs} args - Arguments to filter DashboardUserGroups to count.
     * @example
     * // Count the number of DashboardUserGroups
     * const count = await prisma.dashboardUserGroups.count({
     *   where: {
     *     // ... the filter for the DashboardUserGroups we want to count
     *   }
     * })
    **/
    count<T extends DashboardUserGroupsCountArgs>(
      args?: Subset<T, DashboardUserGroupsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardUserGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUserGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardUserGroupsAggregateArgs>(args: Subset<T, DashboardUserGroupsAggregateArgs>): PrismaPromise<GetDashboardUserGroupsAggregateType<T>>

    /**
     * Group by DashboardUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUserGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardUserGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardUserGroupsGroupByArgs['orderBy'] }
        : { orderBy?: DashboardUserGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardUserGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardUserGroupsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardUserGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DashboardUserGroupsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DashboardUserGroups findUnique
   */
  export type DashboardUserGroupsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserGroups
     * 
    **/
    select?: DashboardUserGroupsSelect | null
    /**
     * Throw an Error if a DashboardUserGroups can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardUserGroups to fetch.
     * 
    **/
    where: DashboardUserGroupsWhereUniqueInput
  }


  /**
   * DashboardUserGroups findFirst
   */
  export type DashboardUserGroupsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserGroups
     * 
    **/
    select?: DashboardUserGroupsSelect | null
    /**
     * Throw an Error if a DashboardUserGroups can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardUserGroups to fetch.
     * 
    **/
    where?: DashboardUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardUserGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardUserGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardUserGroups.
     * 
    **/
    cursor?: DashboardUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardUserGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardUserGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardUserGroups.
     * 
    **/
    distinct?: Enumerable<DashboardUserGroupsScalarFieldEnum>
  }


  /**
   * DashboardUserGroups findMany
   */
  export type DashboardUserGroupsFindManyArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserGroups
     * 
    **/
    select?: DashboardUserGroupsSelect | null
    /**
     * Filter, which DashboardUserGroups to fetch.
     * 
    **/
    where?: DashboardUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardUserGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardUserGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardUserGroups.
     * 
    **/
    cursor?: DashboardUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardUserGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardUserGroups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DashboardUserGroupsScalarFieldEnum>
  }


  /**
   * DashboardUserGroups create
   */
  export type DashboardUserGroupsCreateArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserGroups
     * 
    **/
    select?: DashboardUserGroupsSelect | null
    /**
     * The data needed to create a DashboardUserGroups.
     * 
    **/
    data: XOR<DashboardUserGroupsCreateInput, DashboardUserGroupsUncheckedCreateInput>
  }


  /**
   * DashboardUserGroups createMany
   */
  export type DashboardUserGroupsCreateManyArgs = {
    data: Enumerable<DashboardUserGroupsCreateManyInput>
  }


  /**
   * DashboardUserGroups update
   */
  export type DashboardUserGroupsUpdateArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserGroups
     * 
    **/
    select?: DashboardUserGroupsSelect | null
    /**
     * The data needed to update a DashboardUserGroups.
     * 
    **/
    data: XOR<DashboardUserGroupsUpdateInput, DashboardUserGroupsUncheckedUpdateInput>
    /**
     * Choose, which DashboardUserGroups to update.
     * 
    **/
    where: DashboardUserGroupsWhereUniqueInput
  }


  /**
   * DashboardUserGroups updateMany
   */
  export type DashboardUserGroupsUpdateManyArgs = {
    data: XOR<DashboardUserGroupsUpdateManyMutationInput, DashboardUserGroupsUncheckedUpdateManyInput>
    where?: DashboardUserGroupsWhereInput
  }


  /**
   * DashboardUserGroups upsert
   */
  export type DashboardUserGroupsUpsertArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserGroups
     * 
    **/
    select?: DashboardUserGroupsSelect | null
    /**
     * The filter to search for the DashboardUserGroups to update in case it exists.
     * 
    **/
    where: DashboardUserGroupsWhereUniqueInput
    /**
     * In case the DashboardUserGroups found by the `where` argument doesn't exist, create a new DashboardUserGroups with this data.
     * 
    **/
    create: XOR<DashboardUserGroupsCreateInput, DashboardUserGroupsUncheckedCreateInput>
    /**
     * In case the DashboardUserGroups was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DashboardUserGroupsUpdateInput, DashboardUserGroupsUncheckedUpdateInput>
  }


  /**
   * DashboardUserGroups delete
   */
  export type DashboardUserGroupsDeleteArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserGroups
     * 
    **/
    select?: DashboardUserGroupsSelect | null
    /**
     * Filter which DashboardUserGroups to delete.
     * 
    **/
    where: DashboardUserGroupsWhereUniqueInput
  }


  /**
   * DashboardUserGroups deleteMany
   */
  export type DashboardUserGroupsDeleteManyArgs = {
    where?: DashboardUserGroupsWhereInput
  }


  /**
   * DashboardUserGroups without action
   */
  export type DashboardUserGroupsArgs = {
    /**
     * Select specific fields to fetch from the DashboardUserGroups
     * 
    **/
    select?: DashboardUserGroupsSelect | null
  }



  /**
   * Model DashboardUsers
   */


  export type AggregateDashboardUsers = {
    _count: DashboardUsersCountAggregateOutputType | null
    _min: DashboardUsersMinAggregateOutputType | null
    _max: DashboardUsersMaxAggregateOutputType | null
  }

  export type DashboardUsersMinAggregateOutputType = {
    Id: string | null
    DashboardId: string | null
    UserId: string | null
  }

  export type DashboardUsersMaxAggregateOutputType = {
    Id: string | null
    DashboardId: string | null
    UserId: string | null
  }

  export type DashboardUsersCountAggregateOutputType = {
    Id: number
    DashboardId: number
    UserId: number
    _all: number
  }


  export type DashboardUsersMinAggregateInputType = {
    Id?: true
    DashboardId?: true
    UserId?: true
  }

  export type DashboardUsersMaxAggregateInputType = {
    Id?: true
    DashboardId?: true
    UserId?: true
  }

  export type DashboardUsersCountAggregateInputType = {
    Id?: true
    DashboardId?: true
    UserId?: true
    _all?: true
  }

  export type DashboardUsersAggregateArgs = {
    /**
     * Filter which DashboardUsers to aggregate.
     * 
    **/
    where?: DashboardUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardUsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DashboardUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardUsers
    **/
    _count?: true | DashboardUsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardUsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardUsersMaxAggregateInputType
  }

  export type GetDashboardUsersAggregateType<T extends DashboardUsersAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardUsers[P]>
      : GetScalarType<T[P], AggregateDashboardUsers[P]>
  }




  export type DashboardUsersGroupByArgs = {
    where?: DashboardUsersWhereInput
    orderBy?: Enumerable<DashboardUsersOrderByWithAggregationInput>
    by: Array<DashboardUsersScalarFieldEnum>
    having?: DashboardUsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardUsersCountAggregateInputType | true
    _min?: DashboardUsersMinAggregateInputType
    _max?: DashboardUsersMaxAggregateInputType
  }


  export type DashboardUsersGroupByOutputType = {
    Id: string
    DashboardId: string
    UserId: string
    _count: DashboardUsersCountAggregateOutputType | null
    _min: DashboardUsersMinAggregateOutputType | null
    _max: DashboardUsersMaxAggregateOutputType | null
  }

  type GetDashboardUsersGroupByPayload<T extends DashboardUsersGroupByArgs> = Promise<
    Array<
      PickArray<DashboardUsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardUsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardUsersGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardUsersGroupByOutputType[P]>
        }
      >
    >


  export type DashboardUsersSelect = {
    Id?: boolean
    DashboardId?: boolean
    UserId?: boolean
  }

  export type DashboardUsersGetPayload<
    S extends boolean | null | undefined | DashboardUsersArgs,
    U = keyof S
      > = S extends true
        ? DashboardUsers
    : S extends undefined
    ? never
    : S extends DashboardUsersArgs | DashboardUsersFindManyArgs
    ?'include' extends U
    ? DashboardUsers 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DashboardUsers ?DashboardUsers [P]
  : 
     never
  } 
    : DashboardUsers
  : DashboardUsers


  type DashboardUsersCountArgs = Merge<
    Omit<DashboardUsersFindManyArgs, 'select' | 'include'> & {
      select?: DashboardUsersCountAggregateInputType | true
    }
  >

  export interface DashboardUsersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DashboardUsers that matches the filter.
     * @param {DashboardUsersFindUniqueArgs} args - Arguments to find a DashboardUsers
     * @example
     * // Get one DashboardUsers
     * const dashboardUsers = await prisma.dashboardUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DashboardUsersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DashboardUsersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DashboardUsers'> extends True ? CheckSelect<T, Prisma__DashboardUsersClient<DashboardUsers>, Prisma__DashboardUsersClient<DashboardUsersGetPayload<T>>> : CheckSelect<T, Prisma__DashboardUsersClient<DashboardUsers | null >, Prisma__DashboardUsersClient<DashboardUsersGetPayload<T> | null >>

    /**
     * Find the first DashboardUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUsersFindFirstArgs} args - Arguments to find a DashboardUsers
     * @example
     * // Get one DashboardUsers
     * const dashboardUsers = await prisma.dashboardUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DashboardUsersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DashboardUsersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DashboardUsers'> extends True ? CheckSelect<T, Prisma__DashboardUsersClient<DashboardUsers>, Prisma__DashboardUsersClient<DashboardUsersGetPayload<T>>> : CheckSelect<T, Prisma__DashboardUsersClient<DashboardUsers | null >, Prisma__DashboardUsersClient<DashboardUsersGetPayload<T> | null >>

    /**
     * Find zero or more DashboardUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardUsers
     * const dashboardUsers = await prisma.dashboardUsers.findMany()
     * 
     * // Get first 10 DashboardUsers
     * const dashboardUsers = await prisma.dashboardUsers.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const dashboardUsersWithIdOnly = await prisma.dashboardUsers.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends DashboardUsersFindManyArgs>(
      args?: SelectSubset<T, DashboardUsersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DashboardUsers>>, PrismaPromise<Array<DashboardUsersGetPayload<T>>>>

    /**
     * Create a DashboardUsers.
     * @param {DashboardUsersCreateArgs} args - Arguments to create a DashboardUsers.
     * @example
     * // Create one DashboardUsers
     * const DashboardUsers = await prisma.dashboardUsers.create({
     *   data: {
     *     // ... data to create a DashboardUsers
     *   }
     * })
     * 
    **/
    create<T extends DashboardUsersCreateArgs>(
      args: SelectSubset<T, DashboardUsersCreateArgs>
    ): CheckSelect<T, Prisma__DashboardUsersClient<DashboardUsers>, Prisma__DashboardUsersClient<DashboardUsersGetPayload<T>>>

    /**
     * Create many DashboardUsers.
     *     @param {DashboardUsersCreateManyArgs} args - Arguments to create many DashboardUsers.
     *     @example
     *     // Create many DashboardUsers
     *     const dashboardUsers = await prisma.dashboardUsers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DashboardUsersCreateManyArgs>(
      args?: SelectSubset<T, DashboardUsersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DashboardUsers.
     * @param {DashboardUsersDeleteArgs} args - Arguments to delete one DashboardUsers.
     * @example
     * // Delete one DashboardUsers
     * const DashboardUsers = await prisma.dashboardUsers.delete({
     *   where: {
     *     // ... filter to delete one DashboardUsers
     *   }
     * })
     * 
    **/
    delete<T extends DashboardUsersDeleteArgs>(
      args: SelectSubset<T, DashboardUsersDeleteArgs>
    ): CheckSelect<T, Prisma__DashboardUsersClient<DashboardUsers>, Prisma__DashboardUsersClient<DashboardUsersGetPayload<T>>>

    /**
     * Update one DashboardUsers.
     * @param {DashboardUsersUpdateArgs} args - Arguments to update one DashboardUsers.
     * @example
     * // Update one DashboardUsers
     * const dashboardUsers = await prisma.dashboardUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DashboardUsersUpdateArgs>(
      args: SelectSubset<T, DashboardUsersUpdateArgs>
    ): CheckSelect<T, Prisma__DashboardUsersClient<DashboardUsers>, Prisma__DashboardUsersClient<DashboardUsersGetPayload<T>>>

    /**
     * Delete zero or more DashboardUsers.
     * @param {DashboardUsersDeleteManyArgs} args - Arguments to filter DashboardUsers to delete.
     * @example
     * // Delete a few DashboardUsers
     * const { count } = await prisma.dashboardUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DashboardUsersDeleteManyArgs>(
      args?: SelectSubset<T, DashboardUsersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardUsers
     * const dashboardUsers = await prisma.dashboardUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DashboardUsersUpdateManyArgs>(
      args: SelectSubset<T, DashboardUsersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DashboardUsers.
     * @param {DashboardUsersUpsertArgs} args - Arguments to update or create a DashboardUsers.
     * @example
     * // Update or create a DashboardUsers
     * const dashboardUsers = await prisma.dashboardUsers.upsert({
     *   create: {
     *     // ... data to create a DashboardUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardUsers we want to update
     *   }
     * })
    **/
    upsert<T extends DashboardUsersUpsertArgs>(
      args: SelectSubset<T, DashboardUsersUpsertArgs>
    ): CheckSelect<T, Prisma__DashboardUsersClient<DashboardUsers>, Prisma__DashboardUsersClient<DashboardUsersGetPayload<T>>>

    /**
     * Count the number of DashboardUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUsersCountArgs} args - Arguments to filter DashboardUsers to count.
     * @example
     * // Count the number of DashboardUsers
     * const count = await prisma.dashboardUsers.count({
     *   where: {
     *     // ... the filter for the DashboardUsers we want to count
     *   }
     * })
    **/
    count<T extends DashboardUsersCountArgs>(
      args?: Subset<T, DashboardUsersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardUsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardUsersAggregateArgs>(args: Subset<T, DashboardUsersAggregateArgs>): PrismaPromise<GetDashboardUsersAggregateType<T>>

    /**
     * Group by DashboardUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardUsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardUsersGroupByArgs['orderBy'] }
        : { orderBy?: DashboardUsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardUsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardUsersGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardUsers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DashboardUsersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DashboardUsers findUnique
   */
  export type DashboardUsersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DashboardUsers
     * 
    **/
    select?: DashboardUsersSelect | null
    /**
     * Throw an Error if a DashboardUsers can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardUsers to fetch.
     * 
    **/
    where: DashboardUsersWhereUniqueInput
  }


  /**
   * DashboardUsers findFirst
   */
  export type DashboardUsersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DashboardUsers
     * 
    **/
    select?: DashboardUsersSelect | null
    /**
     * Throw an Error if a DashboardUsers can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardUsers to fetch.
     * 
    **/
    where?: DashboardUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardUsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardUsers.
     * 
    **/
    cursor?: DashboardUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardUsers.
     * 
    **/
    distinct?: Enumerable<DashboardUsersScalarFieldEnum>
  }


  /**
   * DashboardUsers findMany
   */
  export type DashboardUsersFindManyArgs = {
    /**
     * Select specific fields to fetch from the DashboardUsers
     * 
    **/
    select?: DashboardUsersSelect | null
    /**
     * Filter, which DashboardUsers to fetch.
     * 
    **/
    where?: DashboardUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardUsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardUsers.
     * 
    **/
    cursor?: DashboardUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DashboardUsersScalarFieldEnum>
  }


  /**
   * DashboardUsers create
   */
  export type DashboardUsersCreateArgs = {
    /**
     * Select specific fields to fetch from the DashboardUsers
     * 
    **/
    select?: DashboardUsersSelect | null
    /**
     * The data needed to create a DashboardUsers.
     * 
    **/
    data: XOR<DashboardUsersCreateInput, DashboardUsersUncheckedCreateInput>
  }


  /**
   * DashboardUsers createMany
   */
  export type DashboardUsersCreateManyArgs = {
    data: Enumerable<DashboardUsersCreateManyInput>
  }


  /**
   * DashboardUsers update
   */
  export type DashboardUsersUpdateArgs = {
    /**
     * Select specific fields to fetch from the DashboardUsers
     * 
    **/
    select?: DashboardUsersSelect | null
    /**
     * The data needed to update a DashboardUsers.
     * 
    **/
    data: XOR<DashboardUsersUpdateInput, DashboardUsersUncheckedUpdateInput>
    /**
     * Choose, which DashboardUsers to update.
     * 
    **/
    where: DashboardUsersWhereUniqueInput
  }


  /**
   * DashboardUsers updateMany
   */
  export type DashboardUsersUpdateManyArgs = {
    data: XOR<DashboardUsersUpdateManyMutationInput, DashboardUsersUncheckedUpdateManyInput>
    where?: DashboardUsersWhereInput
  }


  /**
   * DashboardUsers upsert
   */
  export type DashboardUsersUpsertArgs = {
    /**
     * Select specific fields to fetch from the DashboardUsers
     * 
    **/
    select?: DashboardUsersSelect | null
    /**
     * The filter to search for the DashboardUsers to update in case it exists.
     * 
    **/
    where: DashboardUsersWhereUniqueInput
    /**
     * In case the DashboardUsers found by the `where` argument doesn't exist, create a new DashboardUsers with this data.
     * 
    **/
    create: XOR<DashboardUsersCreateInput, DashboardUsersUncheckedCreateInput>
    /**
     * In case the DashboardUsers was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DashboardUsersUpdateInput, DashboardUsersUncheckedUpdateInput>
  }


  /**
   * DashboardUsers delete
   */
  export type DashboardUsersDeleteArgs = {
    /**
     * Select specific fields to fetch from the DashboardUsers
     * 
    **/
    select?: DashboardUsersSelect | null
    /**
     * Filter which DashboardUsers to delete.
     * 
    **/
    where: DashboardUsersWhereUniqueInput
  }


  /**
   * DashboardUsers deleteMany
   */
  export type DashboardUsersDeleteManyArgs = {
    where?: DashboardUsersWhereInput
  }


  /**
   * DashboardUsers without action
   */
  export type DashboardUsersArgs = {
    /**
     * Select specific fields to fetch from the DashboardUsers
     * 
    **/
    select?: DashboardUsersSelect | null
  }



  /**
   * Model DashboardWidgetBlocks
   */


  export type AggregateDashboardWidgetBlocks = {
    _count: DashboardWidgetBlocksCountAggregateOutputType | null
    _avg: DashboardWidgetBlocksAvgAggregateOutputType | null
    _sum: DashboardWidgetBlocksSumAggregateOutputType | null
    _min: DashboardWidgetBlocksMinAggregateOutputType | null
    _max: DashboardWidgetBlocksMaxAggregateOutputType | null
  }

  export type DashboardWidgetBlocksAvgAggregateOutputType = {
    IsConfigured: number | null
    Position: number | null
  }

  export type DashboardWidgetBlocksSumAggregateOutputType = {
    IsConfigured: number | null
    Position: number | null
  }

  export type DashboardWidgetBlocksMinAggregateOutputType = {
    Id: string | null
    DashboardWidgetId: string | null
    DashboardWidgetBlockTypeId: string | null
    Title: string | null
    Notes: string | null
    EAArtifactGuid: string | null
    IsConfigured: number | null
    Position: number | null
  }

  export type DashboardWidgetBlocksMaxAggregateOutputType = {
    Id: string | null
    DashboardWidgetId: string | null
    DashboardWidgetBlockTypeId: string | null
    Title: string | null
    Notes: string | null
    EAArtifactGuid: string | null
    IsConfigured: number | null
    Position: number | null
  }

  export type DashboardWidgetBlocksCountAggregateOutputType = {
    Id: number
    DashboardWidgetId: number
    DashboardWidgetBlockTypeId: number
    Title: number
    Notes: number
    EAArtifactGuid: number
    IsConfigured: number
    Position: number
    _all: number
  }


  export type DashboardWidgetBlocksAvgAggregateInputType = {
    IsConfigured?: true
    Position?: true
  }

  export type DashboardWidgetBlocksSumAggregateInputType = {
    IsConfigured?: true
    Position?: true
  }

  export type DashboardWidgetBlocksMinAggregateInputType = {
    Id?: true
    DashboardWidgetId?: true
    DashboardWidgetBlockTypeId?: true
    Title?: true
    Notes?: true
    EAArtifactGuid?: true
    IsConfigured?: true
    Position?: true
  }

  export type DashboardWidgetBlocksMaxAggregateInputType = {
    Id?: true
    DashboardWidgetId?: true
    DashboardWidgetBlockTypeId?: true
    Title?: true
    Notes?: true
    EAArtifactGuid?: true
    IsConfigured?: true
    Position?: true
  }

  export type DashboardWidgetBlocksCountAggregateInputType = {
    Id?: true
    DashboardWidgetId?: true
    DashboardWidgetBlockTypeId?: true
    Title?: true
    Notes?: true
    EAArtifactGuid?: true
    IsConfigured?: true
    Position?: true
    _all?: true
  }

  export type DashboardWidgetBlocksAggregateArgs = {
    /**
     * Filter which DashboardWidgetBlocks to aggregate.
     * 
    **/
    where?: DashboardWidgetBlocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardWidgetBlocks to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardWidgetBlocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DashboardWidgetBlocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardWidgetBlocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardWidgetBlocks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardWidgetBlocks
    **/
    _count?: true | DashboardWidgetBlocksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardWidgetBlocksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardWidgetBlocksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardWidgetBlocksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardWidgetBlocksMaxAggregateInputType
  }

  export type GetDashboardWidgetBlocksAggregateType<T extends DashboardWidgetBlocksAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardWidgetBlocks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardWidgetBlocks[P]>
      : GetScalarType<T[P], AggregateDashboardWidgetBlocks[P]>
  }




  export type DashboardWidgetBlocksGroupByArgs = {
    where?: DashboardWidgetBlocksWhereInput
    orderBy?: Enumerable<DashboardWidgetBlocksOrderByWithAggregationInput>
    by: Array<DashboardWidgetBlocksScalarFieldEnum>
    having?: DashboardWidgetBlocksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardWidgetBlocksCountAggregateInputType | true
    _avg?: DashboardWidgetBlocksAvgAggregateInputType
    _sum?: DashboardWidgetBlocksSumAggregateInputType
    _min?: DashboardWidgetBlocksMinAggregateInputType
    _max?: DashboardWidgetBlocksMaxAggregateInputType
  }


  export type DashboardWidgetBlocksGroupByOutputType = {
    Id: string
    DashboardWidgetId: string
    DashboardWidgetBlockTypeId: string
    Title: string | null
    Notes: string | null
    EAArtifactGuid: string | null
    IsConfigured: number
    Position: number | null
    _count: DashboardWidgetBlocksCountAggregateOutputType | null
    _avg: DashboardWidgetBlocksAvgAggregateOutputType | null
    _sum: DashboardWidgetBlocksSumAggregateOutputType | null
    _min: DashboardWidgetBlocksMinAggregateOutputType | null
    _max: DashboardWidgetBlocksMaxAggregateOutputType | null
  }

  type GetDashboardWidgetBlocksGroupByPayload<T extends DashboardWidgetBlocksGroupByArgs> = Promise<
    Array<
      PickArray<DashboardWidgetBlocksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardWidgetBlocksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardWidgetBlocksGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardWidgetBlocksGroupByOutputType[P]>
        }
      >
    >


  export type DashboardWidgetBlocksSelect = {
    Id?: boolean
    DashboardWidgetId?: boolean
    DashboardWidgetBlockTypeId?: boolean
    Title?: boolean
    Notes?: boolean
    EAArtifactGuid?: boolean
    IsConfigured?: boolean
    Position?: boolean
  }

  export type DashboardWidgetBlocksGetPayload<
    S extends boolean | null | undefined | DashboardWidgetBlocksArgs,
    U = keyof S
      > = S extends true
        ? DashboardWidgetBlocks
    : S extends undefined
    ? never
    : S extends DashboardWidgetBlocksArgs | DashboardWidgetBlocksFindManyArgs
    ?'include' extends U
    ? DashboardWidgetBlocks 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DashboardWidgetBlocks ?DashboardWidgetBlocks [P]
  : 
     never
  } 
    : DashboardWidgetBlocks
  : DashboardWidgetBlocks


  type DashboardWidgetBlocksCountArgs = Merge<
    Omit<DashboardWidgetBlocksFindManyArgs, 'select' | 'include'> & {
      select?: DashboardWidgetBlocksCountAggregateInputType | true
    }
  >

  export interface DashboardWidgetBlocksDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DashboardWidgetBlocks that matches the filter.
     * @param {DashboardWidgetBlocksFindUniqueArgs} args - Arguments to find a DashboardWidgetBlocks
     * @example
     * // Get one DashboardWidgetBlocks
     * const dashboardWidgetBlocks = await prisma.dashboardWidgetBlocks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DashboardWidgetBlocksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DashboardWidgetBlocksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DashboardWidgetBlocks'> extends True ? CheckSelect<T, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocks>, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocksGetPayload<T>>> : CheckSelect<T, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocks | null >, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocksGetPayload<T> | null >>

    /**
     * Find the first DashboardWidgetBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetBlocksFindFirstArgs} args - Arguments to find a DashboardWidgetBlocks
     * @example
     * // Get one DashboardWidgetBlocks
     * const dashboardWidgetBlocks = await prisma.dashboardWidgetBlocks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DashboardWidgetBlocksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DashboardWidgetBlocksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DashboardWidgetBlocks'> extends True ? CheckSelect<T, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocks>, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocksGetPayload<T>>> : CheckSelect<T, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocks | null >, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocksGetPayload<T> | null >>

    /**
     * Find zero or more DashboardWidgetBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetBlocksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardWidgetBlocks
     * const dashboardWidgetBlocks = await prisma.dashboardWidgetBlocks.findMany()
     * 
     * // Get first 10 DashboardWidgetBlocks
     * const dashboardWidgetBlocks = await prisma.dashboardWidgetBlocks.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const dashboardWidgetBlocksWithIdOnly = await prisma.dashboardWidgetBlocks.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends DashboardWidgetBlocksFindManyArgs>(
      args?: SelectSubset<T, DashboardWidgetBlocksFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DashboardWidgetBlocks>>, PrismaPromise<Array<DashboardWidgetBlocksGetPayload<T>>>>

    /**
     * Create a DashboardWidgetBlocks.
     * @param {DashboardWidgetBlocksCreateArgs} args - Arguments to create a DashboardWidgetBlocks.
     * @example
     * // Create one DashboardWidgetBlocks
     * const DashboardWidgetBlocks = await prisma.dashboardWidgetBlocks.create({
     *   data: {
     *     // ... data to create a DashboardWidgetBlocks
     *   }
     * })
     * 
    **/
    create<T extends DashboardWidgetBlocksCreateArgs>(
      args: SelectSubset<T, DashboardWidgetBlocksCreateArgs>
    ): CheckSelect<T, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocks>, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocksGetPayload<T>>>

    /**
     * Create many DashboardWidgetBlocks.
     *     @param {DashboardWidgetBlocksCreateManyArgs} args - Arguments to create many DashboardWidgetBlocks.
     *     @example
     *     // Create many DashboardWidgetBlocks
     *     const dashboardWidgetBlocks = await prisma.dashboardWidgetBlocks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DashboardWidgetBlocksCreateManyArgs>(
      args?: SelectSubset<T, DashboardWidgetBlocksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DashboardWidgetBlocks.
     * @param {DashboardWidgetBlocksDeleteArgs} args - Arguments to delete one DashboardWidgetBlocks.
     * @example
     * // Delete one DashboardWidgetBlocks
     * const DashboardWidgetBlocks = await prisma.dashboardWidgetBlocks.delete({
     *   where: {
     *     // ... filter to delete one DashboardWidgetBlocks
     *   }
     * })
     * 
    **/
    delete<T extends DashboardWidgetBlocksDeleteArgs>(
      args: SelectSubset<T, DashboardWidgetBlocksDeleteArgs>
    ): CheckSelect<T, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocks>, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocksGetPayload<T>>>

    /**
     * Update one DashboardWidgetBlocks.
     * @param {DashboardWidgetBlocksUpdateArgs} args - Arguments to update one DashboardWidgetBlocks.
     * @example
     * // Update one DashboardWidgetBlocks
     * const dashboardWidgetBlocks = await prisma.dashboardWidgetBlocks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DashboardWidgetBlocksUpdateArgs>(
      args: SelectSubset<T, DashboardWidgetBlocksUpdateArgs>
    ): CheckSelect<T, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocks>, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocksGetPayload<T>>>

    /**
     * Delete zero or more DashboardWidgetBlocks.
     * @param {DashboardWidgetBlocksDeleteManyArgs} args - Arguments to filter DashboardWidgetBlocks to delete.
     * @example
     * // Delete a few DashboardWidgetBlocks
     * const { count } = await prisma.dashboardWidgetBlocks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DashboardWidgetBlocksDeleteManyArgs>(
      args?: SelectSubset<T, DashboardWidgetBlocksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardWidgetBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetBlocksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardWidgetBlocks
     * const dashboardWidgetBlocks = await prisma.dashboardWidgetBlocks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DashboardWidgetBlocksUpdateManyArgs>(
      args: SelectSubset<T, DashboardWidgetBlocksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DashboardWidgetBlocks.
     * @param {DashboardWidgetBlocksUpsertArgs} args - Arguments to update or create a DashboardWidgetBlocks.
     * @example
     * // Update or create a DashboardWidgetBlocks
     * const dashboardWidgetBlocks = await prisma.dashboardWidgetBlocks.upsert({
     *   create: {
     *     // ... data to create a DashboardWidgetBlocks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardWidgetBlocks we want to update
     *   }
     * })
    **/
    upsert<T extends DashboardWidgetBlocksUpsertArgs>(
      args: SelectSubset<T, DashboardWidgetBlocksUpsertArgs>
    ): CheckSelect<T, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocks>, Prisma__DashboardWidgetBlocksClient<DashboardWidgetBlocksGetPayload<T>>>

    /**
     * Count the number of DashboardWidgetBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetBlocksCountArgs} args - Arguments to filter DashboardWidgetBlocks to count.
     * @example
     * // Count the number of DashboardWidgetBlocks
     * const count = await prisma.dashboardWidgetBlocks.count({
     *   where: {
     *     // ... the filter for the DashboardWidgetBlocks we want to count
     *   }
     * })
    **/
    count<T extends DashboardWidgetBlocksCountArgs>(
      args?: Subset<T, DashboardWidgetBlocksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardWidgetBlocksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardWidgetBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetBlocksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardWidgetBlocksAggregateArgs>(args: Subset<T, DashboardWidgetBlocksAggregateArgs>): PrismaPromise<GetDashboardWidgetBlocksAggregateType<T>>

    /**
     * Group by DashboardWidgetBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetBlocksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardWidgetBlocksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardWidgetBlocksGroupByArgs['orderBy'] }
        : { orderBy?: DashboardWidgetBlocksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardWidgetBlocksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardWidgetBlocksGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardWidgetBlocks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DashboardWidgetBlocksClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DashboardWidgetBlocks findUnique
   */
  export type DashboardWidgetBlocksFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlocks
     * 
    **/
    select?: DashboardWidgetBlocksSelect | null
    /**
     * Throw an Error if a DashboardWidgetBlocks can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardWidgetBlocks to fetch.
     * 
    **/
    where: DashboardWidgetBlocksWhereUniqueInput
  }


  /**
   * DashboardWidgetBlocks findFirst
   */
  export type DashboardWidgetBlocksFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlocks
     * 
    **/
    select?: DashboardWidgetBlocksSelect | null
    /**
     * Throw an Error if a DashboardWidgetBlocks can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardWidgetBlocks to fetch.
     * 
    **/
    where?: DashboardWidgetBlocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardWidgetBlocks to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardWidgetBlocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardWidgetBlocks.
     * 
    **/
    cursor?: DashboardWidgetBlocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardWidgetBlocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardWidgetBlocks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardWidgetBlocks.
     * 
    **/
    distinct?: Enumerable<DashboardWidgetBlocksScalarFieldEnum>
  }


  /**
   * DashboardWidgetBlocks findMany
   */
  export type DashboardWidgetBlocksFindManyArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlocks
     * 
    **/
    select?: DashboardWidgetBlocksSelect | null
    /**
     * Filter, which DashboardWidgetBlocks to fetch.
     * 
    **/
    where?: DashboardWidgetBlocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardWidgetBlocks to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardWidgetBlocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardWidgetBlocks.
     * 
    **/
    cursor?: DashboardWidgetBlocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardWidgetBlocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardWidgetBlocks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DashboardWidgetBlocksScalarFieldEnum>
  }


  /**
   * DashboardWidgetBlocks create
   */
  export type DashboardWidgetBlocksCreateArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlocks
     * 
    **/
    select?: DashboardWidgetBlocksSelect | null
    /**
     * The data needed to create a DashboardWidgetBlocks.
     * 
    **/
    data: XOR<DashboardWidgetBlocksCreateInput, DashboardWidgetBlocksUncheckedCreateInput>
  }


  /**
   * DashboardWidgetBlocks createMany
   */
  export type DashboardWidgetBlocksCreateManyArgs = {
    data: Enumerable<DashboardWidgetBlocksCreateManyInput>
  }


  /**
   * DashboardWidgetBlocks update
   */
  export type DashboardWidgetBlocksUpdateArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlocks
     * 
    **/
    select?: DashboardWidgetBlocksSelect | null
    /**
     * The data needed to update a DashboardWidgetBlocks.
     * 
    **/
    data: XOR<DashboardWidgetBlocksUpdateInput, DashboardWidgetBlocksUncheckedUpdateInput>
    /**
     * Choose, which DashboardWidgetBlocks to update.
     * 
    **/
    where: DashboardWidgetBlocksWhereUniqueInput
  }


  /**
   * DashboardWidgetBlocks updateMany
   */
  export type DashboardWidgetBlocksUpdateManyArgs = {
    data: XOR<DashboardWidgetBlocksUpdateManyMutationInput, DashboardWidgetBlocksUncheckedUpdateManyInput>
    where?: DashboardWidgetBlocksWhereInput
  }


  /**
   * DashboardWidgetBlocks upsert
   */
  export type DashboardWidgetBlocksUpsertArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlocks
     * 
    **/
    select?: DashboardWidgetBlocksSelect | null
    /**
     * The filter to search for the DashboardWidgetBlocks to update in case it exists.
     * 
    **/
    where: DashboardWidgetBlocksWhereUniqueInput
    /**
     * In case the DashboardWidgetBlocks found by the `where` argument doesn't exist, create a new DashboardWidgetBlocks with this data.
     * 
    **/
    create: XOR<DashboardWidgetBlocksCreateInput, DashboardWidgetBlocksUncheckedCreateInput>
    /**
     * In case the DashboardWidgetBlocks was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DashboardWidgetBlocksUpdateInput, DashboardWidgetBlocksUncheckedUpdateInput>
  }


  /**
   * DashboardWidgetBlocks delete
   */
  export type DashboardWidgetBlocksDeleteArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlocks
     * 
    **/
    select?: DashboardWidgetBlocksSelect | null
    /**
     * Filter which DashboardWidgetBlocks to delete.
     * 
    **/
    where: DashboardWidgetBlocksWhereUniqueInput
  }


  /**
   * DashboardWidgetBlocks deleteMany
   */
  export type DashboardWidgetBlocksDeleteManyArgs = {
    where?: DashboardWidgetBlocksWhereInput
  }


  /**
   * DashboardWidgetBlocks without action
   */
  export type DashboardWidgetBlocksArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlocks
     * 
    **/
    select?: DashboardWidgetBlocksSelect | null
  }



  /**
   * Model DashboardWidgetBlockTypes
   */


  export type AggregateDashboardWidgetBlockTypes = {
    _count: DashboardWidgetBlockTypesCountAggregateOutputType | null
    _avg: DashboardWidgetBlockTypesAvgAggregateOutputType | null
    _sum: DashboardWidgetBlockTypesSumAggregateOutputType | null
    _min: DashboardWidgetBlockTypesMinAggregateOutputType | null
    _max: DashboardWidgetBlockTypesMaxAggregateOutputType | null
  }

  export type DashboardWidgetBlockTypesAvgAggregateOutputType = {
    Position: number | null
    ConfigurationRequired: number | null
    IsEnabled: number | null
  }

  export type DashboardWidgetBlockTypesSumAggregateOutputType = {
    Position: number | null
    ConfigurationRequired: number | null
    IsEnabled: number | null
  }

  export type DashboardWidgetBlockTypesMinAggregateOutputType = {
    Id: string | null
    Name: string | null
    Notes: string | null
    Category: string | null
    Position: number | null
    NotSetText: string | null
    ConfigurationRequired: number | null
    IsEnabled: number | null
    Icon: string | null
  }

  export type DashboardWidgetBlockTypesMaxAggregateOutputType = {
    Id: string | null
    Name: string | null
    Notes: string | null
    Category: string | null
    Position: number | null
    NotSetText: string | null
    ConfigurationRequired: number | null
    IsEnabled: number | null
    Icon: string | null
  }

  export type DashboardWidgetBlockTypesCountAggregateOutputType = {
    Id: number
    Name: number
    Notes: number
    Category: number
    Position: number
    NotSetText: number
    ConfigurationRequired: number
    IsEnabled: number
    Icon: number
    _all: number
  }


  export type DashboardWidgetBlockTypesAvgAggregateInputType = {
    Position?: true
    ConfigurationRequired?: true
    IsEnabled?: true
  }

  export type DashboardWidgetBlockTypesSumAggregateInputType = {
    Position?: true
    ConfigurationRequired?: true
    IsEnabled?: true
  }

  export type DashboardWidgetBlockTypesMinAggregateInputType = {
    Id?: true
    Name?: true
    Notes?: true
    Category?: true
    Position?: true
    NotSetText?: true
    ConfigurationRequired?: true
    IsEnabled?: true
    Icon?: true
  }

  export type DashboardWidgetBlockTypesMaxAggregateInputType = {
    Id?: true
    Name?: true
    Notes?: true
    Category?: true
    Position?: true
    NotSetText?: true
    ConfigurationRequired?: true
    IsEnabled?: true
    Icon?: true
  }

  export type DashboardWidgetBlockTypesCountAggregateInputType = {
    Id?: true
    Name?: true
    Notes?: true
    Category?: true
    Position?: true
    NotSetText?: true
    ConfigurationRequired?: true
    IsEnabled?: true
    Icon?: true
    _all?: true
  }

  export type DashboardWidgetBlockTypesAggregateArgs = {
    /**
     * Filter which DashboardWidgetBlockTypes to aggregate.
     * 
    **/
    where?: DashboardWidgetBlockTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardWidgetBlockTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardWidgetBlockTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DashboardWidgetBlockTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardWidgetBlockTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardWidgetBlockTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardWidgetBlockTypes
    **/
    _count?: true | DashboardWidgetBlockTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardWidgetBlockTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardWidgetBlockTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardWidgetBlockTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardWidgetBlockTypesMaxAggregateInputType
  }

  export type GetDashboardWidgetBlockTypesAggregateType<T extends DashboardWidgetBlockTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardWidgetBlockTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardWidgetBlockTypes[P]>
      : GetScalarType<T[P], AggregateDashboardWidgetBlockTypes[P]>
  }




  export type DashboardWidgetBlockTypesGroupByArgs = {
    where?: DashboardWidgetBlockTypesWhereInput
    orderBy?: Enumerable<DashboardWidgetBlockTypesOrderByWithAggregationInput>
    by: Array<DashboardWidgetBlockTypesScalarFieldEnum>
    having?: DashboardWidgetBlockTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardWidgetBlockTypesCountAggregateInputType | true
    _avg?: DashboardWidgetBlockTypesAvgAggregateInputType
    _sum?: DashboardWidgetBlockTypesSumAggregateInputType
    _min?: DashboardWidgetBlockTypesMinAggregateInputType
    _max?: DashboardWidgetBlockTypesMaxAggregateInputType
  }


  export type DashboardWidgetBlockTypesGroupByOutputType = {
    Id: string
    Name: string
    Notes: string | null
    Category: string | null
    Position: number
    NotSetText: string
    ConfigurationRequired: number
    IsEnabled: number
    Icon: string | null
    _count: DashboardWidgetBlockTypesCountAggregateOutputType | null
    _avg: DashboardWidgetBlockTypesAvgAggregateOutputType | null
    _sum: DashboardWidgetBlockTypesSumAggregateOutputType | null
    _min: DashboardWidgetBlockTypesMinAggregateOutputType | null
    _max: DashboardWidgetBlockTypesMaxAggregateOutputType | null
  }

  type GetDashboardWidgetBlockTypesGroupByPayload<T extends DashboardWidgetBlockTypesGroupByArgs> = Promise<
    Array<
      PickArray<DashboardWidgetBlockTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardWidgetBlockTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardWidgetBlockTypesGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardWidgetBlockTypesGroupByOutputType[P]>
        }
      >
    >


  export type DashboardWidgetBlockTypesSelect = {
    Id?: boolean
    Name?: boolean
    Notes?: boolean
    Category?: boolean
    Position?: boolean
    NotSetText?: boolean
    ConfigurationRequired?: boolean
    IsEnabled?: boolean
    Icon?: boolean
  }

  export type DashboardWidgetBlockTypesGetPayload<
    S extends boolean | null | undefined | DashboardWidgetBlockTypesArgs,
    U = keyof S
      > = S extends true
        ? DashboardWidgetBlockTypes
    : S extends undefined
    ? never
    : S extends DashboardWidgetBlockTypesArgs | DashboardWidgetBlockTypesFindManyArgs
    ?'include' extends U
    ? DashboardWidgetBlockTypes 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DashboardWidgetBlockTypes ?DashboardWidgetBlockTypes [P]
  : 
     never
  } 
    : DashboardWidgetBlockTypes
  : DashboardWidgetBlockTypes


  type DashboardWidgetBlockTypesCountArgs = Merge<
    Omit<DashboardWidgetBlockTypesFindManyArgs, 'select' | 'include'> & {
      select?: DashboardWidgetBlockTypesCountAggregateInputType | true
    }
  >

  export interface DashboardWidgetBlockTypesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DashboardWidgetBlockTypes that matches the filter.
     * @param {DashboardWidgetBlockTypesFindUniqueArgs} args - Arguments to find a DashboardWidgetBlockTypes
     * @example
     * // Get one DashboardWidgetBlockTypes
     * const dashboardWidgetBlockTypes = await prisma.dashboardWidgetBlockTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DashboardWidgetBlockTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DashboardWidgetBlockTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DashboardWidgetBlockTypes'> extends True ? CheckSelect<T, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypes>, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypesGetPayload<T>>> : CheckSelect<T, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypes | null >, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypesGetPayload<T> | null >>

    /**
     * Find the first DashboardWidgetBlockTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetBlockTypesFindFirstArgs} args - Arguments to find a DashboardWidgetBlockTypes
     * @example
     * // Get one DashboardWidgetBlockTypes
     * const dashboardWidgetBlockTypes = await prisma.dashboardWidgetBlockTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DashboardWidgetBlockTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DashboardWidgetBlockTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DashboardWidgetBlockTypes'> extends True ? CheckSelect<T, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypes>, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypesGetPayload<T>>> : CheckSelect<T, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypes | null >, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypesGetPayload<T> | null >>

    /**
     * Find zero or more DashboardWidgetBlockTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetBlockTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardWidgetBlockTypes
     * const dashboardWidgetBlockTypes = await prisma.dashboardWidgetBlockTypes.findMany()
     * 
     * // Get first 10 DashboardWidgetBlockTypes
     * const dashboardWidgetBlockTypes = await prisma.dashboardWidgetBlockTypes.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const dashboardWidgetBlockTypesWithIdOnly = await prisma.dashboardWidgetBlockTypes.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends DashboardWidgetBlockTypesFindManyArgs>(
      args?: SelectSubset<T, DashboardWidgetBlockTypesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DashboardWidgetBlockTypes>>, PrismaPromise<Array<DashboardWidgetBlockTypesGetPayload<T>>>>

    /**
     * Create a DashboardWidgetBlockTypes.
     * @param {DashboardWidgetBlockTypesCreateArgs} args - Arguments to create a DashboardWidgetBlockTypes.
     * @example
     * // Create one DashboardWidgetBlockTypes
     * const DashboardWidgetBlockTypes = await prisma.dashboardWidgetBlockTypes.create({
     *   data: {
     *     // ... data to create a DashboardWidgetBlockTypes
     *   }
     * })
     * 
    **/
    create<T extends DashboardWidgetBlockTypesCreateArgs>(
      args: SelectSubset<T, DashboardWidgetBlockTypesCreateArgs>
    ): CheckSelect<T, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypes>, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypesGetPayload<T>>>

    /**
     * Create many DashboardWidgetBlockTypes.
     *     @param {DashboardWidgetBlockTypesCreateManyArgs} args - Arguments to create many DashboardWidgetBlockTypes.
     *     @example
     *     // Create many DashboardWidgetBlockTypes
     *     const dashboardWidgetBlockTypes = await prisma.dashboardWidgetBlockTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DashboardWidgetBlockTypesCreateManyArgs>(
      args?: SelectSubset<T, DashboardWidgetBlockTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DashboardWidgetBlockTypes.
     * @param {DashboardWidgetBlockTypesDeleteArgs} args - Arguments to delete one DashboardWidgetBlockTypes.
     * @example
     * // Delete one DashboardWidgetBlockTypes
     * const DashboardWidgetBlockTypes = await prisma.dashboardWidgetBlockTypes.delete({
     *   where: {
     *     // ... filter to delete one DashboardWidgetBlockTypes
     *   }
     * })
     * 
    **/
    delete<T extends DashboardWidgetBlockTypesDeleteArgs>(
      args: SelectSubset<T, DashboardWidgetBlockTypesDeleteArgs>
    ): CheckSelect<T, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypes>, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypesGetPayload<T>>>

    /**
     * Update one DashboardWidgetBlockTypes.
     * @param {DashboardWidgetBlockTypesUpdateArgs} args - Arguments to update one DashboardWidgetBlockTypes.
     * @example
     * // Update one DashboardWidgetBlockTypes
     * const dashboardWidgetBlockTypes = await prisma.dashboardWidgetBlockTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DashboardWidgetBlockTypesUpdateArgs>(
      args: SelectSubset<T, DashboardWidgetBlockTypesUpdateArgs>
    ): CheckSelect<T, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypes>, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypesGetPayload<T>>>

    /**
     * Delete zero or more DashboardWidgetBlockTypes.
     * @param {DashboardWidgetBlockTypesDeleteManyArgs} args - Arguments to filter DashboardWidgetBlockTypes to delete.
     * @example
     * // Delete a few DashboardWidgetBlockTypes
     * const { count } = await prisma.dashboardWidgetBlockTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DashboardWidgetBlockTypesDeleteManyArgs>(
      args?: SelectSubset<T, DashboardWidgetBlockTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardWidgetBlockTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetBlockTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardWidgetBlockTypes
     * const dashboardWidgetBlockTypes = await prisma.dashboardWidgetBlockTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DashboardWidgetBlockTypesUpdateManyArgs>(
      args: SelectSubset<T, DashboardWidgetBlockTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DashboardWidgetBlockTypes.
     * @param {DashboardWidgetBlockTypesUpsertArgs} args - Arguments to update or create a DashboardWidgetBlockTypes.
     * @example
     * // Update or create a DashboardWidgetBlockTypes
     * const dashboardWidgetBlockTypes = await prisma.dashboardWidgetBlockTypes.upsert({
     *   create: {
     *     // ... data to create a DashboardWidgetBlockTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardWidgetBlockTypes we want to update
     *   }
     * })
    **/
    upsert<T extends DashboardWidgetBlockTypesUpsertArgs>(
      args: SelectSubset<T, DashboardWidgetBlockTypesUpsertArgs>
    ): CheckSelect<T, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypes>, Prisma__DashboardWidgetBlockTypesClient<DashboardWidgetBlockTypesGetPayload<T>>>

    /**
     * Count the number of DashboardWidgetBlockTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetBlockTypesCountArgs} args - Arguments to filter DashboardWidgetBlockTypes to count.
     * @example
     * // Count the number of DashboardWidgetBlockTypes
     * const count = await prisma.dashboardWidgetBlockTypes.count({
     *   where: {
     *     // ... the filter for the DashboardWidgetBlockTypes we want to count
     *   }
     * })
    **/
    count<T extends DashboardWidgetBlockTypesCountArgs>(
      args?: Subset<T, DashboardWidgetBlockTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardWidgetBlockTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardWidgetBlockTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetBlockTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardWidgetBlockTypesAggregateArgs>(args: Subset<T, DashboardWidgetBlockTypesAggregateArgs>): PrismaPromise<GetDashboardWidgetBlockTypesAggregateType<T>>

    /**
     * Group by DashboardWidgetBlockTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetBlockTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardWidgetBlockTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardWidgetBlockTypesGroupByArgs['orderBy'] }
        : { orderBy?: DashboardWidgetBlockTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardWidgetBlockTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardWidgetBlockTypesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardWidgetBlockTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DashboardWidgetBlockTypesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DashboardWidgetBlockTypes findUnique
   */
  export type DashboardWidgetBlockTypesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlockTypes
     * 
    **/
    select?: DashboardWidgetBlockTypesSelect | null
    /**
     * Throw an Error if a DashboardWidgetBlockTypes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardWidgetBlockTypes to fetch.
     * 
    **/
    where: DashboardWidgetBlockTypesWhereUniqueInput
  }


  /**
   * DashboardWidgetBlockTypes findFirst
   */
  export type DashboardWidgetBlockTypesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlockTypes
     * 
    **/
    select?: DashboardWidgetBlockTypesSelect | null
    /**
     * Throw an Error if a DashboardWidgetBlockTypes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardWidgetBlockTypes to fetch.
     * 
    **/
    where?: DashboardWidgetBlockTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardWidgetBlockTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardWidgetBlockTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardWidgetBlockTypes.
     * 
    **/
    cursor?: DashboardWidgetBlockTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardWidgetBlockTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardWidgetBlockTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardWidgetBlockTypes.
     * 
    **/
    distinct?: Enumerable<DashboardWidgetBlockTypesScalarFieldEnum>
  }


  /**
   * DashboardWidgetBlockTypes findMany
   */
  export type DashboardWidgetBlockTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlockTypes
     * 
    **/
    select?: DashboardWidgetBlockTypesSelect | null
    /**
     * Filter, which DashboardWidgetBlockTypes to fetch.
     * 
    **/
    where?: DashboardWidgetBlockTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardWidgetBlockTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardWidgetBlockTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardWidgetBlockTypes.
     * 
    **/
    cursor?: DashboardWidgetBlockTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardWidgetBlockTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardWidgetBlockTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DashboardWidgetBlockTypesScalarFieldEnum>
  }


  /**
   * DashboardWidgetBlockTypes create
   */
  export type DashboardWidgetBlockTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlockTypes
     * 
    **/
    select?: DashboardWidgetBlockTypesSelect | null
    /**
     * The data needed to create a DashboardWidgetBlockTypes.
     * 
    **/
    data: XOR<DashboardWidgetBlockTypesCreateInput, DashboardWidgetBlockTypesUncheckedCreateInput>
  }


  /**
   * DashboardWidgetBlockTypes createMany
   */
  export type DashboardWidgetBlockTypesCreateManyArgs = {
    data: Enumerable<DashboardWidgetBlockTypesCreateManyInput>
  }


  /**
   * DashboardWidgetBlockTypes update
   */
  export type DashboardWidgetBlockTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlockTypes
     * 
    **/
    select?: DashboardWidgetBlockTypesSelect | null
    /**
     * The data needed to update a DashboardWidgetBlockTypes.
     * 
    **/
    data: XOR<DashboardWidgetBlockTypesUpdateInput, DashboardWidgetBlockTypesUncheckedUpdateInput>
    /**
     * Choose, which DashboardWidgetBlockTypes to update.
     * 
    **/
    where: DashboardWidgetBlockTypesWhereUniqueInput
  }


  /**
   * DashboardWidgetBlockTypes updateMany
   */
  export type DashboardWidgetBlockTypesUpdateManyArgs = {
    data: XOR<DashboardWidgetBlockTypesUpdateManyMutationInput, DashboardWidgetBlockTypesUncheckedUpdateManyInput>
    where?: DashboardWidgetBlockTypesWhereInput
  }


  /**
   * DashboardWidgetBlockTypes upsert
   */
  export type DashboardWidgetBlockTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlockTypes
     * 
    **/
    select?: DashboardWidgetBlockTypesSelect | null
    /**
     * The filter to search for the DashboardWidgetBlockTypes to update in case it exists.
     * 
    **/
    where: DashboardWidgetBlockTypesWhereUniqueInput
    /**
     * In case the DashboardWidgetBlockTypes found by the `where` argument doesn't exist, create a new DashboardWidgetBlockTypes with this data.
     * 
    **/
    create: XOR<DashboardWidgetBlockTypesCreateInput, DashboardWidgetBlockTypesUncheckedCreateInput>
    /**
     * In case the DashboardWidgetBlockTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DashboardWidgetBlockTypesUpdateInput, DashboardWidgetBlockTypesUncheckedUpdateInput>
  }


  /**
   * DashboardWidgetBlockTypes delete
   */
  export type DashboardWidgetBlockTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlockTypes
     * 
    **/
    select?: DashboardWidgetBlockTypesSelect | null
    /**
     * Filter which DashboardWidgetBlockTypes to delete.
     * 
    **/
    where: DashboardWidgetBlockTypesWhereUniqueInput
  }


  /**
   * DashboardWidgetBlockTypes deleteMany
   */
  export type DashboardWidgetBlockTypesDeleteManyArgs = {
    where?: DashboardWidgetBlockTypesWhereInput
  }


  /**
   * DashboardWidgetBlockTypes without action
   */
  export type DashboardWidgetBlockTypesArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgetBlockTypes
     * 
    **/
    select?: DashboardWidgetBlockTypesSelect | null
  }



  /**
   * Model DashboardWidgets
   */


  export type AggregateDashboardWidgets = {
    _count: DashboardWidgetsCountAggregateOutputType | null
    _avg: DashboardWidgetsAvgAggregateOutputType | null
    _sum: DashboardWidgetsSumAggregateOutputType | null
    _min: DashboardWidgetsMinAggregateOutputType | null
    _max: DashboardWidgetsMaxAggregateOutputType | null
  }

  export type DashboardWidgetsAvgAggregateOutputType = {
    RowId: number | null
    ColumnId: number | null
    SizeX: number | null
    SizeY: number | null
    Template: number | null
    X: number | null
    Y: number | null
    Rows: number | null
    Cols: number | null
  }

  export type DashboardWidgetsSumAggregateOutputType = {
    RowId: number | null
    ColumnId: number | null
    SizeX: number | null
    SizeY: number | null
    Template: number | null
    X: number | null
    Y: number | null
    Rows: number | null
    Cols: number | null
  }

  export type DashboardWidgetsMinAggregateOutputType = {
    Id: string | null
    DashboardId: string | null
    Name: string | null
    Notes: string | null
    RowId: number | null
    ColumnId: number | null
    ConfigData: string | null
    SizeX: number | null
    SizeY: number | null
    WidgetSettings: string | null
    Template: number | null
    X: number | null
    Y: number | null
    Rows: number | null
    Cols: number | null
  }

  export type DashboardWidgetsMaxAggregateOutputType = {
    Id: string | null
    DashboardId: string | null
    Name: string | null
    Notes: string | null
    RowId: number | null
    ColumnId: number | null
    ConfigData: string | null
    SizeX: number | null
    SizeY: number | null
    WidgetSettings: string | null
    Template: number | null
    X: number | null
    Y: number | null
    Rows: number | null
    Cols: number | null
  }

  export type DashboardWidgetsCountAggregateOutputType = {
    Id: number
    DashboardId: number
    Name: number
    Notes: number
    RowId: number
    ColumnId: number
    ConfigData: number
    SizeX: number
    SizeY: number
    WidgetSettings: number
    Template: number
    X: number
    Y: number
    Rows: number
    Cols: number
    _all: number
  }


  export type DashboardWidgetsAvgAggregateInputType = {
    RowId?: true
    ColumnId?: true
    SizeX?: true
    SizeY?: true
    Template?: true
    X?: true
    Y?: true
    Rows?: true
    Cols?: true
  }

  export type DashboardWidgetsSumAggregateInputType = {
    RowId?: true
    ColumnId?: true
    SizeX?: true
    SizeY?: true
    Template?: true
    X?: true
    Y?: true
    Rows?: true
    Cols?: true
  }

  export type DashboardWidgetsMinAggregateInputType = {
    Id?: true
    DashboardId?: true
    Name?: true
    Notes?: true
    RowId?: true
    ColumnId?: true
    ConfigData?: true
    SizeX?: true
    SizeY?: true
    WidgetSettings?: true
    Template?: true
    X?: true
    Y?: true
    Rows?: true
    Cols?: true
  }

  export type DashboardWidgetsMaxAggregateInputType = {
    Id?: true
    DashboardId?: true
    Name?: true
    Notes?: true
    RowId?: true
    ColumnId?: true
    ConfigData?: true
    SizeX?: true
    SizeY?: true
    WidgetSettings?: true
    Template?: true
    X?: true
    Y?: true
    Rows?: true
    Cols?: true
  }

  export type DashboardWidgetsCountAggregateInputType = {
    Id?: true
    DashboardId?: true
    Name?: true
    Notes?: true
    RowId?: true
    ColumnId?: true
    ConfigData?: true
    SizeX?: true
    SizeY?: true
    WidgetSettings?: true
    Template?: true
    X?: true
    Y?: true
    Rows?: true
    Cols?: true
    _all?: true
  }

  export type DashboardWidgetsAggregateArgs = {
    /**
     * Filter which DashboardWidgets to aggregate.
     * 
    **/
    where?: DashboardWidgetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardWidgets to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardWidgetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DashboardWidgetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardWidgets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardWidgets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardWidgets
    **/
    _count?: true | DashboardWidgetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardWidgetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardWidgetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardWidgetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardWidgetsMaxAggregateInputType
  }

  export type GetDashboardWidgetsAggregateType<T extends DashboardWidgetsAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardWidgets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardWidgets[P]>
      : GetScalarType<T[P], AggregateDashboardWidgets[P]>
  }




  export type DashboardWidgetsGroupByArgs = {
    where?: DashboardWidgetsWhereInput
    orderBy?: Enumerable<DashboardWidgetsOrderByWithAggregationInput>
    by: Array<DashboardWidgetsScalarFieldEnum>
    having?: DashboardWidgetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardWidgetsCountAggregateInputType | true
    _avg?: DashboardWidgetsAvgAggregateInputType
    _sum?: DashboardWidgetsSumAggregateInputType
    _min?: DashboardWidgetsMinAggregateInputType
    _max?: DashboardWidgetsMaxAggregateInputType
  }


  export type DashboardWidgetsGroupByOutputType = {
    Id: string
    DashboardId: string
    Name: string
    Notes: string | null
    RowId: number
    ColumnId: number
    ConfigData: string | null
    SizeX: number
    SizeY: number
    WidgetSettings: string | null
    Template: number
    X: number | null
    Y: number | null
    Rows: number | null
    Cols: number | null
    _count: DashboardWidgetsCountAggregateOutputType | null
    _avg: DashboardWidgetsAvgAggregateOutputType | null
    _sum: DashboardWidgetsSumAggregateOutputType | null
    _min: DashboardWidgetsMinAggregateOutputType | null
    _max: DashboardWidgetsMaxAggregateOutputType | null
  }

  type GetDashboardWidgetsGroupByPayload<T extends DashboardWidgetsGroupByArgs> = Promise<
    Array<
      PickArray<DashboardWidgetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardWidgetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardWidgetsGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardWidgetsGroupByOutputType[P]>
        }
      >
    >


  export type DashboardWidgetsSelect = {
    Id?: boolean
    DashboardId?: boolean
    Name?: boolean
    Notes?: boolean
    RowId?: boolean
    ColumnId?: boolean
    ConfigData?: boolean
    SizeX?: boolean
    SizeY?: boolean
    WidgetSettings?: boolean
    Template?: boolean
    X?: boolean
    Y?: boolean
    Rows?: boolean
    Cols?: boolean
  }

  export type DashboardWidgetsGetPayload<
    S extends boolean | null | undefined | DashboardWidgetsArgs,
    U = keyof S
      > = S extends true
        ? DashboardWidgets
    : S extends undefined
    ? never
    : S extends DashboardWidgetsArgs | DashboardWidgetsFindManyArgs
    ?'include' extends U
    ? DashboardWidgets 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DashboardWidgets ?DashboardWidgets [P]
  : 
     never
  } 
    : DashboardWidgets
  : DashboardWidgets


  type DashboardWidgetsCountArgs = Merge<
    Omit<DashboardWidgetsFindManyArgs, 'select' | 'include'> & {
      select?: DashboardWidgetsCountAggregateInputType | true
    }
  >

  export interface DashboardWidgetsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DashboardWidgets that matches the filter.
     * @param {DashboardWidgetsFindUniqueArgs} args - Arguments to find a DashboardWidgets
     * @example
     * // Get one DashboardWidgets
     * const dashboardWidgets = await prisma.dashboardWidgets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DashboardWidgetsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DashboardWidgetsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DashboardWidgets'> extends True ? CheckSelect<T, Prisma__DashboardWidgetsClient<DashboardWidgets>, Prisma__DashboardWidgetsClient<DashboardWidgetsGetPayload<T>>> : CheckSelect<T, Prisma__DashboardWidgetsClient<DashboardWidgets | null >, Prisma__DashboardWidgetsClient<DashboardWidgetsGetPayload<T> | null >>

    /**
     * Find the first DashboardWidgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetsFindFirstArgs} args - Arguments to find a DashboardWidgets
     * @example
     * // Get one DashboardWidgets
     * const dashboardWidgets = await prisma.dashboardWidgets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DashboardWidgetsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DashboardWidgetsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DashboardWidgets'> extends True ? CheckSelect<T, Prisma__DashboardWidgetsClient<DashboardWidgets>, Prisma__DashboardWidgetsClient<DashboardWidgetsGetPayload<T>>> : CheckSelect<T, Prisma__DashboardWidgetsClient<DashboardWidgets | null >, Prisma__DashboardWidgetsClient<DashboardWidgetsGetPayload<T> | null >>

    /**
     * Find zero or more DashboardWidgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardWidgets
     * const dashboardWidgets = await prisma.dashboardWidgets.findMany()
     * 
     * // Get first 10 DashboardWidgets
     * const dashboardWidgets = await prisma.dashboardWidgets.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const dashboardWidgetsWithIdOnly = await prisma.dashboardWidgets.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends DashboardWidgetsFindManyArgs>(
      args?: SelectSubset<T, DashboardWidgetsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DashboardWidgets>>, PrismaPromise<Array<DashboardWidgetsGetPayload<T>>>>

    /**
     * Create a DashboardWidgets.
     * @param {DashboardWidgetsCreateArgs} args - Arguments to create a DashboardWidgets.
     * @example
     * // Create one DashboardWidgets
     * const DashboardWidgets = await prisma.dashboardWidgets.create({
     *   data: {
     *     // ... data to create a DashboardWidgets
     *   }
     * })
     * 
    **/
    create<T extends DashboardWidgetsCreateArgs>(
      args: SelectSubset<T, DashboardWidgetsCreateArgs>
    ): CheckSelect<T, Prisma__DashboardWidgetsClient<DashboardWidgets>, Prisma__DashboardWidgetsClient<DashboardWidgetsGetPayload<T>>>

    /**
     * Create many DashboardWidgets.
     *     @param {DashboardWidgetsCreateManyArgs} args - Arguments to create many DashboardWidgets.
     *     @example
     *     // Create many DashboardWidgets
     *     const dashboardWidgets = await prisma.dashboardWidgets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DashboardWidgetsCreateManyArgs>(
      args?: SelectSubset<T, DashboardWidgetsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DashboardWidgets.
     * @param {DashboardWidgetsDeleteArgs} args - Arguments to delete one DashboardWidgets.
     * @example
     * // Delete one DashboardWidgets
     * const DashboardWidgets = await prisma.dashboardWidgets.delete({
     *   where: {
     *     // ... filter to delete one DashboardWidgets
     *   }
     * })
     * 
    **/
    delete<T extends DashboardWidgetsDeleteArgs>(
      args: SelectSubset<T, DashboardWidgetsDeleteArgs>
    ): CheckSelect<T, Prisma__DashboardWidgetsClient<DashboardWidgets>, Prisma__DashboardWidgetsClient<DashboardWidgetsGetPayload<T>>>

    /**
     * Update one DashboardWidgets.
     * @param {DashboardWidgetsUpdateArgs} args - Arguments to update one DashboardWidgets.
     * @example
     * // Update one DashboardWidgets
     * const dashboardWidgets = await prisma.dashboardWidgets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DashboardWidgetsUpdateArgs>(
      args: SelectSubset<T, DashboardWidgetsUpdateArgs>
    ): CheckSelect<T, Prisma__DashboardWidgetsClient<DashboardWidgets>, Prisma__DashboardWidgetsClient<DashboardWidgetsGetPayload<T>>>

    /**
     * Delete zero or more DashboardWidgets.
     * @param {DashboardWidgetsDeleteManyArgs} args - Arguments to filter DashboardWidgets to delete.
     * @example
     * // Delete a few DashboardWidgets
     * const { count } = await prisma.dashboardWidgets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DashboardWidgetsDeleteManyArgs>(
      args?: SelectSubset<T, DashboardWidgetsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardWidgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardWidgets
     * const dashboardWidgets = await prisma.dashboardWidgets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DashboardWidgetsUpdateManyArgs>(
      args: SelectSubset<T, DashboardWidgetsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DashboardWidgets.
     * @param {DashboardWidgetsUpsertArgs} args - Arguments to update or create a DashboardWidgets.
     * @example
     * // Update or create a DashboardWidgets
     * const dashboardWidgets = await prisma.dashboardWidgets.upsert({
     *   create: {
     *     // ... data to create a DashboardWidgets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardWidgets we want to update
     *   }
     * })
    **/
    upsert<T extends DashboardWidgetsUpsertArgs>(
      args: SelectSubset<T, DashboardWidgetsUpsertArgs>
    ): CheckSelect<T, Prisma__DashboardWidgetsClient<DashboardWidgets>, Prisma__DashboardWidgetsClient<DashboardWidgetsGetPayload<T>>>

    /**
     * Count the number of DashboardWidgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetsCountArgs} args - Arguments to filter DashboardWidgets to count.
     * @example
     * // Count the number of DashboardWidgets
     * const count = await prisma.dashboardWidgets.count({
     *   where: {
     *     // ... the filter for the DashboardWidgets we want to count
     *   }
     * })
    **/
    count<T extends DashboardWidgetsCountArgs>(
      args?: Subset<T, DashboardWidgetsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardWidgetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardWidgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardWidgetsAggregateArgs>(args: Subset<T, DashboardWidgetsAggregateArgs>): PrismaPromise<GetDashboardWidgetsAggregateType<T>>

    /**
     * Group by DashboardWidgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardWidgetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardWidgetsGroupByArgs['orderBy'] }
        : { orderBy?: DashboardWidgetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardWidgetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardWidgetsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardWidgets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DashboardWidgetsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DashboardWidgets findUnique
   */
  export type DashboardWidgetsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgets
     * 
    **/
    select?: DashboardWidgetsSelect | null
    /**
     * Throw an Error if a DashboardWidgets can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardWidgets to fetch.
     * 
    **/
    where: DashboardWidgetsWhereUniqueInput
  }


  /**
   * DashboardWidgets findFirst
   */
  export type DashboardWidgetsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgets
     * 
    **/
    select?: DashboardWidgetsSelect | null
    /**
     * Throw an Error if a DashboardWidgets can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DashboardWidgets to fetch.
     * 
    **/
    where?: DashboardWidgetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardWidgets to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardWidgetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardWidgets.
     * 
    **/
    cursor?: DashboardWidgetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardWidgets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardWidgets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardWidgets.
     * 
    **/
    distinct?: Enumerable<DashboardWidgetsScalarFieldEnum>
  }


  /**
   * DashboardWidgets findMany
   */
  export type DashboardWidgetsFindManyArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgets
     * 
    **/
    select?: DashboardWidgetsSelect | null
    /**
     * Filter, which DashboardWidgets to fetch.
     * 
    **/
    where?: DashboardWidgetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardWidgets to fetch.
     * 
    **/
    orderBy?: Enumerable<DashboardWidgetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardWidgets.
     * 
    **/
    cursor?: DashboardWidgetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardWidgets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardWidgets.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DashboardWidgetsScalarFieldEnum>
  }


  /**
   * DashboardWidgets create
   */
  export type DashboardWidgetsCreateArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgets
     * 
    **/
    select?: DashboardWidgetsSelect | null
    /**
     * The data needed to create a DashboardWidgets.
     * 
    **/
    data: XOR<DashboardWidgetsCreateInput, DashboardWidgetsUncheckedCreateInput>
  }


  /**
   * DashboardWidgets createMany
   */
  export type DashboardWidgetsCreateManyArgs = {
    data: Enumerable<DashboardWidgetsCreateManyInput>
  }


  /**
   * DashboardWidgets update
   */
  export type DashboardWidgetsUpdateArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgets
     * 
    **/
    select?: DashboardWidgetsSelect | null
    /**
     * The data needed to update a DashboardWidgets.
     * 
    **/
    data: XOR<DashboardWidgetsUpdateInput, DashboardWidgetsUncheckedUpdateInput>
    /**
     * Choose, which DashboardWidgets to update.
     * 
    **/
    where: DashboardWidgetsWhereUniqueInput
  }


  /**
   * DashboardWidgets updateMany
   */
  export type DashboardWidgetsUpdateManyArgs = {
    data: XOR<DashboardWidgetsUpdateManyMutationInput, DashboardWidgetsUncheckedUpdateManyInput>
    where?: DashboardWidgetsWhereInput
  }


  /**
   * DashboardWidgets upsert
   */
  export type DashboardWidgetsUpsertArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgets
     * 
    **/
    select?: DashboardWidgetsSelect | null
    /**
     * The filter to search for the DashboardWidgets to update in case it exists.
     * 
    **/
    where: DashboardWidgetsWhereUniqueInput
    /**
     * In case the DashboardWidgets found by the `where` argument doesn't exist, create a new DashboardWidgets with this data.
     * 
    **/
    create: XOR<DashboardWidgetsCreateInput, DashboardWidgetsUncheckedCreateInput>
    /**
     * In case the DashboardWidgets was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DashboardWidgetsUpdateInput, DashboardWidgetsUncheckedUpdateInput>
  }


  /**
   * DashboardWidgets delete
   */
  export type DashboardWidgetsDeleteArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgets
     * 
    **/
    select?: DashboardWidgetsSelect | null
    /**
     * Filter which DashboardWidgets to delete.
     * 
    **/
    where: DashboardWidgetsWhereUniqueInput
  }


  /**
   * DashboardWidgets deleteMany
   */
  export type DashboardWidgetsDeleteManyArgs = {
    where?: DashboardWidgetsWhereInput
  }


  /**
   * DashboardWidgets without action
   */
  export type DashboardWidgetsArgs = {
    /**
     * Select specific fields to fetch from the DashboardWidgets
     * 
    **/
    select?: DashboardWidgetsSelect | null
  }



  /**
   * Model DocumentationRequests
   */


  export type AggregateDocumentationRequests = {
    _count: DocumentationRequestsCountAggregateOutputType | null
    _avg: DocumentationRequestsAvgAggregateOutputType | null
    _sum: DocumentationRequestsSumAggregateOutputType | null
    _min: DocumentationRequestsMinAggregateOutputType | null
    _max: DocumentationRequestsMaxAggregateOutputType | null
  }

  export type DocumentationRequestsAvgAggregateOutputType = {
    UserDefinedTemplate: number | null
    IsCancelled: number | null
    IsProcessed: number | null
  }

  export type DocumentationRequestsSumAggregateOutputType = {
    UserDefinedTemplate: number | null
    IsCancelled: number | null
    IsProcessed: number | null
  }

  export type DocumentationRequestsMinAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    User_Id: string | null
    UserDefinedTemplate: number | null
    InclusionList: string | null
    ExclusionList: string | null
    FileName: string | null
    IsCancelled: number | null
    IsProcessed: number | null
    Created: Date | null
    Modified: Date | null
  }

  export type DocumentationRequestsMaxAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    User_Id: string | null
    UserDefinedTemplate: number | null
    InclusionList: string | null
    ExclusionList: string | null
    FileName: string | null
    IsCancelled: number | null
    IsProcessed: number | null
    Created: Date | null
    Modified: Date | null
  }

  export type DocumentationRequestsCountAggregateOutputType = {
    Id: number
    Repository_Id: number
    User_Id: number
    UserDefinedTemplate: number
    InclusionList: number
    ExclusionList: number
    FileName: number
    IsCancelled: number
    IsProcessed: number
    Created: number
    Modified: number
    _all: number
  }


  export type DocumentationRequestsAvgAggregateInputType = {
    UserDefinedTemplate?: true
    IsCancelled?: true
    IsProcessed?: true
  }

  export type DocumentationRequestsSumAggregateInputType = {
    UserDefinedTemplate?: true
    IsCancelled?: true
    IsProcessed?: true
  }

  export type DocumentationRequestsMinAggregateInputType = {
    Id?: true
    Repository_Id?: true
    User_Id?: true
    UserDefinedTemplate?: true
    InclusionList?: true
    ExclusionList?: true
    FileName?: true
    IsCancelled?: true
    IsProcessed?: true
    Created?: true
    Modified?: true
  }

  export type DocumentationRequestsMaxAggregateInputType = {
    Id?: true
    Repository_Id?: true
    User_Id?: true
    UserDefinedTemplate?: true
    InclusionList?: true
    ExclusionList?: true
    FileName?: true
    IsCancelled?: true
    IsProcessed?: true
    Created?: true
    Modified?: true
  }

  export type DocumentationRequestsCountAggregateInputType = {
    Id?: true
    Repository_Id?: true
    User_Id?: true
    UserDefinedTemplate?: true
    InclusionList?: true
    ExclusionList?: true
    FileName?: true
    IsCancelled?: true
    IsProcessed?: true
    Created?: true
    Modified?: true
    _all?: true
  }

  export type DocumentationRequestsAggregateArgs = {
    /**
     * Filter which DocumentationRequests to aggregate.
     * 
    **/
    where?: DocumentationRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentationRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<DocumentationRequestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DocumentationRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentationRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentationRequests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentationRequests
    **/
    _count?: true | DocumentationRequestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentationRequestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentationRequestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentationRequestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentationRequestsMaxAggregateInputType
  }

  export type GetDocumentationRequestsAggregateType<T extends DocumentationRequestsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentationRequests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentationRequests[P]>
      : GetScalarType<T[P], AggregateDocumentationRequests[P]>
  }




  export type DocumentationRequestsGroupByArgs = {
    where?: DocumentationRequestsWhereInput
    orderBy?: Enumerable<DocumentationRequestsOrderByWithAggregationInput>
    by: Array<DocumentationRequestsScalarFieldEnum>
    having?: DocumentationRequestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentationRequestsCountAggregateInputType | true
    _avg?: DocumentationRequestsAvgAggregateInputType
    _sum?: DocumentationRequestsSumAggregateInputType
    _min?: DocumentationRequestsMinAggregateInputType
    _max?: DocumentationRequestsMaxAggregateInputType
  }


  export type DocumentationRequestsGroupByOutputType = {
    Id: string
    Repository_Id: string
    User_Id: string
    UserDefinedTemplate: number
    InclusionList: string | null
    ExclusionList: string | null
    FileName: string | null
    IsCancelled: number
    IsProcessed: number
    Created: Date
    Modified: Date
    _count: DocumentationRequestsCountAggregateOutputType | null
    _avg: DocumentationRequestsAvgAggregateOutputType | null
    _sum: DocumentationRequestsSumAggregateOutputType | null
    _min: DocumentationRequestsMinAggregateOutputType | null
    _max: DocumentationRequestsMaxAggregateOutputType | null
  }

  type GetDocumentationRequestsGroupByPayload<T extends DocumentationRequestsGroupByArgs> = Promise<
    Array<
      PickArray<DocumentationRequestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentationRequestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentationRequestsGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentationRequestsGroupByOutputType[P]>
        }
      >
    >


  export type DocumentationRequestsSelect = {
    Id?: boolean
    Repository_Id?: boolean
    User_Id?: boolean
    UserDefinedTemplate?: boolean
    InclusionList?: boolean
    ExclusionList?: boolean
    FileName?: boolean
    IsCancelled?: boolean
    IsProcessed?: boolean
    Created?: boolean
    Modified?: boolean
  }

  export type DocumentationRequestsGetPayload<
    S extends boolean | null | undefined | DocumentationRequestsArgs,
    U = keyof S
      > = S extends true
        ? DocumentationRequests
    : S extends undefined
    ? never
    : S extends DocumentationRequestsArgs | DocumentationRequestsFindManyArgs
    ?'include' extends U
    ? DocumentationRequests 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DocumentationRequests ?DocumentationRequests [P]
  : 
     never
  } 
    : DocumentationRequests
  : DocumentationRequests


  type DocumentationRequestsCountArgs = Merge<
    Omit<DocumentationRequestsFindManyArgs, 'select' | 'include'> & {
      select?: DocumentationRequestsCountAggregateInputType | true
    }
  >

  export interface DocumentationRequestsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DocumentationRequests that matches the filter.
     * @param {DocumentationRequestsFindUniqueArgs} args - Arguments to find a DocumentationRequests
     * @example
     * // Get one DocumentationRequests
     * const documentationRequests = await prisma.documentationRequests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentationRequestsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentationRequestsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DocumentationRequests'> extends True ? CheckSelect<T, Prisma__DocumentationRequestsClient<DocumentationRequests>, Prisma__DocumentationRequestsClient<DocumentationRequestsGetPayload<T>>> : CheckSelect<T, Prisma__DocumentationRequestsClient<DocumentationRequests | null >, Prisma__DocumentationRequestsClient<DocumentationRequestsGetPayload<T> | null >>

    /**
     * Find the first DocumentationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationRequestsFindFirstArgs} args - Arguments to find a DocumentationRequests
     * @example
     * // Get one DocumentationRequests
     * const documentationRequests = await prisma.documentationRequests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentationRequestsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentationRequestsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DocumentationRequests'> extends True ? CheckSelect<T, Prisma__DocumentationRequestsClient<DocumentationRequests>, Prisma__DocumentationRequestsClient<DocumentationRequestsGetPayload<T>>> : CheckSelect<T, Prisma__DocumentationRequestsClient<DocumentationRequests | null >, Prisma__DocumentationRequestsClient<DocumentationRequestsGetPayload<T> | null >>

    /**
     * Find zero or more DocumentationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationRequestsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentationRequests
     * const documentationRequests = await prisma.documentationRequests.findMany()
     * 
     * // Get first 10 DocumentationRequests
     * const documentationRequests = await prisma.documentationRequests.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const documentationRequestsWithIdOnly = await prisma.documentationRequests.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends DocumentationRequestsFindManyArgs>(
      args?: SelectSubset<T, DocumentationRequestsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DocumentationRequests>>, PrismaPromise<Array<DocumentationRequestsGetPayload<T>>>>

    /**
     * Create a DocumentationRequests.
     * @param {DocumentationRequestsCreateArgs} args - Arguments to create a DocumentationRequests.
     * @example
     * // Create one DocumentationRequests
     * const DocumentationRequests = await prisma.documentationRequests.create({
     *   data: {
     *     // ... data to create a DocumentationRequests
     *   }
     * })
     * 
    **/
    create<T extends DocumentationRequestsCreateArgs>(
      args: SelectSubset<T, DocumentationRequestsCreateArgs>
    ): CheckSelect<T, Prisma__DocumentationRequestsClient<DocumentationRequests>, Prisma__DocumentationRequestsClient<DocumentationRequestsGetPayload<T>>>

    /**
     * Create many DocumentationRequests.
     *     @param {DocumentationRequestsCreateManyArgs} args - Arguments to create many DocumentationRequests.
     *     @example
     *     // Create many DocumentationRequests
     *     const documentationRequests = await prisma.documentationRequests.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentationRequestsCreateManyArgs>(
      args?: SelectSubset<T, DocumentationRequestsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentationRequests.
     * @param {DocumentationRequestsDeleteArgs} args - Arguments to delete one DocumentationRequests.
     * @example
     * // Delete one DocumentationRequests
     * const DocumentationRequests = await prisma.documentationRequests.delete({
     *   where: {
     *     // ... filter to delete one DocumentationRequests
     *   }
     * })
     * 
    **/
    delete<T extends DocumentationRequestsDeleteArgs>(
      args: SelectSubset<T, DocumentationRequestsDeleteArgs>
    ): CheckSelect<T, Prisma__DocumentationRequestsClient<DocumentationRequests>, Prisma__DocumentationRequestsClient<DocumentationRequestsGetPayload<T>>>

    /**
     * Update one DocumentationRequests.
     * @param {DocumentationRequestsUpdateArgs} args - Arguments to update one DocumentationRequests.
     * @example
     * // Update one DocumentationRequests
     * const documentationRequests = await prisma.documentationRequests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentationRequestsUpdateArgs>(
      args: SelectSubset<T, DocumentationRequestsUpdateArgs>
    ): CheckSelect<T, Prisma__DocumentationRequestsClient<DocumentationRequests>, Prisma__DocumentationRequestsClient<DocumentationRequestsGetPayload<T>>>

    /**
     * Delete zero or more DocumentationRequests.
     * @param {DocumentationRequestsDeleteManyArgs} args - Arguments to filter DocumentationRequests to delete.
     * @example
     * // Delete a few DocumentationRequests
     * const { count } = await prisma.documentationRequests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentationRequestsDeleteManyArgs>(
      args?: SelectSubset<T, DocumentationRequestsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationRequestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentationRequests
     * const documentationRequests = await prisma.documentationRequests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentationRequestsUpdateManyArgs>(
      args: SelectSubset<T, DocumentationRequestsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentationRequests.
     * @param {DocumentationRequestsUpsertArgs} args - Arguments to update or create a DocumentationRequests.
     * @example
     * // Update or create a DocumentationRequests
     * const documentationRequests = await prisma.documentationRequests.upsert({
     *   create: {
     *     // ... data to create a DocumentationRequests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentationRequests we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentationRequestsUpsertArgs>(
      args: SelectSubset<T, DocumentationRequestsUpsertArgs>
    ): CheckSelect<T, Prisma__DocumentationRequestsClient<DocumentationRequests>, Prisma__DocumentationRequestsClient<DocumentationRequestsGetPayload<T>>>

    /**
     * Count the number of DocumentationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationRequestsCountArgs} args - Arguments to filter DocumentationRequests to count.
     * @example
     * // Count the number of DocumentationRequests
     * const count = await prisma.documentationRequests.count({
     *   where: {
     *     // ... the filter for the DocumentationRequests we want to count
     *   }
     * })
    **/
    count<T extends DocumentationRequestsCountArgs>(
      args?: Subset<T, DocumentationRequestsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentationRequestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationRequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentationRequestsAggregateArgs>(args: Subset<T, DocumentationRequestsAggregateArgs>): PrismaPromise<GetDocumentationRequestsAggregateType<T>>

    /**
     * Group by DocumentationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationRequestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentationRequestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentationRequestsGroupByArgs['orderBy'] }
        : { orderBy?: DocumentationRequestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentationRequestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentationRequestsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentationRequests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentationRequestsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DocumentationRequests findUnique
   */
  export type DocumentationRequestsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DocumentationRequests
     * 
    **/
    select?: DocumentationRequestsSelect | null
    /**
     * Throw an Error if a DocumentationRequests can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DocumentationRequests to fetch.
     * 
    **/
    where: DocumentationRequestsWhereUniqueInput
  }


  /**
   * DocumentationRequests findFirst
   */
  export type DocumentationRequestsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DocumentationRequests
     * 
    **/
    select?: DocumentationRequestsSelect | null
    /**
     * Throw an Error if a DocumentationRequests can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DocumentationRequests to fetch.
     * 
    **/
    where?: DocumentationRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentationRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<DocumentationRequestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentationRequests.
     * 
    **/
    cursor?: DocumentationRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentationRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentationRequests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentationRequests.
     * 
    **/
    distinct?: Enumerable<DocumentationRequestsScalarFieldEnum>
  }


  /**
   * DocumentationRequests findMany
   */
  export type DocumentationRequestsFindManyArgs = {
    /**
     * Select specific fields to fetch from the DocumentationRequests
     * 
    **/
    select?: DocumentationRequestsSelect | null
    /**
     * Filter, which DocumentationRequests to fetch.
     * 
    **/
    where?: DocumentationRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentationRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<DocumentationRequestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentationRequests.
     * 
    **/
    cursor?: DocumentationRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentationRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentationRequests.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DocumentationRequestsScalarFieldEnum>
  }


  /**
   * DocumentationRequests create
   */
  export type DocumentationRequestsCreateArgs = {
    /**
     * Select specific fields to fetch from the DocumentationRequests
     * 
    **/
    select?: DocumentationRequestsSelect | null
    /**
     * The data needed to create a DocumentationRequests.
     * 
    **/
    data: XOR<DocumentationRequestsCreateInput, DocumentationRequestsUncheckedCreateInput>
  }


  /**
   * DocumentationRequests createMany
   */
  export type DocumentationRequestsCreateManyArgs = {
    data: Enumerable<DocumentationRequestsCreateManyInput>
  }


  /**
   * DocumentationRequests update
   */
  export type DocumentationRequestsUpdateArgs = {
    /**
     * Select specific fields to fetch from the DocumentationRequests
     * 
    **/
    select?: DocumentationRequestsSelect | null
    /**
     * The data needed to update a DocumentationRequests.
     * 
    **/
    data: XOR<DocumentationRequestsUpdateInput, DocumentationRequestsUncheckedUpdateInput>
    /**
     * Choose, which DocumentationRequests to update.
     * 
    **/
    where: DocumentationRequestsWhereUniqueInput
  }


  /**
   * DocumentationRequests updateMany
   */
  export type DocumentationRequestsUpdateManyArgs = {
    data: XOR<DocumentationRequestsUpdateManyMutationInput, DocumentationRequestsUncheckedUpdateManyInput>
    where?: DocumentationRequestsWhereInput
  }


  /**
   * DocumentationRequests upsert
   */
  export type DocumentationRequestsUpsertArgs = {
    /**
     * Select specific fields to fetch from the DocumentationRequests
     * 
    **/
    select?: DocumentationRequestsSelect | null
    /**
     * The filter to search for the DocumentationRequests to update in case it exists.
     * 
    **/
    where: DocumentationRequestsWhereUniqueInput
    /**
     * In case the DocumentationRequests found by the `where` argument doesn't exist, create a new DocumentationRequests with this data.
     * 
    **/
    create: XOR<DocumentationRequestsCreateInput, DocumentationRequestsUncheckedCreateInput>
    /**
     * In case the DocumentationRequests was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DocumentationRequestsUpdateInput, DocumentationRequestsUncheckedUpdateInput>
  }


  /**
   * DocumentationRequests delete
   */
  export type DocumentationRequestsDeleteArgs = {
    /**
     * Select specific fields to fetch from the DocumentationRequests
     * 
    **/
    select?: DocumentationRequestsSelect | null
    /**
     * Filter which DocumentationRequests to delete.
     * 
    **/
    where: DocumentationRequestsWhereUniqueInput
  }


  /**
   * DocumentationRequests deleteMany
   */
  export type DocumentationRequestsDeleteManyArgs = {
    where?: DocumentationRequestsWhereInput
  }


  /**
   * DocumentationRequests without action
   */
  export type DocumentationRequestsArgs = {
    /**
     * Select specific fields to fetch from the DocumentationRequests
     * 
    **/
    select?: DocumentationRequestsSelect | null
  }



  /**
   * Model DomainRestrictions
   */


  export type AggregateDomainRestrictions = {
    _count: DomainRestrictionsCountAggregateOutputType | null
    _avg: DomainRestrictionsAvgAggregateOutputType | null
    _sum: DomainRestrictionsSumAggregateOutputType | null
    _min: DomainRestrictionsMinAggregateOutputType | null
    _max: DomainRestrictionsMaxAggregateOutputType | null
  }

  export type DomainRestrictionsAvgAggregateOutputType = {
    IsEnabled: number | null
  }

  export type DomainRestrictionsSumAggregateOutputType = {
    IsEnabled: number | null
  }

  export type DomainRestrictionsMinAggregateOutputType = {
    Id: string | null
    Domain: string | null
    IsEnabled: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type DomainRestrictionsMaxAggregateOutputType = {
    Id: string | null
    Domain: string | null
    IsEnabled: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type DomainRestrictionsCountAggregateOutputType = {
    Id: number
    Domain: number
    IsEnabled: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type DomainRestrictionsAvgAggregateInputType = {
    IsEnabled?: true
  }

  export type DomainRestrictionsSumAggregateInputType = {
    IsEnabled?: true
  }

  export type DomainRestrictionsMinAggregateInputType = {
    Id?: true
    Domain?: true
    IsEnabled?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type DomainRestrictionsMaxAggregateInputType = {
    Id?: true
    Domain?: true
    IsEnabled?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type DomainRestrictionsCountAggregateInputType = {
    Id?: true
    Domain?: true
    IsEnabled?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type DomainRestrictionsAggregateArgs = {
    /**
     * Filter which DomainRestrictions to aggregate.
     * 
    **/
    where?: DomainRestrictionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainRestrictions to fetch.
     * 
    **/
    orderBy?: Enumerable<DomainRestrictionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DomainRestrictionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainRestrictions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainRestrictions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainRestrictions
    **/
    _count?: true | DomainRestrictionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DomainRestrictionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DomainRestrictionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainRestrictionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainRestrictionsMaxAggregateInputType
  }

  export type GetDomainRestrictionsAggregateType<T extends DomainRestrictionsAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainRestrictions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainRestrictions[P]>
      : GetScalarType<T[P], AggregateDomainRestrictions[P]>
  }




  export type DomainRestrictionsGroupByArgs = {
    where?: DomainRestrictionsWhereInput
    orderBy?: Enumerable<DomainRestrictionsOrderByWithAggregationInput>
    by: Array<DomainRestrictionsScalarFieldEnum>
    having?: DomainRestrictionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainRestrictionsCountAggregateInputType | true
    _avg?: DomainRestrictionsAvgAggregateInputType
    _sum?: DomainRestrictionsSumAggregateInputType
    _min?: DomainRestrictionsMinAggregateInputType
    _max?: DomainRestrictionsMaxAggregateInputType
  }


  export type DomainRestrictionsGroupByOutputType = {
    Id: string
    Domain: string | null
    IsEnabled: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: DomainRestrictionsCountAggregateOutputType | null
    _avg: DomainRestrictionsAvgAggregateOutputType | null
    _sum: DomainRestrictionsSumAggregateOutputType | null
    _min: DomainRestrictionsMinAggregateOutputType | null
    _max: DomainRestrictionsMaxAggregateOutputType | null
  }

  type GetDomainRestrictionsGroupByPayload<T extends DomainRestrictionsGroupByArgs> = Promise<
    Array<
      PickArray<DomainRestrictionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainRestrictionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainRestrictionsGroupByOutputType[P]>
            : GetScalarType<T[P], DomainRestrictionsGroupByOutputType[P]>
        }
      >
    >


  export type DomainRestrictionsSelect = {
    Id?: boolean
    Domain?: boolean
    IsEnabled?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type DomainRestrictionsGetPayload<
    S extends boolean | null | undefined | DomainRestrictionsArgs,
    U = keyof S
      > = S extends true
        ? DomainRestrictions
    : S extends undefined
    ? never
    : S extends DomainRestrictionsArgs | DomainRestrictionsFindManyArgs
    ?'include' extends U
    ? DomainRestrictions 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DomainRestrictions ?DomainRestrictions [P]
  : 
     never
  } 
    : DomainRestrictions
  : DomainRestrictions


  type DomainRestrictionsCountArgs = Merge<
    Omit<DomainRestrictionsFindManyArgs, 'select' | 'include'> & {
      select?: DomainRestrictionsCountAggregateInputType | true
    }
  >

  export interface DomainRestrictionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DomainRestrictions that matches the filter.
     * @param {DomainRestrictionsFindUniqueArgs} args - Arguments to find a DomainRestrictions
     * @example
     * // Get one DomainRestrictions
     * const domainRestrictions = await prisma.domainRestrictions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DomainRestrictionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DomainRestrictionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DomainRestrictions'> extends True ? CheckSelect<T, Prisma__DomainRestrictionsClient<DomainRestrictions>, Prisma__DomainRestrictionsClient<DomainRestrictionsGetPayload<T>>> : CheckSelect<T, Prisma__DomainRestrictionsClient<DomainRestrictions | null >, Prisma__DomainRestrictionsClient<DomainRestrictionsGetPayload<T> | null >>

    /**
     * Find the first DomainRestrictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainRestrictionsFindFirstArgs} args - Arguments to find a DomainRestrictions
     * @example
     * // Get one DomainRestrictions
     * const domainRestrictions = await prisma.domainRestrictions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DomainRestrictionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DomainRestrictionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DomainRestrictions'> extends True ? CheckSelect<T, Prisma__DomainRestrictionsClient<DomainRestrictions>, Prisma__DomainRestrictionsClient<DomainRestrictionsGetPayload<T>>> : CheckSelect<T, Prisma__DomainRestrictionsClient<DomainRestrictions | null >, Prisma__DomainRestrictionsClient<DomainRestrictionsGetPayload<T> | null >>

    /**
     * Find zero or more DomainRestrictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainRestrictionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainRestrictions
     * const domainRestrictions = await prisma.domainRestrictions.findMany()
     * 
     * // Get first 10 DomainRestrictions
     * const domainRestrictions = await prisma.domainRestrictions.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const domainRestrictionsWithIdOnly = await prisma.domainRestrictions.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends DomainRestrictionsFindManyArgs>(
      args?: SelectSubset<T, DomainRestrictionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DomainRestrictions>>, PrismaPromise<Array<DomainRestrictionsGetPayload<T>>>>

    /**
     * Create a DomainRestrictions.
     * @param {DomainRestrictionsCreateArgs} args - Arguments to create a DomainRestrictions.
     * @example
     * // Create one DomainRestrictions
     * const DomainRestrictions = await prisma.domainRestrictions.create({
     *   data: {
     *     // ... data to create a DomainRestrictions
     *   }
     * })
     * 
    **/
    create<T extends DomainRestrictionsCreateArgs>(
      args: SelectSubset<T, DomainRestrictionsCreateArgs>
    ): CheckSelect<T, Prisma__DomainRestrictionsClient<DomainRestrictions>, Prisma__DomainRestrictionsClient<DomainRestrictionsGetPayload<T>>>

    /**
     * Create many DomainRestrictions.
     *     @param {DomainRestrictionsCreateManyArgs} args - Arguments to create many DomainRestrictions.
     *     @example
     *     // Create many DomainRestrictions
     *     const domainRestrictions = await prisma.domainRestrictions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DomainRestrictionsCreateManyArgs>(
      args?: SelectSubset<T, DomainRestrictionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DomainRestrictions.
     * @param {DomainRestrictionsDeleteArgs} args - Arguments to delete one DomainRestrictions.
     * @example
     * // Delete one DomainRestrictions
     * const DomainRestrictions = await prisma.domainRestrictions.delete({
     *   where: {
     *     // ... filter to delete one DomainRestrictions
     *   }
     * })
     * 
    **/
    delete<T extends DomainRestrictionsDeleteArgs>(
      args: SelectSubset<T, DomainRestrictionsDeleteArgs>
    ): CheckSelect<T, Prisma__DomainRestrictionsClient<DomainRestrictions>, Prisma__DomainRestrictionsClient<DomainRestrictionsGetPayload<T>>>

    /**
     * Update one DomainRestrictions.
     * @param {DomainRestrictionsUpdateArgs} args - Arguments to update one DomainRestrictions.
     * @example
     * // Update one DomainRestrictions
     * const domainRestrictions = await prisma.domainRestrictions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DomainRestrictionsUpdateArgs>(
      args: SelectSubset<T, DomainRestrictionsUpdateArgs>
    ): CheckSelect<T, Prisma__DomainRestrictionsClient<DomainRestrictions>, Prisma__DomainRestrictionsClient<DomainRestrictionsGetPayload<T>>>

    /**
     * Delete zero or more DomainRestrictions.
     * @param {DomainRestrictionsDeleteManyArgs} args - Arguments to filter DomainRestrictions to delete.
     * @example
     * // Delete a few DomainRestrictions
     * const { count } = await prisma.domainRestrictions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DomainRestrictionsDeleteManyArgs>(
      args?: SelectSubset<T, DomainRestrictionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainRestrictionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainRestrictions
     * const domainRestrictions = await prisma.domainRestrictions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DomainRestrictionsUpdateManyArgs>(
      args: SelectSubset<T, DomainRestrictionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DomainRestrictions.
     * @param {DomainRestrictionsUpsertArgs} args - Arguments to update or create a DomainRestrictions.
     * @example
     * // Update or create a DomainRestrictions
     * const domainRestrictions = await prisma.domainRestrictions.upsert({
     *   create: {
     *     // ... data to create a DomainRestrictions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainRestrictions we want to update
     *   }
     * })
    **/
    upsert<T extends DomainRestrictionsUpsertArgs>(
      args: SelectSubset<T, DomainRestrictionsUpsertArgs>
    ): CheckSelect<T, Prisma__DomainRestrictionsClient<DomainRestrictions>, Prisma__DomainRestrictionsClient<DomainRestrictionsGetPayload<T>>>

    /**
     * Count the number of DomainRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainRestrictionsCountArgs} args - Arguments to filter DomainRestrictions to count.
     * @example
     * // Count the number of DomainRestrictions
     * const count = await prisma.domainRestrictions.count({
     *   where: {
     *     // ... the filter for the DomainRestrictions we want to count
     *   }
     * })
    **/
    count<T extends DomainRestrictionsCountArgs>(
      args?: Subset<T, DomainRestrictionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainRestrictionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainRestrictionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainRestrictionsAggregateArgs>(args: Subset<T, DomainRestrictionsAggregateArgs>): PrismaPromise<GetDomainRestrictionsAggregateType<T>>

    /**
     * Group by DomainRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainRestrictionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainRestrictionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainRestrictionsGroupByArgs['orderBy'] }
        : { orderBy?: DomainRestrictionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainRestrictionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainRestrictionsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainRestrictions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DomainRestrictionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DomainRestrictions findUnique
   */
  export type DomainRestrictionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DomainRestrictions
     * 
    **/
    select?: DomainRestrictionsSelect | null
    /**
     * Throw an Error if a DomainRestrictions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DomainRestrictions to fetch.
     * 
    **/
    where: DomainRestrictionsWhereUniqueInput
  }


  /**
   * DomainRestrictions findFirst
   */
  export type DomainRestrictionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DomainRestrictions
     * 
    **/
    select?: DomainRestrictionsSelect | null
    /**
     * Throw an Error if a DomainRestrictions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DomainRestrictions to fetch.
     * 
    **/
    where?: DomainRestrictionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainRestrictions to fetch.
     * 
    **/
    orderBy?: Enumerable<DomainRestrictionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainRestrictions.
     * 
    **/
    cursor?: DomainRestrictionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainRestrictions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainRestrictions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainRestrictions.
     * 
    **/
    distinct?: Enumerable<DomainRestrictionsScalarFieldEnum>
  }


  /**
   * DomainRestrictions findMany
   */
  export type DomainRestrictionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the DomainRestrictions
     * 
    **/
    select?: DomainRestrictionsSelect | null
    /**
     * Filter, which DomainRestrictions to fetch.
     * 
    **/
    where?: DomainRestrictionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainRestrictions to fetch.
     * 
    **/
    orderBy?: Enumerable<DomainRestrictionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainRestrictions.
     * 
    **/
    cursor?: DomainRestrictionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainRestrictions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainRestrictions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DomainRestrictionsScalarFieldEnum>
  }


  /**
   * DomainRestrictions create
   */
  export type DomainRestrictionsCreateArgs = {
    /**
     * Select specific fields to fetch from the DomainRestrictions
     * 
    **/
    select?: DomainRestrictionsSelect | null
    /**
     * The data needed to create a DomainRestrictions.
     * 
    **/
    data: XOR<DomainRestrictionsCreateInput, DomainRestrictionsUncheckedCreateInput>
  }


  /**
   * DomainRestrictions createMany
   */
  export type DomainRestrictionsCreateManyArgs = {
    data: Enumerable<DomainRestrictionsCreateManyInput>
  }


  /**
   * DomainRestrictions update
   */
  export type DomainRestrictionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the DomainRestrictions
     * 
    **/
    select?: DomainRestrictionsSelect | null
    /**
     * The data needed to update a DomainRestrictions.
     * 
    **/
    data: XOR<DomainRestrictionsUpdateInput, DomainRestrictionsUncheckedUpdateInput>
    /**
     * Choose, which DomainRestrictions to update.
     * 
    **/
    where: DomainRestrictionsWhereUniqueInput
  }


  /**
   * DomainRestrictions updateMany
   */
  export type DomainRestrictionsUpdateManyArgs = {
    data: XOR<DomainRestrictionsUpdateManyMutationInput, DomainRestrictionsUncheckedUpdateManyInput>
    where?: DomainRestrictionsWhereInput
  }


  /**
   * DomainRestrictions upsert
   */
  export type DomainRestrictionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the DomainRestrictions
     * 
    **/
    select?: DomainRestrictionsSelect | null
    /**
     * The filter to search for the DomainRestrictions to update in case it exists.
     * 
    **/
    where: DomainRestrictionsWhereUniqueInput
    /**
     * In case the DomainRestrictions found by the `where` argument doesn't exist, create a new DomainRestrictions with this data.
     * 
    **/
    create: XOR<DomainRestrictionsCreateInput, DomainRestrictionsUncheckedCreateInput>
    /**
     * In case the DomainRestrictions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DomainRestrictionsUpdateInput, DomainRestrictionsUncheckedUpdateInput>
  }


  /**
   * DomainRestrictions delete
   */
  export type DomainRestrictionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the DomainRestrictions
     * 
    **/
    select?: DomainRestrictionsSelect | null
    /**
     * Filter which DomainRestrictions to delete.
     * 
    **/
    where: DomainRestrictionsWhereUniqueInput
  }


  /**
   * DomainRestrictions deleteMany
   */
  export type DomainRestrictionsDeleteManyArgs = {
    where?: DomainRestrictionsWhereInput
  }


  /**
   * DomainRestrictions without action
   */
  export type DomainRestrictionsArgs = {
    /**
     * Select specific fields to fetch from the DomainRestrictions
     * 
    **/
    select?: DomainRestrictionsSelect | null
  }



  /**
   * Model EAChangelogAttributes
   */


  export type AggregateEAChangelogAttributes = {
    _count: EAChangelogAttributesCountAggregateOutputType | null
    _min: EAChangelogAttributesMinAggregateOutputType | null
    _max: EAChangelogAttributesMaxAggregateOutputType | null
  }

  export type EAChangelogAttributesMinAggregateOutputType = {
    Id: string | null
    EAChangelogId: string | null
    PropertyGuid: string | null
    Name: string | null
    CurrentValue: string | null
    PreviousValue: string | null
    ActionType: string | null
    AttributeType: string | null
    CreatedDate: Date | null
  }

  export type EAChangelogAttributesMaxAggregateOutputType = {
    Id: string | null
    EAChangelogId: string | null
    PropertyGuid: string | null
    Name: string | null
    CurrentValue: string | null
    PreviousValue: string | null
    ActionType: string | null
    AttributeType: string | null
    CreatedDate: Date | null
  }

  export type EAChangelogAttributesCountAggregateOutputType = {
    Id: number
    EAChangelogId: number
    PropertyGuid: number
    Name: number
    CurrentValue: number
    PreviousValue: number
    ActionType: number
    AttributeType: number
    CreatedDate: number
    _all: number
  }


  export type EAChangelogAttributesMinAggregateInputType = {
    Id?: true
    EAChangelogId?: true
    PropertyGuid?: true
    Name?: true
    CurrentValue?: true
    PreviousValue?: true
    ActionType?: true
    AttributeType?: true
    CreatedDate?: true
  }

  export type EAChangelogAttributesMaxAggregateInputType = {
    Id?: true
    EAChangelogId?: true
    PropertyGuid?: true
    Name?: true
    CurrentValue?: true
    PreviousValue?: true
    ActionType?: true
    AttributeType?: true
    CreatedDate?: true
  }

  export type EAChangelogAttributesCountAggregateInputType = {
    Id?: true
    EAChangelogId?: true
    PropertyGuid?: true
    Name?: true
    CurrentValue?: true
    PreviousValue?: true
    ActionType?: true
    AttributeType?: true
    CreatedDate?: true
    _all?: true
  }

  export type EAChangelogAttributesAggregateArgs = {
    /**
     * Filter which EAChangelogAttributes to aggregate.
     * 
    **/
    where?: EAChangelogAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAChangelogAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<EAChangelogAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EAChangelogAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAChangelogAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAChangelogAttributes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EAChangelogAttributes
    **/
    _count?: true | EAChangelogAttributesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EAChangelogAttributesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EAChangelogAttributesMaxAggregateInputType
  }

  export type GetEAChangelogAttributesAggregateType<T extends EAChangelogAttributesAggregateArgs> = {
        [P in keyof T & keyof AggregateEAChangelogAttributes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEAChangelogAttributes[P]>
      : GetScalarType<T[P], AggregateEAChangelogAttributes[P]>
  }




  export type EAChangelogAttributesGroupByArgs = {
    where?: EAChangelogAttributesWhereInput
    orderBy?: Enumerable<EAChangelogAttributesOrderByWithAggregationInput>
    by: Array<EAChangelogAttributesScalarFieldEnum>
    having?: EAChangelogAttributesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EAChangelogAttributesCountAggregateInputType | true
    _min?: EAChangelogAttributesMinAggregateInputType
    _max?: EAChangelogAttributesMaxAggregateInputType
  }


  export type EAChangelogAttributesGroupByOutputType = {
    Id: string
    EAChangelogId: string
    PropertyGuid: string | null
    Name: string | null
    CurrentValue: string | null
    PreviousValue: string | null
    ActionType: string | null
    AttributeType: string | null
    CreatedDate: Date | null
    _count: EAChangelogAttributesCountAggregateOutputType | null
    _min: EAChangelogAttributesMinAggregateOutputType | null
    _max: EAChangelogAttributesMaxAggregateOutputType | null
  }

  type GetEAChangelogAttributesGroupByPayload<T extends EAChangelogAttributesGroupByArgs> = Promise<
    Array<
      PickArray<EAChangelogAttributesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EAChangelogAttributesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EAChangelogAttributesGroupByOutputType[P]>
            : GetScalarType<T[P], EAChangelogAttributesGroupByOutputType[P]>
        }
      >
    >


  export type EAChangelogAttributesSelect = {
    Id?: boolean
    EAChangelogId?: boolean
    PropertyGuid?: boolean
    Name?: boolean
    CurrentValue?: boolean
    PreviousValue?: boolean
    ActionType?: boolean
    AttributeType?: boolean
    CreatedDate?: boolean
  }

  export type EAChangelogAttributesGetPayload<
    S extends boolean | null | undefined | EAChangelogAttributesArgs,
    U = keyof S
      > = S extends true
        ? EAChangelogAttributes
    : S extends undefined
    ? never
    : S extends EAChangelogAttributesArgs | EAChangelogAttributesFindManyArgs
    ?'include' extends U
    ? EAChangelogAttributes 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof EAChangelogAttributes ?EAChangelogAttributes [P]
  : 
     never
  } 
    : EAChangelogAttributes
  : EAChangelogAttributes


  type EAChangelogAttributesCountArgs = Merge<
    Omit<EAChangelogAttributesFindManyArgs, 'select' | 'include'> & {
      select?: EAChangelogAttributesCountAggregateInputType | true
    }
  >

  export interface EAChangelogAttributesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one EAChangelogAttributes that matches the filter.
     * @param {EAChangelogAttributesFindUniqueArgs} args - Arguments to find a EAChangelogAttributes
     * @example
     * // Get one EAChangelogAttributes
     * const eAChangelogAttributes = await prisma.eAChangelogAttributes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EAChangelogAttributesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EAChangelogAttributesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EAChangelogAttributes'> extends True ? CheckSelect<T, Prisma__EAChangelogAttributesClient<EAChangelogAttributes>, Prisma__EAChangelogAttributesClient<EAChangelogAttributesGetPayload<T>>> : CheckSelect<T, Prisma__EAChangelogAttributesClient<EAChangelogAttributes | null >, Prisma__EAChangelogAttributesClient<EAChangelogAttributesGetPayload<T> | null >>

    /**
     * Find the first EAChangelogAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAChangelogAttributesFindFirstArgs} args - Arguments to find a EAChangelogAttributes
     * @example
     * // Get one EAChangelogAttributes
     * const eAChangelogAttributes = await prisma.eAChangelogAttributes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EAChangelogAttributesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EAChangelogAttributesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EAChangelogAttributes'> extends True ? CheckSelect<T, Prisma__EAChangelogAttributesClient<EAChangelogAttributes>, Prisma__EAChangelogAttributesClient<EAChangelogAttributesGetPayload<T>>> : CheckSelect<T, Prisma__EAChangelogAttributesClient<EAChangelogAttributes | null >, Prisma__EAChangelogAttributesClient<EAChangelogAttributesGetPayload<T> | null >>

    /**
     * Find zero or more EAChangelogAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAChangelogAttributesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EAChangelogAttributes
     * const eAChangelogAttributes = await prisma.eAChangelogAttributes.findMany()
     * 
     * // Get first 10 EAChangelogAttributes
     * const eAChangelogAttributes = await prisma.eAChangelogAttributes.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const eAChangelogAttributesWithIdOnly = await prisma.eAChangelogAttributes.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends EAChangelogAttributesFindManyArgs>(
      args?: SelectSubset<T, EAChangelogAttributesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<EAChangelogAttributes>>, PrismaPromise<Array<EAChangelogAttributesGetPayload<T>>>>

    /**
     * Create a EAChangelogAttributes.
     * @param {EAChangelogAttributesCreateArgs} args - Arguments to create a EAChangelogAttributes.
     * @example
     * // Create one EAChangelogAttributes
     * const EAChangelogAttributes = await prisma.eAChangelogAttributes.create({
     *   data: {
     *     // ... data to create a EAChangelogAttributes
     *   }
     * })
     * 
    **/
    create<T extends EAChangelogAttributesCreateArgs>(
      args: SelectSubset<T, EAChangelogAttributesCreateArgs>
    ): CheckSelect<T, Prisma__EAChangelogAttributesClient<EAChangelogAttributes>, Prisma__EAChangelogAttributesClient<EAChangelogAttributesGetPayload<T>>>

    /**
     * Create many EAChangelogAttributes.
     *     @param {EAChangelogAttributesCreateManyArgs} args - Arguments to create many EAChangelogAttributes.
     *     @example
     *     // Create many EAChangelogAttributes
     *     const eAChangelogAttributes = await prisma.eAChangelogAttributes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EAChangelogAttributesCreateManyArgs>(
      args?: SelectSubset<T, EAChangelogAttributesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EAChangelogAttributes.
     * @param {EAChangelogAttributesDeleteArgs} args - Arguments to delete one EAChangelogAttributes.
     * @example
     * // Delete one EAChangelogAttributes
     * const EAChangelogAttributes = await prisma.eAChangelogAttributes.delete({
     *   where: {
     *     // ... filter to delete one EAChangelogAttributes
     *   }
     * })
     * 
    **/
    delete<T extends EAChangelogAttributesDeleteArgs>(
      args: SelectSubset<T, EAChangelogAttributesDeleteArgs>
    ): CheckSelect<T, Prisma__EAChangelogAttributesClient<EAChangelogAttributes>, Prisma__EAChangelogAttributesClient<EAChangelogAttributesGetPayload<T>>>

    /**
     * Update one EAChangelogAttributes.
     * @param {EAChangelogAttributesUpdateArgs} args - Arguments to update one EAChangelogAttributes.
     * @example
     * // Update one EAChangelogAttributes
     * const eAChangelogAttributes = await prisma.eAChangelogAttributes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EAChangelogAttributesUpdateArgs>(
      args: SelectSubset<T, EAChangelogAttributesUpdateArgs>
    ): CheckSelect<T, Prisma__EAChangelogAttributesClient<EAChangelogAttributes>, Prisma__EAChangelogAttributesClient<EAChangelogAttributesGetPayload<T>>>

    /**
     * Delete zero or more EAChangelogAttributes.
     * @param {EAChangelogAttributesDeleteManyArgs} args - Arguments to filter EAChangelogAttributes to delete.
     * @example
     * // Delete a few EAChangelogAttributes
     * const { count } = await prisma.eAChangelogAttributes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EAChangelogAttributesDeleteManyArgs>(
      args?: SelectSubset<T, EAChangelogAttributesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EAChangelogAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAChangelogAttributesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EAChangelogAttributes
     * const eAChangelogAttributes = await prisma.eAChangelogAttributes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EAChangelogAttributesUpdateManyArgs>(
      args: SelectSubset<T, EAChangelogAttributesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EAChangelogAttributes.
     * @param {EAChangelogAttributesUpsertArgs} args - Arguments to update or create a EAChangelogAttributes.
     * @example
     * // Update or create a EAChangelogAttributes
     * const eAChangelogAttributes = await prisma.eAChangelogAttributes.upsert({
     *   create: {
     *     // ... data to create a EAChangelogAttributes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EAChangelogAttributes we want to update
     *   }
     * })
    **/
    upsert<T extends EAChangelogAttributesUpsertArgs>(
      args: SelectSubset<T, EAChangelogAttributesUpsertArgs>
    ): CheckSelect<T, Prisma__EAChangelogAttributesClient<EAChangelogAttributes>, Prisma__EAChangelogAttributesClient<EAChangelogAttributesGetPayload<T>>>

    /**
     * Count the number of EAChangelogAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAChangelogAttributesCountArgs} args - Arguments to filter EAChangelogAttributes to count.
     * @example
     * // Count the number of EAChangelogAttributes
     * const count = await prisma.eAChangelogAttributes.count({
     *   where: {
     *     // ... the filter for the EAChangelogAttributes we want to count
     *   }
     * })
    **/
    count<T extends EAChangelogAttributesCountArgs>(
      args?: Subset<T, EAChangelogAttributesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EAChangelogAttributesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EAChangelogAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAChangelogAttributesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EAChangelogAttributesAggregateArgs>(args: Subset<T, EAChangelogAttributesAggregateArgs>): PrismaPromise<GetEAChangelogAttributesAggregateType<T>>

    /**
     * Group by EAChangelogAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAChangelogAttributesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EAChangelogAttributesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EAChangelogAttributesGroupByArgs['orderBy'] }
        : { orderBy?: EAChangelogAttributesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EAChangelogAttributesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEAChangelogAttributesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for EAChangelogAttributes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EAChangelogAttributesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * EAChangelogAttributes findUnique
   */
  export type EAChangelogAttributesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogAttributes
     * 
    **/
    select?: EAChangelogAttributesSelect | null
    /**
     * Throw an Error if a EAChangelogAttributes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EAChangelogAttributes to fetch.
     * 
    **/
    where: EAChangelogAttributesWhereUniqueInput
  }


  /**
   * EAChangelogAttributes findFirst
   */
  export type EAChangelogAttributesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogAttributes
     * 
    **/
    select?: EAChangelogAttributesSelect | null
    /**
     * Throw an Error if a EAChangelogAttributes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EAChangelogAttributes to fetch.
     * 
    **/
    where?: EAChangelogAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAChangelogAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<EAChangelogAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EAChangelogAttributes.
     * 
    **/
    cursor?: EAChangelogAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAChangelogAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAChangelogAttributes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EAChangelogAttributes.
     * 
    **/
    distinct?: Enumerable<EAChangelogAttributesScalarFieldEnum>
  }


  /**
   * EAChangelogAttributes findMany
   */
  export type EAChangelogAttributesFindManyArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogAttributes
     * 
    **/
    select?: EAChangelogAttributesSelect | null
    /**
     * Filter, which EAChangelogAttributes to fetch.
     * 
    **/
    where?: EAChangelogAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAChangelogAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<EAChangelogAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EAChangelogAttributes.
     * 
    **/
    cursor?: EAChangelogAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAChangelogAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAChangelogAttributes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EAChangelogAttributesScalarFieldEnum>
  }


  /**
   * EAChangelogAttributes create
   */
  export type EAChangelogAttributesCreateArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogAttributes
     * 
    **/
    select?: EAChangelogAttributesSelect | null
    /**
     * The data needed to create a EAChangelogAttributes.
     * 
    **/
    data: XOR<EAChangelogAttributesCreateInput, EAChangelogAttributesUncheckedCreateInput>
  }


  /**
   * EAChangelogAttributes createMany
   */
  export type EAChangelogAttributesCreateManyArgs = {
    data: Enumerable<EAChangelogAttributesCreateManyInput>
  }


  /**
   * EAChangelogAttributes update
   */
  export type EAChangelogAttributesUpdateArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogAttributes
     * 
    **/
    select?: EAChangelogAttributesSelect | null
    /**
     * The data needed to update a EAChangelogAttributes.
     * 
    **/
    data: XOR<EAChangelogAttributesUpdateInput, EAChangelogAttributesUncheckedUpdateInput>
    /**
     * Choose, which EAChangelogAttributes to update.
     * 
    **/
    where: EAChangelogAttributesWhereUniqueInput
  }


  /**
   * EAChangelogAttributes updateMany
   */
  export type EAChangelogAttributesUpdateManyArgs = {
    data: XOR<EAChangelogAttributesUpdateManyMutationInput, EAChangelogAttributesUncheckedUpdateManyInput>
    where?: EAChangelogAttributesWhereInput
  }


  /**
   * EAChangelogAttributes upsert
   */
  export type EAChangelogAttributesUpsertArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogAttributes
     * 
    **/
    select?: EAChangelogAttributesSelect | null
    /**
     * The filter to search for the EAChangelogAttributes to update in case it exists.
     * 
    **/
    where: EAChangelogAttributesWhereUniqueInput
    /**
     * In case the EAChangelogAttributes found by the `where` argument doesn't exist, create a new EAChangelogAttributes with this data.
     * 
    **/
    create: XOR<EAChangelogAttributesCreateInput, EAChangelogAttributesUncheckedCreateInput>
    /**
     * In case the EAChangelogAttributes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EAChangelogAttributesUpdateInput, EAChangelogAttributesUncheckedUpdateInput>
  }


  /**
   * EAChangelogAttributes delete
   */
  export type EAChangelogAttributesDeleteArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogAttributes
     * 
    **/
    select?: EAChangelogAttributesSelect | null
    /**
     * Filter which EAChangelogAttributes to delete.
     * 
    **/
    where: EAChangelogAttributesWhereUniqueInput
  }


  /**
   * EAChangelogAttributes deleteMany
   */
  export type EAChangelogAttributesDeleteManyArgs = {
    where?: EAChangelogAttributesWhereInput
  }


  /**
   * EAChangelogAttributes without action
   */
  export type EAChangelogAttributesArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogAttributes
     * 
    **/
    select?: EAChangelogAttributesSelect | null
  }



  /**
   * Model EAChangelogs
   */


  export type AggregateEAChangelogs = {
    _count: EAChangelogsCountAggregateOutputType | null
    _avg: EAChangelogsAvgAggregateOutputType | null
    _sum: EAChangelogsSumAggregateOutputType | null
    _min: EAChangelogsMinAggregateOutputType | null
    _max: EAChangelogsMaxAggregateOutputType | null
  }

  export type EAChangelogsAvgAggregateOutputType = {
    Revision: number | null
  }

  export type EAChangelogsSumAggregateOutputType = {
    Revision: bigint | null
  }

  export type EAChangelogsMinAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    ArtifactGuid: string | null
    ArtifactType: string | null
    ActionType: string | null
    Revision: bigint | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type EAChangelogsMaxAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    ArtifactGuid: string | null
    ArtifactType: string | null
    ActionType: string | null
    Revision: bigint | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type EAChangelogsCountAggregateOutputType = {
    Id: number
    Repository_Id: number
    ArtifactGuid: number
    ArtifactType: number
    ActionType: number
    Revision: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type EAChangelogsAvgAggregateInputType = {
    Revision?: true
  }

  export type EAChangelogsSumAggregateInputType = {
    Revision?: true
  }

  export type EAChangelogsMinAggregateInputType = {
    Id?: true
    Repository_Id?: true
    ArtifactGuid?: true
    ArtifactType?: true
    ActionType?: true
    Revision?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type EAChangelogsMaxAggregateInputType = {
    Id?: true
    Repository_Id?: true
    ArtifactGuid?: true
    ArtifactType?: true
    ActionType?: true
    Revision?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type EAChangelogsCountAggregateInputType = {
    Id?: true
    Repository_Id?: true
    ArtifactGuid?: true
    ArtifactType?: true
    ActionType?: true
    Revision?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type EAChangelogsAggregateArgs = {
    /**
     * Filter which EAChangelogs to aggregate.
     * 
    **/
    where?: EAChangelogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAChangelogs to fetch.
     * 
    **/
    orderBy?: Enumerable<EAChangelogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EAChangelogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAChangelogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAChangelogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EAChangelogs
    **/
    _count?: true | EAChangelogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EAChangelogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EAChangelogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EAChangelogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EAChangelogsMaxAggregateInputType
  }

  export type GetEAChangelogsAggregateType<T extends EAChangelogsAggregateArgs> = {
        [P in keyof T & keyof AggregateEAChangelogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEAChangelogs[P]>
      : GetScalarType<T[P], AggregateEAChangelogs[P]>
  }




  export type EAChangelogsGroupByArgs = {
    where?: EAChangelogsWhereInput
    orderBy?: Enumerable<EAChangelogsOrderByWithAggregationInput>
    by: Array<EAChangelogsScalarFieldEnum>
    having?: EAChangelogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EAChangelogsCountAggregateInputType | true
    _avg?: EAChangelogsAvgAggregateInputType
    _sum?: EAChangelogsSumAggregateInputType
    _min?: EAChangelogsMinAggregateInputType
    _max?: EAChangelogsMaxAggregateInputType
  }


  export type EAChangelogsGroupByOutputType = {
    Id: string
    Repository_Id: string | null
    ArtifactGuid: string
    ArtifactType: string
    ActionType: string
    Revision: bigint | null
    CreatedDate: Date
    ModifiedDate: Date
    _count: EAChangelogsCountAggregateOutputType | null
    _avg: EAChangelogsAvgAggregateOutputType | null
    _sum: EAChangelogsSumAggregateOutputType | null
    _min: EAChangelogsMinAggregateOutputType | null
    _max: EAChangelogsMaxAggregateOutputType | null
  }

  type GetEAChangelogsGroupByPayload<T extends EAChangelogsGroupByArgs> = Promise<
    Array<
      PickArray<EAChangelogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EAChangelogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EAChangelogsGroupByOutputType[P]>
            : GetScalarType<T[P], EAChangelogsGroupByOutputType[P]>
        }
      >
    >


  export type EAChangelogsSelect = {
    Id?: boolean
    Repository_Id?: boolean
    ArtifactGuid?: boolean
    ArtifactType?: boolean
    ActionType?: boolean
    Revision?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type EAChangelogsGetPayload<
    S extends boolean | null | undefined | EAChangelogsArgs,
    U = keyof S
      > = S extends true
        ? EAChangelogs
    : S extends undefined
    ? never
    : S extends EAChangelogsArgs | EAChangelogsFindManyArgs
    ?'include' extends U
    ? EAChangelogs 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof EAChangelogs ?EAChangelogs [P]
  : 
     never
  } 
    : EAChangelogs
  : EAChangelogs


  type EAChangelogsCountArgs = Merge<
    Omit<EAChangelogsFindManyArgs, 'select' | 'include'> & {
      select?: EAChangelogsCountAggregateInputType | true
    }
  >

  export interface EAChangelogsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one EAChangelogs that matches the filter.
     * @param {EAChangelogsFindUniqueArgs} args - Arguments to find a EAChangelogs
     * @example
     * // Get one EAChangelogs
     * const eAChangelogs = await prisma.eAChangelogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EAChangelogsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EAChangelogsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EAChangelogs'> extends True ? CheckSelect<T, Prisma__EAChangelogsClient<EAChangelogs>, Prisma__EAChangelogsClient<EAChangelogsGetPayload<T>>> : CheckSelect<T, Prisma__EAChangelogsClient<EAChangelogs | null >, Prisma__EAChangelogsClient<EAChangelogsGetPayload<T> | null >>

    /**
     * Find the first EAChangelogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAChangelogsFindFirstArgs} args - Arguments to find a EAChangelogs
     * @example
     * // Get one EAChangelogs
     * const eAChangelogs = await prisma.eAChangelogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EAChangelogsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EAChangelogsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EAChangelogs'> extends True ? CheckSelect<T, Prisma__EAChangelogsClient<EAChangelogs>, Prisma__EAChangelogsClient<EAChangelogsGetPayload<T>>> : CheckSelect<T, Prisma__EAChangelogsClient<EAChangelogs | null >, Prisma__EAChangelogsClient<EAChangelogsGetPayload<T> | null >>

    /**
     * Find zero or more EAChangelogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAChangelogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EAChangelogs
     * const eAChangelogs = await prisma.eAChangelogs.findMany()
     * 
     * // Get first 10 EAChangelogs
     * const eAChangelogs = await prisma.eAChangelogs.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const eAChangelogsWithIdOnly = await prisma.eAChangelogs.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends EAChangelogsFindManyArgs>(
      args?: SelectSubset<T, EAChangelogsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<EAChangelogs>>, PrismaPromise<Array<EAChangelogsGetPayload<T>>>>

    /**
     * Create a EAChangelogs.
     * @param {EAChangelogsCreateArgs} args - Arguments to create a EAChangelogs.
     * @example
     * // Create one EAChangelogs
     * const EAChangelogs = await prisma.eAChangelogs.create({
     *   data: {
     *     // ... data to create a EAChangelogs
     *   }
     * })
     * 
    **/
    create<T extends EAChangelogsCreateArgs>(
      args: SelectSubset<T, EAChangelogsCreateArgs>
    ): CheckSelect<T, Prisma__EAChangelogsClient<EAChangelogs>, Prisma__EAChangelogsClient<EAChangelogsGetPayload<T>>>

    /**
     * Create many EAChangelogs.
     *     @param {EAChangelogsCreateManyArgs} args - Arguments to create many EAChangelogs.
     *     @example
     *     // Create many EAChangelogs
     *     const eAChangelogs = await prisma.eAChangelogs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EAChangelogsCreateManyArgs>(
      args?: SelectSubset<T, EAChangelogsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EAChangelogs.
     * @param {EAChangelogsDeleteArgs} args - Arguments to delete one EAChangelogs.
     * @example
     * // Delete one EAChangelogs
     * const EAChangelogs = await prisma.eAChangelogs.delete({
     *   where: {
     *     // ... filter to delete one EAChangelogs
     *   }
     * })
     * 
    **/
    delete<T extends EAChangelogsDeleteArgs>(
      args: SelectSubset<T, EAChangelogsDeleteArgs>
    ): CheckSelect<T, Prisma__EAChangelogsClient<EAChangelogs>, Prisma__EAChangelogsClient<EAChangelogsGetPayload<T>>>

    /**
     * Update one EAChangelogs.
     * @param {EAChangelogsUpdateArgs} args - Arguments to update one EAChangelogs.
     * @example
     * // Update one EAChangelogs
     * const eAChangelogs = await prisma.eAChangelogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EAChangelogsUpdateArgs>(
      args: SelectSubset<T, EAChangelogsUpdateArgs>
    ): CheckSelect<T, Prisma__EAChangelogsClient<EAChangelogs>, Prisma__EAChangelogsClient<EAChangelogsGetPayload<T>>>

    /**
     * Delete zero or more EAChangelogs.
     * @param {EAChangelogsDeleteManyArgs} args - Arguments to filter EAChangelogs to delete.
     * @example
     * // Delete a few EAChangelogs
     * const { count } = await prisma.eAChangelogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EAChangelogsDeleteManyArgs>(
      args?: SelectSubset<T, EAChangelogsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EAChangelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAChangelogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EAChangelogs
     * const eAChangelogs = await prisma.eAChangelogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EAChangelogsUpdateManyArgs>(
      args: SelectSubset<T, EAChangelogsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EAChangelogs.
     * @param {EAChangelogsUpsertArgs} args - Arguments to update or create a EAChangelogs.
     * @example
     * // Update or create a EAChangelogs
     * const eAChangelogs = await prisma.eAChangelogs.upsert({
     *   create: {
     *     // ... data to create a EAChangelogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EAChangelogs we want to update
     *   }
     * })
    **/
    upsert<T extends EAChangelogsUpsertArgs>(
      args: SelectSubset<T, EAChangelogsUpsertArgs>
    ): CheckSelect<T, Prisma__EAChangelogsClient<EAChangelogs>, Prisma__EAChangelogsClient<EAChangelogsGetPayload<T>>>

    /**
     * Count the number of EAChangelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAChangelogsCountArgs} args - Arguments to filter EAChangelogs to count.
     * @example
     * // Count the number of EAChangelogs
     * const count = await prisma.eAChangelogs.count({
     *   where: {
     *     // ... the filter for the EAChangelogs we want to count
     *   }
     * })
    **/
    count<T extends EAChangelogsCountArgs>(
      args?: Subset<T, EAChangelogsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EAChangelogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EAChangelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAChangelogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EAChangelogsAggregateArgs>(args: Subset<T, EAChangelogsAggregateArgs>): PrismaPromise<GetEAChangelogsAggregateType<T>>

    /**
     * Group by EAChangelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAChangelogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EAChangelogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EAChangelogsGroupByArgs['orderBy'] }
        : { orderBy?: EAChangelogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EAChangelogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEAChangelogsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for EAChangelogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EAChangelogsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * EAChangelogs findUnique
   */
  export type EAChangelogsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogs
     * 
    **/
    select?: EAChangelogsSelect | null
    /**
     * Throw an Error if a EAChangelogs can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EAChangelogs to fetch.
     * 
    **/
    where: EAChangelogsWhereUniqueInput
  }


  /**
   * EAChangelogs findFirst
   */
  export type EAChangelogsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogs
     * 
    **/
    select?: EAChangelogsSelect | null
    /**
     * Throw an Error if a EAChangelogs can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EAChangelogs to fetch.
     * 
    **/
    where?: EAChangelogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAChangelogs to fetch.
     * 
    **/
    orderBy?: Enumerable<EAChangelogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EAChangelogs.
     * 
    **/
    cursor?: EAChangelogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAChangelogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAChangelogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EAChangelogs.
     * 
    **/
    distinct?: Enumerable<EAChangelogsScalarFieldEnum>
  }


  /**
   * EAChangelogs findMany
   */
  export type EAChangelogsFindManyArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogs
     * 
    **/
    select?: EAChangelogsSelect | null
    /**
     * Filter, which EAChangelogs to fetch.
     * 
    **/
    where?: EAChangelogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAChangelogs to fetch.
     * 
    **/
    orderBy?: Enumerable<EAChangelogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EAChangelogs.
     * 
    **/
    cursor?: EAChangelogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAChangelogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAChangelogs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EAChangelogsScalarFieldEnum>
  }


  /**
   * EAChangelogs create
   */
  export type EAChangelogsCreateArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogs
     * 
    **/
    select?: EAChangelogsSelect | null
    /**
     * The data needed to create a EAChangelogs.
     * 
    **/
    data: XOR<EAChangelogsCreateInput, EAChangelogsUncheckedCreateInput>
  }


  /**
   * EAChangelogs createMany
   */
  export type EAChangelogsCreateManyArgs = {
    data: Enumerable<EAChangelogsCreateManyInput>
  }


  /**
   * EAChangelogs update
   */
  export type EAChangelogsUpdateArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogs
     * 
    **/
    select?: EAChangelogsSelect | null
    /**
     * The data needed to update a EAChangelogs.
     * 
    **/
    data: XOR<EAChangelogsUpdateInput, EAChangelogsUncheckedUpdateInput>
    /**
     * Choose, which EAChangelogs to update.
     * 
    **/
    where: EAChangelogsWhereUniqueInput
  }


  /**
   * EAChangelogs updateMany
   */
  export type EAChangelogsUpdateManyArgs = {
    data: XOR<EAChangelogsUpdateManyMutationInput, EAChangelogsUncheckedUpdateManyInput>
    where?: EAChangelogsWhereInput
  }


  /**
   * EAChangelogs upsert
   */
  export type EAChangelogsUpsertArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogs
     * 
    **/
    select?: EAChangelogsSelect | null
    /**
     * The filter to search for the EAChangelogs to update in case it exists.
     * 
    **/
    where: EAChangelogsWhereUniqueInput
    /**
     * In case the EAChangelogs found by the `where` argument doesn't exist, create a new EAChangelogs with this data.
     * 
    **/
    create: XOR<EAChangelogsCreateInput, EAChangelogsUncheckedCreateInput>
    /**
     * In case the EAChangelogs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EAChangelogsUpdateInput, EAChangelogsUncheckedUpdateInput>
  }


  /**
   * EAChangelogs delete
   */
  export type EAChangelogsDeleteArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogs
     * 
    **/
    select?: EAChangelogsSelect | null
    /**
     * Filter which EAChangelogs to delete.
     * 
    **/
    where: EAChangelogsWhereUniqueInput
  }


  /**
   * EAChangelogs deleteMany
   */
  export type EAChangelogsDeleteManyArgs = {
    where?: EAChangelogsWhereInput
  }


  /**
   * EAChangelogs without action
   */
  export type EAChangelogsArgs = {
    /**
     * Select specific fields to fetch from the EAChangelogs
     * 
    **/
    select?: EAChangelogsSelect | null
  }



  /**
   * Model ElementConnectors
   */


  export type AggregateElementConnectors = {
    _count: ElementConnectorsCountAggregateOutputType | null
    _avg: ElementConnectorsAvgAggregateOutputType | null
    _sum: ElementConnectorsSumAggregateOutputType | null
    _min: ElementConnectorsMinAggregateOutputType | null
    _max: ElementConnectorsMaxAggregateOutputType | null
  }

  export type ElementConnectorsAvgAggregateOutputType = {
    InheritRight: number | null
  }

  export type ElementConnectorsSumAggregateOutputType = {
    InheritRight: number | null
  }

  export type ElementConnectorsMinAggregateOutputType = {
    Id: string | null
    ElementGuid: string | null
    ElementType: string | null
    Repository_Id: string | null
    User_Id: string | null
    UserGroup_Id: string | null
    AccessRight_AccessRightKey: string | null
    InheritRight: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
    CreatedBy: string | null
    FeatureId: string | null
    OtherInfo: string | null
  }

  export type ElementConnectorsMaxAggregateOutputType = {
    Id: string | null
    ElementGuid: string | null
    ElementType: string | null
    Repository_Id: string | null
    User_Id: string | null
    UserGroup_Id: string | null
    AccessRight_AccessRightKey: string | null
    InheritRight: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
    CreatedBy: string | null
    FeatureId: string | null
    OtherInfo: string | null
  }

  export type ElementConnectorsCountAggregateOutputType = {
    Id: number
    ElementGuid: number
    ElementType: number
    Repository_Id: number
    User_Id: number
    UserGroup_Id: number
    AccessRight_AccessRightKey: number
    InheritRight: number
    CreatedDate: number
    ModifiedDate: number
    Status: number
    CreatedBy: number
    FeatureId: number
    OtherInfo: number
    _all: number
  }


  export type ElementConnectorsAvgAggregateInputType = {
    InheritRight?: true
  }

  export type ElementConnectorsSumAggregateInputType = {
    InheritRight?: true
  }

  export type ElementConnectorsMinAggregateInputType = {
    Id?: true
    ElementGuid?: true
    ElementType?: true
    Repository_Id?: true
    User_Id?: true
    UserGroup_Id?: true
    AccessRight_AccessRightKey?: true
    InheritRight?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
    CreatedBy?: true
    FeatureId?: true
    OtherInfo?: true
  }

  export type ElementConnectorsMaxAggregateInputType = {
    Id?: true
    ElementGuid?: true
    ElementType?: true
    Repository_Id?: true
    User_Id?: true
    UserGroup_Id?: true
    AccessRight_AccessRightKey?: true
    InheritRight?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
    CreatedBy?: true
    FeatureId?: true
    OtherInfo?: true
  }

  export type ElementConnectorsCountAggregateInputType = {
    Id?: true
    ElementGuid?: true
    ElementType?: true
    Repository_Id?: true
    User_Id?: true
    UserGroup_Id?: true
    AccessRight_AccessRightKey?: true
    InheritRight?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
    CreatedBy?: true
    FeatureId?: true
    OtherInfo?: true
    _all?: true
  }

  export type ElementConnectorsAggregateArgs = {
    /**
     * Filter which ElementConnectors to aggregate.
     * 
    **/
    where?: ElementConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElementConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<ElementConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ElementConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElementConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElementConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ElementConnectors
    **/
    _count?: true | ElementConnectorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ElementConnectorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ElementConnectorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElementConnectorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElementConnectorsMaxAggregateInputType
  }

  export type GetElementConnectorsAggregateType<T extends ElementConnectorsAggregateArgs> = {
        [P in keyof T & keyof AggregateElementConnectors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElementConnectors[P]>
      : GetScalarType<T[P], AggregateElementConnectors[P]>
  }




  export type ElementConnectorsGroupByArgs = {
    where?: ElementConnectorsWhereInput
    orderBy?: Enumerable<ElementConnectorsOrderByWithAggregationInput>
    by: Array<ElementConnectorsScalarFieldEnum>
    having?: ElementConnectorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElementConnectorsCountAggregateInputType | true
    _avg?: ElementConnectorsAvgAggregateInputType
    _sum?: ElementConnectorsSumAggregateInputType
    _min?: ElementConnectorsMinAggregateInputType
    _max?: ElementConnectorsMaxAggregateInputType
  }


  export type ElementConnectorsGroupByOutputType = {
    Id: string
    ElementGuid: string | null
    ElementType: string | null
    Repository_Id: string | null
    User_Id: string | null
    UserGroup_Id: string | null
    AccessRight_AccessRightKey: string | null
    InheritRight: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
    CreatedBy: string | null
    FeatureId: string | null
    OtherInfo: string | null
    _count: ElementConnectorsCountAggregateOutputType | null
    _avg: ElementConnectorsAvgAggregateOutputType | null
    _sum: ElementConnectorsSumAggregateOutputType | null
    _min: ElementConnectorsMinAggregateOutputType | null
    _max: ElementConnectorsMaxAggregateOutputType | null
  }

  type GetElementConnectorsGroupByPayload<T extends ElementConnectorsGroupByArgs> = Promise<
    Array<
      PickArray<ElementConnectorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElementConnectorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElementConnectorsGroupByOutputType[P]>
            : GetScalarType<T[P], ElementConnectorsGroupByOutputType[P]>
        }
      >
    >


  export type ElementConnectorsSelect = {
    Id?: boolean
    ElementGuid?: boolean
    ElementType?: boolean
    Repository_Id?: boolean
    User_Id?: boolean
    UserGroup_Id?: boolean
    AccessRight_AccessRightKey?: boolean
    InheritRight?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
    Status?: boolean
    CreatedBy?: boolean
    FeatureId?: boolean
    OtherInfo?: boolean
  }

  export type ElementConnectorsGetPayload<
    S extends boolean | null | undefined | ElementConnectorsArgs,
    U = keyof S
      > = S extends true
        ? ElementConnectors
    : S extends undefined
    ? never
    : S extends ElementConnectorsArgs | ElementConnectorsFindManyArgs
    ?'include' extends U
    ? ElementConnectors 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ElementConnectors ?ElementConnectors [P]
  : 
     never
  } 
    : ElementConnectors
  : ElementConnectors


  type ElementConnectorsCountArgs = Merge<
    Omit<ElementConnectorsFindManyArgs, 'select' | 'include'> & {
      select?: ElementConnectorsCountAggregateInputType | true
    }
  >

  export interface ElementConnectorsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ElementConnectors that matches the filter.
     * @param {ElementConnectorsFindUniqueArgs} args - Arguments to find a ElementConnectors
     * @example
     * // Get one ElementConnectors
     * const elementConnectors = await prisma.elementConnectors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ElementConnectorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ElementConnectorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ElementConnectors'> extends True ? CheckSelect<T, Prisma__ElementConnectorsClient<ElementConnectors>, Prisma__ElementConnectorsClient<ElementConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__ElementConnectorsClient<ElementConnectors | null >, Prisma__ElementConnectorsClient<ElementConnectorsGetPayload<T> | null >>

    /**
     * Find the first ElementConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementConnectorsFindFirstArgs} args - Arguments to find a ElementConnectors
     * @example
     * // Get one ElementConnectors
     * const elementConnectors = await prisma.elementConnectors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ElementConnectorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ElementConnectorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ElementConnectors'> extends True ? CheckSelect<T, Prisma__ElementConnectorsClient<ElementConnectors>, Prisma__ElementConnectorsClient<ElementConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__ElementConnectorsClient<ElementConnectors | null >, Prisma__ElementConnectorsClient<ElementConnectorsGetPayload<T> | null >>

    /**
     * Find zero or more ElementConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementConnectorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ElementConnectors
     * const elementConnectors = await prisma.elementConnectors.findMany()
     * 
     * // Get first 10 ElementConnectors
     * const elementConnectors = await prisma.elementConnectors.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const elementConnectorsWithIdOnly = await prisma.elementConnectors.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ElementConnectorsFindManyArgs>(
      args?: SelectSubset<T, ElementConnectorsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ElementConnectors>>, PrismaPromise<Array<ElementConnectorsGetPayload<T>>>>

    /**
     * Create a ElementConnectors.
     * @param {ElementConnectorsCreateArgs} args - Arguments to create a ElementConnectors.
     * @example
     * // Create one ElementConnectors
     * const ElementConnectors = await prisma.elementConnectors.create({
     *   data: {
     *     // ... data to create a ElementConnectors
     *   }
     * })
     * 
    **/
    create<T extends ElementConnectorsCreateArgs>(
      args: SelectSubset<T, ElementConnectorsCreateArgs>
    ): CheckSelect<T, Prisma__ElementConnectorsClient<ElementConnectors>, Prisma__ElementConnectorsClient<ElementConnectorsGetPayload<T>>>

    /**
     * Create many ElementConnectors.
     *     @param {ElementConnectorsCreateManyArgs} args - Arguments to create many ElementConnectors.
     *     @example
     *     // Create many ElementConnectors
     *     const elementConnectors = await prisma.elementConnectors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ElementConnectorsCreateManyArgs>(
      args?: SelectSubset<T, ElementConnectorsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ElementConnectors.
     * @param {ElementConnectorsDeleteArgs} args - Arguments to delete one ElementConnectors.
     * @example
     * // Delete one ElementConnectors
     * const ElementConnectors = await prisma.elementConnectors.delete({
     *   where: {
     *     // ... filter to delete one ElementConnectors
     *   }
     * })
     * 
    **/
    delete<T extends ElementConnectorsDeleteArgs>(
      args: SelectSubset<T, ElementConnectorsDeleteArgs>
    ): CheckSelect<T, Prisma__ElementConnectorsClient<ElementConnectors>, Prisma__ElementConnectorsClient<ElementConnectorsGetPayload<T>>>

    /**
     * Update one ElementConnectors.
     * @param {ElementConnectorsUpdateArgs} args - Arguments to update one ElementConnectors.
     * @example
     * // Update one ElementConnectors
     * const elementConnectors = await prisma.elementConnectors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ElementConnectorsUpdateArgs>(
      args: SelectSubset<T, ElementConnectorsUpdateArgs>
    ): CheckSelect<T, Prisma__ElementConnectorsClient<ElementConnectors>, Prisma__ElementConnectorsClient<ElementConnectorsGetPayload<T>>>

    /**
     * Delete zero or more ElementConnectors.
     * @param {ElementConnectorsDeleteManyArgs} args - Arguments to filter ElementConnectors to delete.
     * @example
     * // Delete a few ElementConnectors
     * const { count } = await prisma.elementConnectors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ElementConnectorsDeleteManyArgs>(
      args?: SelectSubset<T, ElementConnectorsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElementConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementConnectorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ElementConnectors
     * const elementConnectors = await prisma.elementConnectors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ElementConnectorsUpdateManyArgs>(
      args: SelectSubset<T, ElementConnectorsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ElementConnectors.
     * @param {ElementConnectorsUpsertArgs} args - Arguments to update or create a ElementConnectors.
     * @example
     * // Update or create a ElementConnectors
     * const elementConnectors = await prisma.elementConnectors.upsert({
     *   create: {
     *     // ... data to create a ElementConnectors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ElementConnectors we want to update
     *   }
     * })
    **/
    upsert<T extends ElementConnectorsUpsertArgs>(
      args: SelectSubset<T, ElementConnectorsUpsertArgs>
    ): CheckSelect<T, Prisma__ElementConnectorsClient<ElementConnectors>, Prisma__ElementConnectorsClient<ElementConnectorsGetPayload<T>>>

    /**
     * Count the number of ElementConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementConnectorsCountArgs} args - Arguments to filter ElementConnectors to count.
     * @example
     * // Count the number of ElementConnectors
     * const count = await prisma.elementConnectors.count({
     *   where: {
     *     // ... the filter for the ElementConnectors we want to count
     *   }
     * })
    **/
    count<T extends ElementConnectorsCountArgs>(
      args?: Subset<T, ElementConnectorsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElementConnectorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ElementConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementConnectorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElementConnectorsAggregateArgs>(args: Subset<T, ElementConnectorsAggregateArgs>): PrismaPromise<GetElementConnectorsAggregateType<T>>

    /**
     * Group by ElementConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementConnectorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElementConnectorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElementConnectorsGroupByArgs['orderBy'] }
        : { orderBy?: ElementConnectorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElementConnectorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElementConnectorsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ElementConnectors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ElementConnectorsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ElementConnectors findUnique
   */
  export type ElementConnectorsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ElementConnectors
     * 
    **/
    select?: ElementConnectorsSelect | null
    /**
     * Throw an Error if a ElementConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ElementConnectors to fetch.
     * 
    **/
    where: ElementConnectorsWhereUniqueInput
  }


  /**
   * ElementConnectors findFirst
   */
  export type ElementConnectorsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ElementConnectors
     * 
    **/
    select?: ElementConnectorsSelect | null
    /**
     * Throw an Error if a ElementConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ElementConnectors to fetch.
     * 
    **/
    where?: ElementConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElementConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<ElementConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElementConnectors.
     * 
    **/
    cursor?: ElementConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElementConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElementConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElementConnectors.
     * 
    **/
    distinct?: Enumerable<ElementConnectorsScalarFieldEnum>
  }


  /**
   * ElementConnectors findMany
   */
  export type ElementConnectorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ElementConnectors
     * 
    **/
    select?: ElementConnectorsSelect | null
    /**
     * Filter, which ElementConnectors to fetch.
     * 
    **/
    where?: ElementConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElementConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<ElementConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ElementConnectors.
     * 
    **/
    cursor?: ElementConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElementConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElementConnectors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ElementConnectorsScalarFieldEnum>
  }


  /**
   * ElementConnectors create
   */
  export type ElementConnectorsCreateArgs = {
    /**
     * Select specific fields to fetch from the ElementConnectors
     * 
    **/
    select?: ElementConnectorsSelect | null
    /**
     * The data needed to create a ElementConnectors.
     * 
    **/
    data: XOR<ElementConnectorsCreateInput, ElementConnectorsUncheckedCreateInput>
  }


  /**
   * ElementConnectors createMany
   */
  export type ElementConnectorsCreateManyArgs = {
    data: Enumerable<ElementConnectorsCreateManyInput>
  }


  /**
   * ElementConnectors update
   */
  export type ElementConnectorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ElementConnectors
     * 
    **/
    select?: ElementConnectorsSelect | null
    /**
     * The data needed to update a ElementConnectors.
     * 
    **/
    data: XOR<ElementConnectorsUpdateInput, ElementConnectorsUncheckedUpdateInput>
    /**
     * Choose, which ElementConnectors to update.
     * 
    **/
    where: ElementConnectorsWhereUniqueInput
  }


  /**
   * ElementConnectors updateMany
   */
  export type ElementConnectorsUpdateManyArgs = {
    data: XOR<ElementConnectorsUpdateManyMutationInput, ElementConnectorsUncheckedUpdateManyInput>
    where?: ElementConnectorsWhereInput
  }


  /**
   * ElementConnectors upsert
   */
  export type ElementConnectorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ElementConnectors
     * 
    **/
    select?: ElementConnectorsSelect | null
    /**
     * The filter to search for the ElementConnectors to update in case it exists.
     * 
    **/
    where: ElementConnectorsWhereUniqueInput
    /**
     * In case the ElementConnectors found by the `where` argument doesn't exist, create a new ElementConnectors with this data.
     * 
    **/
    create: XOR<ElementConnectorsCreateInput, ElementConnectorsUncheckedCreateInput>
    /**
     * In case the ElementConnectors was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ElementConnectorsUpdateInput, ElementConnectorsUncheckedUpdateInput>
  }


  /**
   * ElementConnectors delete
   */
  export type ElementConnectorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ElementConnectors
     * 
    **/
    select?: ElementConnectorsSelect | null
    /**
     * Filter which ElementConnectors to delete.
     * 
    **/
    where: ElementConnectorsWhereUniqueInput
  }


  /**
   * ElementConnectors deleteMany
   */
  export type ElementConnectorsDeleteManyArgs = {
    where?: ElementConnectorsWhereInput
  }


  /**
   * ElementConnectors without action
   */
  export type ElementConnectorsArgs = {
    /**
     * Select specific fields to fetch from the ElementConnectors
     * 
    **/
    select?: ElementConnectorsSelect | null
  }



  /**
   * Model ExternalAppAttributeMaster
   */


  export type AggregateExternalAppAttributeMaster = {
    _count: ExternalAppAttributeMasterCountAggregateOutputType | null
    _avg: ExternalAppAttributeMasterAvgAggregateOutputType | null
    _sum: ExternalAppAttributeMasterSumAggregateOutputType | null
    _min: ExternalAppAttributeMasterMinAggregateOutputType | null
    _max: ExternalAppAttributeMasterMaxAggregateOutputType | null
  }

  export type ExternalAppAttributeMasterAvgAggregateOutputType = {
    MultiSelect: number | null
    IsEnabled: number | null
  }

  export type ExternalAppAttributeMasterSumAggregateOutputType = {
    MultiSelect: number | null
    IsEnabled: number | null
  }

  export type ExternalAppAttributeMasterMinAggregateOutputType = {
    Id: string | null
    ExternalAppTypeId: string | null
    ExternalAppId: string | null
    RepositoryId: string | null
    Name: string | null
    InternalName: string | null
    ExternalName: string | null
    HelpText: string | null
    MultiSelect: number | null
    Filters: string | null
    ConfigData: string | null
    IsEnabled: number | null
    Created: Date | null
    Modified: Date | null
    Description: string | null
  }

  export type ExternalAppAttributeMasterMaxAggregateOutputType = {
    Id: string | null
    ExternalAppTypeId: string | null
    ExternalAppId: string | null
    RepositoryId: string | null
    Name: string | null
    InternalName: string | null
    ExternalName: string | null
    HelpText: string | null
    MultiSelect: number | null
    Filters: string | null
    ConfigData: string | null
    IsEnabled: number | null
    Created: Date | null
    Modified: Date | null
    Description: string | null
  }

  export type ExternalAppAttributeMasterCountAggregateOutputType = {
    Id: number
    ExternalAppTypeId: number
    ExternalAppId: number
    RepositoryId: number
    Name: number
    InternalName: number
    ExternalName: number
    HelpText: number
    MultiSelect: number
    Filters: number
    ConfigData: number
    IsEnabled: number
    Created: number
    Modified: number
    Description: number
    _all: number
  }


  export type ExternalAppAttributeMasterAvgAggregateInputType = {
    MultiSelect?: true
    IsEnabled?: true
  }

  export type ExternalAppAttributeMasterSumAggregateInputType = {
    MultiSelect?: true
    IsEnabled?: true
  }

  export type ExternalAppAttributeMasterMinAggregateInputType = {
    Id?: true
    ExternalAppTypeId?: true
    ExternalAppId?: true
    RepositoryId?: true
    Name?: true
    InternalName?: true
    ExternalName?: true
    HelpText?: true
    MultiSelect?: true
    Filters?: true
    ConfigData?: true
    IsEnabled?: true
    Created?: true
    Modified?: true
    Description?: true
  }

  export type ExternalAppAttributeMasterMaxAggregateInputType = {
    Id?: true
    ExternalAppTypeId?: true
    ExternalAppId?: true
    RepositoryId?: true
    Name?: true
    InternalName?: true
    ExternalName?: true
    HelpText?: true
    MultiSelect?: true
    Filters?: true
    ConfigData?: true
    IsEnabled?: true
    Created?: true
    Modified?: true
    Description?: true
  }

  export type ExternalAppAttributeMasterCountAggregateInputType = {
    Id?: true
    ExternalAppTypeId?: true
    ExternalAppId?: true
    RepositoryId?: true
    Name?: true
    InternalName?: true
    ExternalName?: true
    HelpText?: true
    MultiSelect?: true
    Filters?: true
    ConfigData?: true
    IsEnabled?: true
    Created?: true
    Modified?: true
    Description?: true
    _all?: true
  }

  export type ExternalAppAttributeMasterAggregateArgs = {
    /**
     * Filter which ExternalAppAttributeMaster to aggregate.
     * 
    **/
    where?: ExternalAppAttributeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAppAttributeMasters to fetch.
     * 
    **/
    orderBy?: Enumerable<ExternalAppAttributeMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ExternalAppAttributeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAppAttributeMasters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAppAttributeMasters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalAppAttributeMasters
    **/
    _count?: true | ExternalAppAttributeMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExternalAppAttributeMasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExternalAppAttributeMasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalAppAttributeMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalAppAttributeMasterMaxAggregateInputType
  }

  export type GetExternalAppAttributeMasterAggregateType<T extends ExternalAppAttributeMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalAppAttributeMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalAppAttributeMaster[P]>
      : GetScalarType<T[P], AggregateExternalAppAttributeMaster[P]>
  }




  export type ExternalAppAttributeMasterGroupByArgs = {
    where?: ExternalAppAttributeMasterWhereInput
    orderBy?: Enumerable<ExternalAppAttributeMasterOrderByWithAggregationInput>
    by: Array<ExternalAppAttributeMasterScalarFieldEnum>
    having?: ExternalAppAttributeMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalAppAttributeMasterCountAggregateInputType | true
    _avg?: ExternalAppAttributeMasterAvgAggregateInputType
    _sum?: ExternalAppAttributeMasterSumAggregateInputType
    _min?: ExternalAppAttributeMasterMinAggregateInputType
    _max?: ExternalAppAttributeMasterMaxAggregateInputType
  }


  export type ExternalAppAttributeMasterGroupByOutputType = {
    Id: string
    ExternalAppTypeId: string
    ExternalAppId: string
    RepositoryId: string
    Name: string
    InternalName: string
    ExternalName: string
    HelpText: string | null
    MultiSelect: number
    Filters: string | null
    ConfigData: string | null
    IsEnabled: number
    Created: Date
    Modified: Date
    Description: string | null
    _count: ExternalAppAttributeMasterCountAggregateOutputType | null
    _avg: ExternalAppAttributeMasterAvgAggregateOutputType | null
    _sum: ExternalAppAttributeMasterSumAggregateOutputType | null
    _min: ExternalAppAttributeMasterMinAggregateOutputType | null
    _max: ExternalAppAttributeMasterMaxAggregateOutputType | null
  }

  type GetExternalAppAttributeMasterGroupByPayload<T extends ExternalAppAttributeMasterGroupByArgs> = Promise<
    Array<
      PickArray<ExternalAppAttributeMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalAppAttributeMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalAppAttributeMasterGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalAppAttributeMasterGroupByOutputType[P]>
        }
      >
    >


  export type ExternalAppAttributeMasterSelect = {
    Id?: boolean
    ExternalAppTypeId?: boolean
    ExternalAppId?: boolean
    RepositoryId?: boolean
    Name?: boolean
    InternalName?: boolean
    ExternalName?: boolean
    HelpText?: boolean
    MultiSelect?: boolean
    Filters?: boolean
    ConfigData?: boolean
    IsEnabled?: boolean
    Created?: boolean
    Modified?: boolean
    Description?: boolean
  }

  export type ExternalAppAttributeMasterGetPayload<
    S extends boolean | null | undefined | ExternalAppAttributeMasterArgs,
    U = keyof S
      > = S extends true
        ? ExternalAppAttributeMaster
    : S extends undefined
    ? never
    : S extends ExternalAppAttributeMasterArgs | ExternalAppAttributeMasterFindManyArgs
    ?'include' extends U
    ? ExternalAppAttributeMaster 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ExternalAppAttributeMaster ?ExternalAppAttributeMaster [P]
  : 
     never
  } 
    : ExternalAppAttributeMaster
  : ExternalAppAttributeMaster


  type ExternalAppAttributeMasterCountArgs = Merge<
    Omit<ExternalAppAttributeMasterFindManyArgs, 'select' | 'include'> & {
      select?: ExternalAppAttributeMasterCountAggregateInputType | true
    }
  >

  export interface ExternalAppAttributeMasterDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ExternalAppAttributeMaster that matches the filter.
     * @param {ExternalAppAttributeMasterFindUniqueArgs} args - Arguments to find a ExternalAppAttributeMaster
     * @example
     * // Get one ExternalAppAttributeMaster
     * const externalAppAttributeMaster = await prisma.externalAppAttributeMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExternalAppAttributeMasterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExternalAppAttributeMasterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ExternalAppAttributeMaster'> extends True ? CheckSelect<T, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMaster>, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMasterGetPayload<T>>> : CheckSelect<T, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMaster | null >, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMasterGetPayload<T> | null >>

    /**
     * Find the first ExternalAppAttributeMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppAttributeMasterFindFirstArgs} args - Arguments to find a ExternalAppAttributeMaster
     * @example
     * // Get one ExternalAppAttributeMaster
     * const externalAppAttributeMaster = await prisma.externalAppAttributeMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExternalAppAttributeMasterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExternalAppAttributeMasterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ExternalAppAttributeMaster'> extends True ? CheckSelect<T, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMaster>, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMasterGetPayload<T>>> : CheckSelect<T, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMaster | null >, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMasterGetPayload<T> | null >>

    /**
     * Find zero or more ExternalAppAttributeMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppAttributeMasterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalAppAttributeMasters
     * const externalAppAttributeMasters = await prisma.externalAppAttributeMaster.findMany()
     * 
     * // Get first 10 ExternalAppAttributeMasters
     * const externalAppAttributeMasters = await prisma.externalAppAttributeMaster.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const externalAppAttributeMasterWithIdOnly = await prisma.externalAppAttributeMaster.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ExternalAppAttributeMasterFindManyArgs>(
      args?: SelectSubset<T, ExternalAppAttributeMasterFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ExternalAppAttributeMaster>>, PrismaPromise<Array<ExternalAppAttributeMasterGetPayload<T>>>>

    /**
     * Create a ExternalAppAttributeMaster.
     * @param {ExternalAppAttributeMasterCreateArgs} args - Arguments to create a ExternalAppAttributeMaster.
     * @example
     * // Create one ExternalAppAttributeMaster
     * const ExternalAppAttributeMaster = await prisma.externalAppAttributeMaster.create({
     *   data: {
     *     // ... data to create a ExternalAppAttributeMaster
     *   }
     * })
     * 
    **/
    create<T extends ExternalAppAttributeMasterCreateArgs>(
      args: SelectSubset<T, ExternalAppAttributeMasterCreateArgs>
    ): CheckSelect<T, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMaster>, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMasterGetPayload<T>>>

    /**
     * Create many ExternalAppAttributeMasters.
     *     @param {ExternalAppAttributeMasterCreateManyArgs} args - Arguments to create many ExternalAppAttributeMasters.
     *     @example
     *     // Create many ExternalAppAttributeMasters
     *     const externalAppAttributeMaster = await prisma.externalAppAttributeMaster.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExternalAppAttributeMasterCreateManyArgs>(
      args?: SelectSubset<T, ExternalAppAttributeMasterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExternalAppAttributeMaster.
     * @param {ExternalAppAttributeMasterDeleteArgs} args - Arguments to delete one ExternalAppAttributeMaster.
     * @example
     * // Delete one ExternalAppAttributeMaster
     * const ExternalAppAttributeMaster = await prisma.externalAppAttributeMaster.delete({
     *   where: {
     *     // ... filter to delete one ExternalAppAttributeMaster
     *   }
     * })
     * 
    **/
    delete<T extends ExternalAppAttributeMasterDeleteArgs>(
      args: SelectSubset<T, ExternalAppAttributeMasterDeleteArgs>
    ): CheckSelect<T, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMaster>, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMasterGetPayload<T>>>

    /**
     * Update one ExternalAppAttributeMaster.
     * @param {ExternalAppAttributeMasterUpdateArgs} args - Arguments to update one ExternalAppAttributeMaster.
     * @example
     * // Update one ExternalAppAttributeMaster
     * const externalAppAttributeMaster = await prisma.externalAppAttributeMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExternalAppAttributeMasterUpdateArgs>(
      args: SelectSubset<T, ExternalAppAttributeMasterUpdateArgs>
    ): CheckSelect<T, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMaster>, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMasterGetPayload<T>>>

    /**
     * Delete zero or more ExternalAppAttributeMasters.
     * @param {ExternalAppAttributeMasterDeleteManyArgs} args - Arguments to filter ExternalAppAttributeMasters to delete.
     * @example
     * // Delete a few ExternalAppAttributeMasters
     * const { count } = await prisma.externalAppAttributeMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExternalAppAttributeMasterDeleteManyArgs>(
      args?: SelectSubset<T, ExternalAppAttributeMasterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalAppAttributeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppAttributeMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalAppAttributeMasters
     * const externalAppAttributeMaster = await prisma.externalAppAttributeMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExternalAppAttributeMasterUpdateManyArgs>(
      args: SelectSubset<T, ExternalAppAttributeMasterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExternalAppAttributeMaster.
     * @param {ExternalAppAttributeMasterUpsertArgs} args - Arguments to update or create a ExternalAppAttributeMaster.
     * @example
     * // Update or create a ExternalAppAttributeMaster
     * const externalAppAttributeMaster = await prisma.externalAppAttributeMaster.upsert({
     *   create: {
     *     // ... data to create a ExternalAppAttributeMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalAppAttributeMaster we want to update
     *   }
     * })
    **/
    upsert<T extends ExternalAppAttributeMasterUpsertArgs>(
      args: SelectSubset<T, ExternalAppAttributeMasterUpsertArgs>
    ): CheckSelect<T, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMaster>, Prisma__ExternalAppAttributeMasterClient<ExternalAppAttributeMasterGetPayload<T>>>

    /**
     * Count the number of ExternalAppAttributeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppAttributeMasterCountArgs} args - Arguments to filter ExternalAppAttributeMasters to count.
     * @example
     * // Count the number of ExternalAppAttributeMasters
     * const count = await prisma.externalAppAttributeMaster.count({
     *   where: {
     *     // ... the filter for the ExternalAppAttributeMasters we want to count
     *   }
     * })
    **/
    count<T extends ExternalAppAttributeMasterCountArgs>(
      args?: Subset<T, ExternalAppAttributeMasterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalAppAttributeMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalAppAttributeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppAttributeMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalAppAttributeMasterAggregateArgs>(args: Subset<T, ExternalAppAttributeMasterAggregateArgs>): PrismaPromise<GetExternalAppAttributeMasterAggregateType<T>>

    /**
     * Group by ExternalAppAttributeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppAttributeMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalAppAttributeMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalAppAttributeMasterGroupByArgs['orderBy'] }
        : { orderBy?: ExternalAppAttributeMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalAppAttributeMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalAppAttributeMasterGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalAppAttributeMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExternalAppAttributeMasterClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ExternalAppAttributeMaster findUnique
   */
  export type ExternalAppAttributeMasterFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributeMaster
     * 
    **/
    select?: ExternalAppAttributeMasterSelect | null
    /**
     * Throw an Error if a ExternalAppAttributeMaster can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ExternalAppAttributeMaster to fetch.
     * 
    **/
    where: ExternalAppAttributeMasterWhereUniqueInput
  }


  /**
   * ExternalAppAttributeMaster findFirst
   */
  export type ExternalAppAttributeMasterFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributeMaster
     * 
    **/
    select?: ExternalAppAttributeMasterSelect | null
    /**
     * Throw an Error if a ExternalAppAttributeMaster can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ExternalAppAttributeMaster to fetch.
     * 
    **/
    where?: ExternalAppAttributeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAppAttributeMasters to fetch.
     * 
    **/
    orderBy?: Enumerable<ExternalAppAttributeMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalAppAttributeMasters.
     * 
    **/
    cursor?: ExternalAppAttributeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAppAttributeMasters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAppAttributeMasters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalAppAttributeMasters.
     * 
    **/
    distinct?: Enumerable<ExternalAppAttributeMasterScalarFieldEnum>
  }


  /**
   * ExternalAppAttributeMaster findMany
   */
  export type ExternalAppAttributeMasterFindManyArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributeMaster
     * 
    **/
    select?: ExternalAppAttributeMasterSelect | null
    /**
     * Filter, which ExternalAppAttributeMasters to fetch.
     * 
    **/
    where?: ExternalAppAttributeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAppAttributeMasters to fetch.
     * 
    **/
    orderBy?: Enumerable<ExternalAppAttributeMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalAppAttributeMasters.
     * 
    **/
    cursor?: ExternalAppAttributeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAppAttributeMasters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAppAttributeMasters.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExternalAppAttributeMasterScalarFieldEnum>
  }


  /**
   * ExternalAppAttributeMaster create
   */
  export type ExternalAppAttributeMasterCreateArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributeMaster
     * 
    **/
    select?: ExternalAppAttributeMasterSelect | null
    /**
     * The data needed to create a ExternalAppAttributeMaster.
     * 
    **/
    data: XOR<ExternalAppAttributeMasterCreateInput, ExternalAppAttributeMasterUncheckedCreateInput>
  }


  /**
   * ExternalAppAttributeMaster createMany
   */
  export type ExternalAppAttributeMasterCreateManyArgs = {
    data: Enumerable<ExternalAppAttributeMasterCreateManyInput>
  }


  /**
   * ExternalAppAttributeMaster update
   */
  export type ExternalAppAttributeMasterUpdateArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributeMaster
     * 
    **/
    select?: ExternalAppAttributeMasterSelect | null
    /**
     * The data needed to update a ExternalAppAttributeMaster.
     * 
    **/
    data: XOR<ExternalAppAttributeMasterUpdateInput, ExternalAppAttributeMasterUncheckedUpdateInput>
    /**
     * Choose, which ExternalAppAttributeMaster to update.
     * 
    **/
    where: ExternalAppAttributeMasterWhereUniqueInput
  }


  /**
   * ExternalAppAttributeMaster updateMany
   */
  export type ExternalAppAttributeMasterUpdateManyArgs = {
    data: XOR<ExternalAppAttributeMasterUpdateManyMutationInput, ExternalAppAttributeMasterUncheckedUpdateManyInput>
    where?: ExternalAppAttributeMasterWhereInput
  }


  /**
   * ExternalAppAttributeMaster upsert
   */
  export type ExternalAppAttributeMasterUpsertArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributeMaster
     * 
    **/
    select?: ExternalAppAttributeMasterSelect | null
    /**
     * The filter to search for the ExternalAppAttributeMaster to update in case it exists.
     * 
    **/
    where: ExternalAppAttributeMasterWhereUniqueInput
    /**
     * In case the ExternalAppAttributeMaster found by the `where` argument doesn't exist, create a new ExternalAppAttributeMaster with this data.
     * 
    **/
    create: XOR<ExternalAppAttributeMasterCreateInput, ExternalAppAttributeMasterUncheckedCreateInput>
    /**
     * In case the ExternalAppAttributeMaster was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ExternalAppAttributeMasterUpdateInput, ExternalAppAttributeMasterUncheckedUpdateInput>
  }


  /**
   * ExternalAppAttributeMaster delete
   */
  export type ExternalAppAttributeMasterDeleteArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributeMaster
     * 
    **/
    select?: ExternalAppAttributeMasterSelect | null
    /**
     * Filter which ExternalAppAttributeMaster to delete.
     * 
    **/
    where: ExternalAppAttributeMasterWhereUniqueInput
  }


  /**
   * ExternalAppAttributeMaster deleteMany
   */
  export type ExternalAppAttributeMasterDeleteManyArgs = {
    where?: ExternalAppAttributeMasterWhereInput
  }


  /**
   * ExternalAppAttributeMaster without action
   */
  export type ExternalAppAttributeMasterArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributeMaster
     * 
    **/
    select?: ExternalAppAttributeMasterSelect | null
  }



  /**
   * Model ExternalAppAttributes
   */


  export type AggregateExternalAppAttributes = {
    _count: ExternalAppAttributesCountAggregateOutputType | null
    _avg: ExternalAppAttributesAvgAggregateOutputType | null
    _sum: ExternalAppAttributesSumAggregateOutputType | null
    _min: ExternalAppAttributesMinAggregateOutputType | null
    _max: ExternalAppAttributesMaxAggregateOutputType | null
  }

  export type ExternalAppAttributesAvgAggregateOutputType = {
    IsDeleted: number | null
  }

  export type ExternalAppAttributesSumAggregateOutputType = {
    IsDeleted: number | null
  }

  export type ExternalAppAttributesMinAggregateOutputType = {
    Id: string | null
    ExternalAppAttributeMasterId: string | null
    ExternalAppProjectId: string | null
    ArtifactId: string | null
    InternalValue: string | null
    ExternalValue: string | null
    ConfigData: string | null
    IsDeleted: number | null
    RemoteLinkId: string | null
    Created: Date | null
    Modified: Date | null
  }

  export type ExternalAppAttributesMaxAggregateOutputType = {
    Id: string | null
    ExternalAppAttributeMasterId: string | null
    ExternalAppProjectId: string | null
    ArtifactId: string | null
    InternalValue: string | null
    ExternalValue: string | null
    ConfigData: string | null
    IsDeleted: number | null
    RemoteLinkId: string | null
    Created: Date | null
    Modified: Date | null
  }

  export type ExternalAppAttributesCountAggregateOutputType = {
    Id: number
    ExternalAppAttributeMasterId: number
    ExternalAppProjectId: number
    ArtifactId: number
    InternalValue: number
    ExternalValue: number
    ConfigData: number
    IsDeleted: number
    RemoteLinkId: number
    Created: number
    Modified: number
    _all: number
  }


  export type ExternalAppAttributesAvgAggregateInputType = {
    IsDeleted?: true
  }

  export type ExternalAppAttributesSumAggregateInputType = {
    IsDeleted?: true
  }

  export type ExternalAppAttributesMinAggregateInputType = {
    Id?: true
    ExternalAppAttributeMasterId?: true
    ExternalAppProjectId?: true
    ArtifactId?: true
    InternalValue?: true
    ExternalValue?: true
    ConfigData?: true
    IsDeleted?: true
    RemoteLinkId?: true
    Created?: true
    Modified?: true
  }

  export type ExternalAppAttributesMaxAggregateInputType = {
    Id?: true
    ExternalAppAttributeMasterId?: true
    ExternalAppProjectId?: true
    ArtifactId?: true
    InternalValue?: true
    ExternalValue?: true
    ConfigData?: true
    IsDeleted?: true
    RemoteLinkId?: true
    Created?: true
    Modified?: true
  }

  export type ExternalAppAttributesCountAggregateInputType = {
    Id?: true
    ExternalAppAttributeMasterId?: true
    ExternalAppProjectId?: true
    ArtifactId?: true
    InternalValue?: true
    ExternalValue?: true
    ConfigData?: true
    IsDeleted?: true
    RemoteLinkId?: true
    Created?: true
    Modified?: true
    _all?: true
  }

  export type ExternalAppAttributesAggregateArgs = {
    /**
     * Filter which ExternalAppAttributes to aggregate.
     * 
    **/
    where?: ExternalAppAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAppAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<ExternalAppAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ExternalAppAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAppAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAppAttributes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalAppAttributes
    **/
    _count?: true | ExternalAppAttributesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExternalAppAttributesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExternalAppAttributesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalAppAttributesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalAppAttributesMaxAggregateInputType
  }

  export type GetExternalAppAttributesAggregateType<T extends ExternalAppAttributesAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalAppAttributes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalAppAttributes[P]>
      : GetScalarType<T[P], AggregateExternalAppAttributes[P]>
  }




  export type ExternalAppAttributesGroupByArgs = {
    where?: ExternalAppAttributesWhereInput
    orderBy?: Enumerable<ExternalAppAttributesOrderByWithAggregationInput>
    by: Array<ExternalAppAttributesScalarFieldEnum>
    having?: ExternalAppAttributesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalAppAttributesCountAggregateInputType | true
    _avg?: ExternalAppAttributesAvgAggregateInputType
    _sum?: ExternalAppAttributesSumAggregateInputType
    _min?: ExternalAppAttributesMinAggregateInputType
    _max?: ExternalAppAttributesMaxAggregateInputType
  }


  export type ExternalAppAttributesGroupByOutputType = {
    Id: string
    ExternalAppAttributeMasterId: string
    ExternalAppProjectId: string
    ArtifactId: string
    InternalValue: string
    ExternalValue: string
    ConfigData: string
    IsDeleted: number
    RemoteLinkId: string | null
    Created: Date
    Modified: Date
    _count: ExternalAppAttributesCountAggregateOutputType | null
    _avg: ExternalAppAttributesAvgAggregateOutputType | null
    _sum: ExternalAppAttributesSumAggregateOutputType | null
    _min: ExternalAppAttributesMinAggregateOutputType | null
    _max: ExternalAppAttributesMaxAggregateOutputType | null
  }

  type GetExternalAppAttributesGroupByPayload<T extends ExternalAppAttributesGroupByArgs> = Promise<
    Array<
      PickArray<ExternalAppAttributesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalAppAttributesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalAppAttributesGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalAppAttributesGroupByOutputType[P]>
        }
      >
    >


  export type ExternalAppAttributesSelect = {
    Id?: boolean
    ExternalAppAttributeMasterId?: boolean
    ExternalAppProjectId?: boolean
    ArtifactId?: boolean
    InternalValue?: boolean
    ExternalValue?: boolean
    ConfigData?: boolean
    IsDeleted?: boolean
    RemoteLinkId?: boolean
    Created?: boolean
    Modified?: boolean
  }

  export type ExternalAppAttributesGetPayload<
    S extends boolean | null | undefined | ExternalAppAttributesArgs,
    U = keyof S
      > = S extends true
        ? ExternalAppAttributes
    : S extends undefined
    ? never
    : S extends ExternalAppAttributesArgs | ExternalAppAttributesFindManyArgs
    ?'include' extends U
    ? ExternalAppAttributes 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ExternalAppAttributes ?ExternalAppAttributes [P]
  : 
     never
  } 
    : ExternalAppAttributes
  : ExternalAppAttributes


  type ExternalAppAttributesCountArgs = Merge<
    Omit<ExternalAppAttributesFindManyArgs, 'select' | 'include'> & {
      select?: ExternalAppAttributesCountAggregateInputType | true
    }
  >

  export interface ExternalAppAttributesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ExternalAppAttributes that matches the filter.
     * @param {ExternalAppAttributesFindUniqueArgs} args - Arguments to find a ExternalAppAttributes
     * @example
     * // Get one ExternalAppAttributes
     * const externalAppAttributes = await prisma.externalAppAttributes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExternalAppAttributesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExternalAppAttributesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ExternalAppAttributes'> extends True ? CheckSelect<T, Prisma__ExternalAppAttributesClient<ExternalAppAttributes>, Prisma__ExternalAppAttributesClient<ExternalAppAttributesGetPayload<T>>> : CheckSelect<T, Prisma__ExternalAppAttributesClient<ExternalAppAttributes | null >, Prisma__ExternalAppAttributesClient<ExternalAppAttributesGetPayload<T> | null >>

    /**
     * Find the first ExternalAppAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppAttributesFindFirstArgs} args - Arguments to find a ExternalAppAttributes
     * @example
     * // Get one ExternalAppAttributes
     * const externalAppAttributes = await prisma.externalAppAttributes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExternalAppAttributesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExternalAppAttributesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ExternalAppAttributes'> extends True ? CheckSelect<T, Prisma__ExternalAppAttributesClient<ExternalAppAttributes>, Prisma__ExternalAppAttributesClient<ExternalAppAttributesGetPayload<T>>> : CheckSelect<T, Prisma__ExternalAppAttributesClient<ExternalAppAttributes | null >, Prisma__ExternalAppAttributesClient<ExternalAppAttributesGetPayload<T> | null >>

    /**
     * Find zero or more ExternalAppAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppAttributesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalAppAttributes
     * const externalAppAttributes = await prisma.externalAppAttributes.findMany()
     * 
     * // Get first 10 ExternalAppAttributes
     * const externalAppAttributes = await prisma.externalAppAttributes.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const externalAppAttributesWithIdOnly = await prisma.externalAppAttributes.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ExternalAppAttributesFindManyArgs>(
      args?: SelectSubset<T, ExternalAppAttributesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ExternalAppAttributes>>, PrismaPromise<Array<ExternalAppAttributesGetPayload<T>>>>

    /**
     * Create a ExternalAppAttributes.
     * @param {ExternalAppAttributesCreateArgs} args - Arguments to create a ExternalAppAttributes.
     * @example
     * // Create one ExternalAppAttributes
     * const ExternalAppAttributes = await prisma.externalAppAttributes.create({
     *   data: {
     *     // ... data to create a ExternalAppAttributes
     *   }
     * })
     * 
    **/
    create<T extends ExternalAppAttributesCreateArgs>(
      args: SelectSubset<T, ExternalAppAttributesCreateArgs>
    ): CheckSelect<T, Prisma__ExternalAppAttributesClient<ExternalAppAttributes>, Prisma__ExternalAppAttributesClient<ExternalAppAttributesGetPayload<T>>>

    /**
     * Create many ExternalAppAttributes.
     *     @param {ExternalAppAttributesCreateManyArgs} args - Arguments to create many ExternalAppAttributes.
     *     @example
     *     // Create many ExternalAppAttributes
     *     const externalAppAttributes = await prisma.externalAppAttributes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExternalAppAttributesCreateManyArgs>(
      args?: SelectSubset<T, ExternalAppAttributesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExternalAppAttributes.
     * @param {ExternalAppAttributesDeleteArgs} args - Arguments to delete one ExternalAppAttributes.
     * @example
     * // Delete one ExternalAppAttributes
     * const ExternalAppAttributes = await prisma.externalAppAttributes.delete({
     *   where: {
     *     // ... filter to delete one ExternalAppAttributes
     *   }
     * })
     * 
    **/
    delete<T extends ExternalAppAttributesDeleteArgs>(
      args: SelectSubset<T, ExternalAppAttributesDeleteArgs>
    ): CheckSelect<T, Prisma__ExternalAppAttributesClient<ExternalAppAttributes>, Prisma__ExternalAppAttributesClient<ExternalAppAttributesGetPayload<T>>>

    /**
     * Update one ExternalAppAttributes.
     * @param {ExternalAppAttributesUpdateArgs} args - Arguments to update one ExternalAppAttributes.
     * @example
     * // Update one ExternalAppAttributes
     * const externalAppAttributes = await prisma.externalAppAttributes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExternalAppAttributesUpdateArgs>(
      args: SelectSubset<T, ExternalAppAttributesUpdateArgs>
    ): CheckSelect<T, Prisma__ExternalAppAttributesClient<ExternalAppAttributes>, Prisma__ExternalAppAttributesClient<ExternalAppAttributesGetPayload<T>>>

    /**
     * Delete zero or more ExternalAppAttributes.
     * @param {ExternalAppAttributesDeleteManyArgs} args - Arguments to filter ExternalAppAttributes to delete.
     * @example
     * // Delete a few ExternalAppAttributes
     * const { count } = await prisma.externalAppAttributes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExternalAppAttributesDeleteManyArgs>(
      args?: SelectSubset<T, ExternalAppAttributesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalAppAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppAttributesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalAppAttributes
     * const externalAppAttributes = await prisma.externalAppAttributes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExternalAppAttributesUpdateManyArgs>(
      args: SelectSubset<T, ExternalAppAttributesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExternalAppAttributes.
     * @param {ExternalAppAttributesUpsertArgs} args - Arguments to update or create a ExternalAppAttributes.
     * @example
     * // Update or create a ExternalAppAttributes
     * const externalAppAttributes = await prisma.externalAppAttributes.upsert({
     *   create: {
     *     // ... data to create a ExternalAppAttributes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalAppAttributes we want to update
     *   }
     * })
    **/
    upsert<T extends ExternalAppAttributesUpsertArgs>(
      args: SelectSubset<T, ExternalAppAttributesUpsertArgs>
    ): CheckSelect<T, Prisma__ExternalAppAttributesClient<ExternalAppAttributes>, Prisma__ExternalAppAttributesClient<ExternalAppAttributesGetPayload<T>>>

    /**
     * Count the number of ExternalAppAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppAttributesCountArgs} args - Arguments to filter ExternalAppAttributes to count.
     * @example
     * // Count the number of ExternalAppAttributes
     * const count = await prisma.externalAppAttributes.count({
     *   where: {
     *     // ... the filter for the ExternalAppAttributes we want to count
     *   }
     * })
    **/
    count<T extends ExternalAppAttributesCountArgs>(
      args?: Subset<T, ExternalAppAttributesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalAppAttributesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalAppAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppAttributesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalAppAttributesAggregateArgs>(args: Subset<T, ExternalAppAttributesAggregateArgs>): PrismaPromise<GetExternalAppAttributesAggregateType<T>>

    /**
     * Group by ExternalAppAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppAttributesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalAppAttributesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalAppAttributesGroupByArgs['orderBy'] }
        : { orderBy?: ExternalAppAttributesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalAppAttributesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalAppAttributesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalAppAttributes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExternalAppAttributesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ExternalAppAttributes findUnique
   */
  export type ExternalAppAttributesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributes
     * 
    **/
    select?: ExternalAppAttributesSelect | null
    /**
     * Throw an Error if a ExternalAppAttributes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ExternalAppAttributes to fetch.
     * 
    **/
    where: ExternalAppAttributesWhereUniqueInput
  }


  /**
   * ExternalAppAttributes findFirst
   */
  export type ExternalAppAttributesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributes
     * 
    **/
    select?: ExternalAppAttributesSelect | null
    /**
     * Throw an Error if a ExternalAppAttributes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ExternalAppAttributes to fetch.
     * 
    **/
    where?: ExternalAppAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAppAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<ExternalAppAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalAppAttributes.
     * 
    **/
    cursor?: ExternalAppAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAppAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAppAttributes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalAppAttributes.
     * 
    **/
    distinct?: Enumerable<ExternalAppAttributesScalarFieldEnum>
  }


  /**
   * ExternalAppAttributes findMany
   */
  export type ExternalAppAttributesFindManyArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributes
     * 
    **/
    select?: ExternalAppAttributesSelect | null
    /**
     * Filter, which ExternalAppAttributes to fetch.
     * 
    **/
    where?: ExternalAppAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAppAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<ExternalAppAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalAppAttributes.
     * 
    **/
    cursor?: ExternalAppAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAppAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAppAttributes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExternalAppAttributesScalarFieldEnum>
  }


  /**
   * ExternalAppAttributes create
   */
  export type ExternalAppAttributesCreateArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributes
     * 
    **/
    select?: ExternalAppAttributesSelect | null
    /**
     * The data needed to create a ExternalAppAttributes.
     * 
    **/
    data: XOR<ExternalAppAttributesCreateInput, ExternalAppAttributesUncheckedCreateInput>
  }


  /**
   * ExternalAppAttributes createMany
   */
  export type ExternalAppAttributesCreateManyArgs = {
    data: Enumerable<ExternalAppAttributesCreateManyInput>
  }


  /**
   * ExternalAppAttributes update
   */
  export type ExternalAppAttributesUpdateArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributes
     * 
    **/
    select?: ExternalAppAttributesSelect | null
    /**
     * The data needed to update a ExternalAppAttributes.
     * 
    **/
    data: XOR<ExternalAppAttributesUpdateInput, ExternalAppAttributesUncheckedUpdateInput>
    /**
     * Choose, which ExternalAppAttributes to update.
     * 
    **/
    where: ExternalAppAttributesWhereUniqueInput
  }


  /**
   * ExternalAppAttributes updateMany
   */
  export type ExternalAppAttributesUpdateManyArgs = {
    data: XOR<ExternalAppAttributesUpdateManyMutationInput, ExternalAppAttributesUncheckedUpdateManyInput>
    where?: ExternalAppAttributesWhereInput
  }


  /**
   * ExternalAppAttributes upsert
   */
  export type ExternalAppAttributesUpsertArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributes
     * 
    **/
    select?: ExternalAppAttributesSelect | null
    /**
     * The filter to search for the ExternalAppAttributes to update in case it exists.
     * 
    **/
    where: ExternalAppAttributesWhereUniqueInput
    /**
     * In case the ExternalAppAttributes found by the `where` argument doesn't exist, create a new ExternalAppAttributes with this data.
     * 
    **/
    create: XOR<ExternalAppAttributesCreateInput, ExternalAppAttributesUncheckedCreateInput>
    /**
     * In case the ExternalAppAttributes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ExternalAppAttributesUpdateInput, ExternalAppAttributesUncheckedUpdateInput>
  }


  /**
   * ExternalAppAttributes delete
   */
  export type ExternalAppAttributesDeleteArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributes
     * 
    **/
    select?: ExternalAppAttributesSelect | null
    /**
     * Filter which ExternalAppAttributes to delete.
     * 
    **/
    where: ExternalAppAttributesWhereUniqueInput
  }


  /**
   * ExternalAppAttributes deleteMany
   */
  export type ExternalAppAttributesDeleteManyArgs = {
    where?: ExternalAppAttributesWhereInput
  }


  /**
   * ExternalAppAttributes without action
   */
  export type ExternalAppAttributesArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppAttributes
     * 
    **/
    select?: ExternalAppAttributesSelect | null
  }



  /**
   * Model ExternalApps
   */


  export type AggregateExternalApps = {
    _count: ExternalAppsCountAggregateOutputType | null
    _avg: ExternalAppsAvgAggregateOutputType | null
    _sum: ExternalAppsSumAggregateOutputType | null
    _min: ExternalAppsMinAggregateOutputType | null
    _max: ExternalAppsMaxAggregateOutputType | null
  }

  export type ExternalAppsAvgAggregateOutputType = {
    IsExternal: number | null
    IsEnabled: number | null
  }

  export type ExternalAppsSumAggregateOutputType = {
    IsExternal: number | null
    IsEnabled: number | null
  }

  export type ExternalAppsMinAggregateOutputType = {
    Id: string | null
    ExternalAppTypeId: string | null
    ExternalAppEnvironment: string | null
    RepositoryId: string | null
    Name: string | null
    Description: string | null
    EndPointURL: string | null
    IsExternal: number | null
    ExternalPath: string | null
    Username: string | null
    Password: string | null
    ProjectId: string | null
    ProjectName: string | null
    ConfigData: string | null
    IsEnabled: number | null
    Created: Date | null
    Modified: Date | null
  }

  export type ExternalAppsMaxAggregateOutputType = {
    Id: string | null
    ExternalAppTypeId: string | null
    ExternalAppEnvironment: string | null
    RepositoryId: string | null
    Name: string | null
    Description: string | null
    EndPointURL: string | null
    IsExternal: number | null
    ExternalPath: string | null
    Username: string | null
    Password: string | null
    ProjectId: string | null
    ProjectName: string | null
    ConfigData: string | null
    IsEnabled: number | null
    Created: Date | null
    Modified: Date | null
  }

  export type ExternalAppsCountAggregateOutputType = {
    Id: number
    ExternalAppTypeId: number
    ExternalAppEnvironment: number
    RepositoryId: number
    Name: number
    Description: number
    EndPointURL: number
    IsExternal: number
    ExternalPath: number
    Username: number
    Password: number
    ProjectId: number
    ProjectName: number
    ConfigData: number
    IsEnabled: number
    Created: number
    Modified: number
    _all: number
  }


  export type ExternalAppsAvgAggregateInputType = {
    IsExternal?: true
    IsEnabled?: true
  }

  export type ExternalAppsSumAggregateInputType = {
    IsExternal?: true
    IsEnabled?: true
  }

  export type ExternalAppsMinAggregateInputType = {
    Id?: true
    ExternalAppTypeId?: true
    ExternalAppEnvironment?: true
    RepositoryId?: true
    Name?: true
    Description?: true
    EndPointURL?: true
    IsExternal?: true
    ExternalPath?: true
    Username?: true
    Password?: true
    ProjectId?: true
    ProjectName?: true
    ConfigData?: true
    IsEnabled?: true
    Created?: true
    Modified?: true
  }

  export type ExternalAppsMaxAggregateInputType = {
    Id?: true
    ExternalAppTypeId?: true
    ExternalAppEnvironment?: true
    RepositoryId?: true
    Name?: true
    Description?: true
    EndPointURL?: true
    IsExternal?: true
    ExternalPath?: true
    Username?: true
    Password?: true
    ProjectId?: true
    ProjectName?: true
    ConfigData?: true
    IsEnabled?: true
    Created?: true
    Modified?: true
  }

  export type ExternalAppsCountAggregateInputType = {
    Id?: true
    ExternalAppTypeId?: true
    ExternalAppEnvironment?: true
    RepositoryId?: true
    Name?: true
    Description?: true
    EndPointURL?: true
    IsExternal?: true
    ExternalPath?: true
    Username?: true
    Password?: true
    ProjectId?: true
    ProjectName?: true
    ConfigData?: true
    IsEnabled?: true
    Created?: true
    Modified?: true
    _all?: true
  }

  export type ExternalAppsAggregateArgs = {
    /**
     * Filter which ExternalApps to aggregate.
     * 
    **/
    where?: ExternalAppsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalApps to fetch.
     * 
    **/
    orderBy?: Enumerable<ExternalAppsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ExternalAppsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalApps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalApps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalApps
    **/
    _count?: true | ExternalAppsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExternalAppsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExternalAppsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalAppsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalAppsMaxAggregateInputType
  }

  export type GetExternalAppsAggregateType<T extends ExternalAppsAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalApps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalApps[P]>
      : GetScalarType<T[P], AggregateExternalApps[P]>
  }




  export type ExternalAppsGroupByArgs = {
    where?: ExternalAppsWhereInput
    orderBy?: Enumerable<ExternalAppsOrderByWithAggregationInput>
    by: Array<ExternalAppsScalarFieldEnum>
    having?: ExternalAppsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalAppsCountAggregateInputType | true
    _avg?: ExternalAppsAvgAggregateInputType
    _sum?: ExternalAppsSumAggregateInputType
    _min?: ExternalAppsMinAggregateInputType
    _max?: ExternalAppsMaxAggregateInputType
  }


  export type ExternalAppsGroupByOutputType = {
    Id: string
    ExternalAppTypeId: string | null
    ExternalAppEnvironment: string | null
    RepositoryId: string | null
    Name: string | null
    Description: string | null
    EndPointURL: string | null
    IsExternal: number | null
    ExternalPath: string | null
    Username: string | null
    Password: string | null
    ProjectId: string | null
    ProjectName: string | null
    ConfigData: string | null
    IsEnabled: number
    Created: Date
    Modified: Date | null
    _count: ExternalAppsCountAggregateOutputType | null
    _avg: ExternalAppsAvgAggregateOutputType | null
    _sum: ExternalAppsSumAggregateOutputType | null
    _min: ExternalAppsMinAggregateOutputType | null
    _max: ExternalAppsMaxAggregateOutputType | null
  }

  type GetExternalAppsGroupByPayload<T extends ExternalAppsGroupByArgs> = Promise<
    Array<
      PickArray<ExternalAppsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalAppsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalAppsGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalAppsGroupByOutputType[P]>
        }
      >
    >


  export type ExternalAppsSelect = {
    Id?: boolean
    ExternalAppTypeId?: boolean
    ExternalAppEnvironment?: boolean
    RepositoryId?: boolean
    Name?: boolean
    Description?: boolean
    EndPointURL?: boolean
    IsExternal?: boolean
    ExternalPath?: boolean
    Username?: boolean
    Password?: boolean
    ProjectId?: boolean
    ProjectName?: boolean
    ConfigData?: boolean
    IsEnabled?: boolean
    Created?: boolean
    Modified?: boolean
  }

  export type ExternalAppsGetPayload<
    S extends boolean | null | undefined | ExternalAppsArgs,
    U = keyof S
      > = S extends true
        ? ExternalApps
    : S extends undefined
    ? never
    : S extends ExternalAppsArgs | ExternalAppsFindManyArgs
    ?'include' extends U
    ? ExternalApps 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ExternalApps ?ExternalApps [P]
  : 
     never
  } 
    : ExternalApps
  : ExternalApps


  type ExternalAppsCountArgs = Merge<
    Omit<ExternalAppsFindManyArgs, 'select' | 'include'> & {
      select?: ExternalAppsCountAggregateInputType | true
    }
  >

  export interface ExternalAppsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ExternalApps that matches the filter.
     * @param {ExternalAppsFindUniqueArgs} args - Arguments to find a ExternalApps
     * @example
     * // Get one ExternalApps
     * const externalApps = await prisma.externalApps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExternalAppsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExternalAppsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ExternalApps'> extends True ? CheckSelect<T, Prisma__ExternalAppsClient<ExternalApps>, Prisma__ExternalAppsClient<ExternalAppsGetPayload<T>>> : CheckSelect<T, Prisma__ExternalAppsClient<ExternalApps | null >, Prisma__ExternalAppsClient<ExternalAppsGetPayload<T> | null >>

    /**
     * Find the first ExternalApps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppsFindFirstArgs} args - Arguments to find a ExternalApps
     * @example
     * // Get one ExternalApps
     * const externalApps = await prisma.externalApps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExternalAppsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExternalAppsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ExternalApps'> extends True ? CheckSelect<T, Prisma__ExternalAppsClient<ExternalApps>, Prisma__ExternalAppsClient<ExternalAppsGetPayload<T>>> : CheckSelect<T, Prisma__ExternalAppsClient<ExternalApps | null >, Prisma__ExternalAppsClient<ExternalAppsGetPayload<T> | null >>

    /**
     * Find zero or more ExternalApps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalApps
     * const externalApps = await prisma.externalApps.findMany()
     * 
     * // Get first 10 ExternalApps
     * const externalApps = await prisma.externalApps.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const externalAppsWithIdOnly = await prisma.externalApps.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ExternalAppsFindManyArgs>(
      args?: SelectSubset<T, ExternalAppsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ExternalApps>>, PrismaPromise<Array<ExternalAppsGetPayload<T>>>>

    /**
     * Create a ExternalApps.
     * @param {ExternalAppsCreateArgs} args - Arguments to create a ExternalApps.
     * @example
     * // Create one ExternalApps
     * const ExternalApps = await prisma.externalApps.create({
     *   data: {
     *     // ... data to create a ExternalApps
     *   }
     * })
     * 
    **/
    create<T extends ExternalAppsCreateArgs>(
      args: SelectSubset<T, ExternalAppsCreateArgs>
    ): CheckSelect<T, Prisma__ExternalAppsClient<ExternalApps>, Prisma__ExternalAppsClient<ExternalAppsGetPayload<T>>>

    /**
     * Create many ExternalApps.
     *     @param {ExternalAppsCreateManyArgs} args - Arguments to create many ExternalApps.
     *     @example
     *     // Create many ExternalApps
     *     const externalApps = await prisma.externalApps.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExternalAppsCreateManyArgs>(
      args?: SelectSubset<T, ExternalAppsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExternalApps.
     * @param {ExternalAppsDeleteArgs} args - Arguments to delete one ExternalApps.
     * @example
     * // Delete one ExternalApps
     * const ExternalApps = await prisma.externalApps.delete({
     *   where: {
     *     // ... filter to delete one ExternalApps
     *   }
     * })
     * 
    **/
    delete<T extends ExternalAppsDeleteArgs>(
      args: SelectSubset<T, ExternalAppsDeleteArgs>
    ): CheckSelect<T, Prisma__ExternalAppsClient<ExternalApps>, Prisma__ExternalAppsClient<ExternalAppsGetPayload<T>>>

    /**
     * Update one ExternalApps.
     * @param {ExternalAppsUpdateArgs} args - Arguments to update one ExternalApps.
     * @example
     * // Update one ExternalApps
     * const externalApps = await prisma.externalApps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExternalAppsUpdateArgs>(
      args: SelectSubset<T, ExternalAppsUpdateArgs>
    ): CheckSelect<T, Prisma__ExternalAppsClient<ExternalApps>, Prisma__ExternalAppsClient<ExternalAppsGetPayload<T>>>

    /**
     * Delete zero or more ExternalApps.
     * @param {ExternalAppsDeleteManyArgs} args - Arguments to filter ExternalApps to delete.
     * @example
     * // Delete a few ExternalApps
     * const { count } = await prisma.externalApps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExternalAppsDeleteManyArgs>(
      args?: SelectSubset<T, ExternalAppsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalApps
     * const externalApps = await prisma.externalApps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExternalAppsUpdateManyArgs>(
      args: SelectSubset<T, ExternalAppsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExternalApps.
     * @param {ExternalAppsUpsertArgs} args - Arguments to update or create a ExternalApps.
     * @example
     * // Update or create a ExternalApps
     * const externalApps = await prisma.externalApps.upsert({
     *   create: {
     *     // ... data to create a ExternalApps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalApps we want to update
     *   }
     * })
    **/
    upsert<T extends ExternalAppsUpsertArgs>(
      args: SelectSubset<T, ExternalAppsUpsertArgs>
    ): CheckSelect<T, Prisma__ExternalAppsClient<ExternalApps>, Prisma__ExternalAppsClient<ExternalAppsGetPayload<T>>>

    /**
     * Count the number of ExternalApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppsCountArgs} args - Arguments to filter ExternalApps to count.
     * @example
     * // Count the number of ExternalApps
     * const count = await prisma.externalApps.count({
     *   where: {
     *     // ... the filter for the ExternalApps we want to count
     *   }
     * })
    **/
    count<T extends ExternalAppsCountArgs>(
      args?: Subset<T, ExternalAppsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalAppsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalAppsAggregateArgs>(args: Subset<T, ExternalAppsAggregateArgs>): PrismaPromise<GetExternalAppsAggregateType<T>>

    /**
     * Group by ExternalApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalAppsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalAppsGroupByArgs['orderBy'] }
        : { orderBy?: ExternalAppsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalAppsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalAppsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalApps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExternalAppsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ExternalApps findUnique
   */
  export type ExternalAppsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ExternalApps
     * 
    **/
    select?: ExternalAppsSelect | null
    /**
     * Throw an Error if a ExternalApps can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ExternalApps to fetch.
     * 
    **/
    where: ExternalAppsWhereUniqueInput
  }


  /**
   * ExternalApps findFirst
   */
  export type ExternalAppsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ExternalApps
     * 
    **/
    select?: ExternalAppsSelect | null
    /**
     * Throw an Error if a ExternalApps can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ExternalApps to fetch.
     * 
    **/
    where?: ExternalAppsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalApps to fetch.
     * 
    **/
    orderBy?: Enumerable<ExternalAppsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalApps.
     * 
    **/
    cursor?: ExternalAppsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalApps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalApps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalApps.
     * 
    **/
    distinct?: Enumerable<ExternalAppsScalarFieldEnum>
  }


  /**
   * ExternalApps findMany
   */
  export type ExternalAppsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ExternalApps
     * 
    **/
    select?: ExternalAppsSelect | null
    /**
     * Filter, which ExternalApps to fetch.
     * 
    **/
    where?: ExternalAppsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalApps to fetch.
     * 
    **/
    orderBy?: Enumerable<ExternalAppsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalApps.
     * 
    **/
    cursor?: ExternalAppsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalApps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalApps.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExternalAppsScalarFieldEnum>
  }


  /**
   * ExternalApps create
   */
  export type ExternalAppsCreateArgs = {
    /**
     * Select specific fields to fetch from the ExternalApps
     * 
    **/
    select?: ExternalAppsSelect | null
    /**
     * The data needed to create a ExternalApps.
     * 
    **/
    data: XOR<ExternalAppsCreateInput, ExternalAppsUncheckedCreateInput>
  }


  /**
   * ExternalApps createMany
   */
  export type ExternalAppsCreateManyArgs = {
    data: Enumerable<ExternalAppsCreateManyInput>
  }


  /**
   * ExternalApps update
   */
  export type ExternalAppsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ExternalApps
     * 
    **/
    select?: ExternalAppsSelect | null
    /**
     * The data needed to update a ExternalApps.
     * 
    **/
    data: XOR<ExternalAppsUpdateInput, ExternalAppsUncheckedUpdateInput>
    /**
     * Choose, which ExternalApps to update.
     * 
    **/
    where: ExternalAppsWhereUniqueInput
  }


  /**
   * ExternalApps updateMany
   */
  export type ExternalAppsUpdateManyArgs = {
    data: XOR<ExternalAppsUpdateManyMutationInput, ExternalAppsUncheckedUpdateManyInput>
    where?: ExternalAppsWhereInput
  }


  /**
   * ExternalApps upsert
   */
  export type ExternalAppsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ExternalApps
     * 
    **/
    select?: ExternalAppsSelect | null
    /**
     * The filter to search for the ExternalApps to update in case it exists.
     * 
    **/
    where: ExternalAppsWhereUniqueInput
    /**
     * In case the ExternalApps found by the `where` argument doesn't exist, create a new ExternalApps with this data.
     * 
    **/
    create: XOR<ExternalAppsCreateInput, ExternalAppsUncheckedCreateInput>
    /**
     * In case the ExternalApps was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ExternalAppsUpdateInput, ExternalAppsUncheckedUpdateInput>
  }


  /**
   * ExternalApps delete
   */
  export type ExternalAppsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ExternalApps
     * 
    **/
    select?: ExternalAppsSelect | null
    /**
     * Filter which ExternalApps to delete.
     * 
    **/
    where: ExternalAppsWhereUniqueInput
  }


  /**
   * ExternalApps deleteMany
   */
  export type ExternalAppsDeleteManyArgs = {
    where?: ExternalAppsWhereInput
  }


  /**
   * ExternalApps without action
   */
  export type ExternalAppsArgs = {
    /**
     * Select specific fields to fetch from the ExternalApps
     * 
    **/
    select?: ExternalAppsSelect | null
  }



  /**
   * Model ExternalAppTypes
   */


  export type AggregateExternalAppTypes = {
    _count: ExternalAppTypesCountAggregateOutputType | null
    _avg: ExternalAppTypesAvgAggregateOutputType | null
    _sum: ExternalAppTypesSumAggregateOutputType | null
    _min: ExternalAppTypesMinAggregateOutputType | null
    _max: ExternalAppTypesMaxAggregateOutputType | null
  }

  export type ExternalAppTypesAvgAggregateOutputType = {
    IsExternal: number | null
    Position: number | null
    IsEnabled: number | null
  }

  export type ExternalAppTypesSumAggregateOutputType = {
    IsExternal: number | null
    Position: number | null
    IsEnabled: number | null
  }

  export type ExternalAppTypesMinAggregateOutputType = {
    Id: string | null
    Name: string | null
    Description: string | null
    IsExternal: number | null
    ExternalPath: string | null
    Logo: string | null
    Position: number | null
    IsEnabled: number | null
    AppContent: string | null
  }

  export type ExternalAppTypesMaxAggregateOutputType = {
    Id: string | null
    Name: string | null
    Description: string | null
    IsExternal: number | null
    ExternalPath: string | null
    Logo: string | null
    Position: number | null
    IsEnabled: number | null
    AppContent: string | null
  }

  export type ExternalAppTypesCountAggregateOutputType = {
    Id: number
    Name: number
    Description: number
    IsExternal: number
    ExternalPath: number
    Logo: number
    Position: number
    IsEnabled: number
    AppContent: number
    _all: number
  }


  export type ExternalAppTypesAvgAggregateInputType = {
    IsExternal?: true
    Position?: true
    IsEnabled?: true
  }

  export type ExternalAppTypesSumAggregateInputType = {
    IsExternal?: true
    Position?: true
    IsEnabled?: true
  }

  export type ExternalAppTypesMinAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    IsExternal?: true
    ExternalPath?: true
    Logo?: true
    Position?: true
    IsEnabled?: true
    AppContent?: true
  }

  export type ExternalAppTypesMaxAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    IsExternal?: true
    ExternalPath?: true
    Logo?: true
    Position?: true
    IsEnabled?: true
    AppContent?: true
  }

  export type ExternalAppTypesCountAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    IsExternal?: true
    ExternalPath?: true
    Logo?: true
    Position?: true
    IsEnabled?: true
    AppContent?: true
    _all?: true
  }

  export type ExternalAppTypesAggregateArgs = {
    /**
     * Filter which ExternalAppTypes to aggregate.
     * 
    **/
    where?: ExternalAppTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAppTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ExternalAppTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ExternalAppTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAppTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAppTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalAppTypes
    **/
    _count?: true | ExternalAppTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExternalAppTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExternalAppTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalAppTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalAppTypesMaxAggregateInputType
  }

  export type GetExternalAppTypesAggregateType<T extends ExternalAppTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalAppTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalAppTypes[P]>
      : GetScalarType<T[P], AggregateExternalAppTypes[P]>
  }




  export type ExternalAppTypesGroupByArgs = {
    where?: ExternalAppTypesWhereInput
    orderBy?: Enumerable<ExternalAppTypesOrderByWithAggregationInput>
    by: Array<ExternalAppTypesScalarFieldEnum>
    having?: ExternalAppTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalAppTypesCountAggregateInputType | true
    _avg?: ExternalAppTypesAvgAggregateInputType
    _sum?: ExternalAppTypesSumAggregateInputType
    _min?: ExternalAppTypesMinAggregateInputType
    _max?: ExternalAppTypesMaxAggregateInputType
  }


  export type ExternalAppTypesGroupByOutputType = {
    Id: string
    Name: string | null
    Description: string | null
    IsExternal: number | null
    ExternalPath: string | null
    Logo: string | null
    Position: number
    IsEnabled: number
    AppContent: string | null
    _count: ExternalAppTypesCountAggregateOutputType | null
    _avg: ExternalAppTypesAvgAggregateOutputType | null
    _sum: ExternalAppTypesSumAggregateOutputType | null
    _min: ExternalAppTypesMinAggregateOutputType | null
    _max: ExternalAppTypesMaxAggregateOutputType | null
  }

  type GetExternalAppTypesGroupByPayload<T extends ExternalAppTypesGroupByArgs> = Promise<
    Array<
      PickArray<ExternalAppTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalAppTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalAppTypesGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalAppTypesGroupByOutputType[P]>
        }
      >
    >


  export type ExternalAppTypesSelect = {
    Id?: boolean
    Name?: boolean
    Description?: boolean
    IsExternal?: boolean
    ExternalPath?: boolean
    Logo?: boolean
    Position?: boolean
    IsEnabled?: boolean
    AppContent?: boolean
  }

  export type ExternalAppTypesGetPayload<
    S extends boolean | null | undefined | ExternalAppTypesArgs,
    U = keyof S
      > = S extends true
        ? ExternalAppTypes
    : S extends undefined
    ? never
    : S extends ExternalAppTypesArgs | ExternalAppTypesFindManyArgs
    ?'include' extends U
    ? ExternalAppTypes 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ExternalAppTypes ?ExternalAppTypes [P]
  : 
     never
  } 
    : ExternalAppTypes
  : ExternalAppTypes


  type ExternalAppTypesCountArgs = Merge<
    Omit<ExternalAppTypesFindManyArgs, 'select' | 'include'> & {
      select?: ExternalAppTypesCountAggregateInputType | true
    }
  >

  export interface ExternalAppTypesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ExternalAppTypes that matches the filter.
     * @param {ExternalAppTypesFindUniqueArgs} args - Arguments to find a ExternalAppTypes
     * @example
     * // Get one ExternalAppTypes
     * const externalAppTypes = await prisma.externalAppTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExternalAppTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExternalAppTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ExternalAppTypes'> extends True ? CheckSelect<T, Prisma__ExternalAppTypesClient<ExternalAppTypes>, Prisma__ExternalAppTypesClient<ExternalAppTypesGetPayload<T>>> : CheckSelect<T, Prisma__ExternalAppTypesClient<ExternalAppTypes | null >, Prisma__ExternalAppTypesClient<ExternalAppTypesGetPayload<T> | null >>

    /**
     * Find the first ExternalAppTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppTypesFindFirstArgs} args - Arguments to find a ExternalAppTypes
     * @example
     * // Get one ExternalAppTypes
     * const externalAppTypes = await prisma.externalAppTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExternalAppTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExternalAppTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ExternalAppTypes'> extends True ? CheckSelect<T, Prisma__ExternalAppTypesClient<ExternalAppTypes>, Prisma__ExternalAppTypesClient<ExternalAppTypesGetPayload<T>>> : CheckSelect<T, Prisma__ExternalAppTypesClient<ExternalAppTypes | null >, Prisma__ExternalAppTypesClient<ExternalAppTypesGetPayload<T> | null >>

    /**
     * Find zero or more ExternalAppTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalAppTypes
     * const externalAppTypes = await prisma.externalAppTypes.findMany()
     * 
     * // Get first 10 ExternalAppTypes
     * const externalAppTypes = await prisma.externalAppTypes.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const externalAppTypesWithIdOnly = await prisma.externalAppTypes.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ExternalAppTypesFindManyArgs>(
      args?: SelectSubset<T, ExternalAppTypesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ExternalAppTypes>>, PrismaPromise<Array<ExternalAppTypesGetPayload<T>>>>

    /**
     * Create a ExternalAppTypes.
     * @param {ExternalAppTypesCreateArgs} args - Arguments to create a ExternalAppTypes.
     * @example
     * // Create one ExternalAppTypes
     * const ExternalAppTypes = await prisma.externalAppTypes.create({
     *   data: {
     *     // ... data to create a ExternalAppTypes
     *   }
     * })
     * 
    **/
    create<T extends ExternalAppTypesCreateArgs>(
      args: SelectSubset<T, ExternalAppTypesCreateArgs>
    ): CheckSelect<T, Prisma__ExternalAppTypesClient<ExternalAppTypes>, Prisma__ExternalAppTypesClient<ExternalAppTypesGetPayload<T>>>

    /**
     * Create many ExternalAppTypes.
     *     @param {ExternalAppTypesCreateManyArgs} args - Arguments to create many ExternalAppTypes.
     *     @example
     *     // Create many ExternalAppTypes
     *     const externalAppTypes = await prisma.externalAppTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExternalAppTypesCreateManyArgs>(
      args?: SelectSubset<T, ExternalAppTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExternalAppTypes.
     * @param {ExternalAppTypesDeleteArgs} args - Arguments to delete one ExternalAppTypes.
     * @example
     * // Delete one ExternalAppTypes
     * const ExternalAppTypes = await prisma.externalAppTypes.delete({
     *   where: {
     *     // ... filter to delete one ExternalAppTypes
     *   }
     * })
     * 
    **/
    delete<T extends ExternalAppTypesDeleteArgs>(
      args: SelectSubset<T, ExternalAppTypesDeleteArgs>
    ): CheckSelect<T, Prisma__ExternalAppTypesClient<ExternalAppTypes>, Prisma__ExternalAppTypesClient<ExternalAppTypesGetPayload<T>>>

    /**
     * Update one ExternalAppTypes.
     * @param {ExternalAppTypesUpdateArgs} args - Arguments to update one ExternalAppTypes.
     * @example
     * // Update one ExternalAppTypes
     * const externalAppTypes = await prisma.externalAppTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExternalAppTypesUpdateArgs>(
      args: SelectSubset<T, ExternalAppTypesUpdateArgs>
    ): CheckSelect<T, Prisma__ExternalAppTypesClient<ExternalAppTypes>, Prisma__ExternalAppTypesClient<ExternalAppTypesGetPayload<T>>>

    /**
     * Delete zero or more ExternalAppTypes.
     * @param {ExternalAppTypesDeleteManyArgs} args - Arguments to filter ExternalAppTypes to delete.
     * @example
     * // Delete a few ExternalAppTypes
     * const { count } = await prisma.externalAppTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExternalAppTypesDeleteManyArgs>(
      args?: SelectSubset<T, ExternalAppTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalAppTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalAppTypes
     * const externalAppTypes = await prisma.externalAppTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExternalAppTypesUpdateManyArgs>(
      args: SelectSubset<T, ExternalAppTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExternalAppTypes.
     * @param {ExternalAppTypesUpsertArgs} args - Arguments to update or create a ExternalAppTypes.
     * @example
     * // Update or create a ExternalAppTypes
     * const externalAppTypes = await prisma.externalAppTypes.upsert({
     *   create: {
     *     // ... data to create a ExternalAppTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalAppTypes we want to update
     *   }
     * })
    **/
    upsert<T extends ExternalAppTypesUpsertArgs>(
      args: SelectSubset<T, ExternalAppTypesUpsertArgs>
    ): CheckSelect<T, Prisma__ExternalAppTypesClient<ExternalAppTypes>, Prisma__ExternalAppTypesClient<ExternalAppTypesGetPayload<T>>>

    /**
     * Count the number of ExternalAppTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppTypesCountArgs} args - Arguments to filter ExternalAppTypes to count.
     * @example
     * // Count the number of ExternalAppTypes
     * const count = await prisma.externalAppTypes.count({
     *   where: {
     *     // ... the filter for the ExternalAppTypes we want to count
     *   }
     * })
    **/
    count<T extends ExternalAppTypesCountArgs>(
      args?: Subset<T, ExternalAppTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalAppTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalAppTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalAppTypesAggregateArgs>(args: Subset<T, ExternalAppTypesAggregateArgs>): PrismaPromise<GetExternalAppTypesAggregateType<T>>

    /**
     * Group by ExternalAppTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAppTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalAppTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalAppTypesGroupByArgs['orderBy'] }
        : { orderBy?: ExternalAppTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalAppTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalAppTypesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalAppTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExternalAppTypesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ExternalAppTypes findUnique
   */
  export type ExternalAppTypesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppTypes
     * 
    **/
    select?: ExternalAppTypesSelect | null
    /**
     * Throw an Error if a ExternalAppTypes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ExternalAppTypes to fetch.
     * 
    **/
    where: ExternalAppTypesWhereUniqueInput
  }


  /**
   * ExternalAppTypes findFirst
   */
  export type ExternalAppTypesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppTypes
     * 
    **/
    select?: ExternalAppTypesSelect | null
    /**
     * Throw an Error if a ExternalAppTypes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ExternalAppTypes to fetch.
     * 
    **/
    where?: ExternalAppTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAppTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ExternalAppTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalAppTypes.
     * 
    **/
    cursor?: ExternalAppTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAppTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAppTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalAppTypes.
     * 
    **/
    distinct?: Enumerable<ExternalAppTypesScalarFieldEnum>
  }


  /**
   * ExternalAppTypes findMany
   */
  export type ExternalAppTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppTypes
     * 
    **/
    select?: ExternalAppTypesSelect | null
    /**
     * Filter, which ExternalAppTypes to fetch.
     * 
    **/
    where?: ExternalAppTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAppTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ExternalAppTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalAppTypes.
     * 
    **/
    cursor?: ExternalAppTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAppTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAppTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExternalAppTypesScalarFieldEnum>
  }


  /**
   * ExternalAppTypes create
   */
  export type ExternalAppTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppTypes
     * 
    **/
    select?: ExternalAppTypesSelect | null
    /**
     * The data needed to create a ExternalAppTypes.
     * 
    **/
    data: XOR<ExternalAppTypesCreateInput, ExternalAppTypesUncheckedCreateInput>
  }


  /**
   * ExternalAppTypes createMany
   */
  export type ExternalAppTypesCreateManyArgs = {
    data: Enumerable<ExternalAppTypesCreateManyInput>
  }


  /**
   * ExternalAppTypes update
   */
  export type ExternalAppTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppTypes
     * 
    **/
    select?: ExternalAppTypesSelect | null
    /**
     * The data needed to update a ExternalAppTypes.
     * 
    **/
    data: XOR<ExternalAppTypesUpdateInput, ExternalAppTypesUncheckedUpdateInput>
    /**
     * Choose, which ExternalAppTypes to update.
     * 
    **/
    where: ExternalAppTypesWhereUniqueInput
  }


  /**
   * ExternalAppTypes updateMany
   */
  export type ExternalAppTypesUpdateManyArgs = {
    data: XOR<ExternalAppTypesUpdateManyMutationInput, ExternalAppTypesUncheckedUpdateManyInput>
    where?: ExternalAppTypesWhereInput
  }


  /**
   * ExternalAppTypes upsert
   */
  export type ExternalAppTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppTypes
     * 
    **/
    select?: ExternalAppTypesSelect | null
    /**
     * The filter to search for the ExternalAppTypes to update in case it exists.
     * 
    **/
    where: ExternalAppTypesWhereUniqueInput
    /**
     * In case the ExternalAppTypes found by the `where` argument doesn't exist, create a new ExternalAppTypes with this data.
     * 
    **/
    create: XOR<ExternalAppTypesCreateInput, ExternalAppTypesUncheckedCreateInput>
    /**
     * In case the ExternalAppTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ExternalAppTypesUpdateInput, ExternalAppTypesUncheckedUpdateInput>
  }


  /**
   * ExternalAppTypes delete
   */
  export type ExternalAppTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppTypes
     * 
    **/
    select?: ExternalAppTypesSelect | null
    /**
     * Filter which ExternalAppTypes to delete.
     * 
    **/
    where: ExternalAppTypesWhereUniqueInput
  }


  /**
   * ExternalAppTypes deleteMany
   */
  export type ExternalAppTypesDeleteManyArgs = {
    where?: ExternalAppTypesWhereInput
  }


  /**
   * ExternalAppTypes without action
   */
  export type ExternalAppTypesArgs = {
    /**
     * Select specific fields to fetch from the ExternalAppTypes
     * 
    **/
    select?: ExternalAppTypesSelect | null
  }



  /**
   * Model Features
   */


  export type AggregateFeatures = {
    _count: FeaturesCountAggregateOutputType | null
    _min: FeaturesMinAggregateOutputType | null
    _max: FeaturesMaxAggregateOutputType | null
  }

  export type FeaturesMinAggregateOutputType = {
    Id: string | null
    Name: string | null
    Status: string | null
    CreatedDate: Date | null
    FeatureKey: string | null
  }

  export type FeaturesMaxAggregateOutputType = {
    Id: string | null
    Name: string | null
    Status: string | null
    CreatedDate: Date | null
    FeatureKey: string | null
  }

  export type FeaturesCountAggregateOutputType = {
    Id: number
    Name: number
    Status: number
    CreatedDate: number
    FeatureKey: number
    _all: number
  }


  export type FeaturesMinAggregateInputType = {
    Id?: true
    Name?: true
    Status?: true
    CreatedDate?: true
    FeatureKey?: true
  }

  export type FeaturesMaxAggregateInputType = {
    Id?: true
    Name?: true
    Status?: true
    CreatedDate?: true
    FeatureKey?: true
  }

  export type FeaturesCountAggregateInputType = {
    Id?: true
    Name?: true
    Status?: true
    CreatedDate?: true
    FeatureKey?: true
    _all?: true
  }

  export type FeaturesAggregateArgs = {
    /**
     * Filter which Features to aggregate.
     * 
    **/
    where?: FeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     * 
    **/
    orderBy?: Enumerable<FeaturesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Features
    **/
    _count?: true | FeaturesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturesMaxAggregateInputType
  }

  export type GetFeaturesAggregateType<T extends FeaturesAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatures[P]>
      : GetScalarType<T[P], AggregateFeatures[P]>
  }




  export type FeaturesGroupByArgs = {
    where?: FeaturesWhereInput
    orderBy?: Enumerable<FeaturesOrderByWithAggregationInput>
    by: Array<FeaturesScalarFieldEnum>
    having?: FeaturesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturesCountAggregateInputType | true
    _min?: FeaturesMinAggregateInputType
    _max?: FeaturesMaxAggregateInputType
  }


  export type FeaturesGroupByOutputType = {
    Id: string
    Name: string | null
    Status: string | null
    CreatedDate: Date | null
    FeatureKey: string | null
    _count: FeaturesCountAggregateOutputType | null
    _min: FeaturesMinAggregateOutputType | null
    _max: FeaturesMaxAggregateOutputType | null
  }

  type GetFeaturesGroupByPayload<T extends FeaturesGroupByArgs> = Promise<
    Array<
      PickArray<FeaturesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturesGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturesGroupByOutputType[P]>
        }
      >
    >


  export type FeaturesSelect = {
    Id?: boolean
    Name?: boolean
    Status?: boolean
    CreatedDate?: boolean
    FeatureKey?: boolean
  }

  export type FeaturesGetPayload<
    S extends boolean | null | undefined | FeaturesArgs,
    U = keyof S
      > = S extends true
        ? Features
    : S extends undefined
    ? never
    : S extends FeaturesArgs | FeaturesFindManyArgs
    ?'include' extends U
    ? Features 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Features ?Features [P]
  : 
     never
  } 
    : Features
  : Features


  type FeaturesCountArgs = Merge<
    Omit<FeaturesFindManyArgs, 'select' | 'include'> & {
      select?: FeaturesCountAggregateInputType | true
    }
  >

  export interface FeaturesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Features that matches the filter.
     * @param {FeaturesFindUniqueArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeaturesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FeaturesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Features'> extends True ? CheckSelect<T, Prisma__FeaturesClient<Features>, Prisma__FeaturesClient<FeaturesGetPayload<T>>> : CheckSelect<T, Prisma__FeaturesClient<Features | null >, Prisma__FeaturesClient<FeaturesGetPayload<T> | null >>

    /**
     * Find the first Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturesFindFirstArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeaturesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FeaturesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Features'> extends True ? CheckSelect<T, Prisma__FeaturesClient<Features>, Prisma__FeaturesClient<FeaturesGetPayload<T>>> : CheckSelect<T, Prisma__FeaturesClient<Features | null >, Prisma__FeaturesClient<FeaturesGetPayload<T> | null >>

    /**
     * Find zero or more Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Features
     * const features = await prisma.features.findMany()
     * 
     * // Get first 10 Features
     * const features = await prisma.features.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const featuresWithIdOnly = await prisma.features.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends FeaturesFindManyArgs>(
      args?: SelectSubset<T, FeaturesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Features>>, PrismaPromise<Array<FeaturesGetPayload<T>>>>

    /**
     * Create a Features.
     * @param {FeaturesCreateArgs} args - Arguments to create a Features.
     * @example
     * // Create one Features
     * const Features = await prisma.features.create({
     *   data: {
     *     // ... data to create a Features
     *   }
     * })
     * 
    **/
    create<T extends FeaturesCreateArgs>(
      args: SelectSubset<T, FeaturesCreateArgs>
    ): CheckSelect<T, Prisma__FeaturesClient<Features>, Prisma__FeaturesClient<FeaturesGetPayload<T>>>

    /**
     * Create many Features.
     *     @param {FeaturesCreateManyArgs} args - Arguments to create many Features.
     *     @example
     *     // Create many Features
     *     const features = await prisma.features.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeaturesCreateManyArgs>(
      args?: SelectSubset<T, FeaturesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Features.
     * @param {FeaturesDeleteArgs} args - Arguments to delete one Features.
     * @example
     * // Delete one Features
     * const Features = await prisma.features.delete({
     *   where: {
     *     // ... filter to delete one Features
     *   }
     * })
     * 
    **/
    delete<T extends FeaturesDeleteArgs>(
      args: SelectSubset<T, FeaturesDeleteArgs>
    ): CheckSelect<T, Prisma__FeaturesClient<Features>, Prisma__FeaturesClient<FeaturesGetPayload<T>>>

    /**
     * Update one Features.
     * @param {FeaturesUpdateArgs} args - Arguments to update one Features.
     * @example
     * // Update one Features
     * const features = await prisma.features.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeaturesUpdateArgs>(
      args: SelectSubset<T, FeaturesUpdateArgs>
    ): CheckSelect<T, Prisma__FeaturesClient<Features>, Prisma__FeaturesClient<FeaturesGetPayload<T>>>

    /**
     * Delete zero or more Features.
     * @param {FeaturesDeleteManyArgs} args - Arguments to filter Features to delete.
     * @example
     * // Delete a few Features
     * const { count } = await prisma.features.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeaturesDeleteManyArgs>(
      args?: SelectSubset<T, FeaturesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Features
     * const features = await prisma.features.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeaturesUpdateManyArgs>(
      args: SelectSubset<T, FeaturesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Features.
     * @param {FeaturesUpsertArgs} args - Arguments to update or create a Features.
     * @example
     * // Update or create a Features
     * const features = await prisma.features.upsert({
     *   create: {
     *     // ... data to create a Features
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Features we want to update
     *   }
     * })
    **/
    upsert<T extends FeaturesUpsertArgs>(
      args: SelectSubset<T, FeaturesUpsertArgs>
    ): CheckSelect<T, Prisma__FeaturesClient<Features>, Prisma__FeaturesClient<FeaturesGetPayload<T>>>

    /**
     * Count the number of Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturesCountArgs} args - Arguments to filter Features to count.
     * @example
     * // Count the number of Features
     * const count = await prisma.features.count({
     *   where: {
     *     // ... the filter for the Features we want to count
     *   }
     * })
    **/
    count<T extends FeaturesCountArgs>(
      args?: Subset<T, FeaturesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturesAggregateArgs>(args: Subset<T, FeaturesAggregateArgs>): PrismaPromise<GetFeaturesAggregateType<T>>

    /**
     * Group by Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeaturesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturesGroupByArgs['orderBy'] }
        : { orderBy?: FeaturesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeaturesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Features.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FeaturesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Features findUnique
   */
  export type FeaturesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Features
     * 
    **/
    select?: FeaturesSelect | null
    /**
     * Throw an Error if a Features can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Features to fetch.
     * 
    **/
    where: FeaturesWhereUniqueInput
  }


  /**
   * Features findFirst
   */
  export type FeaturesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Features
     * 
    **/
    select?: FeaturesSelect | null
    /**
     * Throw an Error if a Features can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Features to fetch.
     * 
    **/
    where?: FeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     * 
    **/
    orderBy?: Enumerable<FeaturesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     * 
    **/
    cursor?: FeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     * 
    **/
    distinct?: Enumerable<FeaturesScalarFieldEnum>
  }


  /**
   * Features findMany
   */
  export type FeaturesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Features
     * 
    **/
    select?: FeaturesSelect | null
    /**
     * Filter, which Features to fetch.
     * 
    **/
    where?: FeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     * 
    **/
    orderBy?: Enumerable<FeaturesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Features.
     * 
    **/
    cursor?: FeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FeaturesScalarFieldEnum>
  }


  /**
   * Features create
   */
  export type FeaturesCreateArgs = {
    /**
     * Select specific fields to fetch from the Features
     * 
    **/
    select?: FeaturesSelect | null
    /**
     * The data needed to create a Features.
     * 
    **/
    data: XOR<FeaturesCreateInput, FeaturesUncheckedCreateInput>
  }


  /**
   * Features createMany
   */
  export type FeaturesCreateManyArgs = {
    data: Enumerable<FeaturesCreateManyInput>
  }


  /**
   * Features update
   */
  export type FeaturesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Features
     * 
    **/
    select?: FeaturesSelect | null
    /**
     * The data needed to update a Features.
     * 
    **/
    data: XOR<FeaturesUpdateInput, FeaturesUncheckedUpdateInput>
    /**
     * Choose, which Features to update.
     * 
    **/
    where: FeaturesWhereUniqueInput
  }


  /**
   * Features updateMany
   */
  export type FeaturesUpdateManyArgs = {
    data: XOR<FeaturesUpdateManyMutationInput, FeaturesUncheckedUpdateManyInput>
    where?: FeaturesWhereInput
  }


  /**
   * Features upsert
   */
  export type FeaturesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Features
     * 
    **/
    select?: FeaturesSelect | null
    /**
     * The filter to search for the Features to update in case it exists.
     * 
    **/
    where: FeaturesWhereUniqueInput
    /**
     * In case the Features found by the `where` argument doesn't exist, create a new Features with this data.
     * 
    **/
    create: XOR<FeaturesCreateInput, FeaturesUncheckedCreateInput>
    /**
     * In case the Features was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FeaturesUpdateInput, FeaturesUncheckedUpdateInput>
  }


  /**
   * Features delete
   */
  export type FeaturesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Features
     * 
    **/
    select?: FeaturesSelect | null
    /**
     * Filter which Features to delete.
     * 
    **/
    where: FeaturesWhereUniqueInput
  }


  /**
   * Features deleteMany
   */
  export type FeaturesDeleteManyArgs = {
    where?: FeaturesWhereInput
  }


  /**
   * Features without action
   */
  export type FeaturesArgs = {
    /**
     * Select specific fields to fetch from the Features
     * 
    **/
    select?: FeaturesSelect | null
  }



  /**
   * Model FilterProfileConnectors
   */


  export type AggregateFilterProfileConnectors = {
    _count: FilterProfileConnectorsCountAggregateOutputType | null
    _min: FilterProfileConnectorsMinAggregateOutputType | null
    _max: FilterProfileConnectorsMaxAggregateOutputType | null
  }

  export type FilterProfileConnectorsMinAggregateOutputType = {
    Id: string | null
    RepositoryId: string | null
    ProfileId: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    CreatedBy: string | null
    ModifiedBy: string | null
  }

  export type FilterProfileConnectorsMaxAggregateOutputType = {
    Id: string | null
    RepositoryId: string | null
    ProfileId: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    CreatedBy: string | null
    ModifiedBy: string | null
  }

  export type FilterProfileConnectorsCountAggregateOutputType = {
    Id: number
    RepositoryId: number
    ProfileId: number
    CreatedDate: number
    ModifiedDate: number
    CreatedBy: number
    ModifiedBy: number
    _all: number
  }


  export type FilterProfileConnectorsMinAggregateInputType = {
    Id?: true
    RepositoryId?: true
    ProfileId?: true
    CreatedDate?: true
    ModifiedDate?: true
    CreatedBy?: true
    ModifiedBy?: true
  }

  export type FilterProfileConnectorsMaxAggregateInputType = {
    Id?: true
    RepositoryId?: true
    ProfileId?: true
    CreatedDate?: true
    ModifiedDate?: true
    CreatedBy?: true
    ModifiedBy?: true
  }

  export type FilterProfileConnectorsCountAggregateInputType = {
    Id?: true
    RepositoryId?: true
    ProfileId?: true
    CreatedDate?: true
    ModifiedDate?: true
    CreatedBy?: true
    ModifiedBy?: true
    _all?: true
  }

  export type FilterProfileConnectorsAggregateArgs = {
    /**
     * Filter which FilterProfileConnectors to aggregate.
     * 
    **/
    where?: FilterProfileConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilterProfileConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<FilterProfileConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FilterProfileConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilterProfileConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilterProfileConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FilterProfileConnectors
    **/
    _count?: true | FilterProfileConnectorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilterProfileConnectorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilterProfileConnectorsMaxAggregateInputType
  }

  export type GetFilterProfileConnectorsAggregateType<T extends FilterProfileConnectorsAggregateArgs> = {
        [P in keyof T & keyof AggregateFilterProfileConnectors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilterProfileConnectors[P]>
      : GetScalarType<T[P], AggregateFilterProfileConnectors[P]>
  }




  export type FilterProfileConnectorsGroupByArgs = {
    where?: FilterProfileConnectorsWhereInput
    orderBy?: Enumerable<FilterProfileConnectorsOrderByWithAggregationInput>
    by: Array<FilterProfileConnectorsScalarFieldEnum>
    having?: FilterProfileConnectorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilterProfileConnectorsCountAggregateInputType | true
    _min?: FilterProfileConnectorsMinAggregateInputType
    _max?: FilterProfileConnectorsMaxAggregateInputType
  }


  export type FilterProfileConnectorsGroupByOutputType = {
    Id: string
    RepositoryId: string
    ProfileId: string
    CreatedDate: Date | null
    ModifiedDate: Date | null
    CreatedBy: string | null
    ModifiedBy: string | null
    _count: FilterProfileConnectorsCountAggregateOutputType | null
    _min: FilterProfileConnectorsMinAggregateOutputType | null
    _max: FilterProfileConnectorsMaxAggregateOutputType | null
  }

  type GetFilterProfileConnectorsGroupByPayload<T extends FilterProfileConnectorsGroupByArgs> = Promise<
    Array<
      PickArray<FilterProfileConnectorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilterProfileConnectorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilterProfileConnectorsGroupByOutputType[P]>
            : GetScalarType<T[P], FilterProfileConnectorsGroupByOutputType[P]>
        }
      >
    >


  export type FilterProfileConnectorsSelect = {
    Id?: boolean
    RepositoryId?: boolean
    ProfileId?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
    CreatedBy?: boolean
    ModifiedBy?: boolean
  }

  export type FilterProfileConnectorsGetPayload<
    S extends boolean | null | undefined | FilterProfileConnectorsArgs,
    U = keyof S
      > = S extends true
        ? FilterProfileConnectors
    : S extends undefined
    ? never
    : S extends FilterProfileConnectorsArgs | FilterProfileConnectorsFindManyArgs
    ?'include' extends U
    ? FilterProfileConnectors 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof FilterProfileConnectors ?FilterProfileConnectors [P]
  : 
     never
  } 
    : FilterProfileConnectors
  : FilterProfileConnectors


  type FilterProfileConnectorsCountArgs = Merge<
    Omit<FilterProfileConnectorsFindManyArgs, 'select' | 'include'> & {
      select?: FilterProfileConnectorsCountAggregateInputType | true
    }
  >

  export interface FilterProfileConnectorsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one FilterProfileConnectors that matches the filter.
     * @param {FilterProfileConnectorsFindUniqueArgs} args - Arguments to find a FilterProfileConnectors
     * @example
     * // Get one FilterProfileConnectors
     * const filterProfileConnectors = await prisma.filterProfileConnectors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FilterProfileConnectorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FilterProfileConnectorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FilterProfileConnectors'> extends True ? CheckSelect<T, Prisma__FilterProfileConnectorsClient<FilterProfileConnectors>, Prisma__FilterProfileConnectorsClient<FilterProfileConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__FilterProfileConnectorsClient<FilterProfileConnectors | null >, Prisma__FilterProfileConnectorsClient<FilterProfileConnectorsGetPayload<T> | null >>

    /**
     * Find the first FilterProfileConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterProfileConnectorsFindFirstArgs} args - Arguments to find a FilterProfileConnectors
     * @example
     * // Get one FilterProfileConnectors
     * const filterProfileConnectors = await prisma.filterProfileConnectors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FilterProfileConnectorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FilterProfileConnectorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FilterProfileConnectors'> extends True ? CheckSelect<T, Prisma__FilterProfileConnectorsClient<FilterProfileConnectors>, Prisma__FilterProfileConnectorsClient<FilterProfileConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__FilterProfileConnectorsClient<FilterProfileConnectors | null >, Prisma__FilterProfileConnectorsClient<FilterProfileConnectorsGetPayload<T> | null >>

    /**
     * Find zero or more FilterProfileConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterProfileConnectorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FilterProfileConnectors
     * const filterProfileConnectors = await prisma.filterProfileConnectors.findMany()
     * 
     * // Get first 10 FilterProfileConnectors
     * const filterProfileConnectors = await prisma.filterProfileConnectors.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const filterProfileConnectorsWithIdOnly = await prisma.filterProfileConnectors.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends FilterProfileConnectorsFindManyArgs>(
      args?: SelectSubset<T, FilterProfileConnectorsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<FilterProfileConnectors>>, PrismaPromise<Array<FilterProfileConnectorsGetPayload<T>>>>

    /**
     * Create a FilterProfileConnectors.
     * @param {FilterProfileConnectorsCreateArgs} args - Arguments to create a FilterProfileConnectors.
     * @example
     * // Create one FilterProfileConnectors
     * const FilterProfileConnectors = await prisma.filterProfileConnectors.create({
     *   data: {
     *     // ... data to create a FilterProfileConnectors
     *   }
     * })
     * 
    **/
    create<T extends FilterProfileConnectorsCreateArgs>(
      args: SelectSubset<T, FilterProfileConnectorsCreateArgs>
    ): CheckSelect<T, Prisma__FilterProfileConnectorsClient<FilterProfileConnectors>, Prisma__FilterProfileConnectorsClient<FilterProfileConnectorsGetPayload<T>>>

    /**
     * Create many FilterProfileConnectors.
     *     @param {FilterProfileConnectorsCreateManyArgs} args - Arguments to create many FilterProfileConnectors.
     *     @example
     *     // Create many FilterProfileConnectors
     *     const filterProfileConnectors = await prisma.filterProfileConnectors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FilterProfileConnectorsCreateManyArgs>(
      args?: SelectSubset<T, FilterProfileConnectorsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FilterProfileConnectors.
     * @param {FilterProfileConnectorsDeleteArgs} args - Arguments to delete one FilterProfileConnectors.
     * @example
     * // Delete one FilterProfileConnectors
     * const FilterProfileConnectors = await prisma.filterProfileConnectors.delete({
     *   where: {
     *     // ... filter to delete one FilterProfileConnectors
     *   }
     * })
     * 
    **/
    delete<T extends FilterProfileConnectorsDeleteArgs>(
      args: SelectSubset<T, FilterProfileConnectorsDeleteArgs>
    ): CheckSelect<T, Prisma__FilterProfileConnectorsClient<FilterProfileConnectors>, Prisma__FilterProfileConnectorsClient<FilterProfileConnectorsGetPayload<T>>>

    /**
     * Update one FilterProfileConnectors.
     * @param {FilterProfileConnectorsUpdateArgs} args - Arguments to update one FilterProfileConnectors.
     * @example
     * // Update one FilterProfileConnectors
     * const filterProfileConnectors = await prisma.filterProfileConnectors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FilterProfileConnectorsUpdateArgs>(
      args: SelectSubset<T, FilterProfileConnectorsUpdateArgs>
    ): CheckSelect<T, Prisma__FilterProfileConnectorsClient<FilterProfileConnectors>, Prisma__FilterProfileConnectorsClient<FilterProfileConnectorsGetPayload<T>>>

    /**
     * Delete zero or more FilterProfileConnectors.
     * @param {FilterProfileConnectorsDeleteManyArgs} args - Arguments to filter FilterProfileConnectors to delete.
     * @example
     * // Delete a few FilterProfileConnectors
     * const { count } = await prisma.filterProfileConnectors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FilterProfileConnectorsDeleteManyArgs>(
      args?: SelectSubset<T, FilterProfileConnectorsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FilterProfileConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterProfileConnectorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FilterProfileConnectors
     * const filterProfileConnectors = await prisma.filterProfileConnectors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FilterProfileConnectorsUpdateManyArgs>(
      args: SelectSubset<T, FilterProfileConnectorsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FilterProfileConnectors.
     * @param {FilterProfileConnectorsUpsertArgs} args - Arguments to update or create a FilterProfileConnectors.
     * @example
     * // Update or create a FilterProfileConnectors
     * const filterProfileConnectors = await prisma.filterProfileConnectors.upsert({
     *   create: {
     *     // ... data to create a FilterProfileConnectors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FilterProfileConnectors we want to update
     *   }
     * })
    **/
    upsert<T extends FilterProfileConnectorsUpsertArgs>(
      args: SelectSubset<T, FilterProfileConnectorsUpsertArgs>
    ): CheckSelect<T, Prisma__FilterProfileConnectorsClient<FilterProfileConnectors>, Prisma__FilterProfileConnectorsClient<FilterProfileConnectorsGetPayload<T>>>

    /**
     * Count the number of FilterProfileConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterProfileConnectorsCountArgs} args - Arguments to filter FilterProfileConnectors to count.
     * @example
     * // Count the number of FilterProfileConnectors
     * const count = await prisma.filterProfileConnectors.count({
     *   where: {
     *     // ... the filter for the FilterProfileConnectors we want to count
     *   }
     * })
    **/
    count<T extends FilterProfileConnectorsCountArgs>(
      args?: Subset<T, FilterProfileConnectorsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilterProfileConnectorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FilterProfileConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterProfileConnectorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilterProfileConnectorsAggregateArgs>(args: Subset<T, FilterProfileConnectorsAggregateArgs>): PrismaPromise<GetFilterProfileConnectorsAggregateType<T>>

    /**
     * Group by FilterProfileConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterProfileConnectorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilterProfileConnectorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilterProfileConnectorsGroupByArgs['orderBy'] }
        : { orderBy?: FilterProfileConnectorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilterProfileConnectorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilterProfileConnectorsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for FilterProfileConnectors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FilterProfileConnectorsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * FilterProfileConnectors findUnique
   */
  export type FilterProfileConnectorsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the FilterProfileConnectors
     * 
    **/
    select?: FilterProfileConnectorsSelect | null
    /**
     * Throw an Error if a FilterProfileConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FilterProfileConnectors to fetch.
     * 
    **/
    where: FilterProfileConnectorsWhereUniqueInput
  }


  /**
   * FilterProfileConnectors findFirst
   */
  export type FilterProfileConnectorsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the FilterProfileConnectors
     * 
    **/
    select?: FilterProfileConnectorsSelect | null
    /**
     * Throw an Error if a FilterProfileConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FilterProfileConnectors to fetch.
     * 
    **/
    where?: FilterProfileConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilterProfileConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<FilterProfileConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilterProfileConnectors.
     * 
    **/
    cursor?: FilterProfileConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilterProfileConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilterProfileConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilterProfileConnectors.
     * 
    **/
    distinct?: Enumerable<FilterProfileConnectorsScalarFieldEnum>
  }


  /**
   * FilterProfileConnectors findMany
   */
  export type FilterProfileConnectorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the FilterProfileConnectors
     * 
    **/
    select?: FilterProfileConnectorsSelect | null
    /**
     * Filter, which FilterProfileConnectors to fetch.
     * 
    **/
    where?: FilterProfileConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilterProfileConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<FilterProfileConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FilterProfileConnectors.
     * 
    **/
    cursor?: FilterProfileConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilterProfileConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilterProfileConnectors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FilterProfileConnectorsScalarFieldEnum>
  }


  /**
   * FilterProfileConnectors create
   */
  export type FilterProfileConnectorsCreateArgs = {
    /**
     * Select specific fields to fetch from the FilterProfileConnectors
     * 
    **/
    select?: FilterProfileConnectorsSelect | null
    /**
     * The data needed to create a FilterProfileConnectors.
     * 
    **/
    data: XOR<FilterProfileConnectorsCreateInput, FilterProfileConnectorsUncheckedCreateInput>
  }


  /**
   * FilterProfileConnectors createMany
   */
  export type FilterProfileConnectorsCreateManyArgs = {
    data: Enumerable<FilterProfileConnectorsCreateManyInput>
  }


  /**
   * FilterProfileConnectors update
   */
  export type FilterProfileConnectorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the FilterProfileConnectors
     * 
    **/
    select?: FilterProfileConnectorsSelect | null
    /**
     * The data needed to update a FilterProfileConnectors.
     * 
    **/
    data: XOR<FilterProfileConnectorsUpdateInput, FilterProfileConnectorsUncheckedUpdateInput>
    /**
     * Choose, which FilterProfileConnectors to update.
     * 
    **/
    where: FilterProfileConnectorsWhereUniqueInput
  }


  /**
   * FilterProfileConnectors updateMany
   */
  export type FilterProfileConnectorsUpdateManyArgs = {
    data: XOR<FilterProfileConnectorsUpdateManyMutationInput, FilterProfileConnectorsUncheckedUpdateManyInput>
    where?: FilterProfileConnectorsWhereInput
  }


  /**
   * FilterProfileConnectors upsert
   */
  export type FilterProfileConnectorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the FilterProfileConnectors
     * 
    **/
    select?: FilterProfileConnectorsSelect | null
    /**
     * The filter to search for the FilterProfileConnectors to update in case it exists.
     * 
    **/
    where: FilterProfileConnectorsWhereUniqueInput
    /**
     * In case the FilterProfileConnectors found by the `where` argument doesn't exist, create a new FilterProfileConnectors with this data.
     * 
    **/
    create: XOR<FilterProfileConnectorsCreateInput, FilterProfileConnectorsUncheckedCreateInput>
    /**
     * In case the FilterProfileConnectors was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FilterProfileConnectorsUpdateInput, FilterProfileConnectorsUncheckedUpdateInput>
  }


  /**
   * FilterProfileConnectors delete
   */
  export type FilterProfileConnectorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the FilterProfileConnectors
     * 
    **/
    select?: FilterProfileConnectorsSelect | null
    /**
     * Filter which FilterProfileConnectors to delete.
     * 
    **/
    where: FilterProfileConnectorsWhereUniqueInput
  }


  /**
   * FilterProfileConnectors deleteMany
   */
  export type FilterProfileConnectorsDeleteManyArgs = {
    where?: FilterProfileConnectorsWhereInput
  }


  /**
   * FilterProfileConnectors without action
   */
  export type FilterProfileConnectorsArgs = {
    /**
     * Select specific fields to fetch from the FilterProfileConnectors
     * 
    **/
    select?: FilterProfileConnectorsSelect | null
  }



  /**
   * Model FilterProfiles
   */


  export type AggregateFilterProfiles = {
    _count: FilterProfilesCountAggregateOutputType | null
    _avg: FilterProfilesAvgAggregateOutputType | null
    _sum: FilterProfilesSumAggregateOutputType | null
    _min: FilterProfilesMinAggregateOutputType | null
    _max: FilterProfilesMaxAggregateOutputType | null
  }

  export type FilterProfilesAvgAggregateOutputType = {
    Status: number | null
    IsCacheEnabled: number | null
  }

  export type FilterProfilesSumAggregateOutputType = {
    Status: number | null
    IsCacheEnabled: number | null
  }

  export type FilterProfilesMinAggregateOutputType = {
    Id: string | null
    Name: string | null
    Type: string | null
    Status: number | null
    Configuration: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    CreatedBy: string | null
    ModifiedBy: string | null
    IsCacheEnabled: number | null
  }

  export type FilterProfilesMaxAggregateOutputType = {
    Id: string | null
    Name: string | null
    Type: string | null
    Status: number | null
    Configuration: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    CreatedBy: string | null
    ModifiedBy: string | null
    IsCacheEnabled: number | null
  }

  export type FilterProfilesCountAggregateOutputType = {
    Id: number
    Name: number
    Type: number
    Status: number
    Configuration: number
    CreatedDate: number
    ModifiedDate: number
    CreatedBy: number
    ModifiedBy: number
    IsCacheEnabled: number
    _all: number
  }


  export type FilterProfilesAvgAggregateInputType = {
    Status?: true
    IsCacheEnabled?: true
  }

  export type FilterProfilesSumAggregateInputType = {
    Status?: true
    IsCacheEnabled?: true
  }

  export type FilterProfilesMinAggregateInputType = {
    Id?: true
    Name?: true
    Type?: true
    Status?: true
    Configuration?: true
    CreatedDate?: true
    ModifiedDate?: true
    CreatedBy?: true
    ModifiedBy?: true
    IsCacheEnabled?: true
  }

  export type FilterProfilesMaxAggregateInputType = {
    Id?: true
    Name?: true
    Type?: true
    Status?: true
    Configuration?: true
    CreatedDate?: true
    ModifiedDate?: true
    CreatedBy?: true
    ModifiedBy?: true
    IsCacheEnabled?: true
  }

  export type FilterProfilesCountAggregateInputType = {
    Id?: true
    Name?: true
    Type?: true
    Status?: true
    Configuration?: true
    CreatedDate?: true
    ModifiedDate?: true
    CreatedBy?: true
    ModifiedBy?: true
    IsCacheEnabled?: true
    _all?: true
  }

  export type FilterProfilesAggregateArgs = {
    /**
     * Filter which FilterProfiles to aggregate.
     * 
    **/
    where?: FilterProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilterProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<FilterProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FilterProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilterProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilterProfiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FilterProfiles
    **/
    _count?: true | FilterProfilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilterProfilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilterProfilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilterProfilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilterProfilesMaxAggregateInputType
  }

  export type GetFilterProfilesAggregateType<T extends FilterProfilesAggregateArgs> = {
        [P in keyof T & keyof AggregateFilterProfiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilterProfiles[P]>
      : GetScalarType<T[P], AggregateFilterProfiles[P]>
  }




  export type FilterProfilesGroupByArgs = {
    where?: FilterProfilesWhereInput
    orderBy?: Enumerable<FilterProfilesOrderByWithAggregationInput>
    by: Array<FilterProfilesScalarFieldEnum>
    having?: FilterProfilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilterProfilesCountAggregateInputType | true
    _avg?: FilterProfilesAvgAggregateInputType
    _sum?: FilterProfilesSumAggregateInputType
    _min?: FilterProfilesMinAggregateInputType
    _max?: FilterProfilesMaxAggregateInputType
  }


  export type FilterProfilesGroupByOutputType = {
    Id: string
    Name: string | null
    Type: string | null
    Status: number
    Configuration: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    CreatedBy: string | null
    ModifiedBy: string | null
    IsCacheEnabled: number | null
    _count: FilterProfilesCountAggregateOutputType | null
    _avg: FilterProfilesAvgAggregateOutputType | null
    _sum: FilterProfilesSumAggregateOutputType | null
    _min: FilterProfilesMinAggregateOutputType | null
    _max: FilterProfilesMaxAggregateOutputType | null
  }

  type GetFilterProfilesGroupByPayload<T extends FilterProfilesGroupByArgs> = Promise<
    Array<
      PickArray<FilterProfilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilterProfilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilterProfilesGroupByOutputType[P]>
            : GetScalarType<T[P], FilterProfilesGroupByOutputType[P]>
        }
      >
    >


  export type FilterProfilesSelect = {
    Id?: boolean
    Name?: boolean
    Type?: boolean
    Status?: boolean
    Configuration?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
    CreatedBy?: boolean
    ModifiedBy?: boolean
    IsCacheEnabled?: boolean
  }

  export type FilterProfilesGetPayload<
    S extends boolean | null | undefined | FilterProfilesArgs,
    U = keyof S
      > = S extends true
        ? FilterProfiles
    : S extends undefined
    ? never
    : S extends FilterProfilesArgs | FilterProfilesFindManyArgs
    ?'include' extends U
    ? FilterProfiles 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof FilterProfiles ?FilterProfiles [P]
  : 
     never
  } 
    : FilterProfiles
  : FilterProfiles


  type FilterProfilesCountArgs = Merge<
    Omit<FilterProfilesFindManyArgs, 'select' | 'include'> & {
      select?: FilterProfilesCountAggregateInputType | true
    }
  >

  export interface FilterProfilesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one FilterProfiles that matches the filter.
     * @param {FilterProfilesFindUniqueArgs} args - Arguments to find a FilterProfiles
     * @example
     * // Get one FilterProfiles
     * const filterProfiles = await prisma.filterProfiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FilterProfilesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FilterProfilesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FilterProfiles'> extends True ? CheckSelect<T, Prisma__FilterProfilesClient<FilterProfiles>, Prisma__FilterProfilesClient<FilterProfilesGetPayload<T>>> : CheckSelect<T, Prisma__FilterProfilesClient<FilterProfiles | null >, Prisma__FilterProfilesClient<FilterProfilesGetPayload<T> | null >>

    /**
     * Find the first FilterProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterProfilesFindFirstArgs} args - Arguments to find a FilterProfiles
     * @example
     * // Get one FilterProfiles
     * const filterProfiles = await prisma.filterProfiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FilterProfilesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FilterProfilesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FilterProfiles'> extends True ? CheckSelect<T, Prisma__FilterProfilesClient<FilterProfiles>, Prisma__FilterProfilesClient<FilterProfilesGetPayload<T>>> : CheckSelect<T, Prisma__FilterProfilesClient<FilterProfiles | null >, Prisma__FilterProfilesClient<FilterProfilesGetPayload<T> | null >>

    /**
     * Find zero or more FilterProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterProfilesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FilterProfiles
     * const filterProfiles = await prisma.filterProfiles.findMany()
     * 
     * // Get first 10 FilterProfiles
     * const filterProfiles = await prisma.filterProfiles.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const filterProfilesWithIdOnly = await prisma.filterProfiles.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends FilterProfilesFindManyArgs>(
      args?: SelectSubset<T, FilterProfilesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<FilterProfiles>>, PrismaPromise<Array<FilterProfilesGetPayload<T>>>>

    /**
     * Create a FilterProfiles.
     * @param {FilterProfilesCreateArgs} args - Arguments to create a FilterProfiles.
     * @example
     * // Create one FilterProfiles
     * const FilterProfiles = await prisma.filterProfiles.create({
     *   data: {
     *     // ... data to create a FilterProfiles
     *   }
     * })
     * 
    **/
    create<T extends FilterProfilesCreateArgs>(
      args: SelectSubset<T, FilterProfilesCreateArgs>
    ): CheckSelect<T, Prisma__FilterProfilesClient<FilterProfiles>, Prisma__FilterProfilesClient<FilterProfilesGetPayload<T>>>

    /**
     * Create many FilterProfiles.
     *     @param {FilterProfilesCreateManyArgs} args - Arguments to create many FilterProfiles.
     *     @example
     *     // Create many FilterProfiles
     *     const filterProfiles = await prisma.filterProfiles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FilterProfilesCreateManyArgs>(
      args?: SelectSubset<T, FilterProfilesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FilterProfiles.
     * @param {FilterProfilesDeleteArgs} args - Arguments to delete one FilterProfiles.
     * @example
     * // Delete one FilterProfiles
     * const FilterProfiles = await prisma.filterProfiles.delete({
     *   where: {
     *     // ... filter to delete one FilterProfiles
     *   }
     * })
     * 
    **/
    delete<T extends FilterProfilesDeleteArgs>(
      args: SelectSubset<T, FilterProfilesDeleteArgs>
    ): CheckSelect<T, Prisma__FilterProfilesClient<FilterProfiles>, Prisma__FilterProfilesClient<FilterProfilesGetPayload<T>>>

    /**
     * Update one FilterProfiles.
     * @param {FilterProfilesUpdateArgs} args - Arguments to update one FilterProfiles.
     * @example
     * // Update one FilterProfiles
     * const filterProfiles = await prisma.filterProfiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FilterProfilesUpdateArgs>(
      args: SelectSubset<T, FilterProfilesUpdateArgs>
    ): CheckSelect<T, Prisma__FilterProfilesClient<FilterProfiles>, Prisma__FilterProfilesClient<FilterProfilesGetPayload<T>>>

    /**
     * Delete zero or more FilterProfiles.
     * @param {FilterProfilesDeleteManyArgs} args - Arguments to filter FilterProfiles to delete.
     * @example
     * // Delete a few FilterProfiles
     * const { count } = await prisma.filterProfiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FilterProfilesDeleteManyArgs>(
      args?: SelectSubset<T, FilterProfilesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FilterProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterProfilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FilterProfiles
     * const filterProfiles = await prisma.filterProfiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FilterProfilesUpdateManyArgs>(
      args: SelectSubset<T, FilterProfilesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FilterProfiles.
     * @param {FilterProfilesUpsertArgs} args - Arguments to update or create a FilterProfiles.
     * @example
     * // Update or create a FilterProfiles
     * const filterProfiles = await prisma.filterProfiles.upsert({
     *   create: {
     *     // ... data to create a FilterProfiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FilterProfiles we want to update
     *   }
     * })
    **/
    upsert<T extends FilterProfilesUpsertArgs>(
      args: SelectSubset<T, FilterProfilesUpsertArgs>
    ): CheckSelect<T, Prisma__FilterProfilesClient<FilterProfiles>, Prisma__FilterProfilesClient<FilterProfilesGetPayload<T>>>

    /**
     * Count the number of FilterProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterProfilesCountArgs} args - Arguments to filter FilterProfiles to count.
     * @example
     * // Count the number of FilterProfiles
     * const count = await prisma.filterProfiles.count({
     *   where: {
     *     // ... the filter for the FilterProfiles we want to count
     *   }
     * })
    **/
    count<T extends FilterProfilesCountArgs>(
      args?: Subset<T, FilterProfilesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilterProfilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FilterProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterProfilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilterProfilesAggregateArgs>(args: Subset<T, FilterProfilesAggregateArgs>): PrismaPromise<GetFilterProfilesAggregateType<T>>

    /**
     * Group by FilterProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterProfilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilterProfilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilterProfilesGroupByArgs['orderBy'] }
        : { orderBy?: FilterProfilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilterProfilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilterProfilesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for FilterProfiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FilterProfilesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * FilterProfiles findUnique
   */
  export type FilterProfilesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the FilterProfiles
     * 
    **/
    select?: FilterProfilesSelect | null
    /**
     * Throw an Error if a FilterProfiles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FilterProfiles to fetch.
     * 
    **/
    where: FilterProfilesWhereUniqueInput
  }


  /**
   * FilterProfiles findFirst
   */
  export type FilterProfilesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the FilterProfiles
     * 
    **/
    select?: FilterProfilesSelect | null
    /**
     * Throw an Error if a FilterProfiles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FilterProfiles to fetch.
     * 
    **/
    where?: FilterProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilterProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<FilterProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilterProfiles.
     * 
    **/
    cursor?: FilterProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilterProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilterProfiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilterProfiles.
     * 
    **/
    distinct?: Enumerable<FilterProfilesScalarFieldEnum>
  }


  /**
   * FilterProfiles findMany
   */
  export type FilterProfilesFindManyArgs = {
    /**
     * Select specific fields to fetch from the FilterProfiles
     * 
    **/
    select?: FilterProfilesSelect | null
    /**
     * Filter, which FilterProfiles to fetch.
     * 
    **/
    where?: FilterProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilterProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<FilterProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FilterProfiles.
     * 
    **/
    cursor?: FilterProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilterProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilterProfiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FilterProfilesScalarFieldEnum>
  }


  /**
   * FilterProfiles create
   */
  export type FilterProfilesCreateArgs = {
    /**
     * Select specific fields to fetch from the FilterProfiles
     * 
    **/
    select?: FilterProfilesSelect | null
    /**
     * The data needed to create a FilterProfiles.
     * 
    **/
    data: XOR<FilterProfilesCreateInput, FilterProfilesUncheckedCreateInput>
  }


  /**
   * FilterProfiles createMany
   */
  export type FilterProfilesCreateManyArgs = {
    data: Enumerable<FilterProfilesCreateManyInput>
  }


  /**
   * FilterProfiles update
   */
  export type FilterProfilesUpdateArgs = {
    /**
     * Select specific fields to fetch from the FilterProfiles
     * 
    **/
    select?: FilterProfilesSelect | null
    /**
     * The data needed to update a FilterProfiles.
     * 
    **/
    data: XOR<FilterProfilesUpdateInput, FilterProfilesUncheckedUpdateInput>
    /**
     * Choose, which FilterProfiles to update.
     * 
    **/
    where: FilterProfilesWhereUniqueInput
  }


  /**
   * FilterProfiles updateMany
   */
  export type FilterProfilesUpdateManyArgs = {
    data: XOR<FilterProfilesUpdateManyMutationInput, FilterProfilesUncheckedUpdateManyInput>
    where?: FilterProfilesWhereInput
  }


  /**
   * FilterProfiles upsert
   */
  export type FilterProfilesUpsertArgs = {
    /**
     * Select specific fields to fetch from the FilterProfiles
     * 
    **/
    select?: FilterProfilesSelect | null
    /**
     * The filter to search for the FilterProfiles to update in case it exists.
     * 
    **/
    where: FilterProfilesWhereUniqueInput
    /**
     * In case the FilterProfiles found by the `where` argument doesn't exist, create a new FilterProfiles with this data.
     * 
    **/
    create: XOR<FilterProfilesCreateInput, FilterProfilesUncheckedCreateInput>
    /**
     * In case the FilterProfiles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FilterProfilesUpdateInput, FilterProfilesUncheckedUpdateInput>
  }


  /**
   * FilterProfiles delete
   */
  export type FilterProfilesDeleteArgs = {
    /**
     * Select specific fields to fetch from the FilterProfiles
     * 
    **/
    select?: FilterProfilesSelect | null
    /**
     * Filter which FilterProfiles to delete.
     * 
    **/
    where: FilterProfilesWhereUniqueInput
  }


  /**
   * FilterProfiles deleteMany
   */
  export type FilterProfilesDeleteManyArgs = {
    where?: FilterProfilesWhereInput
  }


  /**
   * FilterProfiles without action
   */
  export type FilterProfilesArgs = {
    /**
     * Select specific fields to fetch from the FilterProfiles
     * 
    **/
    select?: FilterProfilesSelect | null
  }



  /**
   * Model GlobalRepositoryConfigurations
   */


  export type AggregateGlobalRepositoryConfigurations = {
    _count: GlobalRepositoryConfigurationsCountAggregateOutputType | null
    _avg: GlobalRepositoryConfigurationsAvgAggregateOutputType | null
    _sum: GlobalRepositoryConfigurationsSumAggregateOutputType | null
    _min: GlobalRepositoryConfigurationsMinAggregateOutputType | null
    _max: GlobalRepositoryConfigurationsMaxAggregateOutputType | null
  }

  export type GlobalRepositoryConfigurationsAvgAggregateOutputType = {
    IsReadOnly: number | null
    AllowAllRepository: number | null
  }

  export type GlobalRepositoryConfigurationsSumAggregateOutputType = {
    IsReadOnly: number | null
    AllowAllRepository: number | null
  }

  export type GlobalRepositoryConfigurationsMinAggregateOutputType = {
    Id: string | null
    Name: string | null
    IsReadOnly: number | null
    RepositoryConfiguration: string | null
    AllowAllRepository: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type GlobalRepositoryConfigurationsMaxAggregateOutputType = {
    Id: string | null
    Name: string | null
    IsReadOnly: number | null
    RepositoryConfiguration: string | null
    AllowAllRepository: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type GlobalRepositoryConfigurationsCountAggregateOutputType = {
    Id: number
    Name: number
    IsReadOnly: number
    RepositoryConfiguration: number
    AllowAllRepository: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type GlobalRepositoryConfigurationsAvgAggregateInputType = {
    IsReadOnly?: true
    AllowAllRepository?: true
  }

  export type GlobalRepositoryConfigurationsSumAggregateInputType = {
    IsReadOnly?: true
    AllowAllRepository?: true
  }

  export type GlobalRepositoryConfigurationsMinAggregateInputType = {
    Id?: true
    Name?: true
    IsReadOnly?: true
    RepositoryConfiguration?: true
    AllowAllRepository?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type GlobalRepositoryConfigurationsMaxAggregateInputType = {
    Id?: true
    Name?: true
    IsReadOnly?: true
    RepositoryConfiguration?: true
    AllowAllRepository?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type GlobalRepositoryConfigurationsCountAggregateInputType = {
    Id?: true
    Name?: true
    IsReadOnly?: true
    RepositoryConfiguration?: true
    AllowAllRepository?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type GlobalRepositoryConfigurationsAggregateArgs = {
    /**
     * Filter which GlobalRepositoryConfigurations to aggregate.
     * 
    **/
    where?: GlobalRepositoryConfigurationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalRepositoryConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<GlobalRepositoryConfigurationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GlobalRepositoryConfigurationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalRepositoryConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalRepositoryConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GlobalRepositoryConfigurations
    **/
    _count?: true | GlobalRepositoryConfigurationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GlobalRepositoryConfigurationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GlobalRepositoryConfigurationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlobalRepositoryConfigurationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlobalRepositoryConfigurationsMaxAggregateInputType
  }

  export type GetGlobalRepositoryConfigurationsAggregateType<T extends GlobalRepositoryConfigurationsAggregateArgs> = {
        [P in keyof T & keyof AggregateGlobalRepositoryConfigurations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlobalRepositoryConfigurations[P]>
      : GetScalarType<T[P], AggregateGlobalRepositoryConfigurations[P]>
  }




  export type GlobalRepositoryConfigurationsGroupByArgs = {
    where?: GlobalRepositoryConfigurationsWhereInput
    orderBy?: Enumerable<GlobalRepositoryConfigurationsOrderByWithAggregationInput>
    by: Array<GlobalRepositoryConfigurationsScalarFieldEnum>
    having?: GlobalRepositoryConfigurationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlobalRepositoryConfigurationsCountAggregateInputType | true
    _avg?: GlobalRepositoryConfigurationsAvgAggregateInputType
    _sum?: GlobalRepositoryConfigurationsSumAggregateInputType
    _min?: GlobalRepositoryConfigurationsMinAggregateInputType
    _max?: GlobalRepositoryConfigurationsMaxAggregateInputType
  }


  export type GlobalRepositoryConfigurationsGroupByOutputType = {
    Id: string
    Name: string
    IsReadOnly: number
    RepositoryConfiguration: string | null
    AllowAllRepository: number
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: GlobalRepositoryConfigurationsCountAggregateOutputType | null
    _avg: GlobalRepositoryConfigurationsAvgAggregateOutputType | null
    _sum: GlobalRepositoryConfigurationsSumAggregateOutputType | null
    _min: GlobalRepositoryConfigurationsMinAggregateOutputType | null
    _max: GlobalRepositoryConfigurationsMaxAggregateOutputType | null
  }

  type GetGlobalRepositoryConfigurationsGroupByPayload<T extends GlobalRepositoryConfigurationsGroupByArgs> = Promise<
    Array<
      PickArray<GlobalRepositoryConfigurationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlobalRepositoryConfigurationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlobalRepositoryConfigurationsGroupByOutputType[P]>
            : GetScalarType<T[P], GlobalRepositoryConfigurationsGroupByOutputType[P]>
        }
      >
    >


  export type GlobalRepositoryConfigurationsSelect = {
    Id?: boolean
    Name?: boolean
    IsReadOnly?: boolean
    RepositoryConfiguration?: boolean
    AllowAllRepository?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type GlobalRepositoryConfigurationsGetPayload<
    S extends boolean | null | undefined | GlobalRepositoryConfigurationsArgs,
    U = keyof S
      > = S extends true
        ? GlobalRepositoryConfigurations
    : S extends undefined
    ? never
    : S extends GlobalRepositoryConfigurationsArgs | GlobalRepositoryConfigurationsFindManyArgs
    ?'include' extends U
    ? GlobalRepositoryConfigurations 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof GlobalRepositoryConfigurations ?GlobalRepositoryConfigurations [P]
  : 
     never
  } 
    : GlobalRepositoryConfigurations
  : GlobalRepositoryConfigurations


  type GlobalRepositoryConfigurationsCountArgs = Merge<
    Omit<GlobalRepositoryConfigurationsFindManyArgs, 'select' | 'include'> & {
      select?: GlobalRepositoryConfigurationsCountAggregateInputType | true
    }
  >

  export interface GlobalRepositoryConfigurationsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one GlobalRepositoryConfigurations that matches the filter.
     * @param {GlobalRepositoryConfigurationsFindUniqueArgs} args - Arguments to find a GlobalRepositoryConfigurations
     * @example
     * // Get one GlobalRepositoryConfigurations
     * const globalRepositoryConfigurations = await prisma.globalRepositoryConfigurations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GlobalRepositoryConfigurationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GlobalRepositoryConfigurationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GlobalRepositoryConfigurations'> extends True ? CheckSelect<T, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurations>, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurationsGetPayload<T>>> : CheckSelect<T, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurations | null >, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurationsGetPayload<T> | null >>

    /**
     * Find the first GlobalRepositoryConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalRepositoryConfigurationsFindFirstArgs} args - Arguments to find a GlobalRepositoryConfigurations
     * @example
     * // Get one GlobalRepositoryConfigurations
     * const globalRepositoryConfigurations = await prisma.globalRepositoryConfigurations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GlobalRepositoryConfigurationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GlobalRepositoryConfigurationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GlobalRepositoryConfigurations'> extends True ? CheckSelect<T, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurations>, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurationsGetPayload<T>>> : CheckSelect<T, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurations | null >, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurationsGetPayload<T> | null >>

    /**
     * Find zero or more GlobalRepositoryConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalRepositoryConfigurationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GlobalRepositoryConfigurations
     * const globalRepositoryConfigurations = await prisma.globalRepositoryConfigurations.findMany()
     * 
     * // Get first 10 GlobalRepositoryConfigurations
     * const globalRepositoryConfigurations = await prisma.globalRepositoryConfigurations.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const globalRepositoryConfigurationsWithIdOnly = await prisma.globalRepositoryConfigurations.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends GlobalRepositoryConfigurationsFindManyArgs>(
      args?: SelectSubset<T, GlobalRepositoryConfigurationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GlobalRepositoryConfigurations>>, PrismaPromise<Array<GlobalRepositoryConfigurationsGetPayload<T>>>>

    /**
     * Create a GlobalRepositoryConfigurations.
     * @param {GlobalRepositoryConfigurationsCreateArgs} args - Arguments to create a GlobalRepositoryConfigurations.
     * @example
     * // Create one GlobalRepositoryConfigurations
     * const GlobalRepositoryConfigurations = await prisma.globalRepositoryConfigurations.create({
     *   data: {
     *     // ... data to create a GlobalRepositoryConfigurations
     *   }
     * })
     * 
    **/
    create<T extends GlobalRepositoryConfigurationsCreateArgs>(
      args: SelectSubset<T, GlobalRepositoryConfigurationsCreateArgs>
    ): CheckSelect<T, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurations>, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurationsGetPayload<T>>>

    /**
     * Create many GlobalRepositoryConfigurations.
     *     @param {GlobalRepositoryConfigurationsCreateManyArgs} args - Arguments to create many GlobalRepositoryConfigurations.
     *     @example
     *     // Create many GlobalRepositoryConfigurations
     *     const globalRepositoryConfigurations = await prisma.globalRepositoryConfigurations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GlobalRepositoryConfigurationsCreateManyArgs>(
      args?: SelectSubset<T, GlobalRepositoryConfigurationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GlobalRepositoryConfigurations.
     * @param {GlobalRepositoryConfigurationsDeleteArgs} args - Arguments to delete one GlobalRepositoryConfigurations.
     * @example
     * // Delete one GlobalRepositoryConfigurations
     * const GlobalRepositoryConfigurations = await prisma.globalRepositoryConfigurations.delete({
     *   where: {
     *     // ... filter to delete one GlobalRepositoryConfigurations
     *   }
     * })
     * 
    **/
    delete<T extends GlobalRepositoryConfigurationsDeleteArgs>(
      args: SelectSubset<T, GlobalRepositoryConfigurationsDeleteArgs>
    ): CheckSelect<T, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurations>, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurationsGetPayload<T>>>

    /**
     * Update one GlobalRepositoryConfigurations.
     * @param {GlobalRepositoryConfigurationsUpdateArgs} args - Arguments to update one GlobalRepositoryConfigurations.
     * @example
     * // Update one GlobalRepositoryConfigurations
     * const globalRepositoryConfigurations = await prisma.globalRepositoryConfigurations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GlobalRepositoryConfigurationsUpdateArgs>(
      args: SelectSubset<T, GlobalRepositoryConfigurationsUpdateArgs>
    ): CheckSelect<T, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurations>, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurationsGetPayload<T>>>

    /**
     * Delete zero or more GlobalRepositoryConfigurations.
     * @param {GlobalRepositoryConfigurationsDeleteManyArgs} args - Arguments to filter GlobalRepositoryConfigurations to delete.
     * @example
     * // Delete a few GlobalRepositoryConfigurations
     * const { count } = await prisma.globalRepositoryConfigurations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GlobalRepositoryConfigurationsDeleteManyArgs>(
      args?: SelectSubset<T, GlobalRepositoryConfigurationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalRepositoryConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalRepositoryConfigurationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GlobalRepositoryConfigurations
     * const globalRepositoryConfigurations = await prisma.globalRepositoryConfigurations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GlobalRepositoryConfigurationsUpdateManyArgs>(
      args: SelectSubset<T, GlobalRepositoryConfigurationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GlobalRepositoryConfigurations.
     * @param {GlobalRepositoryConfigurationsUpsertArgs} args - Arguments to update or create a GlobalRepositoryConfigurations.
     * @example
     * // Update or create a GlobalRepositoryConfigurations
     * const globalRepositoryConfigurations = await prisma.globalRepositoryConfigurations.upsert({
     *   create: {
     *     // ... data to create a GlobalRepositoryConfigurations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GlobalRepositoryConfigurations we want to update
     *   }
     * })
    **/
    upsert<T extends GlobalRepositoryConfigurationsUpsertArgs>(
      args: SelectSubset<T, GlobalRepositoryConfigurationsUpsertArgs>
    ): CheckSelect<T, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurations>, Prisma__GlobalRepositoryConfigurationsClient<GlobalRepositoryConfigurationsGetPayload<T>>>

    /**
     * Count the number of GlobalRepositoryConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalRepositoryConfigurationsCountArgs} args - Arguments to filter GlobalRepositoryConfigurations to count.
     * @example
     * // Count the number of GlobalRepositoryConfigurations
     * const count = await prisma.globalRepositoryConfigurations.count({
     *   where: {
     *     // ... the filter for the GlobalRepositoryConfigurations we want to count
     *   }
     * })
    **/
    count<T extends GlobalRepositoryConfigurationsCountArgs>(
      args?: Subset<T, GlobalRepositoryConfigurationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlobalRepositoryConfigurationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GlobalRepositoryConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalRepositoryConfigurationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlobalRepositoryConfigurationsAggregateArgs>(args: Subset<T, GlobalRepositoryConfigurationsAggregateArgs>): PrismaPromise<GetGlobalRepositoryConfigurationsAggregateType<T>>

    /**
     * Group by GlobalRepositoryConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalRepositoryConfigurationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlobalRepositoryConfigurationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlobalRepositoryConfigurationsGroupByArgs['orderBy'] }
        : { orderBy?: GlobalRepositoryConfigurationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlobalRepositoryConfigurationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlobalRepositoryConfigurationsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for GlobalRepositoryConfigurations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GlobalRepositoryConfigurationsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * GlobalRepositoryConfigurations findUnique
   */
  export type GlobalRepositoryConfigurationsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the GlobalRepositoryConfigurations
     * 
    **/
    select?: GlobalRepositoryConfigurationsSelect | null
    /**
     * Throw an Error if a GlobalRepositoryConfigurations can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GlobalRepositoryConfigurations to fetch.
     * 
    **/
    where: GlobalRepositoryConfigurationsWhereUniqueInput
  }


  /**
   * GlobalRepositoryConfigurations findFirst
   */
  export type GlobalRepositoryConfigurationsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the GlobalRepositoryConfigurations
     * 
    **/
    select?: GlobalRepositoryConfigurationsSelect | null
    /**
     * Throw an Error if a GlobalRepositoryConfigurations can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GlobalRepositoryConfigurations to fetch.
     * 
    **/
    where?: GlobalRepositoryConfigurationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalRepositoryConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<GlobalRepositoryConfigurationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalRepositoryConfigurations.
     * 
    **/
    cursor?: GlobalRepositoryConfigurationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalRepositoryConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalRepositoryConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalRepositoryConfigurations.
     * 
    **/
    distinct?: Enumerable<GlobalRepositoryConfigurationsScalarFieldEnum>
  }


  /**
   * GlobalRepositoryConfigurations findMany
   */
  export type GlobalRepositoryConfigurationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the GlobalRepositoryConfigurations
     * 
    **/
    select?: GlobalRepositoryConfigurationsSelect | null
    /**
     * Filter, which GlobalRepositoryConfigurations to fetch.
     * 
    **/
    where?: GlobalRepositoryConfigurationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalRepositoryConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<GlobalRepositoryConfigurationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GlobalRepositoryConfigurations.
     * 
    **/
    cursor?: GlobalRepositoryConfigurationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalRepositoryConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalRepositoryConfigurations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GlobalRepositoryConfigurationsScalarFieldEnum>
  }


  /**
   * GlobalRepositoryConfigurations create
   */
  export type GlobalRepositoryConfigurationsCreateArgs = {
    /**
     * Select specific fields to fetch from the GlobalRepositoryConfigurations
     * 
    **/
    select?: GlobalRepositoryConfigurationsSelect | null
    /**
     * The data needed to create a GlobalRepositoryConfigurations.
     * 
    **/
    data: XOR<GlobalRepositoryConfigurationsCreateInput, GlobalRepositoryConfigurationsUncheckedCreateInput>
  }


  /**
   * GlobalRepositoryConfigurations createMany
   */
  export type GlobalRepositoryConfigurationsCreateManyArgs = {
    data: Enumerable<GlobalRepositoryConfigurationsCreateManyInput>
  }


  /**
   * GlobalRepositoryConfigurations update
   */
  export type GlobalRepositoryConfigurationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the GlobalRepositoryConfigurations
     * 
    **/
    select?: GlobalRepositoryConfigurationsSelect | null
    /**
     * The data needed to update a GlobalRepositoryConfigurations.
     * 
    **/
    data: XOR<GlobalRepositoryConfigurationsUpdateInput, GlobalRepositoryConfigurationsUncheckedUpdateInput>
    /**
     * Choose, which GlobalRepositoryConfigurations to update.
     * 
    **/
    where: GlobalRepositoryConfigurationsWhereUniqueInput
  }


  /**
   * GlobalRepositoryConfigurations updateMany
   */
  export type GlobalRepositoryConfigurationsUpdateManyArgs = {
    data: XOR<GlobalRepositoryConfigurationsUpdateManyMutationInput, GlobalRepositoryConfigurationsUncheckedUpdateManyInput>
    where?: GlobalRepositoryConfigurationsWhereInput
  }


  /**
   * GlobalRepositoryConfigurations upsert
   */
  export type GlobalRepositoryConfigurationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the GlobalRepositoryConfigurations
     * 
    **/
    select?: GlobalRepositoryConfigurationsSelect | null
    /**
     * The filter to search for the GlobalRepositoryConfigurations to update in case it exists.
     * 
    **/
    where: GlobalRepositoryConfigurationsWhereUniqueInput
    /**
     * In case the GlobalRepositoryConfigurations found by the `where` argument doesn't exist, create a new GlobalRepositoryConfigurations with this data.
     * 
    **/
    create: XOR<GlobalRepositoryConfigurationsCreateInput, GlobalRepositoryConfigurationsUncheckedCreateInput>
    /**
     * In case the GlobalRepositoryConfigurations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GlobalRepositoryConfigurationsUpdateInput, GlobalRepositoryConfigurationsUncheckedUpdateInput>
  }


  /**
   * GlobalRepositoryConfigurations delete
   */
  export type GlobalRepositoryConfigurationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the GlobalRepositoryConfigurations
     * 
    **/
    select?: GlobalRepositoryConfigurationsSelect | null
    /**
     * Filter which GlobalRepositoryConfigurations to delete.
     * 
    **/
    where: GlobalRepositoryConfigurationsWhereUniqueInput
  }


  /**
   * GlobalRepositoryConfigurations deleteMany
   */
  export type GlobalRepositoryConfigurationsDeleteManyArgs = {
    where?: GlobalRepositoryConfigurationsWhereInput
  }


  /**
   * GlobalRepositoryConfigurations without action
   */
  export type GlobalRepositoryConfigurationsArgs = {
    /**
     * Select specific fields to fetch from the GlobalRepositoryConfigurations
     * 
    **/
    select?: GlobalRepositoryConfigurationsSelect | null
  }



  /**
   * Model GroupFeatures
   */


  export type AggregateGroupFeatures = {
    _count: GroupFeaturesCountAggregateOutputType | null
    _min: GroupFeaturesMinAggregateOutputType | null
    _max: GroupFeaturesMaxAggregateOutputType | null
  }

  export type GroupFeaturesMinAggregateOutputType = {
    Id: string | null
    UserGroup_Id: string | null
    Feature_Id: string | null
    CreatedDate: Date | null
    Status: string | null
  }

  export type GroupFeaturesMaxAggregateOutputType = {
    Id: string | null
    UserGroup_Id: string | null
    Feature_Id: string | null
    CreatedDate: Date | null
    Status: string | null
  }

  export type GroupFeaturesCountAggregateOutputType = {
    Id: number
    UserGroup_Id: number
    Feature_Id: number
    CreatedDate: number
    Status: number
    _all: number
  }


  export type GroupFeaturesMinAggregateInputType = {
    Id?: true
    UserGroup_Id?: true
    Feature_Id?: true
    CreatedDate?: true
    Status?: true
  }

  export type GroupFeaturesMaxAggregateInputType = {
    Id?: true
    UserGroup_Id?: true
    Feature_Id?: true
    CreatedDate?: true
    Status?: true
  }

  export type GroupFeaturesCountAggregateInputType = {
    Id?: true
    UserGroup_Id?: true
    Feature_Id?: true
    CreatedDate?: true
    Status?: true
    _all?: true
  }

  export type GroupFeaturesAggregateArgs = {
    /**
     * Filter which GroupFeatures to aggregate.
     * 
    **/
    where?: GroupFeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupFeatures to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupFeaturesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GroupFeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupFeatures from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupFeatures.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupFeatures
    **/
    _count?: true | GroupFeaturesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupFeaturesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupFeaturesMaxAggregateInputType
  }

  export type GetGroupFeaturesAggregateType<T extends GroupFeaturesAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupFeatures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupFeatures[P]>
      : GetScalarType<T[P], AggregateGroupFeatures[P]>
  }




  export type GroupFeaturesGroupByArgs = {
    where?: GroupFeaturesWhereInput
    orderBy?: Enumerable<GroupFeaturesOrderByWithAggregationInput>
    by: Array<GroupFeaturesScalarFieldEnum>
    having?: GroupFeaturesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupFeaturesCountAggregateInputType | true
    _min?: GroupFeaturesMinAggregateInputType
    _max?: GroupFeaturesMaxAggregateInputType
  }


  export type GroupFeaturesGroupByOutputType = {
    Id: string
    UserGroup_Id: string | null
    Feature_Id: string | null
    CreatedDate: Date | null
    Status: string | null
    _count: GroupFeaturesCountAggregateOutputType | null
    _min: GroupFeaturesMinAggregateOutputType | null
    _max: GroupFeaturesMaxAggregateOutputType | null
  }

  type GetGroupFeaturesGroupByPayload<T extends GroupFeaturesGroupByArgs> = Promise<
    Array<
      PickArray<GroupFeaturesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupFeaturesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupFeaturesGroupByOutputType[P]>
            : GetScalarType<T[P], GroupFeaturesGroupByOutputType[P]>
        }
      >
    >


  export type GroupFeaturesSelect = {
    Id?: boolean
    UserGroup_Id?: boolean
    Feature_Id?: boolean
    CreatedDate?: boolean
    Status?: boolean
  }

  export type GroupFeaturesGetPayload<
    S extends boolean | null | undefined | GroupFeaturesArgs,
    U = keyof S
      > = S extends true
        ? GroupFeatures
    : S extends undefined
    ? never
    : S extends GroupFeaturesArgs | GroupFeaturesFindManyArgs
    ?'include' extends U
    ? GroupFeatures 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof GroupFeatures ?GroupFeatures [P]
  : 
     never
  } 
    : GroupFeatures
  : GroupFeatures


  type GroupFeaturesCountArgs = Merge<
    Omit<GroupFeaturesFindManyArgs, 'select' | 'include'> & {
      select?: GroupFeaturesCountAggregateInputType | true
    }
  >

  export interface GroupFeaturesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one GroupFeatures that matches the filter.
     * @param {GroupFeaturesFindUniqueArgs} args - Arguments to find a GroupFeatures
     * @example
     * // Get one GroupFeatures
     * const groupFeatures = await prisma.groupFeatures.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupFeaturesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GroupFeaturesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GroupFeatures'> extends True ? CheckSelect<T, Prisma__GroupFeaturesClient<GroupFeatures>, Prisma__GroupFeaturesClient<GroupFeaturesGetPayload<T>>> : CheckSelect<T, Prisma__GroupFeaturesClient<GroupFeatures | null >, Prisma__GroupFeaturesClient<GroupFeaturesGetPayload<T> | null >>

    /**
     * Find the first GroupFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFeaturesFindFirstArgs} args - Arguments to find a GroupFeatures
     * @example
     * // Get one GroupFeatures
     * const groupFeatures = await prisma.groupFeatures.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupFeaturesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GroupFeaturesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GroupFeatures'> extends True ? CheckSelect<T, Prisma__GroupFeaturesClient<GroupFeatures>, Prisma__GroupFeaturesClient<GroupFeaturesGetPayload<T>>> : CheckSelect<T, Prisma__GroupFeaturesClient<GroupFeatures | null >, Prisma__GroupFeaturesClient<GroupFeaturesGetPayload<T> | null >>

    /**
     * Find zero or more GroupFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFeaturesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupFeatures
     * const groupFeatures = await prisma.groupFeatures.findMany()
     * 
     * // Get first 10 GroupFeatures
     * const groupFeatures = await prisma.groupFeatures.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const groupFeaturesWithIdOnly = await prisma.groupFeatures.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends GroupFeaturesFindManyArgs>(
      args?: SelectSubset<T, GroupFeaturesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GroupFeatures>>, PrismaPromise<Array<GroupFeaturesGetPayload<T>>>>

    /**
     * Create a GroupFeatures.
     * @param {GroupFeaturesCreateArgs} args - Arguments to create a GroupFeatures.
     * @example
     * // Create one GroupFeatures
     * const GroupFeatures = await prisma.groupFeatures.create({
     *   data: {
     *     // ... data to create a GroupFeatures
     *   }
     * })
     * 
    **/
    create<T extends GroupFeaturesCreateArgs>(
      args: SelectSubset<T, GroupFeaturesCreateArgs>
    ): CheckSelect<T, Prisma__GroupFeaturesClient<GroupFeatures>, Prisma__GroupFeaturesClient<GroupFeaturesGetPayload<T>>>

    /**
     * Create many GroupFeatures.
     *     @param {GroupFeaturesCreateManyArgs} args - Arguments to create many GroupFeatures.
     *     @example
     *     // Create many GroupFeatures
     *     const groupFeatures = await prisma.groupFeatures.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupFeaturesCreateManyArgs>(
      args?: SelectSubset<T, GroupFeaturesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GroupFeatures.
     * @param {GroupFeaturesDeleteArgs} args - Arguments to delete one GroupFeatures.
     * @example
     * // Delete one GroupFeatures
     * const GroupFeatures = await prisma.groupFeatures.delete({
     *   where: {
     *     // ... filter to delete one GroupFeatures
     *   }
     * })
     * 
    **/
    delete<T extends GroupFeaturesDeleteArgs>(
      args: SelectSubset<T, GroupFeaturesDeleteArgs>
    ): CheckSelect<T, Prisma__GroupFeaturesClient<GroupFeatures>, Prisma__GroupFeaturesClient<GroupFeaturesGetPayload<T>>>

    /**
     * Update one GroupFeatures.
     * @param {GroupFeaturesUpdateArgs} args - Arguments to update one GroupFeatures.
     * @example
     * // Update one GroupFeatures
     * const groupFeatures = await prisma.groupFeatures.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupFeaturesUpdateArgs>(
      args: SelectSubset<T, GroupFeaturesUpdateArgs>
    ): CheckSelect<T, Prisma__GroupFeaturesClient<GroupFeatures>, Prisma__GroupFeaturesClient<GroupFeaturesGetPayload<T>>>

    /**
     * Delete zero or more GroupFeatures.
     * @param {GroupFeaturesDeleteManyArgs} args - Arguments to filter GroupFeatures to delete.
     * @example
     * // Delete a few GroupFeatures
     * const { count } = await prisma.groupFeatures.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupFeaturesDeleteManyArgs>(
      args?: SelectSubset<T, GroupFeaturesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFeaturesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupFeatures
     * const groupFeatures = await prisma.groupFeatures.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupFeaturesUpdateManyArgs>(
      args: SelectSubset<T, GroupFeaturesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupFeatures.
     * @param {GroupFeaturesUpsertArgs} args - Arguments to update or create a GroupFeatures.
     * @example
     * // Update or create a GroupFeatures
     * const groupFeatures = await prisma.groupFeatures.upsert({
     *   create: {
     *     // ... data to create a GroupFeatures
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupFeatures we want to update
     *   }
     * })
    **/
    upsert<T extends GroupFeaturesUpsertArgs>(
      args: SelectSubset<T, GroupFeaturesUpsertArgs>
    ): CheckSelect<T, Prisma__GroupFeaturesClient<GroupFeatures>, Prisma__GroupFeaturesClient<GroupFeaturesGetPayload<T>>>

    /**
     * Count the number of GroupFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFeaturesCountArgs} args - Arguments to filter GroupFeatures to count.
     * @example
     * // Count the number of GroupFeatures
     * const count = await prisma.groupFeatures.count({
     *   where: {
     *     // ... the filter for the GroupFeatures we want to count
     *   }
     * })
    **/
    count<T extends GroupFeaturesCountArgs>(
      args?: Subset<T, GroupFeaturesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupFeaturesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFeaturesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupFeaturesAggregateArgs>(args: Subset<T, GroupFeaturesAggregateArgs>): PrismaPromise<GetGroupFeaturesAggregateType<T>>

    /**
     * Group by GroupFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFeaturesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupFeaturesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupFeaturesGroupByArgs['orderBy'] }
        : { orderBy?: GroupFeaturesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupFeaturesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupFeaturesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupFeatures.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GroupFeaturesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * GroupFeatures findUnique
   */
  export type GroupFeaturesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the GroupFeatures
     * 
    **/
    select?: GroupFeaturesSelect | null
    /**
     * Throw an Error if a GroupFeatures can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GroupFeatures to fetch.
     * 
    **/
    where: GroupFeaturesWhereUniqueInput
  }


  /**
   * GroupFeatures findFirst
   */
  export type GroupFeaturesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the GroupFeatures
     * 
    **/
    select?: GroupFeaturesSelect | null
    /**
     * Throw an Error if a GroupFeatures can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GroupFeatures to fetch.
     * 
    **/
    where?: GroupFeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupFeatures to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupFeaturesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupFeatures.
     * 
    **/
    cursor?: GroupFeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupFeatures from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupFeatures.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupFeatures.
     * 
    **/
    distinct?: Enumerable<GroupFeaturesScalarFieldEnum>
  }


  /**
   * GroupFeatures findMany
   */
  export type GroupFeaturesFindManyArgs = {
    /**
     * Select specific fields to fetch from the GroupFeatures
     * 
    **/
    select?: GroupFeaturesSelect | null
    /**
     * Filter, which GroupFeatures to fetch.
     * 
    **/
    where?: GroupFeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupFeatures to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupFeaturesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupFeatures.
     * 
    **/
    cursor?: GroupFeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupFeatures from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupFeatures.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GroupFeaturesScalarFieldEnum>
  }


  /**
   * GroupFeatures create
   */
  export type GroupFeaturesCreateArgs = {
    /**
     * Select specific fields to fetch from the GroupFeatures
     * 
    **/
    select?: GroupFeaturesSelect | null
    /**
     * The data needed to create a GroupFeatures.
     * 
    **/
    data: XOR<GroupFeaturesCreateInput, GroupFeaturesUncheckedCreateInput>
  }


  /**
   * GroupFeatures createMany
   */
  export type GroupFeaturesCreateManyArgs = {
    data: Enumerable<GroupFeaturesCreateManyInput>
  }


  /**
   * GroupFeatures update
   */
  export type GroupFeaturesUpdateArgs = {
    /**
     * Select specific fields to fetch from the GroupFeatures
     * 
    **/
    select?: GroupFeaturesSelect | null
    /**
     * The data needed to update a GroupFeatures.
     * 
    **/
    data: XOR<GroupFeaturesUpdateInput, GroupFeaturesUncheckedUpdateInput>
    /**
     * Choose, which GroupFeatures to update.
     * 
    **/
    where: GroupFeaturesWhereUniqueInput
  }


  /**
   * GroupFeatures updateMany
   */
  export type GroupFeaturesUpdateManyArgs = {
    data: XOR<GroupFeaturesUpdateManyMutationInput, GroupFeaturesUncheckedUpdateManyInput>
    where?: GroupFeaturesWhereInput
  }


  /**
   * GroupFeatures upsert
   */
  export type GroupFeaturesUpsertArgs = {
    /**
     * Select specific fields to fetch from the GroupFeatures
     * 
    **/
    select?: GroupFeaturesSelect | null
    /**
     * The filter to search for the GroupFeatures to update in case it exists.
     * 
    **/
    where: GroupFeaturesWhereUniqueInput
    /**
     * In case the GroupFeatures found by the `where` argument doesn't exist, create a new GroupFeatures with this data.
     * 
    **/
    create: XOR<GroupFeaturesCreateInput, GroupFeaturesUncheckedCreateInput>
    /**
     * In case the GroupFeatures was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GroupFeaturesUpdateInput, GroupFeaturesUncheckedUpdateInput>
  }


  /**
   * GroupFeatures delete
   */
  export type GroupFeaturesDeleteArgs = {
    /**
     * Select specific fields to fetch from the GroupFeatures
     * 
    **/
    select?: GroupFeaturesSelect | null
    /**
     * Filter which GroupFeatures to delete.
     * 
    **/
    where: GroupFeaturesWhereUniqueInput
  }


  /**
   * GroupFeatures deleteMany
   */
  export type GroupFeaturesDeleteManyArgs = {
    where?: GroupFeaturesWhereInput
  }


  /**
   * GroupFeatures without action
   */
  export type GroupFeaturesArgs = {
    /**
     * Select specific fields to fetch from the GroupFeatures
     * 
    **/
    select?: GroupFeaturesSelect | null
  }



  /**
   * Model GuestSignupSettings
   */


  export type AggregateGuestSignupSettings = {
    _count: GuestSignupSettingsCountAggregateOutputType | null
    _avg: GuestSignupSettingsAvgAggregateOutputType | null
    _sum: GuestSignupSettingsSumAggregateOutputType | null
    _min: GuestSignupSettingsMinAggregateOutputType | null
    _max: GuestSignupSettingsMaxAggregateOutputType | null
  }

  export type GuestSignupSettingsAvgAggregateOutputType = {
    AllowAllRepository: number | null
  }

  export type GuestSignupSettingsSumAggregateOutputType = {
    AllowAllRepository: number | null
  }

  export type GuestSignupSettingsMinAggregateOutputType = {
    Id: string | null
    GlobalRepoConfigId: string | null
    AllowAllRepository: number | null
    RepositoryPermissions: string | null
    Status: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type GuestSignupSettingsMaxAggregateOutputType = {
    Id: string | null
    GlobalRepoConfigId: string | null
    AllowAllRepository: number | null
    RepositoryPermissions: string | null
    Status: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type GuestSignupSettingsCountAggregateOutputType = {
    Id: number
    GlobalRepoConfigId: number
    AllowAllRepository: number
    RepositoryPermissions: number
    Status: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type GuestSignupSettingsAvgAggregateInputType = {
    AllowAllRepository?: true
  }

  export type GuestSignupSettingsSumAggregateInputType = {
    AllowAllRepository?: true
  }

  export type GuestSignupSettingsMinAggregateInputType = {
    Id?: true
    GlobalRepoConfigId?: true
    AllowAllRepository?: true
    RepositoryPermissions?: true
    Status?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type GuestSignupSettingsMaxAggregateInputType = {
    Id?: true
    GlobalRepoConfigId?: true
    AllowAllRepository?: true
    RepositoryPermissions?: true
    Status?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type GuestSignupSettingsCountAggregateInputType = {
    Id?: true
    GlobalRepoConfigId?: true
    AllowAllRepository?: true
    RepositoryPermissions?: true
    Status?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type GuestSignupSettingsAggregateArgs = {
    /**
     * Filter which GuestSignupSettings to aggregate.
     * 
    **/
    where?: GuestSignupSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuestSignupSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<GuestSignupSettingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GuestSignupSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuestSignupSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuestSignupSettings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuestSignupSettings
    **/
    _count?: true | GuestSignupSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuestSignupSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuestSignupSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuestSignupSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuestSignupSettingsMaxAggregateInputType
  }

  export type GetGuestSignupSettingsAggregateType<T extends GuestSignupSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuestSignupSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuestSignupSettings[P]>
      : GetScalarType<T[P], AggregateGuestSignupSettings[P]>
  }




  export type GuestSignupSettingsGroupByArgs = {
    where?: GuestSignupSettingsWhereInput
    orderBy?: Enumerable<GuestSignupSettingsOrderByWithAggregationInput>
    by: Array<GuestSignupSettingsScalarFieldEnum>
    having?: GuestSignupSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuestSignupSettingsCountAggregateInputType | true
    _avg?: GuestSignupSettingsAvgAggregateInputType
    _sum?: GuestSignupSettingsSumAggregateInputType
    _min?: GuestSignupSettingsMinAggregateInputType
    _max?: GuestSignupSettingsMaxAggregateInputType
  }


  export type GuestSignupSettingsGroupByOutputType = {
    Id: string
    GlobalRepoConfigId: string | null
    AllowAllRepository: number | null
    RepositoryPermissions: string | null
    Status: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: GuestSignupSettingsCountAggregateOutputType | null
    _avg: GuestSignupSettingsAvgAggregateOutputType | null
    _sum: GuestSignupSettingsSumAggregateOutputType | null
    _min: GuestSignupSettingsMinAggregateOutputType | null
    _max: GuestSignupSettingsMaxAggregateOutputType | null
  }

  type GetGuestSignupSettingsGroupByPayload<T extends GuestSignupSettingsGroupByArgs> = Promise<
    Array<
      PickArray<GuestSignupSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuestSignupSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuestSignupSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], GuestSignupSettingsGroupByOutputType[P]>
        }
      >
    >


  export type GuestSignupSettingsSelect = {
    Id?: boolean
    GlobalRepoConfigId?: boolean
    AllowAllRepository?: boolean
    RepositoryPermissions?: boolean
    Status?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type GuestSignupSettingsGetPayload<
    S extends boolean | null | undefined | GuestSignupSettingsArgs,
    U = keyof S
      > = S extends true
        ? GuestSignupSettings
    : S extends undefined
    ? never
    : S extends GuestSignupSettingsArgs | GuestSignupSettingsFindManyArgs
    ?'include' extends U
    ? GuestSignupSettings 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof GuestSignupSettings ?GuestSignupSettings [P]
  : 
     never
  } 
    : GuestSignupSettings
  : GuestSignupSettings


  type GuestSignupSettingsCountArgs = Merge<
    Omit<GuestSignupSettingsFindManyArgs, 'select' | 'include'> & {
      select?: GuestSignupSettingsCountAggregateInputType | true
    }
  >

  export interface GuestSignupSettingsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one GuestSignupSettings that matches the filter.
     * @param {GuestSignupSettingsFindUniqueArgs} args - Arguments to find a GuestSignupSettings
     * @example
     * // Get one GuestSignupSettings
     * const guestSignupSettings = await prisma.guestSignupSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GuestSignupSettingsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GuestSignupSettingsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GuestSignupSettings'> extends True ? CheckSelect<T, Prisma__GuestSignupSettingsClient<GuestSignupSettings>, Prisma__GuestSignupSettingsClient<GuestSignupSettingsGetPayload<T>>> : CheckSelect<T, Prisma__GuestSignupSettingsClient<GuestSignupSettings | null >, Prisma__GuestSignupSettingsClient<GuestSignupSettingsGetPayload<T> | null >>

    /**
     * Find the first GuestSignupSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestSignupSettingsFindFirstArgs} args - Arguments to find a GuestSignupSettings
     * @example
     * // Get one GuestSignupSettings
     * const guestSignupSettings = await prisma.guestSignupSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GuestSignupSettingsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GuestSignupSettingsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GuestSignupSettings'> extends True ? CheckSelect<T, Prisma__GuestSignupSettingsClient<GuestSignupSettings>, Prisma__GuestSignupSettingsClient<GuestSignupSettingsGetPayload<T>>> : CheckSelect<T, Prisma__GuestSignupSettingsClient<GuestSignupSettings | null >, Prisma__GuestSignupSettingsClient<GuestSignupSettingsGetPayload<T> | null >>

    /**
     * Find zero or more GuestSignupSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestSignupSettingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuestSignupSettings
     * const guestSignupSettings = await prisma.guestSignupSettings.findMany()
     * 
     * // Get first 10 GuestSignupSettings
     * const guestSignupSettings = await prisma.guestSignupSettings.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const guestSignupSettingsWithIdOnly = await prisma.guestSignupSettings.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends GuestSignupSettingsFindManyArgs>(
      args?: SelectSubset<T, GuestSignupSettingsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GuestSignupSettings>>, PrismaPromise<Array<GuestSignupSettingsGetPayload<T>>>>

    /**
     * Create a GuestSignupSettings.
     * @param {GuestSignupSettingsCreateArgs} args - Arguments to create a GuestSignupSettings.
     * @example
     * // Create one GuestSignupSettings
     * const GuestSignupSettings = await prisma.guestSignupSettings.create({
     *   data: {
     *     // ... data to create a GuestSignupSettings
     *   }
     * })
     * 
    **/
    create<T extends GuestSignupSettingsCreateArgs>(
      args: SelectSubset<T, GuestSignupSettingsCreateArgs>
    ): CheckSelect<T, Prisma__GuestSignupSettingsClient<GuestSignupSettings>, Prisma__GuestSignupSettingsClient<GuestSignupSettingsGetPayload<T>>>

    /**
     * Create many GuestSignupSettings.
     *     @param {GuestSignupSettingsCreateManyArgs} args - Arguments to create many GuestSignupSettings.
     *     @example
     *     // Create many GuestSignupSettings
     *     const guestSignupSettings = await prisma.guestSignupSettings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GuestSignupSettingsCreateManyArgs>(
      args?: SelectSubset<T, GuestSignupSettingsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GuestSignupSettings.
     * @param {GuestSignupSettingsDeleteArgs} args - Arguments to delete one GuestSignupSettings.
     * @example
     * // Delete one GuestSignupSettings
     * const GuestSignupSettings = await prisma.guestSignupSettings.delete({
     *   where: {
     *     // ... filter to delete one GuestSignupSettings
     *   }
     * })
     * 
    **/
    delete<T extends GuestSignupSettingsDeleteArgs>(
      args: SelectSubset<T, GuestSignupSettingsDeleteArgs>
    ): CheckSelect<T, Prisma__GuestSignupSettingsClient<GuestSignupSettings>, Prisma__GuestSignupSettingsClient<GuestSignupSettingsGetPayload<T>>>

    /**
     * Update one GuestSignupSettings.
     * @param {GuestSignupSettingsUpdateArgs} args - Arguments to update one GuestSignupSettings.
     * @example
     * // Update one GuestSignupSettings
     * const guestSignupSettings = await prisma.guestSignupSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GuestSignupSettingsUpdateArgs>(
      args: SelectSubset<T, GuestSignupSettingsUpdateArgs>
    ): CheckSelect<T, Prisma__GuestSignupSettingsClient<GuestSignupSettings>, Prisma__GuestSignupSettingsClient<GuestSignupSettingsGetPayload<T>>>

    /**
     * Delete zero or more GuestSignupSettings.
     * @param {GuestSignupSettingsDeleteManyArgs} args - Arguments to filter GuestSignupSettings to delete.
     * @example
     * // Delete a few GuestSignupSettings
     * const { count } = await prisma.guestSignupSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GuestSignupSettingsDeleteManyArgs>(
      args?: SelectSubset<T, GuestSignupSettingsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuestSignupSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestSignupSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuestSignupSettings
     * const guestSignupSettings = await prisma.guestSignupSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GuestSignupSettingsUpdateManyArgs>(
      args: SelectSubset<T, GuestSignupSettingsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GuestSignupSettings.
     * @param {GuestSignupSettingsUpsertArgs} args - Arguments to update or create a GuestSignupSettings.
     * @example
     * // Update or create a GuestSignupSettings
     * const guestSignupSettings = await prisma.guestSignupSettings.upsert({
     *   create: {
     *     // ... data to create a GuestSignupSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuestSignupSettings we want to update
     *   }
     * })
    **/
    upsert<T extends GuestSignupSettingsUpsertArgs>(
      args: SelectSubset<T, GuestSignupSettingsUpsertArgs>
    ): CheckSelect<T, Prisma__GuestSignupSettingsClient<GuestSignupSettings>, Prisma__GuestSignupSettingsClient<GuestSignupSettingsGetPayload<T>>>

    /**
     * Count the number of GuestSignupSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestSignupSettingsCountArgs} args - Arguments to filter GuestSignupSettings to count.
     * @example
     * // Count the number of GuestSignupSettings
     * const count = await prisma.guestSignupSettings.count({
     *   where: {
     *     // ... the filter for the GuestSignupSettings we want to count
     *   }
     * })
    **/
    count<T extends GuestSignupSettingsCountArgs>(
      args?: Subset<T, GuestSignupSettingsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuestSignupSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuestSignupSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestSignupSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuestSignupSettingsAggregateArgs>(args: Subset<T, GuestSignupSettingsAggregateArgs>): PrismaPromise<GetGuestSignupSettingsAggregateType<T>>

    /**
     * Group by GuestSignupSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestSignupSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuestSignupSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuestSignupSettingsGroupByArgs['orderBy'] }
        : { orderBy?: GuestSignupSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuestSignupSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuestSignupSettingsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuestSignupSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GuestSignupSettingsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * GuestSignupSettings findUnique
   */
  export type GuestSignupSettingsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the GuestSignupSettings
     * 
    **/
    select?: GuestSignupSettingsSelect | null
    /**
     * Throw an Error if a GuestSignupSettings can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GuestSignupSettings to fetch.
     * 
    **/
    where: GuestSignupSettingsWhereUniqueInput
  }


  /**
   * GuestSignupSettings findFirst
   */
  export type GuestSignupSettingsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the GuestSignupSettings
     * 
    **/
    select?: GuestSignupSettingsSelect | null
    /**
     * Throw an Error if a GuestSignupSettings can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GuestSignupSettings to fetch.
     * 
    **/
    where?: GuestSignupSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuestSignupSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<GuestSignupSettingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuestSignupSettings.
     * 
    **/
    cursor?: GuestSignupSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuestSignupSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuestSignupSettings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuestSignupSettings.
     * 
    **/
    distinct?: Enumerable<GuestSignupSettingsScalarFieldEnum>
  }


  /**
   * GuestSignupSettings findMany
   */
  export type GuestSignupSettingsFindManyArgs = {
    /**
     * Select specific fields to fetch from the GuestSignupSettings
     * 
    **/
    select?: GuestSignupSettingsSelect | null
    /**
     * Filter, which GuestSignupSettings to fetch.
     * 
    **/
    where?: GuestSignupSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuestSignupSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<GuestSignupSettingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuestSignupSettings.
     * 
    **/
    cursor?: GuestSignupSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuestSignupSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuestSignupSettings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GuestSignupSettingsScalarFieldEnum>
  }


  /**
   * GuestSignupSettings create
   */
  export type GuestSignupSettingsCreateArgs = {
    /**
     * Select specific fields to fetch from the GuestSignupSettings
     * 
    **/
    select?: GuestSignupSettingsSelect | null
    /**
     * The data needed to create a GuestSignupSettings.
     * 
    **/
    data: XOR<GuestSignupSettingsCreateInput, GuestSignupSettingsUncheckedCreateInput>
  }


  /**
   * GuestSignupSettings createMany
   */
  export type GuestSignupSettingsCreateManyArgs = {
    data: Enumerable<GuestSignupSettingsCreateManyInput>
  }


  /**
   * GuestSignupSettings update
   */
  export type GuestSignupSettingsUpdateArgs = {
    /**
     * Select specific fields to fetch from the GuestSignupSettings
     * 
    **/
    select?: GuestSignupSettingsSelect | null
    /**
     * The data needed to update a GuestSignupSettings.
     * 
    **/
    data: XOR<GuestSignupSettingsUpdateInput, GuestSignupSettingsUncheckedUpdateInput>
    /**
     * Choose, which GuestSignupSettings to update.
     * 
    **/
    where: GuestSignupSettingsWhereUniqueInput
  }


  /**
   * GuestSignupSettings updateMany
   */
  export type GuestSignupSettingsUpdateManyArgs = {
    data: XOR<GuestSignupSettingsUpdateManyMutationInput, GuestSignupSettingsUncheckedUpdateManyInput>
    where?: GuestSignupSettingsWhereInput
  }


  /**
   * GuestSignupSettings upsert
   */
  export type GuestSignupSettingsUpsertArgs = {
    /**
     * Select specific fields to fetch from the GuestSignupSettings
     * 
    **/
    select?: GuestSignupSettingsSelect | null
    /**
     * The filter to search for the GuestSignupSettings to update in case it exists.
     * 
    **/
    where: GuestSignupSettingsWhereUniqueInput
    /**
     * In case the GuestSignupSettings found by the `where` argument doesn't exist, create a new GuestSignupSettings with this data.
     * 
    **/
    create: XOR<GuestSignupSettingsCreateInput, GuestSignupSettingsUncheckedCreateInput>
    /**
     * In case the GuestSignupSettings was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GuestSignupSettingsUpdateInput, GuestSignupSettingsUncheckedUpdateInput>
  }


  /**
   * GuestSignupSettings delete
   */
  export type GuestSignupSettingsDeleteArgs = {
    /**
     * Select specific fields to fetch from the GuestSignupSettings
     * 
    **/
    select?: GuestSignupSettingsSelect | null
    /**
     * Filter which GuestSignupSettings to delete.
     * 
    **/
    where: GuestSignupSettingsWhereUniqueInput
  }


  /**
   * GuestSignupSettings deleteMany
   */
  export type GuestSignupSettingsDeleteManyArgs = {
    where?: GuestSignupSettingsWhereInput
  }


  /**
   * GuestSignupSettings without action
   */
  export type GuestSignupSettingsArgs = {
    /**
     * Select specific fields to fetch from the GuestSignupSettings
     * 
    **/
    select?: GuestSignupSettingsSelect | null
  }



  /**
   * Model IdPConnections
   */


  export type AggregateIdPConnections = {
    _count: IdPConnectionsCountAggregateOutputType | null
    _avg: IdPConnectionsAvgAggregateOutputType | null
    _sum: IdPConnectionsSumAggregateOutputType | null
    _min: IdPConnectionsMinAggregateOutputType | null
    _max: IdPConnectionsMaxAggregateOutputType | null
  }

  export type IdPConnectionsAvgAggregateOutputType = {
    AllowAllRepository: number | null
  }

  export type IdPConnectionsSumAggregateOutputType = {
    AllowAllRepository: number | null
  }

  export type IdPConnectionsMinAggregateOutputType = {
    Id: string | null
    Name: string | null
    SigninUrl: string | null
    CertificatePath: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
    AllowAllRepository: number | null
    RepositoryPermissions: string | null
    RepositoryPermissionId: string | null
    IdPSource: string | null
    LogoutUrl: string | null
    IDPCertificateEncrypted: string | null
    SPCertificateEncrypted: string | null
    SPCertificatePath: string | null
    SPCertificatePassword: string | null
    GlobalRepoConfigId: string | null
    AttributesMapping: string | null
  }

  export type IdPConnectionsMaxAggregateOutputType = {
    Id: string | null
    Name: string | null
    SigninUrl: string | null
    CertificatePath: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
    AllowAllRepository: number | null
    RepositoryPermissions: string | null
    RepositoryPermissionId: string | null
    IdPSource: string | null
    LogoutUrl: string | null
    IDPCertificateEncrypted: string | null
    SPCertificateEncrypted: string | null
    SPCertificatePath: string | null
    SPCertificatePassword: string | null
    GlobalRepoConfigId: string | null
    AttributesMapping: string | null
  }

  export type IdPConnectionsCountAggregateOutputType = {
    Id: number
    Name: number
    SigninUrl: number
    CertificatePath: number
    CreatedDate: number
    ModifiedDate: number
    Status: number
    AllowAllRepository: number
    RepositoryPermissions: number
    RepositoryPermissionId: number
    IdPSource: number
    LogoutUrl: number
    IDPCertificateEncrypted: number
    SPCertificateEncrypted: number
    SPCertificatePath: number
    SPCertificatePassword: number
    GlobalRepoConfigId: number
    AttributesMapping: number
    _all: number
  }


  export type IdPConnectionsAvgAggregateInputType = {
    AllowAllRepository?: true
  }

  export type IdPConnectionsSumAggregateInputType = {
    AllowAllRepository?: true
  }

  export type IdPConnectionsMinAggregateInputType = {
    Id?: true
    Name?: true
    SigninUrl?: true
    CertificatePath?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
    AllowAllRepository?: true
    RepositoryPermissions?: true
    RepositoryPermissionId?: true
    IdPSource?: true
    LogoutUrl?: true
    IDPCertificateEncrypted?: true
    SPCertificateEncrypted?: true
    SPCertificatePath?: true
    SPCertificatePassword?: true
    GlobalRepoConfigId?: true
    AttributesMapping?: true
  }

  export type IdPConnectionsMaxAggregateInputType = {
    Id?: true
    Name?: true
    SigninUrl?: true
    CertificatePath?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
    AllowAllRepository?: true
    RepositoryPermissions?: true
    RepositoryPermissionId?: true
    IdPSource?: true
    LogoutUrl?: true
    IDPCertificateEncrypted?: true
    SPCertificateEncrypted?: true
    SPCertificatePath?: true
    SPCertificatePassword?: true
    GlobalRepoConfigId?: true
    AttributesMapping?: true
  }

  export type IdPConnectionsCountAggregateInputType = {
    Id?: true
    Name?: true
    SigninUrl?: true
    CertificatePath?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
    AllowAllRepository?: true
    RepositoryPermissions?: true
    RepositoryPermissionId?: true
    IdPSource?: true
    LogoutUrl?: true
    IDPCertificateEncrypted?: true
    SPCertificateEncrypted?: true
    SPCertificatePath?: true
    SPCertificatePassword?: true
    GlobalRepoConfigId?: true
    AttributesMapping?: true
    _all?: true
  }

  export type IdPConnectionsAggregateArgs = {
    /**
     * Filter which IdPConnections to aggregate.
     * 
    **/
    where?: IdPConnectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdPConnections to fetch.
     * 
    **/
    orderBy?: Enumerable<IdPConnectionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IdPConnectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdPConnections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdPConnections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IdPConnections
    **/
    _count?: true | IdPConnectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IdPConnectionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IdPConnectionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdPConnectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdPConnectionsMaxAggregateInputType
  }

  export type GetIdPConnectionsAggregateType<T extends IdPConnectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateIdPConnections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdPConnections[P]>
      : GetScalarType<T[P], AggregateIdPConnections[P]>
  }




  export type IdPConnectionsGroupByArgs = {
    where?: IdPConnectionsWhereInput
    orderBy?: Enumerable<IdPConnectionsOrderByWithAggregationInput>
    by: Array<IdPConnectionsScalarFieldEnum>
    having?: IdPConnectionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdPConnectionsCountAggregateInputType | true
    _avg?: IdPConnectionsAvgAggregateInputType
    _sum?: IdPConnectionsSumAggregateInputType
    _min?: IdPConnectionsMinAggregateInputType
    _max?: IdPConnectionsMaxAggregateInputType
  }


  export type IdPConnectionsGroupByOutputType = {
    Id: string
    Name: string | null
    SigninUrl: string | null
    CertificatePath: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
    AllowAllRepository: number | null
    RepositoryPermissions: string | null
    RepositoryPermissionId: string | null
    IdPSource: string | null
    LogoutUrl: string | null
    IDPCertificateEncrypted: string | null
    SPCertificateEncrypted: string | null
    SPCertificatePath: string | null
    SPCertificatePassword: string | null
    GlobalRepoConfigId: string | null
    AttributesMapping: string | null
    _count: IdPConnectionsCountAggregateOutputType | null
    _avg: IdPConnectionsAvgAggregateOutputType | null
    _sum: IdPConnectionsSumAggregateOutputType | null
    _min: IdPConnectionsMinAggregateOutputType | null
    _max: IdPConnectionsMaxAggregateOutputType | null
  }

  type GetIdPConnectionsGroupByPayload<T extends IdPConnectionsGroupByArgs> = Promise<
    Array<
      PickArray<IdPConnectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdPConnectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdPConnectionsGroupByOutputType[P]>
            : GetScalarType<T[P], IdPConnectionsGroupByOutputType[P]>
        }
      >
    >


  export type IdPConnectionsSelect = {
    Id?: boolean
    Name?: boolean
    SigninUrl?: boolean
    CertificatePath?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
    Status?: boolean
    AllowAllRepository?: boolean
    RepositoryPermissions?: boolean
    RepositoryPermissionId?: boolean
    IdPSource?: boolean
    LogoutUrl?: boolean
    IDPCertificateEncrypted?: boolean
    SPCertificateEncrypted?: boolean
    SPCertificatePath?: boolean
    SPCertificatePassword?: boolean
    GlobalRepoConfigId?: boolean
    AttributesMapping?: boolean
  }

  export type IdPConnectionsGetPayload<
    S extends boolean | null | undefined | IdPConnectionsArgs,
    U = keyof S
      > = S extends true
        ? IdPConnections
    : S extends undefined
    ? never
    : S extends IdPConnectionsArgs | IdPConnectionsFindManyArgs
    ?'include' extends U
    ? IdPConnections 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IdPConnections ?IdPConnections [P]
  : 
     never
  } 
    : IdPConnections
  : IdPConnections


  type IdPConnectionsCountArgs = Merge<
    Omit<IdPConnectionsFindManyArgs, 'select' | 'include'> & {
      select?: IdPConnectionsCountAggregateInputType | true
    }
  >

  export interface IdPConnectionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IdPConnections that matches the filter.
     * @param {IdPConnectionsFindUniqueArgs} args - Arguments to find a IdPConnections
     * @example
     * // Get one IdPConnections
     * const idPConnections = await prisma.idPConnections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IdPConnectionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IdPConnectionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IdPConnections'> extends True ? CheckSelect<T, Prisma__IdPConnectionsClient<IdPConnections>, Prisma__IdPConnectionsClient<IdPConnectionsGetPayload<T>>> : CheckSelect<T, Prisma__IdPConnectionsClient<IdPConnections | null >, Prisma__IdPConnectionsClient<IdPConnectionsGetPayload<T> | null >>

    /**
     * Find the first IdPConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdPConnectionsFindFirstArgs} args - Arguments to find a IdPConnections
     * @example
     * // Get one IdPConnections
     * const idPConnections = await prisma.idPConnections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IdPConnectionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IdPConnectionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IdPConnections'> extends True ? CheckSelect<T, Prisma__IdPConnectionsClient<IdPConnections>, Prisma__IdPConnectionsClient<IdPConnectionsGetPayload<T>>> : CheckSelect<T, Prisma__IdPConnectionsClient<IdPConnections | null >, Prisma__IdPConnectionsClient<IdPConnectionsGetPayload<T> | null >>

    /**
     * Find zero or more IdPConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdPConnectionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IdPConnections
     * const idPConnections = await prisma.idPConnections.findMany()
     * 
     * // Get first 10 IdPConnections
     * const idPConnections = await prisma.idPConnections.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const idPConnectionsWithIdOnly = await prisma.idPConnections.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends IdPConnectionsFindManyArgs>(
      args?: SelectSubset<T, IdPConnectionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IdPConnections>>, PrismaPromise<Array<IdPConnectionsGetPayload<T>>>>

    /**
     * Create a IdPConnections.
     * @param {IdPConnectionsCreateArgs} args - Arguments to create a IdPConnections.
     * @example
     * // Create one IdPConnections
     * const IdPConnections = await prisma.idPConnections.create({
     *   data: {
     *     // ... data to create a IdPConnections
     *   }
     * })
     * 
    **/
    create<T extends IdPConnectionsCreateArgs>(
      args: SelectSubset<T, IdPConnectionsCreateArgs>
    ): CheckSelect<T, Prisma__IdPConnectionsClient<IdPConnections>, Prisma__IdPConnectionsClient<IdPConnectionsGetPayload<T>>>

    /**
     * Create many IdPConnections.
     *     @param {IdPConnectionsCreateManyArgs} args - Arguments to create many IdPConnections.
     *     @example
     *     // Create many IdPConnections
     *     const idPConnections = await prisma.idPConnections.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IdPConnectionsCreateManyArgs>(
      args?: SelectSubset<T, IdPConnectionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IdPConnections.
     * @param {IdPConnectionsDeleteArgs} args - Arguments to delete one IdPConnections.
     * @example
     * // Delete one IdPConnections
     * const IdPConnections = await prisma.idPConnections.delete({
     *   where: {
     *     // ... filter to delete one IdPConnections
     *   }
     * })
     * 
    **/
    delete<T extends IdPConnectionsDeleteArgs>(
      args: SelectSubset<T, IdPConnectionsDeleteArgs>
    ): CheckSelect<T, Prisma__IdPConnectionsClient<IdPConnections>, Prisma__IdPConnectionsClient<IdPConnectionsGetPayload<T>>>

    /**
     * Update one IdPConnections.
     * @param {IdPConnectionsUpdateArgs} args - Arguments to update one IdPConnections.
     * @example
     * // Update one IdPConnections
     * const idPConnections = await prisma.idPConnections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IdPConnectionsUpdateArgs>(
      args: SelectSubset<T, IdPConnectionsUpdateArgs>
    ): CheckSelect<T, Prisma__IdPConnectionsClient<IdPConnections>, Prisma__IdPConnectionsClient<IdPConnectionsGetPayload<T>>>

    /**
     * Delete zero or more IdPConnections.
     * @param {IdPConnectionsDeleteManyArgs} args - Arguments to filter IdPConnections to delete.
     * @example
     * // Delete a few IdPConnections
     * const { count } = await prisma.idPConnections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IdPConnectionsDeleteManyArgs>(
      args?: SelectSubset<T, IdPConnectionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdPConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdPConnectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IdPConnections
     * const idPConnections = await prisma.idPConnections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IdPConnectionsUpdateManyArgs>(
      args: SelectSubset<T, IdPConnectionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IdPConnections.
     * @param {IdPConnectionsUpsertArgs} args - Arguments to update or create a IdPConnections.
     * @example
     * // Update or create a IdPConnections
     * const idPConnections = await prisma.idPConnections.upsert({
     *   create: {
     *     // ... data to create a IdPConnections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IdPConnections we want to update
     *   }
     * })
    **/
    upsert<T extends IdPConnectionsUpsertArgs>(
      args: SelectSubset<T, IdPConnectionsUpsertArgs>
    ): CheckSelect<T, Prisma__IdPConnectionsClient<IdPConnections>, Prisma__IdPConnectionsClient<IdPConnectionsGetPayload<T>>>

    /**
     * Count the number of IdPConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdPConnectionsCountArgs} args - Arguments to filter IdPConnections to count.
     * @example
     * // Count the number of IdPConnections
     * const count = await prisma.idPConnections.count({
     *   where: {
     *     // ... the filter for the IdPConnections we want to count
     *   }
     * })
    **/
    count<T extends IdPConnectionsCountArgs>(
      args?: Subset<T, IdPConnectionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdPConnectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IdPConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdPConnectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdPConnectionsAggregateArgs>(args: Subset<T, IdPConnectionsAggregateArgs>): PrismaPromise<GetIdPConnectionsAggregateType<T>>

    /**
     * Group by IdPConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdPConnectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdPConnectionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdPConnectionsGroupByArgs['orderBy'] }
        : { orderBy?: IdPConnectionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdPConnectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdPConnectionsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IdPConnections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IdPConnectionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IdPConnections findUnique
   */
  export type IdPConnectionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IdPConnections
     * 
    **/
    select?: IdPConnectionsSelect | null
    /**
     * Throw an Error if a IdPConnections can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IdPConnections to fetch.
     * 
    **/
    where: IdPConnectionsWhereUniqueInput
  }


  /**
   * IdPConnections findFirst
   */
  export type IdPConnectionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IdPConnections
     * 
    **/
    select?: IdPConnectionsSelect | null
    /**
     * Throw an Error if a IdPConnections can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IdPConnections to fetch.
     * 
    **/
    where?: IdPConnectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdPConnections to fetch.
     * 
    **/
    orderBy?: Enumerable<IdPConnectionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdPConnections.
     * 
    **/
    cursor?: IdPConnectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdPConnections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdPConnections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdPConnections.
     * 
    **/
    distinct?: Enumerable<IdPConnectionsScalarFieldEnum>
  }


  /**
   * IdPConnections findMany
   */
  export type IdPConnectionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the IdPConnections
     * 
    **/
    select?: IdPConnectionsSelect | null
    /**
     * Filter, which IdPConnections to fetch.
     * 
    **/
    where?: IdPConnectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdPConnections to fetch.
     * 
    **/
    orderBy?: Enumerable<IdPConnectionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IdPConnections.
     * 
    **/
    cursor?: IdPConnectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdPConnections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdPConnections.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IdPConnectionsScalarFieldEnum>
  }


  /**
   * IdPConnections create
   */
  export type IdPConnectionsCreateArgs = {
    /**
     * Select specific fields to fetch from the IdPConnections
     * 
    **/
    select?: IdPConnectionsSelect | null
    /**
     * The data needed to create a IdPConnections.
     * 
    **/
    data: XOR<IdPConnectionsCreateInput, IdPConnectionsUncheckedCreateInput>
  }


  /**
   * IdPConnections createMany
   */
  export type IdPConnectionsCreateManyArgs = {
    data: Enumerable<IdPConnectionsCreateManyInput>
  }


  /**
   * IdPConnections update
   */
  export type IdPConnectionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the IdPConnections
     * 
    **/
    select?: IdPConnectionsSelect | null
    /**
     * The data needed to update a IdPConnections.
     * 
    **/
    data: XOR<IdPConnectionsUpdateInput, IdPConnectionsUncheckedUpdateInput>
    /**
     * Choose, which IdPConnections to update.
     * 
    **/
    where: IdPConnectionsWhereUniqueInput
  }


  /**
   * IdPConnections updateMany
   */
  export type IdPConnectionsUpdateManyArgs = {
    data: XOR<IdPConnectionsUpdateManyMutationInput, IdPConnectionsUncheckedUpdateManyInput>
    where?: IdPConnectionsWhereInput
  }


  /**
   * IdPConnections upsert
   */
  export type IdPConnectionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the IdPConnections
     * 
    **/
    select?: IdPConnectionsSelect | null
    /**
     * The filter to search for the IdPConnections to update in case it exists.
     * 
    **/
    where: IdPConnectionsWhereUniqueInput
    /**
     * In case the IdPConnections found by the `where` argument doesn't exist, create a new IdPConnections with this data.
     * 
    **/
    create: XOR<IdPConnectionsCreateInput, IdPConnectionsUncheckedCreateInput>
    /**
     * In case the IdPConnections was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IdPConnectionsUpdateInput, IdPConnectionsUncheckedUpdateInput>
  }


  /**
   * IdPConnections delete
   */
  export type IdPConnectionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the IdPConnections
     * 
    **/
    select?: IdPConnectionsSelect | null
    /**
     * Filter which IdPConnections to delete.
     * 
    **/
    where: IdPConnectionsWhereUniqueInput
  }


  /**
   * IdPConnections deleteMany
   */
  export type IdPConnectionsDeleteManyArgs = {
    where?: IdPConnectionsWhereInput
  }


  /**
   * IdPConnections without action
   */
  export type IdPConnectionsArgs = {
    /**
     * Select specific fields to fetch from the IdPConnections
     * 
    **/
    select?: IdPConnectionsSelect | null
  }



  /**
   * Model LDAPConnections
   */


  export type AggregateLDAPConnections = {
    _count: LDAPConnectionsCountAggregateOutputType | null
    _avg: LDAPConnectionsAvgAggregateOutputType | null
    _sum: LDAPConnectionsSumAggregateOutputType | null
    _min: LDAPConnectionsMinAggregateOutputType | null
    _max: LDAPConnectionsMaxAggregateOutputType | null
  }

  export type LDAPConnectionsAvgAggregateOutputType = {
    Port: number | null
    SSL: number | null
  }

  export type LDAPConnectionsSumAggregateOutputType = {
    Port: number | null
    SSL: number | null
  }

  export type LDAPConnectionsMinAggregateOutputType = {
    Id: string | null
    Name: string | null
    Server: string | null
    Port: number | null
    Domain: string | null
    UserName: string | null
    Password: string | null
    SSL: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
  }

  export type LDAPConnectionsMaxAggregateOutputType = {
    Id: string | null
    Name: string | null
    Server: string | null
    Port: number | null
    Domain: string | null
    UserName: string | null
    Password: string | null
    SSL: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
  }

  export type LDAPConnectionsCountAggregateOutputType = {
    Id: number
    Name: number
    Server: number
    Port: number
    Domain: number
    UserName: number
    Password: number
    SSL: number
    CreatedDate: number
    ModifiedDate: number
    Status: number
    _all: number
  }


  export type LDAPConnectionsAvgAggregateInputType = {
    Port?: true
    SSL?: true
  }

  export type LDAPConnectionsSumAggregateInputType = {
    Port?: true
    SSL?: true
  }

  export type LDAPConnectionsMinAggregateInputType = {
    Id?: true
    Name?: true
    Server?: true
    Port?: true
    Domain?: true
    UserName?: true
    Password?: true
    SSL?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
  }

  export type LDAPConnectionsMaxAggregateInputType = {
    Id?: true
    Name?: true
    Server?: true
    Port?: true
    Domain?: true
    UserName?: true
    Password?: true
    SSL?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
  }

  export type LDAPConnectionsCountAggregateInputType = {
    Id?: true
    Name?: true
    Server?: true
    Port?: true
    Domain?: true
    UserName?: true
    Password?: true
    SSL?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
    _all?: true
  }

  export type LDAPConnectionsAggregateArgs = {
    /**
     * Filter which LDAPConnections to aggregate.
     * 
    **/
    where?: LDAPConnectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LDAPConnections to fetch.
     * 
    **/
    orderBy?: Enumerable<LDAPConnectionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LDAPConnectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LDAPConnections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LDAPConnections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LDAPConnections
    **/
    _count?: true | LDAPConnectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LDAPConnectionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LDAPConnectionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LDAPConnectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LDAPConnectionsMaxAggregateInputType
  }

  export type GetLDAPConnectionsAggregateType<T extends LDAPConnectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateLDAPConnections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLDAPConnections[P]>
      : GetScalarType<T[P], AggregateLDAPConnections[P]>
  }




  export type LDAPConnectionsGroupByArgs = {
    where?: LDAPConnectionsWhereInput
    orderBy?: Enumerable<LDAPConnectionsOrderByWithAggregationInput>
    by: Array<LDAPConnectionsScalarFieldEnum>
    having?: LDAPConnectionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LDAPConnectionsCountAggregateInputType | true
    _avg?: LDAPConnectionsAvgAggregateInputType
    _sum?: LDAPConnectionsSumAggregateInputType
    _min?: LDAPConnectionsMinAggregateInputType
    _max?: LDAPConnectionsMaxAggregateInputType
  }


  export type LDAPConnectionsGroupByOutputType = {
    Id: string
    Name: string | null
    Server: string | null
    Port: number | null
    Domain: string | null
    UserName: string | null
    Password: string | null
    SSL: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
    _count: LDAPConnectionsCountAggregateOutputType | null
    _avg: LDAPConnectionsAvgAggregateOutputType | null
    _sum: LDAPConnectionsSumAggregateOutputType | null
    _min: LDAPConnectionsMinAggregateOutputType | null
    _max: LDAPConnectionsMaxAggregateOutputType | null
  }

  type GetLDAPConnectionsGroupByPayload<T extends LDAPConnectionsGroupByArgs> = Promise<
    Array<
      PickArray<LDAPConnectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LDAPConnectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LDAPConnectionsGroupByOutputType[P]>
            : GetScalarType<T[P], LDAPConnectionsGroupByOutputType[P]>
        }
      >
    >


  export type LDAPConnectionsSelect = {
    Id?: boolean
    Name?: boolean
    Server?: boolean
    Port?: boolean
    Domain?: boolean
    UserName?: boolean
    Password?: boolean
    SSL?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
    Status?: boolean
  }

  export type LDAPConnectionsGetPayload<
    S extends boolean | null | undefined | LDAPConnectionsArgs,
    U = keyof S
      > = S extends true
        ? LDAPConnections
    : S extends undefined
    ? never
    : S extends LDAPConnectionsArgs | LDAPConnectionsFindManyArgs
    ?'include' extends U
    ? LDAPConnections 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof LDAPConnections ?LDAPConnections [P]
  : 
     never
  } 
    : LDAPConnections
  : LDAPConnections


  type LDAPConnectionsCountArgs = Merge<
    Omit<LDAPConnectionsFindManyArgs, 'select' | 'include'> & {
      select?: LDAPConnectionsCountAggregateInputType | true
    }
  >

  export interface LDAPConnectionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one LDAPConnections that matches the filter.
     * @param {LDAPConnectionsFindUniqueArgs} args - Arguments to find a LDAPConnections
     * @example
     * // Get one LDAPConnections
     * const lDAPConnections = await prisma.lDAPConnections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LDAPConnectionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LDAPConnectionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LDAPConnections'> extends True ? CheckSelect<T, Prisma__LDAPConnectionsClient<LDAPConnections>, Prisma__LDAPConnectionsClient<LDAPConnectionsGetPayload<T>>> : CheckSelect<T, Prisma__LDAPConnectionsClient<LDAPConnections | null >, Prisma__LDAPConnectionsClient<LDAPConnectionsGetPayload<T> | null >>

    /**
     * Find the first LDAPConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LDAPConnectionsFindFirstArgs} args - Arguments to find a LDAPConnections
     * @example
     * // Get one LDAPConnections
     * const lDAPConnections = await prisma.lDAPConnections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LDAPConnectionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LDAPConnectionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LDAPConnections'> extends True ? CheckSelect<T, Prisma__LDAPConnectionsClient<LDAPConnections>, Prisma__LDAPConnectionsClient<LDAPConnectionsGetPayload<T>>> : CheckSelect<T, Prisma__LDAPConnectionsClient<LDAPConnections | null >, Prisma__LDAPConnectionsClient<LDAPConnectionsGetPayload<T> | null >>

    /**
     * Find zero or more LDAPConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LDAPConnectionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LDAPConnections
     * const lDAPConnections = await prisma.lDAPConnections.findMany()
     * 
     * // Get first 10 LDAPConnections
     * const lDAPConnections = await prisma.lDAPConnections.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const lDAPConnectionsWithIdOnly = await prisma.lDAPConnections.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends LDAPConnectionsFindManyArgs>(
      args?: SelectSubset<T, LDAPConnectionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<LDAPConnections>>, PrismaPromise<Array<LDAPConnectionsGetPayload<T>>>>

    /**
     * Create a LDAPConnections.
     * @param {LDAPConnectionsCreateArgs} args - Arguments to create a LDAPConnections.
     * @example
     * // Create one LDAPConnections
     * const LDAPConnections = await prisma.lDAPConnections.create({
     *   data: {
     *     // ... data to create a LDAPConnections
     *   }
     * })
     * 
    **/
    create<T extends LDAPConnectionsCreateArgs>(
      args: SelectSubset<T, LDAPConnectionsCreateArgs>
    ): CheckSelect<T, Prisma__LDAPConnectionsClient<LDAPConnections>, Prisma__LDAPConnectionsClient<LDAPConnectionsGetPayload<T>>>

    /**
     * Create many LDAPConnections.
     *     @param {LDAPConnectionsCreateManyArgs} args - Arguments to create many LDAPConnections.
     *     @example
     *     // Create many LDAPConnections
     *     const lDAPConnections = await prisma.lDAPConnections.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LDAPConnectionsCreateManyArgs>(
      args?: SelectSubset<T, LDAPConnectionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LDAPConnections.
     * @param {LDAPConnectionsDeleteArgs} args - Arguments to delete one LDAPConnections.
     * @example
     * // Delete one LDAPConnections
     * const LDAPConnections = await prisma.lDAPConnections.delete({
     *   where: {
     *     // ... filter to delete one LDAPConnections
     *   }
     * })
     * 
    **/
    delete<T extends LDAPConnectionsDeleteArgs>(
      args: SelectSubset<T, LDAPConnectionsDeleteArgs>
    ): CheckSelect<T, Prisma__LDAPConnectionsClient<LDAPConnections>, Prisma__LDAPConnectionsClient<LDAPConnectionsGetPayload<T>>>

    /**
     * Update one LDAPConnections.
     * @param {LDAPConnectionsUpdateArgs} args - Arguments to update one LDAPConnections.
     * @example
     * // Update one LDAPConnections
     * const lDAPConnections = await prisma.lDAPConnections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LDAPConnectionsUpdateArgs>(
      args: SelectSubset<T, LDAPConnectionsUpdateArgs>
    ): CheckSelect<T, Prisma__LDAPConnectionsClient<LDAPConnections>, Prisma__LDAPConnectionsClient<LDAPConnectionsGetPayload<T>>>

    /**
     * Delete zero or more LDAPConnections.
     * @param {LDAPConnectionsDeleteManyArgs} args - Arguments to filter LDAPConnections to delete.
     * @example
     * // Delete a few LDAPConnections
     * const { count } = await prisma.lDAPConnections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LDAPConnectionsDeleteManyArgs>(
      args?: SelectSubset<T, LDAPConnectionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LDAPConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LDAPConnectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LDAPConnections
     * const lDAPConnections = await prisma.lDAPConnections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LDAPConnectionsUpdateManyArgs>(
      args: SelectSubset<T, LDAPConnectionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LDAPConnections.
     * @param {LDAPConnectionsUpsertArgs} args - Arguments to update or create a LDAPConnections.
     * @example
     * // Update or create a LDAPConnections
     * const lDAPConnections = await prisma.lDAPConnections.upsert({
     *   create: {
     *     // ... data to create a LDAPConnections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LDAPConnections we want to update
     *   }
     * })
    **/
    upsert<T extends LDAPConnectionsUpsertArgs>(
      args: SelectSubset<T, LDAPConnectionsUpsertArgs>
    ): CheckSelect<T, Prisma__LDAPConnectionsClient<LDAPConnections>, Prisma__LDAPConnectionsClient<LDAPConnectionsGetPayload<T>>>

    /**
     * Count the number of LDAPConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LDAPConnectionsCountArgs} args - Arguments to filter LDAPConnections to count.
     * @example
     * // Count the number of LDAPConnections
     * const count = await prisma.lDAPConnections.count({
     *   where: {
     *     // ... the filter for the LDAPConnections we want to count
     *   }
     * })
    **/
    count<T extends LDAPConnectionsCountArgs>(
      args?: Subset<T, LDAPConnectionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LDAPConnectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LDAPConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LDAPConnectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LDAPConnectionsAggregateArgs>(args: Subset<T, LDAPConnectionsAggregateArgs>): PrismaPromise<GetLDAPConnectionsAggregateType<T>>

    /**
     * Group by LDAPConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LDAPConnectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LDAPConnectionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LDAPConnectionsGroupByArgs['orderBy'] }
        : { orderBy?: LDAPConnectionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LDAPConnectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLDAPConnectionsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for LDAPConnections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LDAPConnectionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * LDAPConnections findUnique
   */
  export type LDAPConnectionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the LDAPConnections
     * 
    **/
    select?: LDAPConnectionsSelect | null
    /**
     * Throw an Error if a LDAPConnections can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LDAPConnections to fetch.
     * 
    **/
    where: LDAPConnectionsWhereUniqueInput
  }


  /**
   * LDAPConnections findFirst
   */
  export type LDAPConnectionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the LDAPConnections
     * 
    **/
    select?: LDAPConnectionsSelect | null
    /**
     * Throw an Error if a LDAPConnections can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LDAPConnections to fetch.
     * 
    **/
    where?: LDAPConnectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LDAPConnections to fetch.
     * 
    **/
    orderBy?: Enumerable<LDAPConnectionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LDAPConnections.
     * 
    **/
    cursor?: LDAPConnectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LDAPConnections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LDAPConnections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LDAPConnections.
     * 
    **/
    distinct?: Enumerable<LDAPConnectionsScalarFieldEnum>
  }


  /**
   * LDAPConnections findMany
   */
  export type LDAPConnectionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the LDAPConnections
     * 
    **/
    select?: LDAPConnectionsSelect | null
    /**
     * Filter, which LDAPConnections to fetch.
     * 
    **/
    where?: LDAPConnectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LDAPConnections to fetch.
     * 
    **/
    orderBy?: Enumerable<LDAPConnectionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LDAPConnections.
     * 
    **/
    cursor?: LDAPConnectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LDAPConnections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LDAPConnections.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LDAPConnectionsScalarFieldEnum>
  }


  /**
   * LDAPConnections create
   */
  export type LDAPConnectionsCreateArgs = {
    /**
     * Select specific fields to fetch from the LDAPConnections
     * 
    **/
    select?: LDAPConnectionsSelect | null
    /**
     * The data needed to create a LDAPConnections.
     * 
    **/
    data: XOR<LDAPConnectionsCreateInput, LDAPConnectionsUncheckedCreateInput>
  }


  /**
   * LDAPConnections createMany
   */
  export type LDAPConnectionsCreateManyArgs = {
    data: Enumerable<LDAPConnectionsCreateManyInput>
  }


  /**
   * LDAPConnections update
   */
  export type LDAPConnectionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the LDAPConnections
     * 
    **/
    select?: LDAPConnectionsSelect | null
    /**
     * The data needed to update a LDAPConnections.
     * 
    **/
    data: XOR<LDAPConnectionsUpdateInput, LDAPConnectionsUncheckedUpdateInput>
    /**
     * Choose, which LDAPConnections to update.
     * 
    **/
    where: LDAPConnectionsWhereUniqueInput
  }


  /**
   * LDAPConnections updateMany
   */
  export type LDAPConnectionsUpdateManyArgs = {
    data: XOR<LDAPConnectionsUpdateManyMutationInput, LDAPConnectionsUncheckedUpdateManyInput>
    where?: LDAPConnectionsWhereInput
  }


  /**
   * LDAPConnections upsert
   */
  export type LDAPConnectionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the LDAPConnections
     * 
    **/
    select?: LDAPConnectionsSelect | null
    /**
     * The filter to search for the LDAPConnections to update in case it exists.
     * 
    **/
    where: LDAPConnectionsWhereUniqueInput
    /**
     * In case the LDAPConnections found by the `where` argument doesn't exist, create a new LDAPConnections with this data.
     * 
    **/
    create: XOR<LDAPConnectionsCreateInput, LDAPConnectionsUncheckedCreateInput>
    /**
     * In case the LDAPConnections was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LDAPConnectionsUpdateInput, LDAPConnectionsUncheckedUpdateInput>
  }


  /**
   * LDAPConnections delete
   */
  export type LDAPConnectionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the LDAPConnections
     * 
    **/
    select?: LDAPConnectionsSelect | null
    /**
     * Filter which LDAPConnections to delete.
     * 
    **/
    where: LDAPConnectionsWhereUniqueInput
  }


  /**
   * LDAPConnections deleteMany
   */
  export type LDAPConnectionsDeleteManyArgs = {
    where?: LDAPConnectionsWhereInput
  }


  /**
   * LDAPConnections without action
   */
  export type LDAPConnectionsArgs = {
    /**
     * Select specific fields to fetch from the LDAPConnections
     * 
    **/
    select?: LDAPConnectionsSelect | null
  }



  /**
   * Model MDGProfileConnectors
   */


  export type AggregateMDGProfileConnectors = {
    _count: MDGProfileConnectorsCountAggregateOutputType | null
    _avg: MDGProfileConnectorsAvgAggregateOutputType | null
    _sum: MDGProfileConnectorsSumAggregateOutputType | null
    _min: MDGProfileConnectorsMinAggregateOutputType | null
    _max: MDGProfileConnectorsMaxAggregateOutputType | null
  }

  export type MDGProfileConnectorsAvgAggregateOutputType = {
    Status: number | null
  }

  export type MDGProfileConnectorsSumAggregateOutputType = {
    Status: number | null
  }

  export type MDGProfileConnectorsMinAggregateOutputType = {
    Id: string | null
    UserGroupId: string | null
    ProfileId: string | null
    MdgId: string | null
    RepositoryId: string | null
    Status: number | null
    CreatedDate: Date | null
  }

  export type MDGProfileConnectorsMaxAggregateOutputType = {
    Id: string | null
    UserGroupId: string | null
    ProfileId: string | null
    MdgId: string | null
    RepositoryId: string | null
    Status: number | null
    CreatedDate: Date | null
  }

  export type MDGProfileConnectorsCountAggregateOutputType = {
    Id: number
    UserGroupId: number
    ProfileId: number
    MdgId: number
    RepositoryId: number
    Status: number
    CreatedDate: number
    _all: number
  }


  export type MDGProfileConnectorsAvgAggregateInputType = {
    Status?: true
  }

  export type MDGProfileConnectorsSumAggregateInputType = {
    Status?: true
  }

  export type MDGProfileConnectorsMinAggregateInputType = {
    Id?: true
    UserGroupId?: true
    ProfileId?: true
    MdgId?: true
    RepositoryId?: true
    Status?: true
    CreatedDate?: true
  }

  export type MDGProfileConnectorsMaxAggregateInputType = {
    Id?: true
    UserGroupId?: true
    ProfileId?: true
    MdgId?: true
    RepositoryId?: true
    Status?: true
    CreatedDate?: true
  }

  export type MDGProfileConnectorsCountAggregateInputType = {
    Id?: true
    UserGroupId?: true
    ProfileId?: true
    MdgId?: true
    RepositoryId?: true
    Status?: true
    CreatedDate?: true
    _all?: true
  }

  export type MDGProfileConnectorsAggregateArgs = {
    /**
     * Filter which MDGProfileConnectors to aggregate.
     * 
    **/
    where?: MDGProfileConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MDGProfileConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<MDGProfileConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MDGProfileConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MDGProfileConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MDGProfileConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MDGProfileConnectors
    **/
    _count?: true | MDGProfileConnectorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MDGProfileConnectorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MDGProfileConnectorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MDGProfileConnectorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MDGProfileConnectorsMaxAggregateInputType
  }

  export type GetMDGProfileConnectorsAggregateType<T extends MDGProfileConnectorsAggregateArgs> = {
        [P in keyof T & keyof AggregateMDGProfileConnectors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMDGProfileConnectors[P]>
      : GetScalarType<T[P], AggregateMDGProfileConnectors[P]>
  }




  export type MDGProfileConnectorsGroupByArgs = {
    where?: MDGProfileConnectorsWhereInput
    orderBy?: Enumerable<MDGProfileConnectorsOrderByWithAggregationInput>
    by: Array<MDGProfileConnectorsScalarFieldEnum>
    having?: MDGProfileConnectorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MDGProfileConnectorsCountAggregateInputType | true
    _avg?: MDGProfileConnectorsAvgAggregateInputType
    _sum?: MDGProfileConnectorsSumAggregateInputType
    _min?: MDGProfileConnectorsMinAggregateInputType
    _max?: MDGProfileConnectorsMaxAggregateInputType
  }


  export type MDGProfileConnectorsGroupByOutputType = {
    Id: string
    UserGroupId: string | null
    ProfileId: string | null
    MdgId: string | null
    RepositoryId: string | null
    Status: number | null
    CreatedDate: Date | null
    _count: MDGProfileConnectorsCountAggregateOutputType | null
    _avg: MDGProfileConnectorsAvgAggregateOutputType | null
    _sum: MDGProfileConnectorsSumAggregateOutputType | null
    _min: MDGProfileConnectorsMinAggregateOutputType | null
    _max: MDGProfileConnectorsMaxAggregateOutputType | null
  }

  type GetMDGProfileConnectorsGroupByPayload<T extends MDGProfileConnectorsGroupByArgs> = Promise<
    Array<
      PickArray<MDGProfileConnectorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MDGProfileConnectorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MDGProfileConnectorsGroupByOutputType[P]>
            : GetScalarType<T[P], MDGProfileConnectorsGroupByOutputType[P]>
        }
      >
    >


  export type MDGProfileConnectorsSelect = {
    Id?: boolean
    UserGroupId?: boolean
    ProfileId?: boolean
    MdgId?: boolean
    RepositoryId?: boolean
    Status?: boolean
    CreatedDate?: boolean
  }

  export type MDGProfileConnectorsGetPayload<
    S extends boolean | null | undefined | MDGProfileConnectorsArgs,
    U = keyof S
      > = S extends true
        ? MDGProfileConnectors
    : S extends undefined
    ? never
    : S extends MDGProfileConnectorsArgs | MDGProfileConnectorsFindManyArgs
    ?'include' extends U
    ? MDGProfileConnectors 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MDGProfileConnectors ?MDGProfileConnectors [P]
  : 
     never
  } 
    : MDGProfileConnectors
  : MDGProfileConnectors


  type MDGProfileConnectorsCountArgs = Merge<
    Omit<MDGProfileConnectorsFindManyArgs, 'select' | 'include'> & {
      select?: MDGProfileConnectorsCountAggregateInputType | true
    }
  >

  export interface MDGProfileConnectorsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MDGProfileConnectors that matches the filter.
     * @param {MDGProfileConnectorsFindUniqueArgs} args - Arguments to find a MDGProfileConnectors
     * @example
     * // Get one MDGProfileConnectors
     * const mDGProfileConnectors = await prisma.mDGProfileConnectors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MDGProfileConnectorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MDGProfileConnectorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MDGProfileConnectors'> extends True ? CheckSelect<T, Prisma__MDGProfileConnectorsClient<MDGProfileConnectors>, Prisma__MDGProfileConnectorsClient<MDGProfileConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__MDGProfileConnectorsClient<MDGProfileConnectors | null >, Prisma__MDGProfileConnectorsClient<MDGProfileConnectorsGetPayload<T> | null >>

    /**
     * Find the first MDGProfileConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MDGProfileConnectorsFindFirstArgs} args - Arguments to find a MDGProfileConnectors
     * @example
     * // Get one MDGProfileConnectors
     * const mDGProfileConnectors = await prisma.mDGProfileConnectors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MDGProfileConnectorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MDGProfileConnectorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MDGProfileConnectors'> extends True ? CheckSelect<T, Prisma__MDGProfileConnectorsClient<MDGProfileConnectors>, Prisma__MDGProfileConnectorsClient<MDGProfileConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__MDGProfileConnectorsClient<MDGProfileConnectors | null >, Prisma__MDGProfileConnectorsClient<MDGProfileConnectorsGetPayload<T> | null >>

    /**
     * Find zero or more MDGProfileConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MDGProfileConnectorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MDGProfileConnectors
     * const mDGProfileConnectors = await prisma.mDGProfileConnectors.findMany()
     * 
     * // Get first 10 MDGProfileConnectors
     * const mDGProfileConnectors = await prisma.mDGProfileConnectors.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const mDGProfileConnectorsWithIdOnly = await prisma.mDGProfileConnectors.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends MDGProfileConnectorsFindManyArgs>(
      args?: SelectSubset<T, MDGProfileConnectorsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MDGProfileConnectors>>, PrismaPromise<Array<MDGProfileConnectorsGetPayload<T>>>>

    /**
     * Create a MDGProfileConnectors.
     * @param {MDGProfileConnectorsCreateArgs} args - Arguments to create a MDGProfileConnectors.
     * @example
     * // Create one MDGProfileConnectors
     * const MDGProfileConnectors = await prisma.mDGProfileConnectors.create({
     *   data: {
     *     // ... data to create a MDGProfileConnectors
     *   }
     * })
     * 
    **/
    create<T extends MDGProfileConnectorsCreateArgs>(
      args: SelectSubset<T, MDGProfileConnectorsCreateArgs>
    ): CheckSelect<T, Prisma__MDGProfileConnectorsClient<MDGProfileConnectors>, Prisma__MDGProfileConnectorsClient<MDGProfileConnectorsGetPayload<T>>>

    /**
     * Create many MDGProfileConnectors.
     *     @param {MDGProfileConnectorsCreateManyArgs} args - Arguments to create many MDGProfileConnectors.
     *     @example
     *     // Create many MDGProfileConnectors
     *     const mDGProfileConnectors = await prisma.mDGProfileConnectors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MDGProfileConnectorsCreateManyArgs>(
      args?: SelectSubset<T, MDGProfileConnectorsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MDGProfileConnectors.
     * @param {MDGProfileConnectorsDeleteArgs} args - Arguments to delete one MDGProfileConnectors.
     * @example
     * // Delete one MDGProfileConnectors
     * const MDGProfileConnectors = await prisma.mDGProfileConnectors.delete({
     *   where: {
     *     // ... filter to delete one MDGProfileConnectors
     *   }
     * })
     * 
    **/
    delete<T extends MDGProfileConnectorsDeleteArgs>(
      args: SelectSubset<T, MDGProfileConnectorsDeleteArgs>
    ): CheckSelect<T, Prisma__MDGProfileConnectorsClient<MDGProfileConnectors>, Prisma__MDGProfileConnectorsClient<MDGProfileConnectorsGetPayload<T>>>

    /**
     * Update one MDGProfileConnectors.
     * @param {MDGProfileConnectorsUpdateArgs} args - Arguments to update one MDGProfileConnectors.
     * @example
     * // Update one MDGProfileConnectors
     * const mDGProfileConnectors = await prisma.mDGProfileConnectors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MDGProfileConnectorsUpdateArgs>(
      args: SelectSubset<T, MDGProfileConnectorsUpdateArgs>
    ): CheckSelect<T, Prisma__MDGProfileConnectorsClient<MDGProfileConnectors>, Prisma__MDGProfileConnectorsClient<MDGProfileConnectorsGetPayload<T>>>

    /**
     * Delete zero or more MDGProfileConnectors.
     * @param {MDGProfileConnectorsDeleteManyArgs} args - Arguments to filter MDGProfileConnectors to delete.
     * @example
     * // Delete a few MDGProfileConnectors
     * const { count } = await prisma.mDGProfileConnectors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MDGProfileConnectorsDeleteManyArgs>(
      args?: SelectSubset<T, MDGProfileConnectorsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MDGProfileConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MDGProfileConnectorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MDGProfileConnectors
     * const mDGProfileConnectors = await prisma.mDGProfileConnectors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MDGProfileConnectorsUpdateManyArgs>(
      args: SelectSubset<T, MDGProfileConnectorsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MDGProfileConnectors.
     * @param {MDGProfileConnectorsUpsertArgs} args - Arguments to update or create a MDGProfileConnectors.
     * @example
     * // Update or create a MDGProfileConnectors
     * const mDGProfileConnectors = await prisma.mDGProfileConnectors.upsert({
     *   create: {
     *     // ... data to create a MDGProfileConnectors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MDGProfileConnectors we want to update
     *   }
     * })
    **/
    upsert<T extends MDGProfileConnectorsUpsertArgs>(
      args: SelectSubset<T, MDGProfileConnectorsUpsertArgs>
    ): CheckSelect<T, Prisma__MDGProfileConnectorsClient<MDGProfileConnectors>, Prisma__MDGProfileConnectorsClient<MDGProfileConnectorsGetPayload<T>>>

    /**
     * Count the number of MDGProfileConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MDGProfileConnectorsCountArgs} args - Arguments to filter MDGProfileConnectors to count.
     * @example
     * // Count the number of MDGProfileConnectors
     * const count = await prisma.mDGProfileConnectors.count({
     *   where: {
     *     // ... the filter for the MDGProfileConnectors we want to count
     *   }
     * })
    **/
    count<T extends MDGProfileConnectorsCountArgs>(
      args?: Subset<T, MDGProfileConnectorsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MDGProfileConnectorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MDGProfileConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MDGProfileConnectorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MDGProfileConnectorsAggregateArgs>(args: Subset<T, MDGProfileConnectorsAggregateArgs>): PrismaPromise<GetMDGProfileConnectorsAggregateType<T>>

    /**
     * Group by MDGProfileConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MDGProfileConnectorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MDGProfileConnectorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MDGProfileConnectorsGroupByArgs['orderBy'] }
        : { orderBy?: MDGProfileConnectorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MDGProfileConnectorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMDGProfileConnectorsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MDGProfileConnectors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MDGProfileConnectorsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MDGProfileConnectors findUnique
   */
  export type MDGProfileConnectorsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MDGProfileConnectors
     * 
    **/
    select?: MDGProfileConnectorsSelect | null
    /**
     * Throw an Error if a MDGProfileConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MDGProfileConnectors to fetch.
     * 
    **/
    where: MDGProfileConnectorsWhereUniqueInput
  }


  /**
   * MDGProfileConnectors findFirst
   */
  export type MDGProfileConnectorsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MDGProfileConnectors
     * 
    **/
    select?: MDGProfileConnectorsSelect | null
    /**
     * Throw an Error if a MDGProfileConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MDGProfileConnectors to fetch.
     * 
    **/
    where?: MDGProfileConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MDGProfileConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<MDGProfileConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MDGProfileConnectors.
     * 
    **/
    cursor?: MDGProfileConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MDGProfileConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MDGProfileConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MDGProfileConnectors.
     * 
    **/
    distinct?: Enumerable<MDGProfileConnectorsScalarFieldEnum>
  }


  /**
   * MDGProfileConnectors findMany
   */
  export type MDGProfileConnectorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the MDGProfileConnectors
     * 
    **/
    select?: MDGProfileConnectorsSelect | null
    /**
     * Filter, which MDGProfileConnectors to fetch.
     * 
    **/
    where?: MDGProfileConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MDGProfileConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<MDGProfileConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MDGProfileConnectors.
     * 
    **/
    cursor?: MDGProfileConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MDGProfileConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MDGProfileConnectors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MDGProfileConnectorsScalarFieldEnum>
  }


  /**
   * MDGProfileConnectors create
   */
  export type MDGProfileConnectorsCreateArgs = {
    /**
     * Select specific fields to fetch from the MDGProfileConnectors
     * 
    **/
    select?: MDGProfileConnectorsSelect | null
    /**
     * The data needed to create a MDGProfileConnectors.
     * 
    **/
    data: XOR<MDGProfileConnectorsCreateInput, MDGProfileConnectorsUncheckedCreateInput>
  }


  /**
   * MDGProfileConnectors createMany
   */
  export type MDGProfileConnectorsCreateManyArgs = {
    data: Enumerable<MDGProfileConnectorsCreateManyInput>
  }


  /**
   * MDGProfileConnectors update
   */
  export type MDGProfileConnectorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the MDGProfileConnectors
     * 
    **/
    select?: MDGProfileConnectorsSelect | null
    /**
     * The data needed to update a MDGProfileConnectors.
     * 
    **/
    data: XOR<MDGProfileConnectorsUpdateInput, MDGProfileConnectorsUncheckedUpdateInput>
    /**
     * Choose, which MDGProfileConnectors to update.
     * 
    **/
    where: MDGProfileConnectorsWhereUniqueInput
  }


  /**
   * MDGProfileConnectors updateMany
   */
  export type MDGProfileConnectorsUpdateManyArgs = {
    data: XOR<MDGProfileConnectorsUpdateManyMutationInput, MDGProfileConnectorsUncheckedUpdateManyInput>
    where?: MDGProfileConnectorsWhereInput
  }


  /**
   * MDGProfileConnectors upsert
   */
  export type MDGProfileConnectorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the MDGProfileConnectors
     * 
    **/
    select?: MDGProfileConnectorsSelect | null
    /**
     * The filter to search for the MDGProfileConnectors to update in case it exists.
     * 
    **/
    where: MDGProfileConnectorsWhereUniqueInput
    /**
     * In case the MDGProfileConnectors found by the `where` argument doesn't exist, create a new MDGProfileConnectors with this data.
     * 
    **/
    create: XOR<MDGProfileConnectorsCreateInput, MDGProfileConnectorsUncheckedCreateInput>
    /**
     * In case the MDGProfileConnectors was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MDGProfileConnectorsUpdateInput, MDGProfileConnectorsUncheckedUpdateInput>
  }


  /**
   * MDGProfileConnectors delete
   */
  export type MDGProfileConnectorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the MDGProfileConnectors
     * 
    **/
    select?: MDGProfileConnectorsSelect | null
    /**
     * Filter which MDGProfileConnectors to delete.
     * 
    **/
    where: MDGProfileConnectorsWhereUniqueInput
  }


  /**
   * MDGProfileConnectors deleteMany
   */
  export type MDGProfileConnectorsDeleteManyArgs = {
    where?: MDGProfileConnectorsWhereInput
  }


  /**
   * MDGProfileConnectors without action
   */
  export type MDGProfileConnectorsArgs = {
    /**
     * Select specific fields to fetch from the MDGProfileConnectors
     * 
    **/
    select?: MDGProfileConnectorsSelect | null
  }



  /**
   * Model MDGTechnologies
   */


  export type AggregateMDGTechnologies = {
    _count: MDGTechnologiesCountAggregateOutputType | null
    _avg: MDGTechnologiesAvgAggregateOutputType | null
    _sum: MDGTechnologiesSumAggregateOutputType | null
    _min: MDGTechnologiesMinAggregateOutputType | null
    _max: MDGTechnologiesMaxAggregateOutputType | null
  }

  export type MDGTechnologiesAvgAggregateOutputType = {
    BuiltIn: number | null
    IsEnabled: number | null
  }

  export type MDGTechnologiesSumAggregateOutputType = {
    BuiltIn: number | null
    IsEnabled: number | null
  }

  export type MDGTechnologiesMinAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    Name: string | null
    InternalName: string | null
    Description: string | null
    XmlContent: string | null
    BuiltIn: number | null
    IsEnabled: number | null
    Created: Date | null
    Modified: Date | null
  }

  export type MDGTechnologiesMaxAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    Name: string | null
    InternalName: string | null
    Description: string | null
    XmlContent: string | null
    BuiltIn: number | null
    IsEnabled: number | null
    Created: Date | null
    Modified: Date | null
  }

  export type MDGTechnologiesCountAggregateOutputType = {
    Id: number
    Repository_Id: number
    Name: number
    InternalName: number
    Description: number
    XmlContent: number
    BuiltIn: number
    IsEnabled: number
    Created: number
    Modified: number
    _all: number
  }


  export type MDGTechnologiesAvgAggregateInputType = {
    BuiltIn?: true
    IsEnabled?: true
  }

  export type MDGTechnologiesSumAggregateInputType = {
    BuiltIn?: true
    IsEnabled?: true
  }

  export type MDGTechnologiesMinAggregateInputType = {
    Id?: true
    Repository_Id?: true
    Name?: true
    InternalName?: true
    Description?: true
    XmlContent?: true
    BuiltIn?: true
    IsEnabled?: true
    Created?: true
    Modified?: true
  }

  export type MDGTechnologiesMaxAggregateInputType = {
    Id?: true
    Repository_Id?: true
    Name?: true
    InternalName?: true
    Description?: true
    XmlContent?: true
    BuiltIn?: true
    IsEnabled?: true
    Created?: true
    Modified?: true
  }

  export type MDGTechnologiesCountAggregateInputType = {
    Id?: true
    Repository_Id?: true
    Name?: true
    InternalName?: true
    Description?: true
    XmlContent?: true
    BuiltIn?: true
    IsEnabled?: true
    Created?: true
    Modified?: true
    _all?: true
  }

  export type MDGTechnologiesAggregateArgs = {
    /**
     * Filter which MDGTechnologies to aggregate.
     * 
    **/
    where?: MDGTechnologiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MDGTechnologies to fetch.
     * 
    **/
    orderBy?: Enumerable<MDGTechnologiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MDGTechnologiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MDGTechnologies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MDGTechnologies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MDGTechnologies
    **/
    _count?: true | MDGTechnologiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MDGTechnologiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MDGTechnologiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MDGTechnologiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MDGTechnologiesMaxAggregateInputType
  }

  export type GetMDGTechnologiesAggregateType<T extends MDGTechnologiesAggregateArgs> = {
        [P in keyof T & keyof AggregateMDGTechnologies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMDGTechnologies[P]>
      : GetScalarType<T[P], AggregateMDGTechnologies[P]>
  }




  export type MDGTechnologiesGroupByArgs = {
    where?: MDGTechnologiesWhereInput
    orderBy?: Enumerable<MDGTechnologiesOrderByWithAggregationInput>
    by: Array<MDGTechnologiesScalarFieldEnum>
    having?: MDGTechnologiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MDGTechnologiesCountAggregateInputType | true
    _avg?: MDGTechnologiesAvgAggregateInputType
    _sum?: MDGTechnologiesSumAggregateInputType
    _min?: MDGTechnologiesMinAggregateInputType
    _max?: MDGTechnologiesMaxAggregateInputType
  }


  export type MDGTechnologiesGroupByOutputType = {
    Id: string
    Repository_Id: string
    Name: string
    InternalName: string | null
    Description: string | null
    XmlContent: string | null
    BuiltIn: number
    IsEnabled: number
    Created: Date
    Modified: Date
    _count: MDGTechnologiesCountAggregateOutputType | null
    _avg: MDGTechnologiesAvgAggregateOutputType | null
    _sum: MDGTechnologiesSumAggregateOutputType | null
    _min: MDGTechnologiesMinAggregateOutputType | null
    _max: MDGTechnologiesMaxAggregateOutputType | null
  }

  type GetMDGTechnologiesGroupByPayload<T extends MDGTechnologiesGroupByArgs> = Promise<
    Array<
      PickArray<MDGTechnologiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MDGTechnologiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MDGTechnologiesGroupByOutputType[P]>
            : GetScalarType<T[P], MDGTechnologiesGroupByOutputType[P]>
        }
      >
    >


  export type MDGTechnologiesSelect = {
    Id?: boolean
    Repository_Id?: boolean
    Name?: boolean
    InternalName?: boolean
    Description?: boolean
    XmlContent?: boolean
    BuiltIn?: boolean
    IsEnabled?: boolean
    Created?: boolean
    Modified?: boolean
  }

  export type MDGTechnologiesGetPayload<
    S extends boolean | null | undefined | MDGTechnologiesArgs,
    U = keyof S
      > = S extends true
        ? MDGTechnologies
    : S extends undefined
    ? never
    : S extends MDGTechnologiesArgs | MDGTechnologiesFindManyArgs
    ?'include' extends U
    ? MDGTechnologies 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MDGTechnologies ?MDGTechnologies [P]
  : 
     never
  } 
    : MDGTechnologies
  : MDGTechnologies


  type MDGTechnologiesCountArgs = Merge<
    Omit<MDGTechnologiesFindManyArgs, 'select' | 'include'> & {
      select?: MDGTechnologiesCountAggregateInputType | true
    }
  >

  export interface MDGTechnologiesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MDGTechnologies that matches the filter.
     * @param {MDGTechnologiesFindUniqueArgs} args - Arguments to find a MDGTechnologies
     * @example
     * // Get one MDGTechnologies
     * const mDGTechnologies = await prisma.mDGTechnologies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MDGTechnologiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MDGTechnologiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MDGTechnologies'> extends True ? CheckSelect<T, Prisma__MDGTechnologiesClient<MDGTechnologies>, Prisma__MDGTechnologiesClient<MDGTechnologiesGetPayload<T>>> : CheckSelect<T, Prisma__MDGTechnologiesClient<MDGTechnologies | null >, Prisma__MDGTechnologiesClient<MDGTechnologiesGetPayload<T> | null >>

    /**
     * Find the first MDGTechnologies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MDGTechnologiesFindFirstArgs} args - Arguments to find a MDGTechnologies
     * @example
     * // Get one MDGTechnologies
     * const mDGTechnologies = await prisma.mDGTechnologies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MDGTechnologiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MDGTechnologiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MDGTechnologies'> extends True ? CheckSelect<T, Prisma__MDGTechnologiesClient<MDGTechnologies>, Prisma__MDGTechnologiesClient<MDGTechnologiesGetPayload<T>>> : CheckSelect<T, Prisma__MDGTechnologiesClient<MDGTechnologies | null >, Prisma__MDGTechnologiesClient<MDGTechnologiesGetPayload<T> | null >>

    /**
     * Find zero or more MDGTechnologies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MDGTechnologiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MDGTechnologies
     * const mDGTechnologies = await prisma.mDGTechnologies.findMany()
     * 
     * // Get first 10 MDGTechnologies
     * const mDGTechnologies = await prisma.mDGTechnologies.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const mDGTechnologiesWithIdOnly = await prisma.mDGTechnologies.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends MDGTechnologiesFindManyArgs>(
      args?: SelectSubset<T, MDGTechnologiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MDGTechnologies>>, PrismaPromise<Array<MDGTechnologiesGetPayload<T>>>>

    /**
     * Create a MDGTechnologies.
     * @param {MDGTechnologiesCreateArgs} args - Arguments to create a MDGTechnologies.
     * @example
     * // Create one MDGTechnologies
     * const MDGTechnologies = await prisma.mDGTechnologies.create({
     *   data: {
     *     // ... data to create a MDGTechnologies
     *   }
     * })
     * 
    **/
    create<T extends MDGTechnologiesCreateArgs>(
      args: SelectSubset<T, MDGTechnologiesCreateArgs>
    ): CheckSelect<T, Prisma__MDGTechnologiesClient<MDGTechnologies>, Prisma__MDGTechnologiesClient<MDGTechnologiesGetPayload<T>>>

    /**
     * Create many MDGTechnologies.
     *     @param {MDGTechnologiesCreateManyArgs} args - Arguments to create many MDGTechnologies.
     *     @example
     *     // Create many MDGTechnologies
     *     const mDGTechnologies = await prisma.mDGTechnologies.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MDGTechnologiesCreateManyArgs>(
      args?: SelectSubset<T, MDGTechnologiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MDGTechnologies.
     * @param {MDGTechnologiesDeleteArgs} args - Arguments to delete one MDGTechnologies.
     * @example
     * // Delete one MDGTechnologies
     * const MDGTechnologies = await prisma.mDGTechnologies.delete({
     *   where: {
     *     // ... filter to delete one MDGTechnologies
     *   }
     * })
     * 
    **/
    delete<T extends MDGTechnologiesDeleteArgs>(
      args: SelectSubset<T, MDGTechnologiesDeleteArgs>
    ): CheckSelect<T, Prisma__MDGTechnologiesClient<MDGTechnologies>, Prisma__MDGTechnologiesClient<MDGTechnologiesGetPayload<T>>>

    /**
     * Update one MDGTechnologies.
     * @param {MDGTechnologiesUpdateArgs} args - Arguments to update one MDGTechnologies.
     * @example
     * // Update one MDGTechnologies
     * const mDGTechnologies = await prisma.mDGTechnologies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MDGTechnologiesUpdateArgs>(
      args: SelectSubset<T, MDGTechnologiesUpdateArgs>
    ): CheckSelect<T, Prisma__MDGTechnologiesClient<MDGTechnologies>, Prisma__MDGTechnologiesClient<MDGTechnologiesGetPayload<T>>>

    /**
     * Delete zero or more MDGTechnologies.
     * @param {MDGTechnologiesDeleteManyArgs} args - Arguments to filter MDGTechnologies to delete.
     * @example
     * // Delete a few MDGTechnologies
     * const { count } = await prisma.mDGTechnologies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MDGTechnologiesDeleteManyArgs>(
      args?: SelectSubset<T, MDGTechnologiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MDGTechnologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MDGTechnologiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MDGTechnologies
     * const mDGTechnologies = await prisma.mDGTechnologies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MDGTechnologiesUpdateManyArgs>(
      args: SelectSubset<T, MDGTechnologiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MDGTechnologies.
     * @param {MDGTechnologiesUpsertArgs} args - Arguments to update or create a MDGTechnologies.
     * @example
     * // Update or create a MDGTechnologies
     * const mDGTechnologies = await prisma.mDGTechnologies.upsert({
     *   create: {
     *     // ... data to create a MDGTechnologies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MDGTechnologies we want to update
     *   }
     * })
    **/
    upsert<T extends MDGTechnologiesUpsertArgs>(
      args: SelectSubset<T, MDGTechnologiesUpsertArgs>
    ): CheckSelect<T, Prisma__MDGTechnologiesClient<MDGTechnologies>, Prisma__MDGTechnologiesClient<MDGTechnologiesGetPayload<T>>>

    /**
     * Count the number of MDGTechnologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MDGTechnologiesCountArgs} args - Arguments to filter MDGTechnologies to count.
     * @example
     * // Count the number of MDGTechnologies
     * const count = await prisma.mDGTechnologies.count({
     *   where: {
     *     // ... the filter for the MDGTechnologies we want to count
     *   }
     * })
    **/
    count<T extends MDGTechnologiesCountArgs>(
      args?: Subset<T, MDGTechnologiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MDGTechnologiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MDGTechnologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MDGTechnologiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MDGTechnologiesAggregateArgs>(args: Subset<T, MDGTechnologiesAggregateArgs>): PrismaPromise<GetMDGTechnologiesAggregateType<T>>

    /**
     * Group by MDGTechnologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MDGTechnologiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MDGTechnologiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MDGTechnologiesGroupByArgs['orderBy'] }
        : { orderBy?: MDGTechnologiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MDGTechnologiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMDGTechnologiesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MDGTechnologies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MDGTechnologiesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MDGTechnologies findUnique
   */
  export type MDGTechnologiesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MDGTechnologies
     * 
    **/
    select?: MDGTechnologiesSelect | null
    /**
     * Throw an Error if a MDGTechnologies can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MDGTechnologies to fetch.
     * 
    **/
    where: MDGTechnologiesWhereUniqueInput
  }


  /**
   * MDGTechnologies findFirst
   */
  export type MDGTechnologiesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MDGTechnologies
     * 
    **/
    select?: MDGTechnologiesSelect | null
    /**
     * Throw an Error if a MDGTechnologies can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MDGTechnologies to fetch.
     * 
    **/
    where?: MDGTechnologiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MDGTechnologies to fetch.
     * 
    **/
    orderBy?: Enumerable<MDGTechnologiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MDGTechnologies.
     * 
    **/
    cursor?: MDGTechnologiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MDGTechnologies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MDGTechnologies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MDGTechnologies.
     * 
    **/
    distinct?: Enumerable<MDGTechnologiesScalarFieldEnum>
  }


  /**
   * MDGTechnologies findMany
   */
  export type MDGTechnologiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the MDGTechnologies
     * 
    **/
    select?: MDGTechnologiesSelect | null
    /**
     * Filter, which MDGTechnologies to fetch.
     * 
    **/
    where?: MDGTechnologiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MDGTechnologies to fetch.
     * 
    **/
    orderBy?: Enumerable<MDGTechnologiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MDGTechnologies.
     * 
    **/
    cursor?: MDGTechnologiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MDGTechnologies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MDGTechnologies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MDGTechnologiesScalarFieldEnum>
  }


  /**
   * MDGTechnologies create
   */
  export type MDGTechnologiesCreateArgs = {
    /**
     * Select specific fields to fetch from the MDGTechnologies
     * 
    **/
    select?: MDGTechnologiesSelect | null
    /**
     * The data needed to create a MDGTechnologies.
     * 
    **/
    data: XOR<MDGTechnologiesCreateInput, MDGTechnologiesUncheckedCreateInput>
  }


  /**
   * MDGTechnologies createMany
   */
  export type MDGTechnologiesCreateManyArgs = {
    data: Enumerable<MDGTechnologiesCreateManyInput>
  }


  /**
   * MDGTechnologies update
   */
  export type MDGTechnologiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the MDGTechnologies
     * 
    **/
    select?: MDGTechnologiesSelect | null
    /**
     * The data needed to update a MDGTechnologies.
     * 
    **/
    data: XOR<MDGTechnologiesUpdateInput, MDGTechnologiesUncheckedUpdateInput>
    /**
     * Choose, which MDGTechnologies to update.
     * 
    **/
    where: MDGTechnologiesWhereUniqueInput
  }


  /**
   * MDGTechnologies updateMany
   */
  export type MDGTechnologiesUpdateManyArgs = {
    data: XOR<MDGTechnologiesUpdateManyMutationInput, MDGTechnologiesUncheckedUpdateManyInput>
    where?: MDGTechnologiesWhereInput
  }


  /**
   * MDGTechnologies upsert
   */
  export type MDGTechnologiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the MDGTechnologies
     * 
    **/
    select?: MDGTechnologiesSelect | null
    /**
     * The filter to search for the MDGTechnologies to update in case it exists.
     * 
    **/
    where: MDGTechnologiesWhereUniqueInput
    /**
     * In case the MDGTechnologies found by the `where` argument doesn't exist, create a new MDGTechnologies with this data.
     * 
    **/
    create: XOR<MDGTechnologiesCreateInput, MDGTechnologiesUncheckedCreateInput>
    /**
     * In case the MDGTechnologies was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MDGTechnologiesUpdateInput, MDGTechnologiesUncheckedUpdateInput>
  }


  /**
   * MDGTechnologies delete
   */
  export type MDGTechnologiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the MDGTechnologies
     * 
    **/
    select?: MDGTechnologiesSelect | null
    /**
     * Filter which MDGTechnologies to delete.
     * 
    **/
    where: MDGTechnologiesWhereUniqueInput
  }


  /**
   * MDGTechnologies deleteMany
   */
  export type MDGTechnologiesDeleteManyArgs = {
    where?: MDGTechnologiesWhereInput
  }


  /**
   * MDGTechnologies without action
   */
  export type MDGTechnologiesArgs = {
    /**
     * Select specific fields to fetch from the MDGTechnologies
     * 
    **/
    select?: MDGTechnologiesSelect | null
  }



  /**
   * Model MenuItemProfileConnectors
   */


  export type AggregateMenuItemProfileConnectors = {
    _count: MenuItemProfileConnectorsCountAggregateOutputType | null
    _min: MenuItemProfileConnectorsMinAggregateOutputType | null
    _max: MenuItemProfileConnectorsMaxAggregateOutputType | null
  }

  export type MenuItemProfileConnectorsMinAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    User_Id: string | null
    UserGroup_Id: string | null
    Profile_Id: string | null
    Default_Profile_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type MenuItemProfileConnectorsMaxAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    User_Id: string | null
    UserGroup_Id: string | null
    Profile_Id: string | null
    Default_Profile_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type MenuItemProfileConnectorsCountAggregateOutputType = {
    Id: number
    Repository_Id: number
    User_Id: number
    UserGroup_Id: number
    Profile_Id: number
    Default_Profile_Id: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type MenuItemProfileConnectorsMinAggregateInputType = {
    Id?: true
    Repository_Id?: true
    User_Id?: true
    UserGroup_Id?: true
    Profile_Id?: true
    Default_Profile_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type MenuItemProfileConnectorsMaxAggregateInputType = {
    Id?: true
    Repository_Id?: true
    User_Id?: true
    UserGroup_Id?: true
    Profile_Id?: true
    Default_Profile_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type MenuItemProfileConnectorsCountAggregateInputType = {
    Id?: true
    Repository_Id?: true
    User_Id?: true
    UserGroup_Id?: true
    Profile_Id?: true
    Default_Profile_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type MenuItemProfileConnectorsAggregateArgs = {
    /**
     * Filter which MenuItemProfileConnectors to aggregate.
     * 
    **/
    where?: MenuItemProfileConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemProfileConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<MenuItemProfileConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MenuItemProfileConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemProfileConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemProfileConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuItemProfileConnectors
    **/
    _count?: true | MenuItemProfileConnectorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuItemProfileConnectorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuItemProfileConnectorsMaxAggregateInputType
  }

  export type GetMenuItemProfileConnectorsAggregateType<T extends MenuItemProfileConnectorsAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuItemProfileConnectors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuItemProfileConnectors[P]>
      : GetScalarType<T[P], AggregateMenuItemProfileConnectors[P]>
  }




  export type MenuItemProfileConnectorsGroupByArgs = {
    where?: MenuItemProfileConnectorsWhereInput
    orderBy?: Enumerable<MenuItemProfileConnectorsOrderByWithAggregationInput>
    by: Array<MenuItemProfileConnectorsScalarFieldEnum>
    having?: MenuItemProfileConnectorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuItemProfileConnectorsCountAggregateInputType | true
    _min?: MenuItemProfileConnectorsMinAggregateInputType
    _max?: MenuItemProfileConnectorsMaxAggregateInputType
  }


  export type MenuItemProfileConnectorsGroupByOutputType = {
    Id: string
    Repository_Id: string | null
    User_Id: string | null
    UserGroup_Id: string | null
    Profile_Id: string | null
    Default_Profile_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: MenuItemProfileConnectorsCountAggregateOutputType | null
    _min: MenuItemProfileConnectorsMinAggregateOutputType | null
    _max: MenuItemProfileConnectorsMaxAggregateOutputType | null
  }

  type GetMenuItemProfileConnectorsGroupByPayload<T extends MenuItemProfileConnectorsGroupByArgs> = Promise<
    Array<
      PickArray<MenuItemProfileConnectorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuItemProfileConnectorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuItemProfileConnectorsGroupByOutputType[P]>
            : GetScalarType<T[P], MenuItemProfileConnectorsGroupByOutputType[P]>
        }
      >
    >


  export type MenuItemProfileConnectorsSelect = {
    Id?: boolean
    Repository_Id?: boolean
    User_Id?: boolean
    UserGroup_Id?: boolean
    Profile_Id?: boolean
    Default_Profile_Id?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type MenuItemProfileConnectorsGetPayload<
    S extends boolean | null | undefined | MenuItemProfileConnectorsArgs,
    U = keyof S
      > = S extends true
        ? MenuItemProfileConnectors
    : S extends undefined
    ? never
    : S extends MenuItemProfileConnectorsArgs | MenuItemProfileConnectorsFindManyArgs
    ?'include' extends U
    ? MenuItemProfileConnectors 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MenuItemProfileConnectors ?MenuItemProfileConnectors [P]
  : 
     never
  } 
    : MenuItemProfileConnectors
  : MenuItemProfileConnectors


  type MenuItemProfileConnectorsCountArgs = Merge<
    Omit<MenuItemProfileConnectorsFindManyArgs, 'select' | 'include'> & {
      select?: MenuItemProfileConnectorsCountAggregateInputType | true
    }
  >

  export interface MenuItemProfileConnectorsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MenuItemProfileConnectors that matches the filter.
     * @param {MenuItemProfileConnectorsFindUniqueArgs} args - Arguments to find a MenuItemProfileConnectors
     * @example
     * // Get one MenuItemProfileConnectors
     * const menuItemProfileConnectors = await prisma.menuItemProfileConnectors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MenuItemProfileConnectorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MenuItemProfileConnectorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MenuItemProfileConnectors'> extends True ? CheckSelect<T, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectors>, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectors | null >, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectorsGetPayload<T> | null >>

    /**
     * Find the first MenuItemProfileConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfileConnectorsFindFirstArgs} args - Arguments to find a MenuItemProfileConnectors
     * @example
     * // Get one MenuItemProfileConnectors
     * const menuItemProfileConnectors = await prisma.menuItemProfileConnectors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MenuItemProfileConnectorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MenuItemProfileConnectorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MenuItemProfileConnectors'> extends True ? CheckSelect<T, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectors>, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectors | null >, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectorsGetPayload<T> | null >>

    /**
     * Find zero or more MenuItemProfileConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfileConnectorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuItemProfileConnectors
     * const menuItemProfileConnectors = await prisma.menuItemProfileConnectors.findMany()
     * 
     * // Get first 10 MenuItemProfileConnectors
     * const menuItemProfileConnectors = await prisma.menuItemProfileConnectors.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const menuItemProfileConnectorsWithIdOnly = await prisma.menuItemProfileConnectors.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends MenuItemProfileConnectorsFindManyArgs>(
      args?: SelectSubset<T, MenuItemProfileConnectorsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MenuItemProfileConnectors>>, PrismaPromise<Array<MenuItemProfileConnectorsGetPayload<T>>>>

    /**
     * Create a MenuItemProfileConnectors.
     * @param {MenuItemProfileConnectorsCreateArgs} args - Arguments to create a MenuItemProfileConnectors.
     * @example
     * // Create one MenuItemProfileConnectors
     * const MenuItemProfileConnectors = await prisma.menuItemProfileConnectors.create({
     *   data: {
     *     // ... data to create a MenuItemProfileConnectors
     *   }
     * })
     * 
    **/
    create<T extends MenuItemProfileConnectorsCreateArgs>(
      args: SelectSubset<T, MenuItemProfileConnectorsCreateArgs>
    ): CheckSelect<T, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectors>, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectorsGetPayload<T>>>

    /**
     * Create many MenuItemProfileConnectors.
     *     @param {MenuItemProfileConnectorsCreateManyArgs} args - Arguments to create many MenuItemProfileConnectors.
     *     @example
     *     // Create many MenuItemProfileConnectors
     *     const menuItemProfileConnectors = await prisma.menuItemProfileConnectors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MenuItemProfileConnectorsCreateManyArgs>(
      args?: SelectSubset<T, MenuItemProfileConnectorsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MenuItemProfileConnectors.
     * @param {MenuItemProfileConnectorsDeleteArgs} args - Arguments to delete one MenuItemProfileConnectors.
     * @example
     * // Delete one MenuItemProfileConnectors
     * const MenuItemProfileConnectors = await prisma.menuItemProfileConnectors.delete({
     *   where: {
     *     // ... filter to delete one MenuItemProfileConnectors
     *   }
     * })
     * 
    **/
    delete<T extends MenuItemProfileConnectorsDeleteArgs>(
      args: SelectSubset<T, MenuItemProfileConnectorsDeleteArgs>
    ): CheckSelect<T, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectors>, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectorsGetPayload<T>>>

    /**
     * Update one MenuItemProfileConnectors.
     * @param {MenuItemProfileConnectorsUpdateArgs} args - Arguments to update one MenuItemProfileConnectors.
     * @example
     * // Update one MenuItemProfileConnectors
     * const menuItemProfileConnectors = await prisma.menuItemProfileConnectors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MenuItemProfileConnectorsUpdateArgs>(
      args: SelectSubset<T, MenuItemProfileConnectorsUpdateArgs>
    ): CheckSelect<T, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectors>, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectorsGetPayload<T>>>

    /**
     * Delete zero or more MenuItemProfileConnectors.
     * @param {MenuItemProfileConnectorsDeleteManyArgs} args - Arguments to filter MenuItemProfileConnectors to delete.
     * @example
     * // Delete a few MenuItemProfileConnectors
     * const { count } = await prisma.menuItemProfileConnectors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MenuItemProfileConnectorsDeleteManyArgs>(
      args?: SelectSubset<T, MenuItemProfileConnectorsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItemProfileConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfileConnectorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuItemProfileConnectors
     * const menuItemProfileConnectors = await prisma.menuItemProfileConnectors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MenuItemProfileConnectorsUpdateManyArgs>(
      args: SelectSubset<T, MenuItemProfileConnectorsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MenuItemProfileConnectors.
     * @param {MenuItemProfileConnectorsUpsertArgs} args - Arguments to update or create a MenuItemProfileConnectors.
     * @example
     * // Update or create a MenuItemProfileConnectors
     * const menuItemProfileConnectors = await prisma.menuItemProfileConnectors.upsert({
     *   create: {
     *     // ... data to create a MenuItemProfileConnectors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuItemProfileConnectors we want to update
     *   }
     * })
    **/
    upsert<T extends MenuItemProfileConnectorsUpsertArgs>(
      args: SelectSubset<T, MenuItemProfileConnectorsUpsertArgs>
    ): CheckSelect<T, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectors>, Prisma__MenuItemProfileConnectorsClient<MenuItemProfileConnectorsGetPayload<T>>>

    /**
     * Count the number of MenuItemProfileConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfileConnectorsCountArgs} args - Arguments to filter MenuItemProfileConnectors to count.
     * @example
     * // Count the number of MenuItemProfileConnectors
     * const count = await prisma.menuItemProfileConnectors.count({
     *   where: {
     *     // ... the filter for the MenuItemProfileConnectors we want to count
     *   }
     * })
    **/
    count<T extends MenuItemProfileConnectorsCountArgs>(
      args?: Subset<T, MenuItemProfileConnectorsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuItemProfileConnectorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuItemProfileConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfileConnectorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuItemProfileConnectorsAggregateArgs>(args: Subset<T, MenuItemProfileConnectorsAggregateArgs>): PrismaPromise<GetMenuItemProfileConnectorsAggregateType<T>>

    /**
     * Group by MenuItemProfileConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfileConnectorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuItemProfileConnectorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuItemProfileConnectorsGroupByArgs['orderBy'] }
        : { orderBy?: MenuItemProfileConnectorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuItemProfileConnectorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuItemProfileConnectorsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuItemProfileConnectors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MenuItemProfileConnectorsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MenuItemProfileConnectors findUnique
   */
  export type MenuItemProfileConnectorsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileConnectors
     * 
    **/
    select?: MenuItemProfileConnectorsSelect | null
    /**
     * Throw an Error if a MenuItemProfileConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuItemProfileConnectors to fetch.
     * 
    **/
    where: MenuItemProfileConnectorsWhereUniqueInput
  }


  /**
   * MenuItemProfileConnectors findFirst
   */
  export type MenuItemProfileConnectorsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileConnectors
     * 
    **/
    select?: MenuItemProfileConnectorsSelect | null
    /**
     * Throw an Error if a MenuItemProfileConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuItemProfileConnectors to fetch.
     * 
    **/
    where?: MenuItemProfileConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemProfileConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<MenuItemProfileConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItemProfileConnectors.
     * 
    **/
    cursor?: MenuItemProfileConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemProfileConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemProfileConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItemProfileConnectors.
     * 
    **/
    distinct?: Enumerable<MenuItemProfileConnectorsScalarFieldEnum>
  }


  /**
   * MenuItemProfileConnectors findMany
   */
  export type MenuItemProfileConnectorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileConnectors
     * 
    **/
    select?: MenuItemProfileConnectorsSelect | null
    /**
     * Filter, which MenuItemProfileConnectors to fetch.
     * 
    **/
    where?: MenuItemProfileConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemProfileConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<MenuItemProfileConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuItemProfileConnectors.
     * 
    **/
    cursor?: MenuItemProfileConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemProfileConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemProfileConnectors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MenuItemProfileConnectorsScalarFieldEnum>
  }


  /**
   * MenuItemProfileConnectors create
   */
  export type MenuItemProfileConnectorsCreateArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileConnectors
     * 
    **/
    select?: MenuItemProfileConnectorsSelect | null
    /**
     * The data needed to create a MenuItemProfileConnectors.
     * 
    **/
    data: XOR<MenuItemProfileConnectorsCreateInput, MenuItemProfileConnectorsUncheckedCreateInput>
  }


  /**
   * MenuItemProfileConnectors createMany
   */
  export type MenuItemProfileConnectorsCreateManyArgs = {
    data: Enumerable<MenuItemProfileConnectorsCreateManyInput>
  }


  /**
   * MenuItemProfileConnectors update
   */
  export type MenuItemProfileConnectorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileConnectors
     * 
    **/
    select?: MenuItemProfileConnectorsSelect | null
    /**
     * The data needed to update a MenuItemProfileConnectors.
     * 
    **/
    data: XOR<MenuItemProfileConnectorsUpdateInput, MenuItemProfileConnectorsUncheckedUpdateInput>
    /**
     * Choose, which MenuItemProfileConnectors to update.
     * 
    **/
    where: MenuItemProfileConnectorsWhereUniqueInput
  }


  /**
   * MenuItemProfileConnectors updateMany
   */
  export type MenuItemProfileConnectorsUpdateManyArgs = {
    data: XOR<MenuItemProfileConnectorsUpdateManyMutationInput, MenuItemProfileConnectorsUncheckedUpdateManyInput>
    where?: MenuItemProfileConnectorsWhereInput
  }


  /**
   * MenuItemProfileConnectors upsert
   */
  export type MenuItemProfileConnectorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileConnectors
     * 
    **/
    select?: MenuItemProfileConnectorsSelect | null
    /**
     * The filter to search for the MenuItemProfileConnectors to update in case it exists.
     * 
    **/
    where: MenuItemProfileConnectorsWhereUniqueInput
    /**
     * In case the MenuItemProfileConnectors found by the `where` argument doesn't exist, create a new MenuItemProfileConnectors with this data.
     * 
    **/
    create: XOR<MenuItemProfileConnectorsCreateInput, MenuItemProfileConnectorsUncheckedCreateInput>
    /**
     * In case the MenuItemProfileConnectors was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MenuItemProfileConnectorsUpdateInput, MenuItemProfileConnectorsUncheckedUpdateInput>
  }


  /**
   * MenuItemProfileConnectors delete
   */
  export type MenuItemProfileConnectorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileConnectors
     * 
    **/
    select?: MenuItemProfileConnectorsSelect | null
    /**
     * Filter which MenuItemProfileConnectors to delete.
     * 
    **/
    where: MenuItemProfileConnectorsWhereUniqueInput
  }


  /**
   * MenuItemProfileConnectors deleteMany
   */
  export type MenuItemProfileConnectorsDeleteManyArgs = {
    where?: MenuItemProfileConnectorsWhereInput
  }


  /**
   * MenuItemProfileConnectors without action
   */
  export type MenuItemProfileConnectorsArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileConnectors
     * 
    **/
    select?: MenuItemProfileConnectorsSelect | null
  }



  /**
   * Model MenuItemProfiles
   */


  export type AggregateMenuItemProfiles = {
    _count: MenuItemProfilesCountAggregateOutputType | null
    _avg: MenuItemProfilesAvgAggregateOutputType | null
    _sum: MenuItemProfilesSumAggregateOutputType | null
    _min: MenuItemProfilesMinAggregateOutputType | null
    _max: MenuItemProfilesMaxAggregateOutputType | null
  }

  export type MenuItemProfilesAvgAggregateOutputType = {
    Status: number | null
  }

  export type MenuItemProfilesSumAggregateOutputType = {
    Status: number | null
  }

  export type MenuItemProfilesMinAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    Name: string | null
    Type: string | null
    Status: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type MenuItemProfilesMaxAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    Name: string | null
    Type: string | null
    Status: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type MenuItemProfilesCountAggregateOutputType = {
    Id: number
    Repository_Id: number
    Name: number
    Type: number
    Status: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type MenuItemProfilesAvgAggregateInputType = {
    Status?: true
  }

  export type MenuItemProfilesSumAggregateInputType = {
    Status?: true
  }

  export type MenuItemProfilesMinAggregateInputType = {
    Id?: true
    Repository_Id?: true
    Name?: true
    Type?: true
    Status?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type MenuItemProfilesMaxAggregateInputType = {
    Id?: true
    Repository_Id?: true
    Name?: true
    Type?: true
    Status?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type MenuItemProfilesCountAggregateInputType = {
    Id?: true
    Repository_Id?: true
    Name?: true
    Type?: true
    Status?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type MenuItemProfilesAggregateArgs = {
    /**
     * Filter which MenuItemProfiles to aggregate.
     * 
    **/
    where?: MenuItemProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<MenuItemProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MenuItemProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemProfiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuItemProfiles
    **/
    _count?: true | MenuItemProfilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuItemProfilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuItemProfilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuItemProfilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuItemProfilesMaxAggregateInputType
  }

  export type GetMenuItemProfilesAggregateType<T extends MenuItemProfilesAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuItemProfiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuItemProfiles[P]>
      : GetScalarType<T[P], AggregateMenuItemProfiles[P]>
  }




  export type MenuItemProfilesGroupByArgs = {
    where?: MenuItemProfilesWhereInput
    orderBy?: Enumerable<MenuItemProfilesOrderByWithAggregationInput>
    by: Array<MenuItemProfilesScalarFieldEnum>
    having?: MenuItemProfilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuItemProfilesCountAggregateInputType | true
    _avg?: MenuItemProfilesAvgAggregateInputType
    _sum?: MenuItemProfilesSumAggregateInputType
    _min?: MenuItemProfilesMinAggregateInputType
    _max?: MenuItemProfilesMaxAggregateInputType
  }


  export type MenuItemProfilesGroupByOutputType = {
    Id: string
    Repository_Id: string | null
    Name: string | null
    Type: string | null
    Status: number
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: MenuItemProfilesCountAggregateOutputType | null
    _avg: MenuItemProfilesAvgAggregateOutputType | null
    _sum: MenuItemProfilesSumAggregateOutputType | null
    _min: MenuItemProfilesMinAggregateOutputType | null
    _max: MenuItemProfilesMaxAggregateOutputType | null
  }

  type GetMenuItemProfilesGroupByPayload<T extends MenuItemProfilesGroupByArgs> = Promise<
    Array<
      PickArray<MenuItemProfilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuItemProfilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuItemProfilesGroupByOutputType[P]>
            : GetScalarType<T[P], MenuItemProfilesGroupByOutputType[P]>
        }
      >
    >


  export type MenuItemProfilesSelect = {
    Id?: boolean
    Repository_Id?: boolean
    Name?: boolean
    Type?: boolean
    Status?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type MenuItemProfilesGetPayload<
    S extends boolean | null | undefined | MenuItemProfilesArgs,
    U = keyof S
      > = S extends true
        ? MenuItemProfiles
    : S extends undefined
    ? never
    : S extends MenuItemProfilesArgs | MenuItemProfilesFindManyArgs
    ?'include' extends U
    ? MenuItemProfiles 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MenuItemProfiles ?MenuItemProfiles [P]
  : 
     never
  } 
    : MenuItemProfiles
  : MenuItemProfiles


  type MenuItemProfilesCountArgs = Merge<
    Omit<MenuItemProfilesFindManyArgs, 'select' | 'include'> & {
      select?: MenuItemProfilesCountAggregateInputType | true
    }
  >

  export interface MenuItemProfilesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MenuItemProfiles that matches the filter.
     * @param {MenuItemProfilesFindUniqueArgs} args - Arguments to find a MenuItemProfiles
     * @example
     * // Get one MenuItemProfiles
     * const menuItemProfiles = await prisma.menuItemProfiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MenuItemProfilesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MenuItemProfilesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MenuItemProfiles'> extends True ? CheckSelect<T, Prisma__MenuItemProfilesClient<MenuItemProfiles>, Prisma__MenuItemProfilesClient<MenuItemProfilesGetPayload<T>>> : CheckSelect<T, Prisma__MenuItemProfilesClient<MenuItemProfiles | null >, Prisma__MenuItemProfilesClient<MenuItemProfilesGetPayload<T> | null >>

    /**
     * Find the first MenuItemProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfilesFindFirstArgs} args - Arguments to find a MenuItemProfiles
     * @example
     * // Get one MenuItemProfiles
     * const menuItemProfiles = await prisma.menuItemProfiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MenuItemProfilesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MenuItemProfilesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MenuItemProfiles'> extends True ? CheckSelect<T, Prisma__MenuItemProfilesClient<MenuItemProfiles>, Prisma__MenuItemProfilesClient<MenuItemProfilesGetPayload<T>>> : CheckSelect<T, Prisma__MenuItemProfilesClient<MenuItemProfiles | null >, Prisma__MenuItemProfilesClient<MenuItemProfilesGetPayload<T> | null >>

    /**
     * Find zero or more MenuItemProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfilesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuItemProfiles
     * const menuItemProfiles = await prisma.menuItemProfiles.findMany()
     * 
     * // Get first 10 MenuItemProfiles
     * const menuItemProfiles = await prisma.menuItemProfiles.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const menuItemProfilesWithIdOnly = await prisma.menuItemProfiles.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends MenuItemProfilesFindManyArgs>(
      args?: SelectSubset<T, MenuItemProfilesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MenuItemProfiles>>, PrismaPromise<Array<MenuItemProfilesGetPayload<T>>>>

    /**
     * Create a MenuItemProfiles.
     * @param {MenuItemProfilesCreateArgs} args - Arguments to create a MenuItemProfiles.
     * @example
     * // Create one MenuItemProfiles
     * const MenuItemProfiles = await prisma.menuItemProfiles.create({
     *   data: {
     *     // ... data to create a MenuItemProfiles
     *   }
     * })
     * 
    **/
    create<T extends MenuItemProfilesCreateArgs>(
      args: SelectSubset<T, MenuItemProfilesCreateArgs>
    ): CheckSelect<T, Prisma__MenuItemProfilesClient<MenuItemProfiles>, Prisma__MenuItemProfilesClient<MenuItemProfilesGetPayload<T>>>

    /**
     * Create many MenuItemProfiles.
     *     @param {MenuItemProfilesCreateManyArgs} args - Arguments to create many MenuItemProfiles.
     *     @example
     *     // Create many MenuItemProfiles
     *     const menuItemProfiles = await prisma.menuItemProfiles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MenuItemProfilesCreateManyArgs>(
      args?: SelectSubset<T, MenuItemProfilesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MenuItemProfiles.
     * @param {MenuItemProfilesDeleteArgs} args - Arguments to delete one MenuItemProfiles.
     * @example
     * // Delete one MenuItemProfiles
     * const MenuItemProfiles = await prisma.menuItemProfiles.delete({
     *   where: {
     *     // ... filter to delete one MenuItemProfiles
     *   }
     * })
     * 
    **/
    delete<T extends MenuItemProfilesDeleteArgs>(
      args: SelectSubset<T, MenuItemProfilesDeleteArgs>
    ): CheckSelect<T, Prisma__MenuItemProfilesClient<MenuItemProfiles>, Prisma__MenuItemProfilesClient<MenuItemProfilesGetPayload<T>>>

    /**
     * Update one MenuItemProfiles.
     * @param {MenuItemProfilesUpdateArgs} args - Arguments to update one MenuItemProfiles.
     * @example
     * // Update one MenuItemProfiles
     * const menuItemProfiles = await prisma.menuItemProfiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MenuItemProfilesUpdateArgs>(
      args: SelectSubset<T, MenuItemProfilesUpdateArgs>
    ): CheckSelect<T, Prisma__MenuItemProfilesClient<MenuItemProfiles>, Prisma__MenuItemProfilesClient<MenuItemProfilesGetPayload<T>>>

    /**
     * Delete zero or more MenuItemProfiles.
     * @param {MenuItemProfilesDeleteManyArgs} args - Arguments to filter MenuItemProfiles to delete.
     * @example
     * // Delete a few MenuItemProfiles
     * const { count } = await prisma.menuItemProfiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MenuItemProfilesDeleteManyArgs>(
      args?: SelectSubset<T, MenuItemProfilesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItemProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuItemProfiles
     * const menuItemProfiles = await prisma.menuItemProfiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MenuItemProfilesUpdateManyArgs>(
      args: SelectSubset<T, MenuItemProfilesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MenuItemProfiles.
     * @param {MenuItemProfilesUpsertArgs} args - Arguments to update or create a MenuItemProfiles.
     * @example
     * // Update or create a MenuItemProfiles
     * const menuItemProfiles = await prisma.menuItemProfiles.upsert({
     *   create: {
     *     // ... data to create a MenuItemProfiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuItemProfiles we want to update
     *   }
     * })
    **/
    upsert<T extends MenuItemProfilesUpsertArgs>(
      args: SelectSubset<T, MenuItemProfilesUpsertArgs>
    ): CheckSelect<T, Prisma__MenuItemProfilesClient<MenuItemProfiles>, Prisma__MenuItemProfilesClient<MenuItemProfilesGetPayload<T>>>

    /**
     * Count the number of MenuItemProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfilesCountArgs} args - Arguments to filter MenuItemProfiles to count.
     * @example
     * // Count the number of MenuItemProfiles
     * const count = await prisma.menuItemProfiles.count({
     *   where: {
     *     // ... the filter for the MenuItemProfiles we want to count
     *   }
     * })
    **/
    count<T extends MenuItemProfilesCountArgs>(
      args?: Subset<T, MenuItemProfilesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuItemProfilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuItemProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuItemProfilesAggregateArgs>(args: Subset<T, MenuItemProfilesAggregateArgs>): PrismaPromise<GetMenuItemProfilesAggregateType<T>>

    /**
     * Group by MenuItemProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuItemProfilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuItemProfilesGroupByArgs['orderBy'] }
        : { orderBy?: MenuItemProfilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuItemProfilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuItemProfilesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuItemProfiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MenuItemProfilesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MenuItemProfiles findUnique
   */
  export type MenuItemProfilesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfiles
     * 
    **/
    select?: MenuItemProfilesSelect | null
    /**
     * Throw an Error if a MenuItemProfiles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuItemProfiles to fetch.
     * 
    **/
    where: MenuItemProfilesWhereUniqueInput
  }


  /**
   * MenuItemProfiles findFirst
   */
  export type MenuItemProfilesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfiles
     * 
    **/
    select?: MenuItemProfilesSelect | null
    /**
     * Throw an Error if a MenuItemProfiles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuItemProfiles to fetch.
     * 
    **/
    where?: MenuItemProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<MenuItemProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItemProfiles.
     * 
    **/
    cursor?: MenuItemProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemProfiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItemProfiles.
     * 
    **/
    distinct?: Enumerable<MenuItemProfilesScalarFieldEnum>
  }


  /**
   * MenuItemProfiles findMany
   */
  export type MenuItemProfilesFindManyArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfiles
     * 
    **/
    select?: MenuItemProfilesSelect | null
    /**
     * Filter, which MenuItemProfiles to fetch.
     * 
    **/
    where?: MenuItemProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<MenuItemProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuItemProfiles.
     * 
    **/
    cursor?: MenuItemProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemProfiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MenuItemProfilesScalarFieldEnum>
  }


  /**
   * MenuItemProfiles create
   */
  export type MenuItemProfilesCreateArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfiles
     * 
    **/
    select?: MenuItemProfilesSelect | null
    /**
     * The data needed to create a MenuItemProfiles.
     * 
    **/
    data: XOR<MenuItemProfilesCreateInput, MenuItemProfilesUncheckedCreateInput>
  }


  /**
   * MenuItemProfiles createMany
   */
  export type MenuItemProfilesCreateManyArgs = {
    data: Enumerable<MenuItemProfilesCreateManyInput>
  }


  /**
   * MenuItemProfiles update
   */
  export type MenuItemProfilesUpdateArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfiles
     * 
    **/
    select?: MenuItemProfilesSelect | null
    /**
     * The data needed to update a MenuItemProfiles.
     * 
    **/
    data: XOR<MenuItemProfilesUpdateInput, MenuItemProfilesUncheckedUpdateInput>
    /**
     * Choose, which MenuItemProfiles to update.
     * 
    **/
    where: MenuItemProfilesWhereUniqueInput
  }


  /**
   * MenuItemProfiles updateMany
   */
  export type MenuItemProfilesUpdateManyArgs = {
    data: XOR<MenuItemProfilesUpdateManyMutationInput, MenuItemProfilesUncheckedUpdateManyInput>
    where?: MenuItemProfilesWhereInput
  }


  /**
   * MenuItemProfiles upsert
   */
  export type MenuItemProfilesUpsertArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfiles
     * 
    **/
    select?: MenuItemProfilesSelect | null
    /**
     * The filter to search for the MenuItemProfiles to update in case it exists.
     * 
    **/
    where: MenuItemProfilesWhereUniqueInput
    /**
     * In case the MenuItemProfiles found by the `where` argument doesn't exist, create a new MenuItemProfiles with this data.
     * 
    **/
    create: XOR<MenuItemProfilesCreateInput, MenuItemProfilesUncheckedCreateInput>
    /**
     * In case the MenuItemProfiles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MenuItemProfilesUpdateInput, MenuItemProfilesUncheckedUpdateInput>
  }


  /**
   * MenuItemProfiles delete
   */
  export type MenuItemProfilesDeleteArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfiles
     * 
    **/
    select?: MenuItemProfilesSelect | null
    /**
     * Filter which MenuItemProfiles to delete.
     * 
    **/
    where: MenuItemProfilesWhereUniqueInput
  }


  /**
   * MenuItemProfiles deleteMany
   */
  export type MenuItemProfilesDeleteManyArgs = {
    where?: MenuItemProfilesWhereInput
  }


  /**
   * MenuItemProfiles without action
   */
  export type MenuItemProfilesArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfiles
     * 
    **/
    select?: MenuItemProfilesSelect | null
  }



  /**
   * Model MenuItemProfileSettings
   */


  export type AggregateMenuItemProfileSettings = {
    _count: MenuItemProfileSettingsCountAggregateOutputType | null
    _avg: MenuItemProfileSettingsAvgAggregateOutputType | null
    _sum: MenuItemProfileSettingsSumAggregateOutputType | null
    _min: MenuItemProfileSettingsMinAggregateOutputType | null
    _max: MenuItemProfileSettingsMaxAggregateOutputType | null
  }

  export type MenuItemProfileSettingsAvgAggregateOutputType = {
    IsVisible: number | null
    IfShowOnlyContent: number | null
  }

  export type MenuItemProfileSettingsSumAggregateOutputType = {
    IsVisible: number | null
    IfShowOnlyContent: number | null
  }

  export type MenuItemProfileSettingsMinAggregateOutputType = {
    Id: string | null
    Profile_Id: string | null
    MenuItemKey: string | null
    IsVisible: number | null
    IfShowOnlyContent: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type MenuItemProfileSettingsMaxAggregateOutputType = {
    Id: string | null
    Profile_Id: string | null
    MenuItemKey: string | null
    IsVisible: number | null
    IfShowOnlyContent: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type MenuItemProfileSettingsCountAggregateOutputType = {
    Id: number
    Profile_Id: number
    MenuItemKey: number
    IsVisible: number
    IfShowOnlyContent: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type MenuItemProfileSettingsAvgAggregateInputType = {
    IsVisible?: true
    IfShowOnlyContent?: true
  }

  export type MenuItemProfileSettingsSumAggregateInputType = {
    IsVisible?: true
    IfShowOnlyContent?: true
  }

  export type MenuItemProfileSettingsMinAggregateInputType = {
    Id?: true
    Profile_Id?: true
    MenuItemKey?: true
    IsVisible?: true
    IfShowOnlyContent?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type MenuItemProfileSettingsMaxAggregateInputType = {
    Id?: true
    Profile_Id?: true
    MenuItemKey?: true
    IsVisible?: true
    IfShowOnlyContent?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type MenuItemProfileSettingsCountAggregateInputType = {
    Id?: true
    Profile_Id?: true
    MenuItemKey?: true
    IsVisible?: true
    IfShowOnlyContent?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type MenuItemProfileSettingsAggregateArgs = {
    /**
     * Filter which MenuItemProfileSettings to aggregate.
     * 
    **/
    where?: MenuItemProfileSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemProfileSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<MenuItemProfileSettingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MenuItemProfileSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemProfileSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemProfileSettings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuItemProfileSettings
    **/
    _count?: true | MenuItemProfileSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuItemProfileSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuItemProfileSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuItemProfileSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuItemProfileSettingsMaxAggregateInputType
  }

  export type GetMenuItemProfileSettingsAggregateType<T extends MenuItemProfileSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuItemProfileSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuItemProfileSettings[P]>
      : GetScalarType<T[P], AggregateMenuItemProfileSettings[P]>
  }




  export type MenuItemProfileSettingsGroupByArgs = {
    where?: MenuItemProfileSettingsWhereInput
    orderBy?: Enumerable<MenuItemProfileSettingsOrderByWithAggregationInput>
    by: Array<MenuItemProfileSettingsScalarFieldEnum>
    having?: MenuItemProfileSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuItemProfileSettingsCountAggregateInputType | true
    _avg?: MenuItemProfileSettingsAvgAggregateInputType
    _sum?: MenuItemProfileSettingsSumAggregateInputType
    _min?: MenuItemProfileSettingsMinAggregateInputType
    _max?: MenuItemProfileSettingsMaxAggregateInputType
  }


  export type MenuItemProfileSettingsGroupByOutputType = {
    Id: string
    Profile_Id: string | null
    MenuItemKey: string | null
    IsVisible: number | null
    IfShowOnlyContent: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: MenuItemProfileSettingsCountAggregateOutputType | null
    _avg: MenuItemProfileSettingsAvgAggregateOutputType | null
    _sum: MenuItemProfileSettingsSumAggregateOutputType | null
    _min: MenuItemProfileSettingsMinAggregateOutputType | null
    _max: MenuItemProfileSettingsMaxAggregateOutputType | null
  }

  type GetMenuItemProfileSettingsGroupByPayload<T extends MenuItemProfileSettingsGroupByArgs> = Promise<
    Array<
      PickArray<MenuItemProfileSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuItemProfileSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuItemProfileSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], MenuItemProfileSettingsGroupByOutputType[P]>
        }
      >
    >


  export type MenuItemProfileSettingsSelect = {
    Id?: boolean
    Profile_Id?: boolean
    MenuItemKey?: boolean
    IsVisible?: boolean
    IfShowOnlyContent?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type MenuItemProfileSettingsGetPayload<
    S extends boolean | null | undefined | MenuItemProfileSettingsArgs,
    U = keyof S
      > = S extends true
        ? MenuItemProfileSettings
    : S extends undefined
    ? never
    : S extends MenuItemProfileSettingsArgs | MenuItemProfileSettingsFindManyArgs
    ?'include' extends U
    ? MenuItemProfileSettings 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MenuItemProfileSettings ?MenuItemProfileSettings [P]
  : 
     never
  } 
    : MenuItemProfileSettings
  : MenuItemProfileSettings


  type MenuItemProfileSettingsCountArgs = Merge<
    Omit<MenuItemProfileSettingsFindManyArgs, 'select' | 'include'> & {
      select?: MenuItemProfileSettingsCountAggregateInputType | true
    }
  >

  export interface MenuItemProfileSettingsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MenuItemProfileSettings that matches the filter.
     * @param {MenuItemProfileSettingsFindUniqueArgs} args - Arguments to find a MenuItemProfileSettings
     * @example
     * // Get one MenuItemProfileSettings
     * const menuItemProfileSettings = await prisma.menuItemProfileSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MenuItemProfileSettingsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MenuItemProfileSettingsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MenuItemProfileSettings'> extends True ? CheckSelect<T, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettings>, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettingsGetPayload<T>>> : CheckSelect<T, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettings | null >, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettingsGetPayload<T> | null >>

    /**
     * Find the first MenuItemProfileSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfileSettingsFindFirstArgs} args - Arguments to find a MenuItemProfileSettings
     * @example
     * // Get one MenuItemProfileSettings
     * const menuItemProfileSettings = await prisma.menuItemProfileSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MenuItemProfileSettingsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MenuItemProfileSettingsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MenuItemProfileSettings'> extends True ? CheckSelect<T, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettings>, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettingsGetPayload<T>>> : CheckSelect<T, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettings | null >, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettingsGetPayload<T> | null >>

    /**
     * Find zero or more MenuItemProfileSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfileSettingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuItemProfileSettings
     * const menuItemProfileSettings = await prisma.menuItemProfileSettings.findMany()
     * 
     * // Get first 10 MenuItemProfileSettings
     * const menuItemProfileSettings = await prisma.menuItemProfileSettings.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const menuItemProfileSettingsWithIdOnly = await prisma.menuItemProfileSettings.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends MenuItemProfileSettingsFindManyArgs>(
      args?: SelectSubset<T, MenuItemProfileSettingsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MenuItemProfileSettings>>, PrismaPromise<Array<MenuItemProfileSettingsGetPayload<T>>>>

    /**
     * Create a MenuItemProfileSettings.
     * @param {MenuItemProfileSettingsCreateArgs} args - Arguments to create a MenuItemProfileSettings.
     * @example
     * // Create one MenuItemProfileSettings
     * const MenuItemProfileSettings = await prisma.menuItemProfileSettings.create({
     *   data: {
     *     // ... data to create a MenuItemProfileSettings
     *   }
     * })
     * 
    **/
    create<T extends MenuItemProfileSettingsCreateArgs>(
      args: SelectSubset<T, MenuItemProfileSettingsCreateArgs>
    ): CheckSelect<T, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettings>, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettingsGetPayload<T>>>

    /**
     * Create many MenuItemProfileSettings.
     *     @param {MenuItemProfileSettingsCreateManyArgs} args - Arguments to create many MenuItemProfileSettings.
     *     @example
     *     // Create many MenuItemProfileSettings
     *     const menuItemProfileSettings = await prisma.menuItemProfileSettings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MenuItemProfileSettingsCreateManyArgs>(
      args?: SelectSubset<T, MenuItemProfileSettingsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MenuItemProfileSettings.
     * @param {MenuItemProfileSettingsDeleteArgs} args - Arguments to delete one MenuItemProfileSettings.
     * @example
     * // Delete one MenuItemProfileSettings
     * const MenuItemProfileSettings = await prisma.menuItemProfileSettings.delete({
     *   where: {
     *     // ... filter to delete one MenuItemProfileSettings
     *   }
     * })
     * 
    **/
    delete<T extends MenuItemProfileSettingsDeleteArgs>(
      args: SelectSubset<T, MenuItemProfileSettingsDeleteArgs>
    ): CheckSelect<T, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettings>, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettingsGetPayload<T>>>

    /**
     * Update one MenuItemProfileSettings.
     * @param {MenuItemProfileSettingsUpdateArgs} args - Arguments to update one MenuItemProfileSettings.
     * @example
     * // Update one MenuItemProfileSettings
     * const menuItemProfileSettings = await prisma.menuItemProfileSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MenuItemProfileSettingsUpdateArgs>(
      args: SelectSubset<T, MenuItemProfileSettingsUpdateArgs>
    ): CheckSelect<T, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettings>, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettingsGetPayload<T>>>

    /**
     * Delete zero or more MenuItemProfileSettings.
     * @param {MenuItemProfileSettingsDeleteManyArgs} args - Arguments to filter MenuItemProfileSettings to delete.
     * @example
     * // Delete a few MenuItemProfileSettings
     * const { count } = await prisma.menuItemProfileSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MenuItemProfileSettingsDeleteManyArgs>(
      args?: SelectSubset<T, MenuItemProfileSettingsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItemProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfileSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuItemProfileSettings
     * const menuItemProfileSettings = await prisma.menuItemProfileSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MenuItemProfileSettingsUpdateManyArgs>(
      args: SelectSubset<T, MenuItemProfileSettingsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MenuItemProfileSettings.
     * @param {MenuItemProfileSettingsUpsertArgs} args - Arguments to update or create a MenuItemProfileSettings.
     * @example
     * // Update or create a MenuItemProfileSettings
     * const menuItemProfileSettings = await prisma.menuItemProfileSettings.upsert({
     *   create: {
     *     // ... data to create a MenuItemProfileSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuItemProfileSettings we want to update
     *   }
     * })
    **/
    upsert<T extends MenuItemProfileSettingsUpsertArgs>(
      args: SelectSubset<T, MenuItemProfileSettingsUpsertArgs>
    ): CheckSelect<T, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettings>, Prisma__MenuItemProfileSettingsClient<MenuItemProfileSettingsGetPayload<T>>>

    /**
     * Count the number of MenuItemProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfileSettingsCountArgs} args - Arguments to filter MenuItemProfileSettings to count.
     * @example
     * // Count the number of MenuItemProfileSettings
     * const count = await prisma.menuItemProfileSettings.count({
     *   where: {
     *     // ... the filter for the MenuItemProfileSettings we want to count
     *   }
     * })
    **/
    count<T extends MenuItemProfileSettingsCountArgs>(
      args?: Subset<T, MenuItemProfileSettingsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuItemProfileSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuItemProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfileSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuItemProfileSettingsAggregateArgs>(args: Subset<T, MenuItemProfileSettingsAggregateArgs>): PrismaPromise<GetMenuItemProfileSettingsAggregateType<T>>

    /**
     * Group by MenuItemProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemProfileSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuItemProfileSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuItemProfileSettingsGroupByArgs['orderBy'] }
        : { orderBy?: MenuItemProfileSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuItemProfileSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuItemProfileSettingsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuItemProfileSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MenuItemProfileSettingsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MenuItemProfileSettings findUnique
   */
  export type MenuItemProfileSettingsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileSettings
     * 
    **/
    select?: MenuItemProfileSettingsSelect | null
    /**
     * Throw an Error if a MenuItemProfileSettings can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuItemProfileSettings to fetch.
     * 
    **/
    where: MenuItemProfileSettingsWhereUniqueInput
  }


  /**
   * MenuItemProfileSettings findFirst
   */
  export type MenuItemProfileSettingsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileSettings
     * 
    **/
    select?: MenuItemProfileSettingsSelect | null
    /**
     * Throw an Error if a MenuItemProfileSettings can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuItemProfileSettings to fetch.
     * 
    **/
    where?: MenuItemProfileSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemProfileSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<MenuItemProfileSettingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItemProfileSettings.
     * 
    **/
    cursor?: MenuItemProfileSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemProfileSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemProfileSettings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItemProfileSettings.
     * 
    **/
    distinct?: Enumerable<MenuItemProfileSettingsScalarFieldEnum>
  }


  /**
   * MenuItemProfileSettings findMany
   */
  export type MenuItemProfileSettingsFindManyArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileSettings
     * 
    **/
    select?: MenuItemProfileSettingsSelect | null
    /**
     * Filter, which MenuItemProfileSettings to fetch.
     * 
    **/
    where?: MenuItemProfileSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemProfileSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<MenuItemProfileSettingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuItemProfileSettings.
     * 
    **/
    cursor?: MenuItemProfileSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemProfileSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemProfileSettings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MenuItemProfileSettingsScalarFieldEnum>
  }


  /**
   * MenuItemProfileSettings create
   */
  export type MenuItemProfileSettingsCreateArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileSettings
     * 
    **/
    select?: MenuItemProfileSettingsSelect | null
    /**
     * The data needed to create a MenuItemProfileSettings.
     * 
    **/
    data: XOR<MenuItemProfileSettingsCreateInput, MenuItemProfileSettingsUncheckedCreateInput>
  }


  /**
   * MenuItemProfileSettings createMany
   */
  export type MenuItemProfileSettingsCreateManyArgs = {
    data: Enumerable<MenuItemProfileSettingsCreateManyInput>
  }


  /**
   * MenuItemProfileSettings update
   */
  export type MenuItemProfileSettingsUpdateArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileSettings
     * 
    **/
    select?: MenuItemProfileSettingsSelect | null
    /**
     * The data needed to update a MenuItemProfileSettings.
     * 
    **/
    data: XOR<MenuItemProfileSettingsUpdateInput, MenuItemProfileSettingsUncheckedUpdateInput>
    /**
     * Choose, which MenuItemProfileSettings to update.
     * 
    **/
    where: MenuItemProfileSettingsWhereUniqueInput
  }


  /**
   * MenuItemProfileSettings updateMany
   */
  export type MenuItemProfileSettingsUpdateManyArgs = {
    data: XOR<MenuItemProfileSettingsUpdateManyMutationInput, MenuItemProfileSettingsUncheckedUpdateManyInput>
    where?: MenuItemProfileSettingsWhereInput
  }


  /**
   * MenuItemProfileSettings upsert
   */
  export type MenuItemProfileSettingsUpsertArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileSettings
     * 
    **/
    select?: MenuItemProfileSettingsSelect | null
    /**
     * The filter to search for the MenuItemProfileSettings to update in case it exists.
     * 
    **/
    where: MenuItemProfileSettingsWhereUniqueInput
    /**
     * In case the MenuItemProfileSettings found by the `where` argument doesn't exist, create a new MenuItemProfileSettings with this data.
     * 
    **/
    create: XOR<MenuItemProfileSettingsCreateInput, MenuItemProfileSettingsUncheckedCreateInput>
    /**
     * In case the MenuItemProfileSettings was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MenuItemProfileSettingsUpdateInput, MenuItemProfileSettingsUncheckedUpdateInput>
  }


  /**
   * MenuItemProfileSettings delete
   */
  export type MenuItemProfileSettingsDeleteArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileSettings
     * 
    **/
    select?: MenuItemProfileSettingsSelect | null
    /**
     * Filter which MenuItemProfileSettings to delete.
     * 
    **/
    where: MenuItemProfileSettingsWhereUniqueInput
  }


  /**
   * MenuItemProfileSettings deleteMany
   */
  export type MenuItemProfileSettingsDeleteManyArgs = {
    where?: MenuItemProfileSettingsWhereInput
  }


  /**
   * MenuItemProfileSettings without action
   */
  export type MenuItemProfileSettingsArgs = {
    /**
     * Select specific fields to fetch from the MenuItemProfileSettings
     * 
    **/
    select?: MenuItemProfileSettingsSelect | null
  }



  /**
   * Model MenuViewHistory
   */


  export type AggregateMenuViewHistory = {
    _count: MenuViewHistoryCountAggregateOutputType | null
    _min: MenuViewHistoryMinAggregateOutputType | null
    _max: MenuViewHistoryMaxAggregateOutputType | null
  }

  export type MenuViewHistoryMinAggregateOutputType = {
    Id: string | null
    RepositoryId: string | null
    UserId: string | null
    PageKeys: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type MenuViewHistoryMaxAggregateOutputType = {
    Id: string | null
    RepositoryId: string | null
    UserId: string | null
    PageKeys: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type MenuViewHistoryCountAggregateOutputType = {
    Id: number
    RepositoryId: number
    UserId: number
    PageKeys: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type MenuViewHistoryMinAggregateInputType = {
    Id?: true
    RepositoryId?: true
    UserId?: true
    PageKeys?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type MenuViewHistoryMaxAggregateInputType = {
    Id?: true
    RepositoryId?: true
    UserId?: true
    PageKeys?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type MenuViewHistoryCountAggregateInputType = {
    Id?: true
    RepositoryId?: true
    UserId?: true
    PageKeys?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type MenuViewHistoryAggregateArgs = {
    /**
     * Filter which MenuViewHistory to aggregate.
     * 
    **/
    where?: MenuViewHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuViewHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<MenuViewHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MenuViewHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuViewHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuViewHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuViewHistories
    **/
    _count?: true | MenuViewHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuViewHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuViewHistoryMaxAggregateInputType
  }

  export type GetMenuViewHistoryAggregateType<T extends MenuViewHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuViewHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuViewHistory[P]>
      : GetScalarType<T[P], AggregateMenuViewHistory[P]>
  }




  export type MenuViewHistoryGroupByArgs = {
    where?: MenuViewHistoryWhereInput
    orderBy?: Enumerable<MenuViewHistoryOrderByWithAggregationInput>
    by: Array<MenuViewHistoryScalarFieldEnum>
    having?: MenuViewHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuViewHistoryCountAggregateInputType | true
    _min?: MenuViewHistoryMinAggregateInputType
    _max?: MenuViewHistoryMaxAggregateInputType
  }


  export type MenuViewHistoryGroupByOutputType = {
    Id: string
    RepositoryId: string | null
    UserId: string | null
    PageKeys: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: MenuViewHistoryCountAggregateOutputType | null
    _min: MenuViewHistoryMinAggregateOutputType | null
    _max: MenuViewHistoryMaxAggregateOutputType | null
  }

  type GetMenuViewHistoryGroupByPayload<T extends MenuViewHistoryGroupByArgs> = Promise<
    Array<
      PickArray<MenuViewHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuViewHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuViewHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], MenuViewHistoryGroupByOutputType[P]>
        }
      >
    >


  export type MenuViewHistorySelect = {
    Id?: boolean
    RepositoryId?: boolean
    UserId?: boolean
    PageKeys?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type MenuViewHistoryGetPayload<
    S extends boolean | null | undefined | MenuViewHistoryArgs,
    U = keyof S
      > = S extends true
        ? MenuViewHistory
    : S extends undefined
    ? never
    : S extends MenuViewHistoryArgs | MenuViewHistoryFindManyArgs
    ?'include' extends U
    ? MenuViewHistory 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MenuViewHistory ?MenuViewHistory [P]
  : 
     never
  } 
    : MenuViewHistory
  : MenuViewHistory


  type MenuViewHistoryCountArgs = Merge<
    Omit<MenuViewHistoryFindManyArgs, 'select' | 'include'> & {
      select?: MenuViewHistoryCountAggregateInputType | true
    }
  >

  export interface MenuViewHistoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MenuViewHistory that matches the filter.
     * @param {MenuViewHistoryFindUniqueArgs} args - Arguments to find a MenuViewHistory
     * @example
     * // Get one MenuViewHistory
     * const menuViewHistory = await prisma.menuViewHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MenuViewHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MenuViewHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MenuViewHistory'> extends True ? CheckSelect<T, Prisma__MenuViewHistoryClient<MenuViewHistory>, Prisma__MenuViewHistoryClient<MenuViewHistoryGetPayload<T>>> : CheckSelect<T, Prisma__MenuViewHistoryClient<MenuViewHistory | null >, Prisma__MenuViewHistoryClient<MenuViewHistoryGetPayload<T> | null >>

    /**
     * Find the first MenuViewHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuViewHistoryFindFirstArgs} args - Arguments to find a MenuViewHistory
     * @example
     * // Get one MenuViewHistory
     * const menuViewHistory = await prisma.menuViewHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MenuViewHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MenuViewHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MenuViewHistory'> extends True ? CheckSelect<T, Prisma__MenuViewHistoryClient<MenuViewHistory>, Prisma__MenuViewHistoryClient<MenuViewHistoryGetPayload<T>>> : CheckSelect<T, Prisma__MenuViewHistoryClient<MenuViewHistory | null >, Prisma__MenuViewHistoryClient<MenuViewHistoryGetPayload<T> | null >>

    /**
     * Find zero or more MenuViewHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuViewHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuViewHistories
     * const menuViewHistories = await prisma.menuViewHistory.findMany()
     * 
     * // Get first 10 MenuViewHistories
     * const menuViewHistories = await prisma.menuViewHistory.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const menuViewHistoryWithIdOnly = await prisma.menuViewHistory.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends MenuViewHistoryFindManyArgs>(
      args?: SelectSubset<T, MenuViewHistoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MenuViewHistory>>, PrismaPromise<Array<MenuViewHistoryGetPayload<T>>>>

    /**
     * Create a MenuViewHistory.
     * @param {MenuViewHistoryCreateArgs} args - Arguments to create a MenuViewHistory.
     * @example
     * // Create one MenuViewHistory
     * const MenuViewHistory = await prisma.menuViewHistory.create({
     *   data: {
     *     // ... data to create a MenuViewHistory
     *   }
     * })
     * 
    **/
    create<T extends MenuViewHistoryCreateArgs>(
      args: SelectSubset<T, MenuViewHistoryCreateArgs>
    ): CheckSelect<T, Prisma__MenuViewHistoryClient<MenuViewHistory>, Prisma__MenuViewHistoryClient<MenuViewHistoryGetPayload<T>>>

    /**
     * Create many MenuViewHistories.
     *     @param {MenuViewHistoryCreateManyArgs} args - Arguments to create many MenuViewHistories.
     *     @example
     *     // Create many MenuViewHistories
     *     const menuViewHistory = await prisma.menuViewHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MenuViewHistoryCreateManyArgs>(
      args?: SelectSubset<T, MenuViewHistoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MenuViewHistory.
     * @param {MenuViewHistoryDeleteArgs} args - Arguments to delete one MenuViewHistory.
     * @example
     * // Delete one MenuViewHistory
     * const MenuViewHistory = await prisma.menuViewHistory.delete({
     *   where: {
     *     // ... filter to delete one MenuViewHistory
     *   }
     * })
     * 
    **/
    delete<T extends MenuViewHistoryDeleteArgs>(
      args: SelectSubset<T, MenuViewHistoryDeleteArgs>
    ): CheckSelect<T, Prisma__MenuViewHistoryClient<MenuViewHistory>, Prisma__MenuViewHistoryClient<MenuViewHistoryGetPayload<T>>>

    /**
     * Update one MenuViewHistory.
     * @param {MenuViewHistoryUpdateArgs} args - Arguments to update one MenuViewHistory.
     * @example
     * // Update one MenuViewHistory
     * const menuViewHistory = await prisma.menuViewHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MenuViewHistoryUpdateArgs>(
      args: SelectSubset<T, MenuViewHistoryUpdateArgs>
    ): CheckSelect<T, Prisma__MenuViewHistoryClient<MenuViewHistory>, Prisma__MenuViewHistoryClient<MenuViewHistoryGetPayload<T>>>

    /**
     * Delete zero or more MenuViewHistories.
     * @param {MenuViewHistoryDeleteManyArgs} args - Arguments to filter MenuViewHistories to delete.
     * @example
     * // Delete a few MenuViewHistories
     * const { count } = await prisma.menuViewHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MenuViewHistoryDeleteManyArgs>(
      args?: SelectSubset<T, MenuViewHistoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuViewHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuViewHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuViewHistories
     * const menuViewHistory = await prisma.menuViewHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MenuViewHistoryUpdateManyArgs>(
      args: SelectSubset<T, MenuViewHistoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MenuViewHistory.
     * @param {MenuViewHistoryUpsertArgs} args - Arguments to update or create a MenuViewHistory.
     * @example
     * // Update or create a MenuViewHistory
     * const menuViewHistory = await prisma.menuViewHistory.upsert({
     *   create: {
     *     // ... data to create a MenuViewHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuViewHistory we want to update
     *   }
     * })
    **/
    upsert<T extends MenuViewHistoryUpsertArgs>(
      args: SelectSubset<T, MenuViewHistoryUpsertArgs>
    ): CheckSelect<T, Prisma__MenuViewHistoryClient<MenuViewHistory>, Prisma__MenuViewHistoryClient<MenuViewHistoryGetPayload<T>>>

    /**
     * Count the number of MenuViewHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuViewHistoryCountArgs} args - Arguments to filter MenuViewHistories to count.
     * @example
     * // Count the number of MenuViewHistories
     * const count = await prisma.menuViewHistory.count({
     *   where: {
     *     // ... the filter for the MenuViewHistories we want to count
     *   }
     * })
    **/
    count<T extends MenuViewHistoryCountArgs>(
      args?: Subset<T, MenuViewHistoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuViewHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuViewHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuViewHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuViewHistoryAggregateArgs>(args: Subset<T, MenuViewHistoryAggregateArgs>): PrismaPromise<GetMenuViewHistoryAggregateType<T>>

    /**
     * Group by MenuViewHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuViewHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuViewHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuViewHistoryGroupByArgs['orderBy'] }
        : { orderBy?: MenuViewHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuViewHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuViewHistoryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuViewHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MenuViewHistoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MenuViewHistory findUnique
   */
  export type MenuViewHistoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MenuViewHistory
     * 
    **/
    select?: MenuViewHistorySelect | null
    /**
     * Throw an Error if a MenuViewHistory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuViewHistory to fetch.
     * 
    **/
    where: MenuViewHistoryWhereUniqueInput
  }


  /**
   * MenuViewHistory findFirst
   */
  export type MenuViewHistoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MenuViewHistory
     * 
    **/
    select?: MenuViewHistorySelect | null
    /**
     * Throw an Error if a MenuViewHistory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuViewHistory to fetch.
     * 
    **/
    where?: MenuViewHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuViewHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<MenuViewHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuViewHistories.
     * 
    **/
    cursor?: MenuViewHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuViewHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuViewHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuViewHistories.
     * 
    **/
    distinct?: Enumerable<MenuViewHistoryScalarFieldEnum>
  }


  /**
   * MenuViewHistory findMany
   */
  export type MenuViewHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the MenuViewHistory
     * 
    **/
    select?: MenuViewHistorySelect | null
    /**
     * Filter, which MenuViewHistories to fetch.
     * 
    **/
    where?: MenuViewHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuViewHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<MenuViewHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuViewHistories.
     * 
    **/
    cursor?: MenuViewHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuViewHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuViewHistories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MenuViewHistoryScalarFieldEnum>
  }


  /**
   * MenuViewHistory create
   */
  export type MenuViewHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the MenuViewHistory
     * 
    **/
    select?: MenuViewHistorySelect | null
    /**
     * The data needed to create a MenuViewHistory.
     * 
    **/
    data: XOR<MenuViewHistoryCreateInput, MenuViewHistoryUncheckedCreateInput>
  }


  /**
   * MenuViewHistory createMany
   */
  export type MenuViewHistoryCreateManyArgs = {
    data: Enumerable<MenuViewHistoryCreateManyInput>
  }


  /**
   * MenuViewHistory update
   */
  export type MenuViewHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the MenuViewHistory
     * 
    **/
    select?: MenuViewHistorySelect | null
    /**
     * The data needed to update a MenuViewHistory.
     * 
    **/
    data: XOR<MenuViewHistoryUpdateInput, MenuViewHistoryUncheckedUpdateInput>
    /**
     * Choose, which MenuViewHistory to update.
     * 
    **/
    where: MenuViewHistoryWhereUniqueInput
  }


  /**
   * MenuViewHistory updateMany
   */
  export type MenuViewHistoryUpdateManyArgs = {
    data: XOR<MenuViewHistoryUpdateManyMutationInput, MenuViewHistoryUncheckedUpdateManyInput>
    where?: MenuViewHistoryWhereInput
  }


  /**
   * MenuViewHistory upsert
   */
  export type MenuViewHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the MenuViewHistory
     * 
    **/
    select?: MenuViewHistorySelect | null
    /**
     * The filter to search for the MenuViewHistory to update in case it exists.
     * 
    **/
    where: MenuViewHistoryWhereUniqueInput
    /**
     * In case the MenuViewHistory found by the `where` argument doesn't exist, create a new MenuViewHistory with this data.
     * 
    **/
    create: XOR<MenuViewHistoryCreateInput, MenuViewHistoryUncheckedCreateInput>
    /**
     * In case the MenuViewHistory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MenuViewHistoryUpdateInput, MenuViewHistoryUncheckedUpdateInput>
  }


  /**
   * MenuViewHistory delete
   */
  export type MenuViewHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the MenuViewHistory
     * 
    **/
    select?: MenuViewHistorySelect | null
    /**
     * Filter which MenuViewHistory to delete.
     * 
    **/
    where: MenuViewHistoryWhereUniqueInput
  }


  /**
   * MenuViewHistory deleteMany
   */
  export type MenuViewHistoryDeleteManyArgs = {
    where?: MenuViewHistoryWhereInput
  }


  /**
   * MenuViewHistory without action
   */
  export type MenuViewHistoryArgs = {
    /**
     * Select specific fields to fetch from the MenuViewHistory
     * 
    **/
    select?: MenuViewHistorySelect | null
  }



  /**
   * Model OIDCApplications
   */


  export type AggregateOIDCApplications = {
    _count: OIDCApplicationsCountAggregateOutputType | null
    _min: OIDCApplicationsMinAggregateOutputType | null
    _max: OIDCApplicationsMaxAggregateOutputType | null
  }

  export type OIDCApplicationsMinAggregateOutputType = {
    Id: string | null
    ClientId: string | null
    ClientSecret: string | null
    ConcurrencyToken: string | null
    ConsentType: string | null
    DisplayName: string | null
    DisplayNames: string | null
    Permissions: string | null
    PostLogoutRedirectUris: string | null
    Properties: string | null
    RedirectUris: string | null
    Requirements: string | null
    Type: string | null
  }

  export type OIDCApplicationsMaxAggregateOutputType = {
    Id: string | null
    ClientId: string | null
    ClientSecret: string | null
    ConcurrencyToken: string | null
    ConsentType: string | null
    DisplayName: string | null
    DisplayNames: string | null
    Permissions: string | null
    PostLogoutRedirectUris: string | null
    Properties: string | null
    RedirectUris: string | null
    Requirements: string | null
    Type: string | null
  }

  export type OIDCApplicationsCountAggregateOutputType = {
    Id: number
    ClientId: number
    ClientSecret: number
    ConcurrencyToken: number
    ConsentType: number
    DisplayName: number
    DisplayNames: number
    Permissions: number
    PostLogoutRedirectUris: number
    Properties: number
    RedirectUris: number
    Requirements: number
    Type: number
    _all: number
  }


  export type OIDCApplicationsMinAggregateInputType = {
    Id?: true
    ClientId?: true
    ClientSecret?: true
    ConcurrencyToken?: true
    ConsentType?: true
    DisplayName?: true
    DisplayNames?: true
    Permissions?: true
    PostLogoutRedirectUris?: true
    Properties?: true
    RedirectUris?: true
    Requirements?: true
    Type?: true
  }

  export type OIDCApplicationsMaxAggregateInputType = {
    Id?: true
    ClientId?: true
    ClientSecret?: true
    ConcurrencyToken?: true
    ConsentType?: true
    DisplayName?: true
    DisplayNames?: true
    Permissions?: true
    PostLogoutRedirectUris?: true
    Properties?: true
    RedirectUris?: true
    Requirements?: true
    Type?: true
  }

  export type OIDCApplicationsCountAggregateInputType = {
    Id?: true
    ClientId?: true
    ClientSecret?: true
    ConcurrencyToken?: true
    ConsentType?: true
    DisplayName?: true
    DisplayNames?: true
    Permissions?: true
    PostLogoutRedirectUris?: true
    Properties?: true
    RedirectUris?: true
    Requirements?: true
    Type?: true
    _all?: true
  }

  export type OIDCApplicationsAggregateArgs = {
    /**
     * Filter which OIDCApplications to aggregate.
     * 
    **/
    where?: OIDCApplicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCApplications to fetch.
     * 
    **/
    orderBy?: Enumerable<OIDCApplicationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OIDCApplicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCApplications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCApplications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OIDCApplications
    **/
    _count?: true | OIDCApplicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OIDCApplicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OIDCApplicationsMaxAggregateInputType
  }

  export type GetOIDCApplicationsAggregateType<T extends OIDCApplicationsAggregateArgs> = {
        [P in keyof T & keyof AggregateOIDCApplications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOIDCApplications[P]>
      : GetScalarType<T[P], AggregateOIDCApplications[P]>
  }




  export type OIDCApplicationsGroupByArgs = {
    where?: OIDCApplicationsWhereInput
    orderBy?: Enumerable<OIDCApplicationsOrderByWithAggregationInput>
    by: Array<OIDCApplicationsScalarFieldEnum>
    having?: OIDCApplicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OIDCApplicationsCountAggregateInputType | true
    _min?: OIDCApplicationsMinAggregateInputType
    _max?: OIDCApplicationsMaxAggregateInputType
  }


  export type OIDCApplicationsGroupByOutputType = {
    Id: string
    ClientId: string | null
    ClientSecret: string | null
    ConcurrencyToken: string | null
    ConsentType: string | null
    DisplayName: string | null
    DisplayNames: string | null
    Permissions: string | null
    PostLogoutRedirectUris: string | null
    Properties: string | null
    RedirectUris: string | null
    Requirements: string | null
    Type: string | null
    _count: OIDCApplicationsCountAggregateOutputType | null
    _min: OIDCApplicationsMinAggregateOutputType | null
    _max: OIDCApplicationsMaxAggregateOutputType | null
  }

  type GetOIDCApplicationsGroupByPayload<T extends OIDCApplicationsGroupByArgs> = Promise<
    Array<
      PickArray<OIDCApplicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OIDCApplicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OIDCApplicationsGroupByOutputType[P]>
            : GetScalarType<T[P], OIDCApplicationsGroupByOutputType[P]>
        }
      >
    >


  export type OIDCApplicationsSelect = {
    Id?: boolean
    ClientId?: boolean
    ClientSecret?: boolean
    ConcurrencyToken?: boolean
    ConsentType?: boolean
    DisplayName?: boolean
    DisplayNames?: boolean
    Permissions?: boolean
    PostLogoutRedirectUris?: boolean
    Properties?: boolean
    RedirectUris?: boolean
    Requirements?: boolean
    Type?: boolean
    OIDCAuthorizations?: boolean | OIDCAuthorizationsFindManyArgs
    OIDCTokens?: boolean | OIDCTokensFindManyArgs
    _count?: boolean | OIDCApplicationsCountOutputTypeArgs
  }

  export type OIDCApplicationsInclude = {
    OIDCAuthorizations?: boolean | OIDCAuthorizationsFindManyArgs
    OIDCTokens?: boolean | OIDCTokensFindManyArgs
    _count?: boolean | OIDCApplicationsCountOutputTypeArgs
  }

  export type OIDCApplicationsGetPayload<
    S extends boolean | null | undefined | OIDCApplicationsArgs,
    U = keyof S
      > = S extends true
        ? OIDCApplications
    : S extends undefined
    ? never
    : S extends OIDCApplicationsArgs | OIDCApplicationsFindManyArgs
    ?'include' extends U
    ? OIDCApplications  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'OIDCAuthorizations'
        ? Array < OIDCAuthorizationsGetPayload<S['include'][P]>>  :
        P extends 'OIDCTokens'
        ? Array < OIDCTokensGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? OIDCApplicationsCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof OIDCApplications ?OIDCApplications [P]
  : 
          P extends 'OIDCAuthorizations'
        ? Array < OIDCAuthorizationsGetPayload<S['select'][P]>>  :
        P extends 'OIDCTokens'
        ? Array < OIDCTokensGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? OIDCApplicationsCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : OIDCApplications
  : OIDCApplications


  type OIDCApplicationsCountArgs = Merge<
    Omit<OIDCApplicationsFindManyArgs, 'select' | 'include'> & {
      select?: OIDCApplicationsCountAggregateInputType | true
    }
  >

  export interface OIDCApplicationsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OIDCApplications that matches the filter.
     * @param {OIDCApplicationsFindUniqueArgs} args - Arguments to find a OIDCApplications
     * @example
     * // Get one OIDCApplications
     * const oIDCApplications = await prisma.oIDCApplications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OIDCApplicationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OIDCApplicationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OIDCApplications'> extends True ? CheckSelect<T, Prisma__OIDCApplicationsClient<OIDCApplications>, Prisma__OIDCApplicationsClient<OIDCApplicationsGetPayload<T>>> : CheckSelect<T, Prisma__OIDCApplicationsClient<OIDCApplications | null >, Prisma__OIDCApplicationsClient<OIDCApplicationsGetPayload<T> | null >>

    /**
     * Find the first OIDCApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCApplicationsFindFirstArgs} args - Arguments to find a OIDCApplications
     * @example
     * // Get one OIDCApplications
     * const oIDCApplications = await prisma.oIDCApplications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OIDCApplicationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OIDCApplicationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OIDCApplications'> extends True ? CheckSelect<T, Prisma__OIDCApplicationsClient<OIDCApplications>, Prisma__OIDCApplicationsClient<OIDCApplicationsGetPayload<T>>> : CheckSelect<T, Prisma__OIDCApplicationsClient<OIDCApplications | null >, Prisma__OIDCApplicationsClient<OIDCApplicationsGetPayload<T> | null >>

    /**
     * Find zero or more OIDCApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCApplicationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OIDCApplications
     * const oIDCApplications = await prisma.oIDCApplications.findMany()
     * 
     * // Get first 10 OIDCApplications
     * const oIDCApplications = await prisma.oIDCApplications.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const oIDCApplicationsWithIdOnly = await prisma.oIDCApplications.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends OIDCApplicationsFindManyArgs>(
      args?: SelectSubset<T, OIDCApplicationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OIDCApplications>>, PrismaPromise<Array<OIDCApplicationsGetPayload<T>>>>

    /**
     * Create a OIDCApplications.
     * @param {OIDCApplicationsCreateArgs} args - Arguments to create a OIDCApplications.
     * @example
     * // Create one OIDCApplications
     * const OIDCApplications = await prisma.oIDCApplications.create({
     *   data: {
     *     // ... data to create a OIDCApplications
     *   }
     * })
     * 
    **/
    create<T extends OIDCApplicationsCreateArgs>(
      args: SelectSubset<T, OIDCApplicationsCreateArgs>
    ): CheckSelect<T, Prisma__OIDCApplicationsClient<OIDCApplications>, Prisma__OIDCApplicationsClient<OIDCApplicationsGetPayload<T>>>

    /**
     * Create many OIDCApplications.
     *     @param {OIDCApplicationsCreateManyArgs} args - Arguments to create many OIDCApplications.
     *     @example
     *     // Create many OIDCApplications
     *     const oIDCApplications = await prisma.oIDCApplications.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OIDCApplicationsCreateManyArgs>(
      args?: SelectSubset<T, OIDCApplicationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OIDCApplications.
     * @param {OIDCApplicationsDeleteArgs} args - Arguments to delete one OIDCApplications.
     * @example
     * // Delete one OIDCApplications
     * const OIDCApplications = await prisma.oIDCApplications.delete({
     *   where: {
     *     // ... filter to delete one OIDCApplications
     *   }
     * })
     * 
    **/
    delete<T extends OIDCApplicationsDeleteArgs>(
      args: SelectSubset<T, OIDCApplicationsDeleteArgs>
    ): CheckSelect<T, Prisma__OIDCApplicationsClient<OIDCApplications>, Prisma__OIDCApplicationsClient<OIDCApplicationsGetPayload<T>>>

    /**
     * Update one OIDCApplications.
     * @param {OIDCApplicationsUpdateArgs} args - Arguments to update one OIDCApplications.
     * @example
     * // Update one OIDCApplications
     * const oIDCApplications = await prisma.oIDCApplications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OIDCApplicationsUpdateArgs>(
      args: SelectSubset<T, OIDCApplicationsUpdateArgs>
    ): CheckSelect<T, Prisma__OIDCApplicationsClient<OIDCApplications>, Prisma__OIDCApplicationsClient<OIDCApplicationsGetPayload<T>>>

    /**
     * Delete zero or more OIDCApplications.
     * @param {OIDCApplicationsDeleteManyArgs} args - Arguments to filter OIDCApplications to delete.
     * @example
     * // Delete a few OIDCApplications
     * const { count } = await prisma.oIDCApplications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OIDCApplicationsDeleteManyArgs>(
      args?: SelectSubset<T, OIDCApplicationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OIDCApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCApplicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OIDCApplications
     * const oIDCApplications = await prisma.oIDCApplications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OIDCApplicationsUpdateManyArgs>(
      args: SelectSubset<T, OIDCApplicationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OIDCApplications.
     * @param {OIDCApplicationsUpsertArgs} args - Arguments to update or create a OIDCApplications.
     * @example
     * // Update or create a OIDCApplications
     * const oIDCApplications = await prisma.oIDCApplications.upsert({
     *   create: {
     *     // ... data to create a OIDCApplications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OIDCApplications we want to update
     *   }
     * })
    **/
    upsert<T extends OIDCApplicationsUpsertArgs>(
      args: SelectSubset<T, OIDCApplicationsUpsertArgs>
    ): CheckSelect<T, Prisma__OIDCApplicationsClient<OIDCApplications>, Prisma__OIDCApplicationsClient<OIDCApplicationsGetPayload<T>>>

    /**
     * Count the number of OIDCApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCApplicationsCountArgs} args - Arguments to filter OIDCApplications to count.
     * @example
     * // Count the number of OIDCApplications
     * const count = await prisma.oIDCApplications.count({
     *   where: {
     *     // ... the filter for the OIDCApplications we want to count
     *   }
     * })
    **/
    count<T extends OIDCApplicationsCountArgs>(
      args?: Subset<T, OIDCApplicationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OIDCApplicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OIDCApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCApplicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OIDCApplicationsAggregateArgs>(args: Subset<T, OIDCApplicationsAggregateArgs>): PrismaPromise<GetOIDCApplicationsAggregateType<T>>

    /**
     * Group by OIDCApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCApplicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OIDCApplicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OIDCApplicationsGroupByArgs['orderBy'] }
        : { orderBy?: OIDCApplicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OIDCApplicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOIDCApplicationsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OIDCApplications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OIDCApplicationsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    OIDCAuthorizations<T extends OIDCAuthorizationsFindManyArgs = {}>(args?: Subset<T, OIDCAuthorizationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OIDCAuthorizations>>, PrismaPromise<Array<OIDCAuthorizationsGetPayload<T>>>>;

    OIDCTokens<T extends OIDCTokensFindManyArgs = {}>(args?: Subset<T, OIDCTokensFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OIDCTokens>>, PrismaPromise<Array<OIDCTokensGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OIDCApplications findUnique
   */
  export type OIDCApplicationsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OIDCApplications
     * 
    **/
    select?: OIDCApplicationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCApplicationsInclude | null
    /**
     * Throw an Error if a OIDCApplications can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OIDCApplications to fetch.
     * 
    **/
    where: OIDCApplicationsWhereUniqueInput
  }


  /**
   * OIDCApplications findFirst
   */
  export type OIDCApplicationsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OIDCApplications
     * 
    **/
    select?: OIDCApplicationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCApplicationsInclude | null
    /**
     * Throw an Error if a OIDCApplications can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OIDCApplications to fetch.
     * 
    **/
    where?: OIDCApplicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCApplications to fetch.
     * 
    **/
    orderBy?: Enumerable<OIDCApplicationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OIDCApplications.
     * 
    **/
    cursor?: OIDCApplicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCApplications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCApplications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OIDCApplications.
     * 
    **/
    distinct?: Enumerable<OIDCApplicationsScalarFieldEnum>
  }


  /**
   * OIDCApplications findMany
   */
  export type OIDCApplicationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the OIDCApplications
     * 
    **/
    select?: OIDCApplicationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCApplicationsInclude | null
    /**
     * Filter, which OIDCApplications to fetch.
     * 
    **/
    where?: OIDCApplicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCApplications to fetch.
     * 
    **/
    orderBy?: Enumerable<OIDCApplicationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OIDCApplications.
     * 
    **/
    cursor?: OIDCApplicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCApplications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCApplications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OIDCApplicationsScalarFieldEnum>
  }


  /**
   * OIDCApplications create
   */
  export type OIDCApplicationsCreateArgs = {
    /**
     * Select specific fields to fetch from the OIDCApplications
     * 
    **/
    select?: OIDCApplicationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCApplicationsInclude | null
    /**
     * The data needed to create a OIDCApplications.
     * 
    **/
    data: XOR<OIDCApplicationsCreateInput, OIDCApplicationsUncheckedCreateInput>
  }


  /**
   * OIDCApplications createMany
   */
  export type OIDCApplicationsCreateManyArgs = {
    data: Enumerable<OIDCApplicationsCreateManyInput>
  }


  /**
   * OIDCApplications update
   */
  export type OIDCApplicationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the OIDCApplications
     * 
    **/
    select?: OIDCApplicationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCApplicationsInclude | null
    /**
     * The data needed to update a OIDCApplications.
     * 
    **/
    data: XOR<OIDCApplicationsUpdateInput, OIDCApplicationsUncheckedUpdateInput>
    /**
     * Choose, which OIDCApplications to update.
     * 
    **/
    where: OIDCApplicationsWhereUniqueInput
  }


  /**
   * OIDCApplications updateMany
   */
  export type OIDCApplicationsUpdateManyArgs = {
    data: XOR<OIDCApplicationsUpdateManyMutationInput, OIDCApplicationsUncheckedUpdateManyInput>
    where?: OIDCApplicationsWhereInput
  }


  /**
   * OIDCApplications upsert
   */
  export type OIDCApplicationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the OIDCApplications
     * 
    **/
    select?: OIDCApplicationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCApplicationsInclude | null
    /**
     * The filter to search for the OIDCApplications to update in case it exists.
     * 
    **/
    where: OIDCApplicationsWhereUniqueInput
    /**
     * In case the OIDCApplications found by the `where` argument doesn't exist, create a new OIDCApplications with this data.
     * 
    **/
    create: XOR<OIDCApplicationsCreateInput, OIDCApplicationsUncheckedCreateInput>
    /**
     * In case the OIDCApplications was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OIDCApplicationsUpdateInput, OIDCApplicationsUncheckedUpdateInput>
  }


  /**
   * OIDCApplications delete
   */
  export type OIDCApplicationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the OIDCApplications
     * 
    **/
    select?: OIDCApplicationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCApplicationsInclude | null
    /**
     * Filter which OIDCApplications to delete.
     * 
    **/
    where: OIDCApplicationsWhereUniqueInput
  }


  /**
   * OIDCApplications deleteMany
   */
  export type OIDCApplicationsDeleteManyArgs = {
    where?: OIDCApplicationsWhereInput
  }


  /**
   * OIDCApplications without action
   */
  export type OIDCApplicationsArgs = {
    /**
     * Select specific fields to fetch from the OIDCApplications
     * 
    **/
    select?: OIDCApplicationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCApplicationsInclude | null
  }



  /**
   * Model OIDCAuthorizations
   */


  export type AggregateOIDCAuthorizations = {
    _count: OIDCAuthorizationsCountAggregateOutputType | null
    _min: OIDCAuthorizationsMinAggregateOutputType | null
    _max: OIDCAuthorizationsMaxAggregateOutputType | null
  }

  export type OIDCAuthorizationsMinAggregateOutputType = {
    Id: string | null
    ApplicationId: string | null
    ConcurrencyToken: string | null
    CreationDate: Date | null
    Properties: string | null
    Scopes: string | null
    Status: string | null
    Subject: string | null
    Type: string | null
  }

  export type OIDCAuthorizationsMaxAggregateOutputType = {
    Id: string | null
    ApplicationId: string | null
    ConcurrencyToken: string | null
    CreationDate: Date | null
    Properties: string | null
    Scopes: string | null
    Status: string | null
    Subject: string | null
    Type: string | null
  }

  export type OIDCAuthorizationsCountAggregateOutputType = {
    Id: number
    ApplicationId: number
    ConcurrencyToken: number
    CreationDate: number
    Properties: number
    Scopes: number
    Status: number
    Subject: number
    Type: number
    _all: number
  }


  export type OIDCAuthorizationsMinAggregateInputType = {
    Id?: true
    ApplicationId?: true
    ConcurrencyToken?: true
    CreationDate?: true
    Properties?: true
    Scopes?: true
    Status?: true
    Subject?: true
    Type?: true
  }

  export type OIDCAuthorizationsMaxAggregateInputType = {
    Id?: true
    ApplicationId?: true
    ConcurrencyToken?: true
    CreationDate?: true
    Properties?: true
    Scopes?: true
    Status?: true
    Subject?: true
    Type?: true
  }

  export type OIDCAuthorizationsCountAggregateInputType = {
    Id?: true
    ApplicationId?: true
    ConcurrencyToken?: true
    CreationDate?: true
    Properties?: true
    Scopes?: true
    Status?: true
    Subject?: true
    Type?: true
    _all?: true
  }

  export type OIDCAuthorizationsAggregateArgs = {
    /**
     * Filter which OIDCAuthorizations to aggregate.
     * 
    **/
    where?: OIDCAuthorizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCAuthorizations to fetch.
     * 
    **/
    orderBy?: Enumerable<OIDCAuthorizationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OIDCAuthorizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCAuthorizations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCAuthorizations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OIDCAuthorizations
    **/
    _count?: true | OIDCAuthorizationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OIDCAuthorizationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OIDCAuthorizationsMaxAggregateInputType
  }

  export type GetOIDCAuthorizationsAggregateType<T extends OIDCAuthorizationsAggregateArgs> = {
        [P in keyof T & keyof AggregateOIDCAuthorizations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOIDCAuthorizations[P]>
      : GetScalarType<T[P], AggregateOIDCAuthorizations[P]>
  }




  export type OIDCAuthorizationsGroupByArgs = {
    where?: OIDCAuthorizationsWhereInput
    orderBy?: Enumerable<OIDCAuthorizationsOrderByWithAggregationInput>
    by: Array<OIDCAuthorizationsScalarFieldEnum>
    having?: OIDCAuthorizationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OIDCAuthorizationsCountAggregateInputType | true
    _min?: OIDCAuthorizationsMinAggregateInputType
    _max?: OIDCAuthorizationsMaxAggregateInputType
  }


  export type OIDCAuthorizationsGroupByOutputType = {
    Id: string
    ApplicationId: string | null
    ConcurrencyToken: string | null
    CreationDate: Date | null
    Properties: string | null
    Scopes: string | null
    Status: string | null
    Subject: string | null
    Type: string | null
    _count: OIDCAuthorizationsCountAggregateOutputType | null
    _min: OIDCAuthorizationsMinAggregateOutputType | null
    _max: OIDCAuthorizationsMaxAggregateOutputType | null
  }

  type GetOIDCAuthorizationsGroupByPayload<T extends OIDCAuthorizationsGroupByArgs> = Promise<
    Array<
      PickArray<OIDCAuthorizationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OIDCAuthorizationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OIDCAuthorizationsGroupByOutputType[P]>
            : GetScalarType<T[P], OIDCAuthorizationsGroupByOutputType[P]>
        }
      >
    >


  export type OIDCAuthorizationsSelect = {
    Id?: boolean
    ApplicationId?: boolean
    ConcurrencyToken?: boolean
    CreationDate?: boolean
    Properties?: boolean
    Scopes?: boolean
    Status?: boolean
    Subject?: boolean
    Type?: boolean
    OIDCApplications?: boolean | OIDCApplicationsArgs
    OIDCTokens?: boolean | OIDCTokensFindManyArgs
    _count?: boolean | OIDCAuthorizationsCountOutputTypeArgs
  }

  export type OIDCAuthorizationsInclude = {
    OIDCApplications?: boolean | OIDCApplicationsArgs
    OIDCTokens?: boolean | OIDCTokensFindManyArgs
    _count?: boolean | OIDCAuthorizationsCountOutputTypeArgs
  }

  export type OIDCAuthorizationsGetPayload<
    S extends boolean | null | undefined | OIDCAuthorizationsArgs,
    U = keyof S
      > = S extends true
        ? OIDCAuthorizations
    : S extends undefined
    ? never
    : S extends OIDCAuthorizationsArgs | OIDCAuthorizationsFindManyArgs
    ?'include' extends U
    ? OIDCAuthorizations  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'OIDCApplications'
        ? OIDCApplicationsGetPayload<S['include'][P]> | null :
        P extends 'OIDCTokens'
        ? Array < OIDCTokensGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? OIDCAuthorizationsCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof OIDCAuthorizations ?OIDCAuthorizations [P]
  : 
          P extends 'OIDCApplications'
        ? OIDCApplicationsGetPayload<S['select'][P]> | null :
        P extends 'OIDCTokens'
        ? Array < OIDCTokensGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? OIDCAuthorizationsCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : OIDCAuthorizations
  : OIDCAuthorizations


  type OIDCAuthorizationsCountArgs = Merge<
    Omit<OIDCAuthorizationsFindManyArgs, 'select' | 'include'> & {
      select?: OIDCAuthorizationsCountAggregateInputType | true
    }
  >

  export interface OIDCAuthorizationsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OIDCAuthorizations that matches the filter.
     * @param {OIDCAuthorizationsFindUniqueArgs} args - Arguments to find a OIDCAuthorizations
     * @example
     * // Get one OIDCAuthorizations
     * const oIDCAuthorizations = await prisma.oIDCAuthorizations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OIDCAuthorizationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OIDCAuthorizationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OIDCAuthorizations'> extends True ? CheckSelect<T, Prisma__OIDCAuthorizationsClient<OIDCAuthorizations>, Prisma__OIDCAuthorizationsClient<OIDCAuthorizationsGetPayload<T>>> : CheckSelect<T, Prisma__OIDCAuthorizationsClient<OIDCAuthorizations | null >, Prisma__OIDCAuthorizationsClient<OIDCAuthorizationsGetPayload<T> | null >>

    /**
     * Find the first OIDCAuthorizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCAuthorizationsFindFirstArgs} args - Arguments to find a OIDCAuthorizations
     * @example
     * // Get one OIDCAuthorizations
     * const oIDCAuthorizations = await prisma.oIDCAuthorizations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OIDCAuthorizationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OIDCAuthorizationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OIDCAuthorizations'> extends True ? CheckSelect<T, Prisma__OIDCAuthorizationsClient<OIDCAuthorizations>, Prisma__OIDCAuthorizationsClient<OIDCAuthorizationsGetPayload<T>>> : CheckSelect<T, Prisma__OIDCAuthorizationsClient<OIDCAuthorizations | null >, Prisma__OIDCAuthorizationsClient<OIDCAuthorizationsGetPayload<T> | null >>

    /**
     * Find zero or more OIDCAuthorizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCAuthorizationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OIDCAuthorizations
     * const oIDCAuthorizations = await prisma.oIDCAuthorizations.findMany()
     * 
     * // Get first 10 OIDCAuthorizations
     * const oIDCAuthorizations = await prisma.oIDCAuthorizations.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const oIDCAuthorizationsWithIdOnly = await prisma.oIDCAuthorizations.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends OIDCAuthorizationsFindManyArgs>(
      args?: SelectSubset<T, OIDCAuthorizationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OIDCAuthorizations>>, PrismaPromise<Array<OIDCAuthorizationsGetPayload<T>>>>

    /**
     * Create a OIDCAuthorizations.
     * @param {OIDCAuthorizationsCreateArgs} args - Arguments to create a OIDCAuthorizations.
     * @example
     * // Create one OIDCAuthorizations
     * const OIDCAuthorizations = await prisma.oIDCAuthorizations.create({
     *   data: {
     *     // ... data to create a OIDCAuthorizations
     *   }
     * })
     * 
    **/
    create<T extends OIDCAuthorizationsCreateArgs>(
      args: SelectSubset<T, OIDCAuthorizationsCreateArgs>
    ): CheckSelect<T, Prisma__OIDCAuthorizationsClient<OIDCAuthorizations>, Prisma__OIDCAuthorizationsClient<OIDCAuthorizationsGetPayload<T>>>

    /**
     * Create many OIDCAuthorizations.
     *     @param {OIDCAuthorizationsCreateManyArgs} args - Arguments to create many OIDCAuthorizations.
     *     @example
     *     // Create many OIDCAuthorizations
     *     const oIDCAuthorizations = await prisma.oIDCAuthorizations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OIDCAuthorizationsCreateManyArgs>(
      args?: SelectSubset<T, OIDCAuthorizationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OIDCAuthorizations.
     * @param {OIDCAuthorizationsDeleteArgs} args - Arguments to delete one OIDCAuthorizations.
     * @example
     * // Delete one OIDCAuthorizations
     * const OIDCAuthorizations = await prisma.oIDCAuthorizations.delete({
     *   where: {
     *     // ... filter to delete one OIDCAuthorizations
     *   }
     * })
     * 
    **/
    delete<T extends OIDCAuthorizationsDeleteArgs>(
      args: SelectSubset<T, OIDCAuthorizationsDeleteArgs>
    ): CheckSelect<T, Prisma__OIDCAuthorizationsClient<OIDCAuthorizations>, Prisma__OIDCAuthorizationsClient<OIDCAuthorizationsGetPayload<T>>>

    /**
     * Update one OIDCAuthorizations.
     * @param {OIDCAuthorizationsUpdateArgs} args - Arguments to update one OIDCAuthorizations.
     * @example
     * // Update one OIDCAuthorizations
     * const oIDCAuthorizations = await prisma.oIDCAuthorizations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OIDCAuthorizationsUpdateArgs>(
      args: SelectSubset<T, OIDCAuthorizationsUpdateArgs>
    ): CheckSelect<T, Prisma__OIDCAuthorizationsClient<OIDCAuthorizations>, Prisma__OIDCAuthorizationsClient<OIDCAuthorizationsGetPayload<T>>>

    /**
     * Delete zero or more OIDCAuthorizations.
     * @param {OIDCAuthorizationsDeleteManyArgs} args - Arguments to filter OIDCAuthorizations to delete.
     * @example
     * // Delete a few OIDCAuthorizations
     * const { count } = await prisma.oIDCAuthorizations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OIDCAuthorizationsDeleteManyArgs>(
      args?: SelectSubset<T, OIDCAuthorizationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OIDCAuthorizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCAuthorizationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OIDCAuthorizations
     * const oIDCAuthorizations = await prisma.oIDCAuthorizations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OIDCAuthorizationsUpdateManyArgs>(
      args: SelectSubset<T, OIDCAuthorizationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OIDCAuthorizations.
     * @param {OIDCAuthorizationsUpsertArgs} args - Arguments to update or create a OIDCAuthorizations.
     * @example
     * // Update or create a OIDCAuthorizations
     * const oIDCAuthorizations = await prisma.oIDCAuthorizations.upsert({
     *   create: {
     *     // ... data to create a OIDCAuthorizations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OIDCAuthorizations we want to update
     *   }
     * })
    **/
    upsert<T extends OIDCAuthorizationsUpsertArgs>(
      args: SelectSubset<T, OIDCAuthorizationsUpsertArgs>
    ): CheckSelect<T, Prisma__OIDCAuthorizationsClient<OIDCAuthorizations>, Prisma__OIDCAuthorizationsClient<OIDCAuthorizationsGetPayload<T>>>

    /**
     * Count the number of OIDCAuthorizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCAuthorizationsCountArgs} args - Arguments to filter OIDCAuthorizations to count.
     * @example
     * // Count the number of OIDCAuthorizations
     * const count = await prisma.oIDCAuthorizations.count({
     *   where: {
     *     // ... the filter for the OIDCAuthorizations we want to count
     *   }
     * })
    **/
    count<T extends OIDCAuthorizationsCountArgs>(
      args?: Subset<T, OIDCAuthorizationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OIDCAuthorizationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OIDCAuthorizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCAuthorizationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OIDCAuthorizationsAggregateArgs>(args: Subset<T, OIDCAuthorizationsAggregateArgs>): PrismaPromise<GetOIDCAuthorizationsAggregateType<T>>

    /**
     * Group by OIDCAuthorizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCAuthorizationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OIDCAuthorizationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OIDCAuthorizationsGroupByArgs['orderBy'] }
        : { orderBy?: OIDCAuthorizationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OIDCAuthorizationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOIDCAuthorizationsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OIDCAuthorizations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OIDCAuthorizationsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    OIDCApplications<T extends OIDCApplicationsArgs = {}>(args?: Subset<T, OIDCApplicationsArgs>): CheckSelect<T, Prisma__OIDCApplicationsClient<OIDCApplications | null >, Prisma__OIDCApplicationsClient<OIDCApplicationsGetPayload<T> | null >>;

    OIDCTokens<T extends OIDCTokensFindManyArgs = {}>(args?: Subset<T, OIDCTokensFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OIDCTokens>>, PrismaPromise<Array<OIDCTokensGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OIDCAuthorizations findUnique
   */
  export type OIDCAuthorizationsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OIDCAuthorizations
     * 
    **/
    select?: OIDCAuthorizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCAuthorizationsInclude | null
    /**
     * Throw an Error if a OIDCAuthorizations can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OIDCAuthorizations to fetch.
     * 
    **/
    where: OIDCAuthorizationsWhereUniqueInput
  }


  /**
   * OIDCAuthorizations findFirst
   */
  export type OIDCAuthorizationsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OIDCAuthorizations
     * 
    **/
    select?: OIDCAuthorizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCAuthorizationsInclude | null
    /**
     * Throw an Error if a OIDCAuthorizations can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OIDCAuthorizations to fetch.
     * 
    **/
    where?: OIDCAuthorizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCAuthorizations to fetch.
     * 
    **/
    orderBy?: Enumerable<OIDCAuthorizationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OIDCAuthorizations.
     * 
    **/
    cursor?: OIDCAuthorizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCAuthorizations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCAuthorizations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OIDCAuthorizations.
     * 
    **/
    distinct?: Enumerable<OIDCAuthorizationsScalarFieldEnum>
  }


  /**
   * OIDCAuthorizations findMany
   */
  export type OIDCAuthorizationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the OIDCAuthorizations
     * 
    **/
    select?: OIDCAuthorizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCAuthorizationsInclude | null
    /**
     * Filter, which OIDCAuthorizations to fetch.
     * 
    **/
    where?: OIDCAuthorizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCAuthorizations to fetch.
     * 
    **/
    orderBy?: Enumerable<OIDCAuthorizationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OIDCAuthorizations.
     * 
    **/
    cursor?: OIDCAuthorizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCAuthorizations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCAuthorizations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OIDCAuthorizationsScalarFieldEnum>
  }


  /**
   * OIDCAuthorizations create
   */
  export type OIDCAuthorizationsCreateArgs = {
    /**
     * Select specific fields to fetch from the OIDCAuthorizations
     * 
    **/
    select?: OIDCAuthorizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCAuthorizationsInclude | null
    /**
     * The data needed to create a OIDCAuthorizations.
     * 
    **/
    data: XOR<OIDCAuthorizationsCreateInput, OIDCAuthorizationsUncheckedCreateInput>
  }


  /**
   * OIDCAuthorizations createMany
   */
  export type OIDCAuthorizationsCreateManyArgs = {
    data: Enumerable<OIDCAuthorizationsCreateManyInput>
  }


  /**
   * OIDCAuthorizations update
   */
  export type OIDCAuthorizationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the OIDCAuthorizations
     * 
    **/
    select?: OIDCAuthorizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCAuthorizationsInclude | null
    /**
     * The data needed to update a OIDCAuthorizations.
     * 
    **/
    data: XOR<OIDCAuthorizationsUpdateInput, OIDCAuthorizationsUncheckedUpdateInput>
    /**
     * Choose, which OIDCAuthorizations to update.
     * 
    **/
    where: OIDCAuthorizationsWhereUniqueInput
  }


  /**
   * OIDCAuthorizations updateMany
   */
  export type OIDCAuthorizationsUpdateManyArgs = {
    data: XOR<OIDCAuthorizationsUpdateManyMutationInput, OIDCAuthorizationsUncheckedUpdateManyInput>
    where?: OIDCAuthorizationsWhereInput
  }


  /**
   * OIDCAuthorizations upsert
   */
  export type OIDCAuthorizationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the OIDCAuthorizations
     * 
    **/
    select?: OIDCAuthorizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCAuthorizationsInclude | null
    /**
     * The filter to search for the OIDCAuthorizations to update in case it exists.
     * 
    **/
    where: OIDCAuthorizationsWhereUniqueInput
    /**
     * In case the OIDCAuthorizations found by the `where` argument doesn't exist, create a new OIDCAuthorizations with this data.
     * 
    **/
    create: XOR<OIDCAuthorizationsCreateInput, OIDCAuthorizationsUncheckedCreateInput>
    /**
     * In case the OIDCAuthorizations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OIDCAuthorizationsUpdateInput, OIDCAuthorizationsUncheckedUpdateInput>
  }


  /**
   * OIDCAuthorizations delete
   */
  export type OIDCAuthorizationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the OIDCAuthorizations
     * 
    **/
    select?: OIDCAuthorizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCAuthorizationsInclude | null
    /**
     * Filter which OIDCAuthorizations to delete.
     * 
    **/
    where: OIDCAuthorizationsWhereUniqueInput
  }


  /**
   * OIDCAuthorizations deleteMany
   */
  export type OIDCAuthorizationsDeleteManyArgs = {
    where?: OIDCAuthorizationsWhereInput
  }


  /**
   * OIDCAuthorizations without action
   */
  export type OIDCAuthorizationsArgs = {
    /**
     * Select specific fields to fetch from the OIDCAuthorizations
     * 
    **/
    select?: OIDCAuthorizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCAuthorizationsInclude | null
  }



  /**
   * Model OIDCScopes
   */


  export type AggregateOIDCScopes = {
    _count: OIDCScopesCountAggregateOutputType | null
    _min: OIDCScopesMinAggregateOutputType | null
    _max: OIDCScopesMaxAggregateOutputType | null
  }

  export type OIDCScopesMinAggregateOutputType = {
    Id: string | null
    ConcurrencyToken: string | null
    Description: string | null
    Descriptions: string | null
    DisplayName: string | null
    DisplayNames: string | null
    Name: string | null
    Properties: string | null
    Resources: string | null
  }

  export type OIDCScopesMaxAggregateOutputType = {
    Id: string | null
    ConcurrencyToken: string | null
    Description: string | null
    Descriptions: string | null
    DisplayName: string | null
    DisplayNames: string | null
    Name: string | null
    Properties: string | null
    Resources: string | null
  }

  export type OIDCScopesCountAggregateOutputType = {
    Id: number
    ConcurrencyToken: number
    Description: number
    Descriptions: number
    DisplayName: number
    DisplayNames: number
    Name: number
    Properties: number
    Resources: number
    _all: number
  }


  export type OIDCScopesMinAggregateInputType = {
    Id?: true
    ConcurrencyToken?: true
    Description?: true
    Descriptions?: true
    DisplayName?: true
    DisplayNames?: true
    Name?: true
    Properties?: true
    Resources?: true
  }

  export type OIDCScopesMaxAggregateInputType = {
    Id?: true
    ConcurrencyToken?: true
    Description?: true
    Descriptions?: true
    DisplayName?: true
    DisplayNames?: true
    Name?: true
    Properties?: true
    Resources?: true
  }

  export type OIDCScopesCountAggregateInputType = {
    Id?: true
    ConcurrencyToken?: true
    Description?: true
    Descriptions?: true
    DisplayName?: true
    DisplayNames?: true
    Name?: true
    Properties?: true
    Resources?: true
    _all?: true
  }

  export type OIDCScopesAggregateArgs = {
    /**
     * Filter which OIDCScopes to aggregate.
     * 
    **/
    where?: OIDCScopesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCScopes to fetch.
     * 
    **/
    orderBy?: Enumerable<OIDCScopesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OIDCScopesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCScopes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCScopes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OIDCScopes
    **/
    _count?: true | OIDCScopesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OIDCScopesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OIDCScopesMaxAggregateInputType
  }

  export type GetOIDCScopesAggregateType<T extends OIDCScopesAggregateArgs> = {
        [P in keyof T & keyof AggregateOIDCScopes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOIDCScopes[P]>
      : GetScalarType<T[P], AggregateOIDCScopes[P]>
  }




  export type OIDCScopesGroupByArgs = {
    where?: OIDCScopesWhereInput
    orderBy?: Enumerable<OIDCScopesOrderByWithAggregationInput>
    by: Array<OIDCScopesScalarFieldEnum>
    having?: OIDCScopesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OIDCScopesCountAggregateInputType | true
    _min?: OIDCScopesMinAggregateInputType
    _max?: OIDCScopesMaxAggregateInputType
  }


  export type OIDCScopesGroupByOutputType = {
    Id: string
    ConcurrencyToken: string | null
    Description: string | null
    Descriptions: string | null
    DisplayName: string | null
    DisplayNames: string | null
    Name: string | null
    Properties: string | null
    Resources: string | null
    _count: OIDCScopesCountAggregateOutputType | null
    _min: OIDCScopesMinAggregateOutputType | null
    _max: OIDCScopesMaxAggregateOutputType | null
  }

  type GetOIDCScopesGroupByPayload<T extends OIDCScopesGroupByArgs> = Promise<
    Array<
      PickArray<OIDCScopesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OIDCScopesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OIDCScopesGroupByOutputType[P]>
            : GetScalarType<T[P], OIDCScopesGroupByOutputType[P]>
        }
      >
    >


  export type OIDCScopesSelect = {
    Id?: boolean
    ConcurrencyToken?: boolean
    Description?: boolean
    Descriptions?: boolean
    DisplayName?: boolean
    DisplayNames?: boolean
    Name?: boolean
    Properties?: boolean
    Resources?: boolean
  }

  export type OIDCScopesGetPayload<
    S extends boolean | null | undefined | OIDCScopesArgs,
    U = keyof S
      > = S extends true
        ? OIDCScopes
    : S extends undefined
    ? never
    : S extends OIDCScopesArgs | OIDCScopesFindManyArgs
    ?'include' extends U
    ? OIDCScopes 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof OIDCScopes ?OIDCScopes [P]
  : 
     never
  } 
    : OIDCScopes
  : OIDCScopes


  type OIDCScopesCountArgs = Merge<
    Omit<OIDCScopesFindManyArgs, 'select' | 'include'> & {
      select?: OIDCScopesCountAggregateInputType | true
    }
  >

  export interface OIDCScopesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OIDCScopes that matches the filter.
     * @param {OIDCScopesFindUniqueArgs} args - Arguments to find a OIDCScopes
     * @example
     * // Get one OIDCScopes
     * const oIDCScopes = await prisma.oIDCScopes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OIDCScopesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OIDCScopesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OIDCScopes'> extends True ? CheckSelect<T, Prisma__OIDCScopesClient<OIDCScopes>, Prisma__OIDCScopesClient<OIDCScopesGetPayload<T>>> : CheckSelect<T, Prisma__OIDCScopesClient<OIDCScopes | null >, Prisma__OIDCScopesClient<OIDCScopesGetPayload<T> | null >>

    /**
     * Find the first OIDCScopes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCScopesFindFirstArgs} args - Arguments to find a OIDCScopes
     * @example
     * // Get one OIDCScopes
     * const oIDCScopes = await prisma.oIDCScopes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OIDCScopesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OIDCScopesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OIDCScopes'> extends True ? CheckSelect<T, Prisma__OIDCScopesClient<OIDCScopes>, Prisma__OIDCScopesClient<OIDCScopesGetPayload<T>>> : CheckSelect<T, Prisma__OIDCScopesClient<OIDCScopes | null >, Prisma__OIDCScopesClient<OIDCScopesGetPayload<T> | null >>

    /**
     * Find zero or more OIDCScopes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCScopesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OIDCScopes
     * const oIDCScopes = await prisma.oIDCScopes.findMany()
     * 
     * // Get first 10 OIDCScopes
     * const oIDCScopes = await prisma.oIDCScopes.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const oIDCScopesWithIdOnly = await prisma.oIDCScopes.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends OIDCScopesFindManyArgs>(
      args?: SelectSubset<T, OIDCScopesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OIDCScopes>>, PrismaPromise<Array<OIDCScopesGetPayload<T>>>>

    /**
     * Create a OIDCScopes.
     * @param {OIDCScopesCreateArgs} args - Arguments to create a OIDCScopes.
     * @example
     * // Create one OIDCScopes
     * const OIDCScopes = await prisma.oIDCScopes.create({
     *   data: {
     *     // ... data to create a OIDCScopes
     *   }
     * })
     * 
    **/
    create<T extends OIDCScopesCreateArgs>(
      args: SelectSubset<T, OIDCScopesCreateArgs>
    ): CheckSelect<T, Prisma__OIDCScopesClient<OIDCScopes>, Prisma__OIDCScopesClient<OIDCScopesGetPayload<T>>>

    /**
     * Create many OIDCScopes.
     *     @param {OIDCScopesCreateManyArgs} args - Arguments to create many OIDCScopes.
     *     @example
     *     // Create many OIDCScopes
     *     const oIDCScopes = await prisma.oIDCScopes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OIDCScopesCreateManyArgs>(
      args?: SelectSubset<T, OIDCScopesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OIDCScopes.
     * @param {OIDCScopesDeleteArgs} args - Arguments to delete one OIDCScopes.
     * @example
     * // Delete one OIDCScopes
     * const OIDCScopes = await prisma.oIDCScopes.delete({
     *   where: {
     *     // ... filter to delete one OIDCScopes
     *   }
     * })
     * 
    **/
    delete<T extends OIDCScopesDeleteArgs>(
      args: SelectSubset<T, OIDCScopesDeleteArgs>
    ): CheckSelect<T, Prisma__OIDCScopesClient<OIDCScopes>, Prisma__OIDCScopesClient<OIDCScopesGetPayload<T>>>

    /**
     * Update one OIDCScopes.
     * @param {OIDCScopesUpdateArgs} args - Arguments to update one OIDCScopes.
     * @example
     * // Update one OIDCScopes
     * const oIDCScopes = await prisma.oIDCScopes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OIDCScopesUpdateArgs>(
      args: SelectSubset<T, OIDCScopesUpdateArgs>
    ): CheckSelect<T, Prisma__OIDCScopesClient<OIDCScopes>, Prisma__OIDCScopesClient<OIDCScopesGetPayload<T>>>

    /**
     * Delete zero or more OIDCScopes.
     * @param {OIDCScopesDeleteManyArgs} args - Arguments to filter OIDCScopes to delete.
     * @example
     * // Delete a few OIDCScopes
     * const { count } = await prisma.oIDCScopes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OIDCScopesDeleteManyArgs>(
      args?: SelectSubset<T, OIDCScopesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OIDCScopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCScopesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OIDCScopes
     * const oIDCScopes = await prisma.oIDCScopes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OIDCScopesUpdateManyArgs>(
      args: SelectSubset<T, OIDCScopesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OIDCScopes.
     * @param {OIDCScopesUpsertArgs} args - Arguments to update or create a OIDCScopes.
     * @example
     * // Update or create a OIDCScopes
     * const oIDCScopes = await prisma.oIDCScopes.upsert({
     *   create: {
     *     // ... data to create a OIDCScopes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OIDCScopes we want to update
     *   }
     * })
    **/
    upsert<T extends OIDCScopesUpsertArgs>(
      args: SelectSubset<T, OIDCScopesUpsertArgs>
    ): CheckSelect<T, Prisma__OIDCScopesClient<OIDCScopes>, Prisma__OIDCScopesClient<OIDCScopesGetPayload<T>>>

    /**
     * Count the number of OIDCScopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCScopesCountArgs} args - Arguments to filter OIDCScopes to count.
     * @example
     * // Count the number of OIDCScopes
     * const count = await prisma.oIDCScopes.count({
     *   where: {
     *     // ... the filter for the OIDCScopes we want to count
     *   }
     * })
    **/
    count<T extends OIDCScopesCountArgs>(
      args?: Subset<T, OIDCScopesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OIDCScopesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OIDCScopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCScopesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OIDCScopesAggregateArgs>(args: Subset<T, OIDCScopesAggregateArgs>): PrismaPromise<GetOIDCScopesAggregateType<T>>

    /**
     * Group by OIDCScopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCScopesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OIDCScopesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OIDCScopesGroupByArgs['orderBy'] }
        : { orderBy?: OIDCScopesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OIDCScopesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOIDCScopesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OIDCScopes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OIDCScopesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OIDCScopes findUnique
   */
  export type OIDCScopesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OIDCScopes
     * 
    **/
    select?: OIDCScopesSelect | null
    /**
     * Throw an Error if a OIDCScopes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OIDCScopes to fetch.
     * 
    **/
    where: OIDCScopesWhereUniqueInput
  }


  /**
   * OIDCScopes findFirst
   */
  export type OIDCScopesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OIDCScopes
     * 
    **/
    select?: OIDCScopesSelect | null
    /**
     * Throw an Error if a OIDCScopes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OIDCScopes to fetch.
     * 
    **/
    where?: OIDCScopesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCScopes to fetch.
     * 
    **/
    orderBy?: Enumerable<OIDCScopesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OIDCScopes.
     * 
    **/
    cursor?: OIDCScopesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCScopes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCScopes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OIDCScopes.
     * 
    **/
    distinct?: Enumerable<OIDCScopesScalarFieldEnum>
  }


  /**
   * OIDCScopes findMany
   */
  export type OIDCScopesFindManyArgs = {
    /**
     * Select specific fields to fetch from the OIDCScopes
     * 
    **/
    select?: OIDCScopesSelect | null
    /**
     * Filter, which OIDCScopes to fetch.
     * 
    **/
    where?: OIDCScopesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCScopes to fetch.
     * 
    **/
    orderBy?: Enumerable<OIDCScopesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OIDCScopes.
     * 
    **/
    cursor?: OIDCScopesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCScopes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCScopes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OIDCScopesScalarFieldEnum>
  }


  /**
   * OIDCScopes create
   */
  export type OIDCScopesCreateArgs = {
    /**
     * Select specific fields to fetch from the OIDCScopes
     * 
    **/
    select?: OIDCScopesSelect | null
    /**
     * The data needed to create a OIDCScopes.
     * 
    **/
    data: XOR<OIDCScopesCreateInput, OIDCScopesUncheckedCreateInput>
  }


  /**
   * OIDCScopes createMany
   */
  export type OIDCScopesCreateManyArgs = {
    data: Enumerable<OIDCScopesCreateManyInput>
  }


  /**
   * OIDCScopes update
   */
  export type OIDCScopesUpdateArgs = {
    /**
     * Select specific fields to fetch from the OIDCScopes
     * 
    **/
    select?: OIDCScopesSelect | null
    /**
     * The data needed to update a OIDCScopes.
     * 
    **/
    data: XOR<OIDCScopesUpdateInput, OIDCScopesUncheckedUpdateInput>
    /**
     * Choose, which OIDCScopes to update.
     * 
    **/
    where: OIDCScopesWhereUniqueInput
  }


  /**
   * OIDCScopes updateMany
   */
  export type OIDCScopesUpdateManyArgs = {
    data: XOR<OIDCScopesUpdateManyMutationInput, OIDCScopesUncheckedUpdateManyInput>
    where?: OIDCScopesWhereInput
  }


  /**
   * OIDCScopes upsert
   */
  export type OIDCScopesUpsertArgs = {
    /**
     * Select specific fields to fetch from the OIDCScopes
     * 
    **/
    select?: OIDCScopesSelect | null
    /**
     * The filter to search for the OIDCScopes to update in case it exists.
     * 
    **/
    where: OIDCScopesWhereUniqueInput
    /**
     * In case the OIDCScopes found by the `where` argument doesn't exist, create a new OIDCScopes with this data.
     * 
    **/
    create: XOR<OIDCScopesCreateInput, OIDCScopesUncheckedCreateInput>
    /**
     * In case the OIDCScopes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OIDCScopesUpdateInput, OIDCScopesUncheckedUpdateInput>
  }


  /**
   * OIDCScopes delete
   */
  export type OIDCScopesDeleteArgs = {
    /**
     * Select specific fields to fetch from the OIDCScopes
     * 
    **/
    select?: OIDCScopesSelect | null
    /**
     * Filter which OIDCScopes to delete.
     * 
    **/
    where: OIDCScopesWhereUniqueInput
  }


  /**
   * OIDCScopes deleteMany
   */
  export type OIDCScopesDeleteManyArgs = {
    where?: OIDCScopesWhereInput
  }


  /**
   * OIDCScopes without action
   */
  export type OIDCScopesArgs = {
    /**
     * Select specific fields to fetch from the OIDCScopes
     * 
    **/
    select?: OIDCScopesSelect | null
  }



  /**
   * Model OIDCTokens
   */


  export type AggregateOIDCTokens = {
    _count: OIDCTokensCountAggregateOutputType | null
    _min: OIDCTokensMinAggregateOutputType | null
    _max: OIDCTokensMaxAggregateOutputType | null
  }

  export type OIDCTokensMinAggregateOutputType = {
    Id: string | null
    ApplicationId: string | null
    AuthorizationId: string | null
    ConcurrencyToken: string | null
    CreationDate: Date | null
    ExpirationDate: Date | null
    Payload: string | null
    Properties: string | null
    RedemptionDate: Date | null
    ReferenceId: string | null
    Status: string | null
    Subject: string | null
    Type: string | null
  }

  export type OIDCTokensMaxAggregateOutputType = {
    Id: string | null
    ApplicationId: string | null
    AuthorizationId: string | null
    ConcurrencyToken: string | null
    CreationDate: Date | null
    ExpirationDate: Date | null
    Payload: string | null
    Properties: string | null
    RedemptionDate: Date | null
    ReferenceId: string | null
    Status: string | null
    Subject: string | null
    Type: string | null
  }

  export type OIDCTokensCountAggregateOutputType = {
    Id: number
    ApplicationId: number
    AuthorizationId: number
    ConcurrencyToken: number
    CreationDate: number
    ExpirationDate: number
    Payload: number
    Properties: number
    RedemptionDate: number
    ReferenceId: number
    Status: number
    Subject: number
    Type: number
    _all: number
  }


  export type OIDCTokensMinAggregateInputType = {
    Id?: true
    ApplicationId?: true
    AuthorizationId?: true
    ConcurrencyToken?: true
    CreationDate?: true
    ExpirationDate?: true
    Payload?: true
    Properties?: true
    RedemptionDate?: true
    ReferenceId?: true
    Status?: true
    Subject?: true
    Type?: true
  }

  export type OIDCTokensMaxAggregateInputType = {
    Id?: true
    ApplicationId?: true
    AuthorizationId?: true
    ConcurrencyToken?: true
    CreationDate?: true
    ExpirationDate?: true
    Payload?: true
    Properties?: true
    RedemptionDate?: true
    ReferenceId?: true
    Status?: true
    Subject?: true
    Type?: true
  }

  export type OIDCTokensCountAggregateInputType = {
    Id?: true
    ApplicationId?: true
    AuthorizationId?: true
    ConcurrencyToken?: true
    CreationDate?: true
    ExpirationDate?: true
    Payload?: true
    Properties?: true
    RedemptionDate?: true
    ReferenceId?: true
    Status?: true
    Subject?: true
    Type?: true
    _all?: true
  }

  export type OIDCTokensAggregateArgs = {
    /**
     * Filter which OIDCTokens to aggregate.
     * 
    **/
    where?: OIDCTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<OIDCTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OIDCTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OIDCTokens
    **/
    _count?: true | OIDCTokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OIDCTokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OIDCTokensMaxAggregateInputType
  }

  export type GetOIDCTokensAggregateType<T extends OIDCTokensAggregateArgs> = {
        [P in keyof T & keyof AggregateOIDCTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOIDCTokens[P]>
      : GetScalarType<T[P], AggregateOIDCTokens[P]>
  }




  export type OIDCTokensGroupByArgs = {
    where?: OIDCTokensWhereInput
    orderBy?: Enumerable<OIDCTokensOrderByWithAggregationInput>
    by: Array<OIDCTokensScalarFieldEnum>
    having?: OIDCTokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OIDCTokensCountAggregateInputType | true
    _min?: OIDCTokensMinAggregateInputType
    _max?: OIDCTokensMaxAggregateInputType
  }


  export type OIDCTokensGroupByOutputType = {
    Id: string
    ApplicationId: string | null
    AuthorizationId: string | null
    ConcurrencyToken: string | null
    CreationDate: Date | null
    ExpirationDate: Date | null
    Payload: string | null
    Properties: string | null
    RedemptionDate: Date | null
    ReferenceId: string | null
    Status: string | null
    Subject: string | null
    Type: string | null
    _count: OIDCTokensCountAggregateOutputType | null
    _min: OIDCTokensMinAggregateOutputType | null
    _max: OIDCTokensMaxAggregateOutputType | null
  }

  type GetOIDCTokensGroupByPayload<T extends OIDCTokensGroupByArgs> = Promise<
    Array<
      PickArray<OIDCTokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OIDCTokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OIDCTokensGroupByOutputType[P]>
            : GetScalarType<T[P], OIDCTokensGroupByOutputType[P]>
        }
      >
    >


  export type OIDCTokensSelect = {
    Id?: boolean
    ApplicationId?: boolean
    AuthorizationId?: boolean
    ConcurrencyToken?: boolean
    CreationDate?: boolean
    ExpirationDate?: boolean
    Payload?: boolean
    Properties?: boolean
    RedemptionDate?: boolean
    ReferenceId?: boolean
    Status?: boolean
    Subject?: boolean
    Type?: boolean
    OIDCApplications?: boolean | OIDCApplicationsArgs
    OIDCAuthorizations?: boolean | OIDCAuthorizationsArgs
  }

  export type OIDCTokensInclude = {
    OIDCApplications?: boolean | OIDCApplicationsArgs
    OIDCAuthorizations?: boolean | OIDCAuthorizationsArgs
  }

  export type OIDCTokensGetPayload<
    S extends boolean | null | undefined | OIDCTokensArgs,
    U = keyof S
      > = S extends true
        ? OIDCTokens
    : S extends undefined
    ? never
    : S extends OIDCTokensArgs | OIDCTokensFindManyArgs
    ?'include' extends U
    ? OIDCTokens  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'OIDCApplications'
        ? OIDCApplicationsGetPayload<S['include'][P]> | null :
        P extends 'OIDCAuthorizations'
        ? OIDCAuthorizationsGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof OIDCTokens ?OIDCTokens [P]
  : 
          P extends 'OIDCApplications'
        ? OIDCApplicationsGetPayload<S['select'][P]> | null :
        P extends 'OIDCAuthorizations'
        ? OIDCAuthorizationsGetPayload<S['select'][P]> | null : never
  } 
    : OIDCTokens
  : OIDCTokens


  type OIDCTokensCountArgs = Merge<
    Omit<OIDCTokensFindManyArgs, 'select' | 'include'> & {
      select?: OIDCTokensCountAggregateInputType | true
    }
  >

  export interface OIDCTokensDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OIDCTokens that matches the filter.
     * @param {OIDCTokensFindUniqueArgs} args - Arguments to find a OIDCTokens
     * @example
     * // Get one OIDCTokens
     * const oIDCTokens = await prisma.oIDCTokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OIDCTokensFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OIDCTokensFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OIDCTokens'> extends True ? CheckSelect<T, Prisma__OIDCTokensClient<OIDCTokens>, Prisma__OIDCTokensClient<OIDCTokensGetPayload<T>>> : CheckSelect<T, Prisma__OIDCTokensClient<OIDCTokens | null >, Prisma__OIDCTokensClient<OIDCTokensGetPayload<T> | null >>

    /**
     * Find the first OIDCTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCTokensFindFirstArgs} args - Arguments to find a OIDCTokens
     * @example
     * // Get one OIDCTokens
     * const oIDCTokens = await prisma.oIDCTokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OIDCTokensFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OIDCTokensFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OIDCTokens'> extends True ? CheckSelect<T, Prisma__OIDCTokensClient<OIDCTokens>, Prisma__OIDCTokensClient<OIDCTokensGetPayload<T>>> : CheckSelect<T, Prisma__OIDCTokensClient<OIDCTokens | null >, Prisma__OIDCTokensClient<OIDCTokensGetPayload<T> | null >>

    /**
     * Find zero or more OIDCTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCTokensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OIDCTokens
     * const oIDCTokens = await prisma.oIDCTokens.findMany()
     * 
     * // Get first 10 OIDCTokens
     * const oIDCTokens = await prisma.oIDCTokens.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const oIDCTokensWithIdOnly = await prisma.oIDCTokens.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends OIDCTokensFindManyArgs>(
      args?: SelectSubset<T, OIDCTokensFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OIDCTokens>>, PrismaPromise<Array<OIDCTokensGetPayload<T>>>>

    /**
     * Create a OIDCTokens.
     * @param {OIDCTokensCreateArgs} args - Arguments to create a OIDCTokens.
     * @example
     * // Create one OIDCTokens
     * const OIDCTokens = await prisma.oIDCTokens.create({
     *   data: {
     *     // ... data to create a OIDCTokens
     *   }
     * })
     * 
    **/
    create<T extends OIDCTokensCreateArgs>(
      args: SelectSubset<T, OIDCTokensCreateArgs>
    ): CheckSelect<T, Prisma__OIDCTokensClient<OIDCTokens>, Prisma__OIDCTokensClient<OIDCTokensGetPayload<T>>>

    /**
     * Create many OIDCTokens.
     *     @param {OIDCTokensCreateManyArgs} args - Arguments to create many OIDCTokens.
     *     @example
     *     // Create many OIDCTokens
     *     const oIDCTokens = await prisma.oIDCTokens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OIDCTokensCreateManyArgs>(
      args?: SelectSubset<T, OIDCTokensCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OIDCTokens.
     * @param {OIDCTokensDeleteArgs} args - Arguments to delete one OIDCTokens.
     * @example
     * // Delete one OIDCTokens
     * const OIDCTokens = await prisma.oIDCTokens.delete({
     *   where: {
     *     // ... filter to delete one OIDCTokens
     *   }
     * })
     * 
    **/
    delete<T extends OIDCTokensDeleteArgs>(
      args: SelectSubset<T, OIDCTokensDeleteArgs>
    ): CheckSelect<T, Prisma__OIDCTokensClient<OIDCTokens>, Prisma__OIDCTokensClient<OIDCTokensGetPayload<T>>>

    /**
     * Update one OIDCTokens.
     * @param {OIDCTokensUpdateArgs} args - Arguments to update one OIDCTokens.
     * @example
     * // Update one OIDCTokens
     * const oIDCTokens = await prisma.oIDCTokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OIDCTokensUpdateArgs>(
      args: SelectSubset<T, OIDCTokensUpdateArgs>
    ): CheckSelect<T, Prisma__OIDCTokensClient<OIDCTokens>, Prisma__OIDCTokensClient<OIDCTokensGetPayload<T>>>

    /**
     * Delete zero or more OIDCTokens.
     * @param {OIDCTokensDeleteManyArgs} args - Arguments to filter OIDCTokens to delete.
     * @example
     * // Delete a few OIDCTokens
     * const { count } = await prisma.oIDCTokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OIDCTokensDeleteManyArgs>(
      args?: SelectSubset<T, OIDCTokensDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OIDCTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCTokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OIDCTokens
     * const oIDCTokens = await prisma.oIDCTokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OIDCTokensUpdateManyArgs>(
      args: SelectSubset<T, OIDCTokensUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OIDCTokens.
     * @param {OIDCTokensUpsertArgs} args - Arguments to update or create a OIDCTokens.
     * @example
     * // Update or create a OIDCTokens
     * const oIDCTokens = await prisma.oIDCTokens.upsert({
     *   create: {
     *     // ... data to create a OIDCTokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OIDCTokens we want to update
     *   }
     * })
    **/
    upsert<T extends OIDCTokensUpsertArgs>(
      args: SelectSubset<T, OIDCTokensUpsertArgs>
    ): CheckSelect<T, Prisma__OIDCTokensClient<OIDCTokens>, Prisma__OIDCTokensClient<OIDCTokensGetPayload<T>>>

    /**
     * Count the number of OIDCTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCTokensCountArgs} args - Arguments to filter OIDCTokens to count.
     * @example
     * // Count the number of OIDCTokens
     * const count = await prisma.oIDCTokens.count({
     *   where: {
     *     // ... the filter for the OIDCTokens we want to count
     *   }
     * })
    **/
    count<T extends OIDCTokensCountArgs>(
      args?: Subset<T, OIDCTokensCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OIDCTokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OIDCTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCTokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OIDCTokensAggregateArgs>(args: Subset<T, OIDCTokensAggregateArgs>): PrismaPromise<GetOIDCTokensAggregateType<T>>

    /**
     * Group by OIDCTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCTokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OIDCTokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OIDCTokensGroupByArgs['orderBy'] }
        : { orderBy?: OIDCTokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OIDCTokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOIDCTokensGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OIDCTokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OIDCTokensClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    OIDCApplications<T extends OIDCApplicationsArgs = {}>(args?: Subset<T, OIDCApplicationsArgs>): CheckSelect<T, Prisma__OIDCApplicationsClient<OIDCApplications | null >, Prisma__OIDCApplicationsClient<OIDCApplicationsGetPayload<T> | null >>;

    OIDCAuthorizations<T extends OIDCAuthorizationsArgs = {}>(args?: Subset<T, OIDCAuthorizationsArgs>): CheckSelect<T, Prisma__OIDCAuthorizationsClient<OIDCAuthorizations | null >, Prisma__OIDCAuthorizationsClient<OIDCAuthorizationsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OIDCTokens findUnique
   */
  export type OIDCTokensFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OIDCTokens
     * 
    **/
    select?: OIDCTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCTokensInclude | null
    /**
     * Throw an Error if a OIDCTokens can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OIDCTokens to fetch.
     * 
    **/
    where: OIDCTokensWhereUniqueInput
  }


  /**
   * OIDCTokens findFirst
   */
  export type OIDCTokensFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OIDCTokens
     * 
    **/
    select?: OIDCTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCTokensInclude | null
    /**
     * Throw an Error if a OIDCTokens can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OIDCTokens to fetch.
     * 
    **/
    where?: OIDCTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<OIDCTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OIDCTokens.
     * 
    **/
    cursor?: OIDCTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OIDCTokens.
     * 
    **/
    distinct?: Enumerable<OIDCTokensScalarFieldEnum>
  }


  /**
   * OIDCTokens findMany
   */
  export type OIDCTokensFindManyArgs = {
    /**
     * Select specific fields to fetch from the OIDCTokens
     * 
    **/
    select?: OIDCTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCTokensInclude | null
    /**
     * Filter, which OIDCTokens to fetch.
     * 
    **/
    where?: OIDCTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<OIDCTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OIDCTokens.
     * 
    **/
    cursor?: OIDCTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCTokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OIDCTokensScalarFieldEnum>
  }


  /**
   * OIDCTokens create
   */
  export type OIDCTokensCreateArgs = {
    /**
     * Select specific fields to fetch from the OIDCTokens
     * 
    **/
    select?: OIDCTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCTokensInclude | null
    /**
     * The data needed to create a OIDCTokens.
     * 
    **/
    data: XOR<OIDCTokensCreateInput, OIDCTokensUncheckedCreateInput>
  }


  /**
   * OIDCTokens createMany
   */
  export type OIDCTokensCreateManyArgs = {
    data: Enumerable<OIDCTokensCreateManyInput>
  }


  /**
   * OIDCTokens update
   */
  export type OIDCTokensUpdateArgs = {
    /**
     * Select specific fields to fetch from the OIDCTokens
     * 
    **/
    select?: OIDCTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCTokensInclude | null
    /**
     * The data needed to update a OIDCTokens.
     * 
    **/
    data: XOR<OIDCTokensUpdateInput, OIDCTokensUncheckedUpdateInput>
    /**
     * Choose, which OIDCTokens to update.
     * 
    **/
    where: OIDCTokensWhereUniqueInput
  }


  /**
   * OIDCTokens updateMany
   */
  export type OIDCTokensUpdateManyArgs = {
    data: XOR<OIDCTokensUpdateManyMutationInput, OIDCTokensUncheckedUpdateManyInput>
    where?: OIDCTokensWhereInput
  }


  /**
   * OIDCTokens upsert
   */
  export type OIDCTokensUpsertArgs = {
    /**
     * Select specific fields to fetch from the OIDCTokens
     * 
    **/
    select?: OIDCTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCTokensInclude | null
    /**
     * The filter to search for the OIDCTokens to update in case it exists.
     * 
    **/
    where: OIDCTokensWhereUniqueInput
    /**
     * In case the OIDCTokens found by the `where` argument doesn't exist, create a new OIDCTokens with this data.
     * 
    **/
    create: XOR<OIDCTokensCreateInput, OIDCTokensUncheckedCreateInput>
    /**
     * In case the OIDCTokens was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OIDCTokensUpdateInput, OIDCTokensUncheckedUpdateInput>
  }


  /**
   * OIDCTokens delete
   */
  export type OIDCTokensDeleteArgs = {
    /**
     * Select specific fields to fetch from the OIDCTokens
     * 
    **/
    select?: OIDCTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCTokensInclude | null
    /**
     * Filter which OIDCTokens to delete.
     * 
    **/
    where: OIDCTokensWhereUniqueInput
  }


  /**
   * OIDCTokens deleteMany
   */
  export type OIDCTokensDeleteManyArgs = {
    where?: OIDCTokensWhereInput
  }


  /**
   * OIDCTokens without action
   */
  export type OIDCTokensArgs = {
    /**
     * Select specific fields to fetch from the OIDCTokens
     * 
    **/
    select?: OIDCTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OIDCTokensInclude | null
  }



  /**
   * Model Profiles
   */


  export type AggregateProfiles = {
    _count: ProfilesCountAggregateOutputType | null
    _avg: ProfilesAvgAggregateOutputType | null
    _sum: ProfilesSumAggregateOutputType | null
    _min: ProfilesMinAggregateOutputType | null
    _max: ProfilesMaxAggregateOutputType | null
  }

  export type ProfilesAvgAggregateOutputType = {
    IsDefault: number | null
    IsEnabled: number | null
    EnableTechnologyGroup: number | null
    EnableInheritedGroup: number | null
    IncludeBaseAttributes: number | null
  }

  export type ProfilesSumAggregateOutputType = {
    IsDefault: number | null
    IsEnabled: number | null
    EnableTechnologyGroup: number | null
    EnableInheritedGroup: number | null
    IncludeBaseAttributes: number | null
  }

  export type ProfilesMinAggregateOutputType = {
    Id: string | null
    MDGTechnology_Id: string | null
    Name: string | null
    Description: string | null
    ProfileContent: string | null
    IsDefault: number | null
    IsEnabled: number | null
    Created: Date | null
    Modified: Date | null
    EnableTechnologyGroup: number | null
    EnableInheritedGroup: number | null
    IncludeBaseAttributes: number | null
  }

  export type ProfilesMaxAggregateOutputType = {
    Id: string | null
    MDGTechnology_Id: string | null
    Name: string | null
    Description: string | null
    ProfileContent: string | null
    IsDefault: number | null
    IsEnabled: number | null
    Created: Date | null
    Modified: Date | null
    EnableTechnologyGroup: number | null
    EnableInheritedGroup: number | null
    IncludeBaseAttributes: number | null
  }

  export type ProfilesCountAggregateOutputType = {
    Id: number
    MDGTechnology_Id: number
    Name: number
    Description: number
    ProfileContent: number
    IsDefault: number
    IsEnabled: number
    Created: number
    Modified: number
    EnableTechnologyGroup: number
    EnableInheritedGroup: number
    IncludeBaseAttributes: number
    _all: number
  }


  export type ProfilesAvgAggregateInputType = {
    IsDefault?: true
    IsEnabled?: true
    EnableTechnologyGroup?: true
    EnableInheritedGroup?: true
    IncludeBaseAttributes?: true
  }

  export type ProfilesSumAggregateInputType = {
    IsDefault?: true
    IsEnabled?: true
    EnableTechnologyGroup?: true
    EnableInheritedGroup?: true
    IncludeBaseAttributes?: true
  }

  export type ProfilesMinAggregateInputType = {
    Id?: true
    MDGTechnology_Id?: true
    Name?: true
    Description?: true
    ProfileContent?: true
    IsDefault?: true
    IsEnabled?: true
    Created?: true
    Modified?: true
    EnableTechnologyGroup?: true
    EnableInheritedGroup?: true
    IncludeBaseAttributes?: true
  }

  export type ProfilesMaxAggregateInputType = {
    Id?: true
    MDGTechnology_Id?: true
    Name?: true
    Description?: true
    ProfileContent?: true
    IsDefault?: true
    IsEnabled?: true
    Created?: true
    Modified?: true
    EnableTechnologyGroup?: true
    EnableInheritedGroup?: true
    IncludeBaseAttributes?: true
  }

  export type ProfilesCountAggregateInputType = {
    Id?: true
    MDGTechnology_Id?: true
    Name?: true
    Description?: true
    ProfileContent?: true
    IsDefault?: true
    IsEnabled?: true
    Created?: true
    Modified?: true
    EnableTechnologyGroup?: true
    EnableInheritedGroup?: true
    IncludeBaseAttributes?: true
    _all?: true
  }

  export type ProfilesAggregateArgs = {
    /**
     * Filter which Profiles to aggregate.
     * 
    **/
    where?: ProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfilesMaxAggregateInputType
  }

  export type GetProfilesAggregateType<T extends ProfilesAggregateArgs> = {
        [P in keyof T & keyof AggregateProfiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfiles[P]>
      : GetScalarType<T[P], AggregateProfiles[P]>
  }




  export type ProfilesGroupByArgs = {
    where?: ProfilesWhereInput
    orderBy?: Enumerable<ProfilesOrderByWithAggregationInput>
    by: Array<ProfilesScalarFieldEnum>
    having?: ProfilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfilesCountAggregateInputType | true
    _avg?: ProfilesAvgAggregateInputType
    _sum?: ProfilesSumAggregateInputType
    _min?: ProfilesMinAggregateInputType
    _max?: ProfilesMaxAggregateInputType
  }


  export type ProfilesGroupByOutputType = {
    Id: string
    MDGTechnology_Id: string
    Name: string
    Description: string | null
    ProfileContent: string | null
    IsDefault: number
    IsEnabled: number
    Created: Date
    Modified: Date
    EnableTechnologyGroup: number
    EnableInheritedGroup: number
    IncludeBaseAttributes: number
    _count: ProfilesCountAggregateOutputType | null
    _avg: ProfilesAvgAggregateOutputType | null
    _sum: ProfilesSumAggregateOutputType | null
    _min: ProfilesMinAggregateOutputType | null
    _max: ProfilesMaxAggregateOutputType | null
  }

  type GetProfilesGroupByPayload<T extends ProfilesGroupByArgs> = Promise<
    Array<
      PickArray<ProfilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfilesGroupByOutputType[P]>
            : GetScalarType<T[P], ProfilesGroupByOutputType[P]>
        }
      >
    >


  export type ProfilesSelect = {
    Id?: boolean
    MDGTechnology_Id?: boolean
    Name?: boolean
    Description?: boolean
    ProfileContent?: boolean
    IsDefault?: boolean
    IsEnabled?: boolean
    Created?: boolean
    Modified?: boolean
    EnableTechnologyGroup?: boolean
    EnableInheritedGroup?: boolean
    IncludeBaseAttributes?: boolean
  }

  export type ProfilesGetPayload<
    S extends boolean | null | undefined | ProfilesArgs,
    U = keyof S
      > = S extends true
        ? Profiles
    : S extends undefined
    ? never
    : S extends ProfilesArgs | ProfilesFindManyArgs
    ?'include' extends U
    ? Profiles 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Profiles ?Profiles [P]
  : 
     never
  } 
    : Profiles
  : Profiles


  type ProfilesCountArgs = Merge<
    Omit<ProfilesFindManyArgs, 'select' | 'include'> & {
      select?: ProfilesCountAggregateInputType | true
    }
  >

  export interface ProfilesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Profiles that matches the filter.
     * @param {ProfilesFindUniqueArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfilesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProfilesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Profiles'> extends True ? CheckSelect<T, Prisma__ProfilesClient<Profiles>, Prisma__ProfilesClient<ProfilesGetPayload<T>>> : CheckSelect<T, Prisma__ProfilesClient<Profiles | null >, Prisma__ProfilesClient<ProfilesGetPayload<T> | null >>

    /**
     * Find the first Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesFindFirstArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfilesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProfilesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Profiles'> extends True ? CheckSelect<T, Prisma__ProfilesClient<Profiles>, Prisma__ProfilesClient<ProfilesGetPayload<T>>> : CheckSelect<T, Prisma__ProfilesClient<Profiles | null >, Prisma__ProfilesClient<ProfilesGetPayload<T> | null >>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profiles.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profiles.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const profilesWithIdOnly = await prisma.profiles.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ProfilesFindManyArgs>(
      args?: SelectSubset<T, ProfilesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Profiles>>, PrismaPromise<Array<ProfilesGetPayload<T>>>>

    /**
     * Create a Profiles.
     * @param {ProfilesCreateArgs} args - Arguments to create a Profiles.
     * @example
     * // Create one Profiles
     * const Profiles = await prisma.profiles.create({
     *   data: {
     *     // ... data to create a Profiles
     *   }
     * })
     * 
    **/
    create<T extends ProfilesCreateArgs>(
      args: SelectSubset<T, ProfilesCreateArgs>
    ): CheckSelect<T, Prisma__ProfilesClient<Profiles>, Prisma__ProfilesClient<ProfilesGetPayload<T>>>

    /**
     * Create many Profiles.
     *     @param {ProfilesCreateManyArgs} args - Arguments to create many Profiles.
     *     @example
     *     // Create many Profiles
     *     const profiles = await prisma.profiles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProfilesCreateManyArgs>(
      args?: SelectSubset<T, ProfilesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Profiles.
     * @param {ProfilesDeleteArgs} args - Arguments to delete one Profiles.
     * @example
     * // Delete one Profiles
     * const Profiles = await prisma.profiles.delete({
     *   where: {
     *     // ... filter to delete one Profiles
     *   }
     * })
     * 
    **/
    delete<T extends ProfilesDeleteArgs>(
      args: SelectSubset<T, ProfilesDeleteArgs>
    ): CheckSelect<T, Prisma__ProfilesClient<Profiles>, Prisma__ProfilesClient<ProfilesGetPayload<T>>>

    /**
     * Update one Profiles.
     * @param {ProfilesUpdateArgs} args - Arguments to update one Profiles.
     * @example
     * // Update one Profiles
     * const profiles = await prisma.profiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfilesUpdateArgs>(
      args: SelectSubset<T, ProfilesUpdateArgs>
    ): CheckSelect<T, Prisma__ProfilesClient<Profiles>, Prisma__ProfilesClient<ProfilesGetPayload<T>>>

    /**
     * Delete zero or more Profiles.
     * @param {ProfilesDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfilesDeleteManyArgs>(
      args?: SelectSubset<T, ProfilesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profiles = await prisma.profiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfilesUpdateManyArgs>(
      args: SelectSubset<T, ProfilesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Profiles.
     * @param {ProfilesUpsertArgs} args - Arguments to update or create a Profiles.
     * @example
     * // Update or create a Profiles
     * const profiles = await prisma.profiles.upsert({
     *   create: {
     *     // ... data to create a Profiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profiles we want to update
     *   }
     * })
    **/
    upsert<T extends ProfilesUpsertArgs>(
      args: SelectSubset<T, ProfilesUpsertArgs>
    ): CheckSelect<T, Prisma__ProfilesClient<Profiles>, Prisma__ProfilesClient<ProfilesGetPayload<T>>>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profiles.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfilesCountArgs>(
      args?: Subset<T, ProfilesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfilesAggregateArgs>(args: Subset<T, ProfilesAggregateArgs>): PrismaPromise<GetProfilesAggregateType<T>>

    /**
     * Group by Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfilesGroupByArgs['orderBy'] }
        : { orderBy?: ProfilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfilesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProfilesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Profiles findUnique
   */
  export type ProfilesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Profiles
     * 
    **/
    select?: ProfilesSelect | null
    /**
     * Throw an Error if a Profiles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Profiles to fetch.
     * 
    **/
    where: ProfilesWhereUniqueInput
  }


  /**
   * Profiles findFirst
   */
  export type ProfilesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Profiles
     * 
    **/
    select?: ProfilesSelect | null
    /**
     * Throw an Error if a Profiles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Profiles to fetch.
     * 
    **/
    where?: ProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     * 
    **/
    cursor?: ProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     * 
    **/
    distinct?: Enumerable<ProfilesScalarFieldEnum>
  }


  /**
   * Profiles findMany
   */
  export type ProfilesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Profiles
     * 
    **/
    select?: ProfilesSelect | null
    /**
     * Filter, which Profiles to fetch.
     * 
    **/
    where?: ProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     * 
    **/
    cursor?: ProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProfilesScalarFieldEnum>
  }


  /**
   * Profiles create
   */
  export type ProfilesCreateArgs = {
    /**
     * Select specific fields to fetch from the Profiles
     * 
    **/
    select?: ProfilesSelect | null
    /**
     * The data needed to create a Profiles.
     * 
    **/
    data: XOR<ProfilesCreateInput, ProfilesUncheckedCreateInput>
  }


  /**
   * Profiles createMany
   */
  export type ProfilesCreateManyArgs = {
    data: Enumerable<ProfilesCreateManyInput>
  }


  /**
   * Profiles update
   */
  export type ProfilesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Profiles
     * 
    **/
    select?: ProfilesSelect | null
    /**
     * The data needed to update a Profiles.
     * 
    **/
    data: XOR<ProfilesUpdateInput, ProfilesUncheckedUpdateInput>
    /**
     * Choose, which Profiles to update.
     * 
    **/
    where: ProfilesWhereUniqueInput
  }


  /**
   * Profiles updateMany
   */
  export type ProfilesUpdateManyArgs = {
    data: XOR<ProfilesUpdateManyMutationInput, ProfilesUncheckedUpdateManyInput>
    where?: ProfilesWhereInput
  }


  /**
   * Profiles upsert
   */
  export type ProfilesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Profiles
     * 
    **/
    select?: ProfilesSelect | null
    /**
     * The filter to search for the Profiles to update in case it exists.
     * 
    **/
    where: ProfilesWhereUniqueInput
    /**
     * In case the Profiles found by the `where` argument doesn't exist, create a new Profiles with this data.
     * 
    **/
    create: XOR<ProfilesCreateInput, ProfilesUncheckedCreateInput>
    /**
     * In case the Profiles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProfilesUpdateInput, ProfilesUncheckedUpdateInput>
  }


  /**
   * Profiles delete
   */
  export type ProfilesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Profiles
     * 
    **/
    select?: ProfilesSelect | null
    /**
     * Filter which Profiles to delete.
     * 
    **/
    where: ProfilesWhereUniqueInput
  }


  /**
   * Profiles deleteMany
   */
  export type ProfilesDeleteManyArgs = {
    where?: ProfilesWhereInput
  }


  /**
   * Profiles without action
   */
  export type ProfilesArgs = {
    /**
     * Select specific fields to fetch from the Profiles
     * 
    **/
    select?: ProfilesSelect | null
  }



  /**
   * Model PropertyMenuItemConnectors
   */


  export type AggregatePropertyMenuItemConnectors = {
    _count: PropertyMenuItemConnectorsCountAggregateOutputType | null
    _min: PropertyMenuItemConnectorsMinAggregateOutputType | null
    _max: PropertyMenuItemConnectorsMaxAggregateOutputType | null
  }

  export type PropertyMenuItemConnectorsMinAggregateOutputType = {
    Id: string | null
    MenuItemKey: string | null
    PageType: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type PropertyMenuItemConnectorsMaxAggregateOutputType = {
    Id: string | null
    MenuItemKey: string | null
    PageType: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type PropertyMenuItemConnectorsCountAggregateOutputType = {
    Id: number
    MenuItemKey: number
    PageType: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type PropertyMenuItemConnectorsMinAggregateInputType = {
    Id?: true
    MenuItemKey?: true
    PageType?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type PropertyMenuItemConnectorsMaxAggregateInputType = {
    Id?: true
    MenuItemKey?: true
    PageType?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type PropertyMenuItemConnectorsCountAggregateInputType = {
    Id?: true
    MenuItemKey?: true
    PageType?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type PropertyMenuItemConnectorsAggregateArgs = {
    /**
     * Filter which PropertyMenuItemConnectors to aggregate.
     * 
    **/
    where?: PropertyMenuItemConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyMenuItemConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<PropertyMenuItemConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PropertyMenuItemConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyMenuItemConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyMenuItemConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyMenuItemConnectors
    **/
    _count?: true | PropertyMenuItemConnectorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMenuItemConnectorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMenuItemConnectorsMaxAggregateInputType
  }

  export type GetPropertyMenuItemConnectorsAggregateType<T extends PropertyMenuItemConnectorsAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyMenuItemConnectors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyMenuItemConnectors[P]>
      : GetScalarType<T[P], AggregatePropertyMenuItemConnectors[P]>
  }




  export type PropertyMenuItemConnectorsGroupByArgs = {
    where?: PropertyMenuItemConnectorsWhereInput
    orderBy?: Enumerable<PropertyMenuItemConnectorsOrderByWithAggregationInput>
    by: Array<PropertyMenuItemConnectorsScalarFieldEnum>
    having?: PropertyMenuItemConnectorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyMenuItemConnectorsCountAggregateInputType | true
    _min?: PropertyMenuItemConnectorsMinAggregateInputType
    _max?: PropertyMenuItemConnectorsMaxAggregateInputType
  }


  export type PropertyMenuItemConnectorsGroupByOutputType = {
    Id: string
    MenuItemKey: string | null
    PageType: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: PropertyMenuItemConnectorsCountAggregateOutputType | null
    _min: PropertyMenuItemConnectorsMinAggregateOutputType | null
    _max: PropertyMenuItemConnectorsMaxAggregateOutputType | null
  }

  type GetPropertyMenuItemConnectorsGroupByPayload<T extends PropertyMenuItemConnectorsGroupByArgs> = Promise<
    Array<
      PickArray<PropertyMenuItemConnectorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyMenuItemConnectorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyMenuItemConnectorsGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyMenuItemConnectorsGroupByOutputType[P]>
        }
      >
    >


  export type PropertyMenuItemConnectorsSelect = {
    Id?: boolean
    MenuItemKey?: boolean
    PageType?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type PropertyMenuItemConnectorsGetPayload<
    S extends boolean | null | undefined | PropertyMenuItemConnectorsArgs,
    U = keyof S
      > = S extends true
        ? PropertyMenuItemConnectors
    : S extends undefined
    ? never
    : S extends PropertyMenuItemConnectorsArgs | PropertyMenuItemConnectorsFindManyArgs
    ?'include' extends U
    ? PropertyMenuItemConnectors 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PropertyMenuItemConnectors ?PropertyMenuItemConnectors [P]
  : 
     never
  } 
    : PropertyMenuItemConnectors
  : PropertyMenuItemConnectors


  type PropertyMenuItemConnectorsCountArgs = Merge<
    Omit<PropertyMenuItemConnectorsFindManyArgs, 'select' | 'include'> & {
      select?: PropertyMenuItemConnectorsCountAggregateInputType | true
    }
  >

  export interface PropertyMenuItemConnectorsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PropertyMenuItemConnectors that matches the filter.
     * @param {PropertyMenuItemConnectorsFindUniqueArgs} args - Arguments to find a PropertyMenuItemConnectors
     * @example
     * // Get one PropertyMenuItemConnectors
     * const propertyMenuItemConnectors = await prisma.propertyMenuItemConnectors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyMenuItemConnectorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PropertyMenuItemConnectorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PropertyMenuItemConnectors'> extends True ? CheckSelect<T, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectors>, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectors | null >, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectorsGetPayload<T> | null >>

    /**
     * Find the first PropertyMenuItemConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyMenuItemConnectorsFindFirstArgs} args - Arguments to find a PropertyMenuItemConnectors
     * @example
     * // Get one PropertyMenuItemConnectors
     * const propertyMenuItemConnectors = await prisma.propertyMenuItemConnectors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyMenuItemConnectorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PropertyMenuItemConnectorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PropertyMenuItemConnectors'> extends True ? CheckSelect<T, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectors>, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectors | null >, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectorsGetPayload<T> | null >>

    /**
     * Find zero or more PropertyMenuItemConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyMenuItemConnectorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyMenuItemConnectors
     * const propertyMenuItemConnectors = await prisma.propertyMenuItemConnectors.findMany()
     * 
     * // Get first 10 PropertyMenuItemConnectors
     * const propertyMenuItemConnectors = await prisma.propertyMenuItemConnectors.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const propertyMenuItemConnectorsWithIdOnly = await prisma.propertyMenuItemConnectors.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends PropertyMenuItemConnectorsFindManyArgs>(
      args?: SelectSubset<T, PropertyMenuItemConnectorsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PropertyMenuItemConnectors>>, PrismaPromise<Array<PropertyMenuItemConnectorsGetPayload<T>>>>

    /**
     * Create a PropertyMenuItemConnectors.
     * @param {PropertyMenuItemConnectorsCreateArgs} args - Arguments to create a PropertyMenuItemConnectors.
     * @example
     * // Create one PropertyMenuItemConnectors
     * const PropertyMenuItemConnectors = await prisma.propertyMenuItemConnectors.create({
     *   data: {
     *     // ... data to create a PropertyMenuItemConnectors
     *   }
     * })
     * 
    **/
    create<T extends PropertyMenuItemConnectorsCreateArgs>(
      args: SelectSubset<T, PropertyMenuItemConnectorsCreateArgs>
    ): CheckSelect<T, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectors>, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectorsGetPayload<T>>>

    /**
     * Create many PropertyMenuItemConnectors.
     *     @param {PropertyMenuItemConnectorsCreateManyArgs} args - Arguments to create many PropertyMenuItemConnectors.
     *     @example
     *     // Create many PropertyMenuItemConnectors
     *     const propertyMenuItemConnectors = await prisma.propertyMenuItemConnectors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PropertyMenuItemConnectorsCreateManyArgs>(
      args?: SelectSubset<T, PropertyMenuItemConnectorsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PropertyMenuItemConnectors.
     * @param {PropertyMenuItemConnectorsDeleteArgs} args - Arguments to delete one PropertyMenuItemConnectors.
     * @example
     * // Delete one PropertyMenuItemConnectors
     * const PropertyMenuItemConnectors = await prisma.propertyMenuItemConnectors.delete({
     *   where: {
     *     // ... filter to delete one PropertyMenuItemConnectors
     *   }
     * })
     * 
    **/
    delete<T extends PropertyMenuItemConnectorsDeleteArgs>(
      args: SelectSubset<T, PropertyMenuItemConnectorsDeleteArgs>
    ): CheckSelect<T, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectors>, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectorsGetPayload<T>>>

    /**
     * Update one PropertyMenuItemConnectors.
     * @param {PropertyMenuItemConnectorsUpdateArgs} args - Arguments to update one PropertyMenuItemConnectors.
     * @example
     * // Update one PropertyMenuItemConnectors
     * const propertyMenuItemConnectors = await prisma.propertyMenuItemConnectors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyMenuItemConnectorsUpdateArgs>(
      args: SelectSubset<T, PropertyMenuItemConnectorsUpdateArgs>
    ): CheckSelect<T, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectors>, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectorsGetPayload<T>>>

    /**
     * Delete zero or more PropertyMenuItemConnectors.
     * @param {PropertyMenuItemConnectorsDeleteManyArgs} args - Arguments to filter PropertyMenuItemConnectors to delete.
     * @example
     * // Delete a few PropertyMenuItemConnectors
     * const { count } = await prisma.propertyMenuItemConnectors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyMenuItemConnectorsDeleteManyArgs>(
      args?: SelectSubset<T, PropertyMenuItemConnectorsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyMenuItemConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyMenuItemConnectorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyMenuItemConnectors
     * const propertyMenuItemConnectors = await prisma.propertyMenuItemConnectors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyMenuItemConnectorsUpdateManyArgs>(
      args: SelectSubset<T, PropertyMenuItemConnectorsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyMenuItemConnectors.
     * @param {PropertyMenuItemConnectorsUpsertArgs} args - Arguments to update or create a PropertyMenuItemConnectors.
     * @example
     * // Update or create a PropertyMenuItemConnectors
     * const propertyMenuItemConnectors = await prisma.propertyMenuItemConnectors.upsert({
     *   create: {
     *     // ... data to create a PropertyMenuItemConnectors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyMenuItemConnectors we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyMenuItemConnectorsUpsertArgs>(
      args: SelectSubset<T, PropertyMenuItemConnectorsUpsertArgs>
    ): CheckSelect<T, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectors>, Prisma__PropertyMenuItemConnectorsClient<PropertyMenuItemConnectorsGetPayload<T>>>

    /**
     * Count the number of PropertyMenuItemConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyMenuItemConnectorsCountArgs} args - Arguments to filter PropertyMenuItemConnectors to count.
     * @example
     * // Count the number of PropertyMenuItemConnectors
     * const count = await prisma.propertyMenuItemConnectors.count({
     *   where: {
     *     // ... the filter for the PropertyMenuItemConnectors we want to count
     *   }
     * })
    **/
    count<T extends PropertyMenuItemConnectorsCountArgs>(
      args?: Subset<T, PropertyMenuItemConnectorsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyMenuItemConnectorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyMenuItemConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyMenuItemConnectorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyMenuItemConnectorsAggregateArgs>(args: Subset<T, PropertyMenuItemConnectorsAggregateArgs>): PrismaPromise<GetPropertyMenuItemConnectorsAggregateType<T>>

    /**
     * Group by PropertyMenuItemConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyMenuItemConnectorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyMenuItemConnectorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyMenuItemConnectorsGroupByArgs['orderBy'] }
        : { orderBy?: PropertyMenuItemConnectorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyMenuItemConnectorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyMenuItemConnectorsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyMenuItemConnectors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PropertyMenuItemConnectorsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PropertyMenuItemConnectors findUnique
   */
  export type PropertyMenuItemConnectorsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItemConnectors
     * 
    **/
    select?: PropertyMenuItemConnectorsSelect | null
    /**
     * Throw an Error if a PropertyMenuItemConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyMenuItemConnectors to fetch.
     * 
    **/
    where: PropertyMenuItemConnectorsWhereUniqueInput
  }


  /**
   * PropertyMenuItemConnectors findFirst
   */
  export type PropertyMenuItemConnectorsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItemConnectors
     * 
    **/
    select?: PropertyMenuItemConnectorsSelect | null
    /**
     * Throw an Error if a PropertyMenuItemConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyMenuItemConnectors to fetch.
     * 
    **/
    where?: PropertyMenuItemConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyMenuItemConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<PropertyMenuItemConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyMenuItemConnectors.
     * 
    **/
    cursor?: PropertyMenuItemConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyMenuItemConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyMenuItemConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyMenuItemConnectors.
     * 
    **/
    distinct?: Enumerable<PropertyMenuItemConnectorsScalarFieldEnum>
  }


  /**
   * PropertyMenuItemConnectors findMany
   */
  export type PropertyMenuItemConnectorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItemConnectors
     * 
    **/
    select?: PropertyMenuItemConnectorsSelect | null
    /**
     * Filter, which PropertyMenuItemConnectors to fetch.
     * 
    **/
    where?: PropertyMenuItemConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyMenuItemConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<PropertyMenuItemConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyMenuItemConnectors.
     * 
    **/
    cursor?: PropertyMenuItemConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyMenuItemConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyMenuItemConnectors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PropertyMenuItemConnectorsScalarFieldEnum>
  }


  /**
   * PropertyMenuItemConnectors create
   */
  export type PropertyMenuItemConnectorsCreateArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItemConnectors
     * 
    **/
    select?: PropertyMenuItemConnectorsSelect | null
    /**
     * The data needed to create a PropertyMenuItemConnectors.
     * 
    **/
    data: XOR<PropertyMenuItemConnectorsCreateInput, PropertyMenuItemConnectorsUncheckedCreateInput>
  }


  /**
   * PropertyMenuItemConnectors createMany
   */
  export type PropertyMenuItemConnectorsCreateManyArgs = {
    data: Enumerable<PropertyMenuItemConnectorsCreateManyInput>
  }


  /**
   * PropertyMenuItemConnectors update
   */
  export type PropertyMenuItemConnectorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItemConnectors
     * 
    **/
    select?: PropertyMenuItemConnectorsSelect | null
    /**
     * The data needed to update a PropertyMenuItemConnectors.
     * 
    **/
    data: XOR<PropertyMenuItemConnectorsUpdateInput, PropertyMenuItemConnectorsUncheckedUpdateInput>
    /**
     * Choose, which PropertyMenuItemConnectors to update.
     * 
    **/
    where: PropertyMenuItemConnectorsWhereUniqueInput
  }


  /**
   * PropertyMenuItemConnectors updateMany
   */
  export type PropertyMenuItemConnectorsUpdateManyArgs = {
    data: XOR<PropertyMenuItemConnectorsUpdateManyMutationInput, PropertyMenuItemConnectorsUncheckedUpdateManyInput>
    where?: PropertyMenuItemConnectorsWhereInput
  }


  /**
   * PropertyMenuItemConnectors upsert
   */
  export type PropertyMenuItemConnectorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItemConnectors
     * 
    **/
    select?: PropertyMenuItemConnectorsSelect | null
    /**
     * The filter to search for the PropertyMenuItemConnectors to update in case it exists.
     * 
    **/
    where: PropertyMenuItemConnectorsWhereUniqueInput
    /**
     * In case the PropertyMenuItemConnectors found by the `where` argument doesn't exist, create a new PropertyMenuItemConnectors with this data.
     * 
    **/
    create: XOR<PropertyMenuItemConnectorsCreateInput, PropertyMenuItemConnectorsUncheckedCreateInput>
    /**
     * In case the PropertyMenuItemConnectors was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PropertyMenuItemConnectorsUpdateInput, PropertyMenuItemConnectorsUncheckedUpdateInput>
  }


  /**
   * PropertyMenuItemConnectors delete
   */
  export type PropertyMenuItemConnectorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItemConnectors
     * 
    **/
    select?: PropertyMenuItemConnectorsSelect | null
    /**
     * Filter which PropertyMenuItemConnectors to delete.
     * 
    **/
    where: PropertyMenuItemConnectorsWhereUniqueInput
  }


  /**
   * PropertyMenuItemConnectors deleteMany
   */
  export type PropertyMenuItemConnectorsDeleteManyArgs = {
    where?: PropertyMenuItemConnectorsWhereInput
  }


  /**
   * PropertyMenuItemConnectors without action
   */
  export type PropertyMenuItemConnectorsArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItemConnectors
     * 
    **/
    select?: PropertyMenuItemConnectorsSelect | null
  }



  /**
   * Model PropertyMenuItems
   */


  export type AggregatePropertyMenuItems = {
    _count: PropertyMenuItemsCountAggregateOutputType | null
    _avg: PropertyMenuItemsAvgAggregateOutputType | null
    _sum: PropertyMenuItemsSumAggregateOutputType | null
    _min: PropertyMenuItemsMinAggregateOutputType | null
    _max: PropertyMenuItemsMaxAggregateOutputType | null
  }

  export type PropertyMenuItemsAvgAggregateOutputType = {
    Position: number | null
    Status: number | null
  }

  export type PropertyMenuItemsSumAggregateOutputType = {
    Position: number | null
    Status: number | null
  }

  export type PropertyMenuItemsMinAggregateOutputType = {
    Id: string | null
    MenuItemKey: string | null
    Name: string | null
    Description: string | null
    IconClass: string | null
    Position: number | null
    Status: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type PropertyMenuItemsMaxAggregateOutputType = {
    Id: string | null
    MenuItemKey: string | null
    Name: string | null
    Description: string | null
    IconClass: string | null
    Position: number | null
    Status: number | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type PropertyMenuItemsCountAggregateOutputType = {
    Id: number
    MenuItemKey: number
    Name: number
    Description: number
    IconClass: number
    Position: number
    Status: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type PropertyMenuItemsAvgAggregateInputType = {
    Position?: true
    Status?: true
  }

  export type PropertyMenuItemsSumAggregateInputType = {
    Position?: true
    Status?: true
  }

  export type PropertyMenuItemsMinAggregateInputType = {
    Id?: true
    MenuItemKey?: true
    Name?: true
    Description?: true
    IconClass?: true
    Position?: true
    Status?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type PropertyMenuItemsMaxAggregateInputType = {
    Id?: true
    MenuItemKey?: true
    Name?: true
    Description?: true
    IconClass?: true
    Position?: true
    Status?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type PropertyMenuItemsCountAggregateInputType = {
    Id?: true
    MenuItemKey?: true
    Name?: true
    Description?: true
    IconClass?: true
    Position?: true
    Status?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type PropertyMenuItemsAggregateArgs = {
    /**
     * Filter which PropertyMenuItems to aggregate.
     * 
    **/
    where?: PropertyMenuItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyMenuItems to fetch.
     * 
    **/
    orderBy?: Enumerable<PropertyMenuItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PropertyMenuItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyMenuItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyMenuItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyMenuItems
    **/
    _count?: true | PropertyMenuItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyMenuItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyMenuItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMenuItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMenuItemsMaxAggregateInputType
  }

  export type GetPropertyMenuItemsAggregateType<T extends PropertyMenuItemsAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyMenuItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyMenuItems[P]>
      : GetScalarType<T[P], AggregatePropertyMenuItems[P]>
  }




  export type PropertyMenuItemsGroupByArgs = {
    where?: PropertyMenuItemsWhereInput
    orderBy?: Enumerable<PropertyMenuItemsOrderByWithAggregationInput>
    by: Array<PropertyMenuItemsScalarFieldEnum>
    having?: PropertyMenuItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyMenuItemsCountAggregateInputType | true
    _avg?: PropertyMenuItemsAvgAggregateInputType
    _sum?: PropertyMenuItemsSumAggregateInputType
    _min?: PropertyMenuItemsMinAggregateInputType
    _max?: PropertyMenuItemsMaxAggregateInputType
  }


  export type PropertyMenuItemsGroupByOutputType = {
    Id: string
    MenuItemKey: string | null
    Name: string | null
    Description: string | null
    IconClass: string
    Position: number
    Status: number
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: PropertyMenuItemsCountAggregateOutputType | null
    _avg: PropertyMenuItemsAvgAggregateOutputType | null
    _sum: PropertyMenuItemsSumAggregateOutputType | null
    _min: PropertyMenuItemsMinAggregateOutputType | null
    _max: PropertyMenuItemsMaxAggregateOutputType | null
  }

  type GetPropertyMenuItemsGroupByPayload<T extends PropertyMenuItemsGroupByArgs> = Promise<
    Array<
      PickArray<PropertyMenuItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyMenuItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyMenuItemsGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyMenuItemsGroupByOutputType[P]>
        }
      >
    >


  export type PropertyMenuItemsSelect = {
    Id?: boolean
    MenuItemKey?: boolean
    Name?: boolean
    Description?: boolean
    IconClass?: boolean
    Position?: boolean
    Status?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type PropertyMenuItemsGetPayload<
    S extends boolean | null | undefined | PropertyMenuItemsArgs,
    U = keyof S
      > = S extends true
        ? PropertyMenuItems
    : S extends undefined
    ? never
    : S extends PropertyMenuItemsArgs | PropertyMenuItemsFindManyArgs
    ?'include' extends U
    ? PropertyMenuItems 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PropertyMenuItems ?PropertyMenuItems [P]
  : 
     never
  } 
    : PropertyMenuItems
  : PropertyMenuItems


  type PropertyMenuItemsCountArgs = Merge<
    Omit<PropertyMenuItemsFindManyArgs, 'select' | 'include'> & {
      select?: PropertyMenuItemsCountAggregateInputType | true
    }
  >

  export interface PropertyMenuItemsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PropertyMenuItems that matches the filter.
     * @param {PropertyMenuItemsFindUniqueArgs} args - Arguments to find a PropertyMenuItems
     * @example
     * // Get one PropertyMenuItems
     * const propertyMenuItems = await prisma.propertyMenuItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyMenuItemsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PropertyMenuItemsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PropertyMenuItems'> extends True ? CheckSelect<T, Prisma__PropertyMenuItemsClient<PropertyMenuItems>, Prisma__PropertyMenuItemsClient<PropertyMenuItemsGetPayload<T>>> : CheckSelect<T, Prisma__PropertyMenuItemsClient<PropertyMenuItems | null >, Prisma__PropertyMenuItemsClient<PropertyMenuItemsGetPayload<T> | null >>

    /**
     * Find the first PropertyMenuItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyMenuItemsFindFirstArgs} args - Arguments to find a PropertyMenuItems
     * @example
     * // Get one PropertyMenuItems
     * const propertyMenuItems = await prisma.propertyMenuItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyMenuItemsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PropertyMenuItemsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PropertyMenuItems'> extends True ? CheckSelect<T, Prisma__PropertyMenuItemsClient<PropertyMenuItems>, Prisma__PropertyMenuItemsClient<PropertyMenuItemsGetPayload<T>>> : CheckSelect<T, Prisma__PropertyMenuItemsClient<PropertyMenuItems | null >, Prisma__PropertyMenuItemsClient<PropertyMenuItemsGetPayload<T> | null >>

    /**
     * Find zero or more PropertyMenuItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyMenuItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyMenuItems
     * const propertyMenuItems = await prisma.propertyMenuItems.findMany()
     * 
     * // Get first 10 PropertyMenuItems
     * const propertyMenuItems = await prisma.propertyMenuItems.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const propertyMenuItemsWithIdOnly = await prisma.propertyMenuItems.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends PropertyMenuItemsFindManyArgs>(
      args?: SelectSubset<T, PropertyMenuItemsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PropertyMenuItems>>, PrismaPromise<Array<PropertyMenuItemsGetPayload<T>>>>

    /**
     * Create a PropertyMenuItems.
     * @param {PropertyMenuItemsCreateArgs} args - Arguments to create a PropertyMenuItems.
     * @example
     * // Create one PropertyMenuItems
     * const PropertyMenuItems = await prisma.propertyMenuItems.create({
     *   data: {
     *     // ... data to create a PropertyMenuItems
     *   }
     * })
     * 
    **/
    create<T extends PropertyMenuItemsCreateArgs>(
      args: SelectSubset<T, PropertyMenuItemsCreateArgs>
    ): CheckSelect<T, Prisma__PropertyMenuItemsClient<PropertyMenuItems>, Prisma__PropertyMenuItemsClient<PropertyMenuItemsGetPayload<T>>>

    /**
     * Create many PropertyMenuItems.
     *     @param {PropertyMenuItemsCreateManyArgs} args - Arguments to create many PropertyMenuItems.
     *     @example
     *     // Create many PropertyMenuItems
     *     const propertyMenuItems = await prisma.propertyMenuItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PropertyMenuItemsCreateManyArgs>(
      args?: SelectSubset<T, PropertyMenuItemsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PropertyMenuItems.
     * @param {PropertyMenuItemsDeleteArgs} args - Arguments to delete one PropertyMenuItems.
     * @example
     * // Delete one PropertyMenuItems
     * const PropertyMenuItems = await prisma.propertyMenuItems.delete({
     *   where: {
     *     // ... filter to delete one PropertyMenuItems
     *   }
     * })
     * 
    **/
    delete<T extends PropertyMenuItemsDeleteArgs>(
      args: SelectSubset<T, PropertyMenuItemsDeleteArgs>
    ): CheckSelect<T, Prisma__PropertyMenuItemsClient<PropertyMenuItems>, Prisma__PropertyMenuItemsClient<PropertyMenuItemsGetPayload<T>>>

    /**
     * Update one PropertyMenuItems.
     * @param {PropertyMenuItemsUpdateArgs} args - Arguments to update one PropertyMenuItems.
     * @example
     * // Update one PropertyMenuItems
     * const propertyMenuItems = await prisma.propertyMenuItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyMenuItemsUpdateArgs>(
      args: SelectSubset<T, PropertyMenuItemsUpdateArgs>
    ): CheckSelect<T, Prisma__PropertyMenuItemsClient<PropertyMenuItems>, Prisma__PropertyMenuItemsClient<PropertyMenuItemsGetPayload<T>>>

    /**
     * Delete zero or more PropertyMenuItems.
     * @param {PropertyMenuItemsDeleteManyArgs} args - Arguments to filter PropertyMenuItems to delete.
     * @example
     * // Delete a few PropertyMenuItems
     * const { count } = await prisma.propertyMenuItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyMenuItemsDeleteManyArgs>(
      args?: SelectSubset<T, PropertyMenuItemsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyMenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyMenuItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyMenuItems
     * const propertyMenuItems = await prisma.propertyMenuItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyMenuItemsUpdateManyArgs>(
      args: SelectSubset<T, PropertyMenuItemsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyMenuItems.
     * @param {PropertyMenuItemsUpsertArgs} args - Arguments to update or create a PropertyMenuItems.
     * @example
     * // Update or create a PropertyMenuItems
     * const propertyMenuItems = await prisma.propertyMenuItems.upsert({
     *   create: {
     *     // ... data to create a PropertyMenuItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyMenuItems we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyMenuItemsUpsertArgs>(
      args: SelectSubset<T, PropertyMenuItemsUpsertArgs>
    ): CheckSelect<T, Prisma__PropertyMenuItemsClient<PropertyMenuItems>, Prisma__PropertyMenuItemsClient<PropertyMenuItemsGetPayload<T>>>

    /**
     * Count the number of PropertyMenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyMenuItemsCountArgs} args - Arguments to filter PropertyMenuItems to count.
     * @example
     * // Count the number of PropertyMenuItems
     * const count = await prisma.propertyMenuItems.count({
     *   where: {
     *     // ... the filter for the PropertyMenuItems we want to count
     *   }
     * })
    **/
    count<T extends PropertyMenuItemsCountArgs>(
      args?: Subset<T, PropertyMenuItemsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyMenuItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyMenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyMenuItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyMenuItemsAggregateArgs>(args: Subset<T, PropertyMenuItemsAggregateArgs>): PrismaPromise<GetPropertyMenuItemsAggregateType<T>>

    /**
     * Group by PropertyMenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyMenuItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyMenuItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyMenuItemsGroupByArgs['orderBy'] }
        : { orderBy?: PropertyMenuItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyMenuItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyMenuItemsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyMenuItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PropertyMenuItemsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PropertyMenuItems findUnique
   */
  export type PropertyMenuItemsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItems
     * 
    **/
    select?: PropertyMenuItemsSelect | null
    /**
     * Throw an Error if a PropertyMenuItems can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyMenuItems to fetch.
     * 
    **/
    where: PropertyMenuItemsWhereUniqueInput
  }


  /**
   * PropertyMenuItems findFirst
   */
  export type PropertyMenuItemsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItems
     * 
    **/
    select?: PropertyMenuItemsSelect | null
    /**
     * Throw an Error if a PropertyMenuItems can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyMenuItems to fetch.
     * 
    **/
    where?: PropertyMenuItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyMenuItems to fetch.
     * 
    **/
    orderBy?: Enumerable<PropertyMenuItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyMenuItems.
     * 
    **/
    cursor?: PropertyMenuItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyMenuItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyMenuItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyMenuItems.
     * 
    **/
    distinct?: Enumerable<PropertyMenuItemsScalarFieldEnum>
  }


  /**
   * PropertyMenuItems findMany
   */
  export type PropertyMenuItemsFindManyArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItems
     * 
    **/
    select?: PropertyMenuItemsSelect | null
    /**
     * Filter, which PropertyMenuItems to fetch.
     * 
    **/
    where?: PropertyMenuItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyMenuItems to fetch.
     * 
    **/
    orderBy?: Enumerable<PropertyMenuItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyMenuItems.
     * 
    **/
    cursor?: PropertyMenuItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyMenuItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyMenuItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PropertyMenuItemsScalarFieldEnum>
  }


  /**
   * PropertyMenuItems create
   */
  export type PropertyMenuItemsCreateArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItems
     * 
    **/
    select?: PropertyMenuItemsSelect | null
    /**
     * The data needed to create a PropertyMenuItems.
     * 
    **/
    data: XOR<PropertyMenuItemsCreateInput, PropertyMenuItemsUncheckedCreateInput>
  }


  /**
   * PropertyMenuItems createMany
   */
  export type PropertyMenuItemsCreateManyArgs = {
    data: Enumerable<PropertyMenuItemsCreateManyInput>
  }


  /**
   * PropertyMenuItems update
   */
  export type PropertyMenuItemsUpdateArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItems
     * 
    **/
    select?: PropertyMenuItemsSelect | null
    /**
     * The data needed to update a PropertyMenuItems.
     * 
    **/
    data: XOR<PropertyMenuItemsUpdateInput, PropertyMenuItemsUncheckedUpdateInput>
    /**
     * Choose, which PropertyMenuItems to update.
     * 
    **/
    where: PropertyMenuItemsWhereUniqueInput
  }


  /**
   * PropertyMenuItems updateMany
   */
  export type PropertyMenuItemsUpdateManyArgs = {
    data: XOR<PropertyMenuItemsUpdateManyMutationInput, PropertyMenuItemsUncheckedUpdateManyInput>
    where?: PropertyMenuItemsWhereInput
  }


  /**
   * PropertyMenuItems upsert
   */
  export type PropertyMenuItemsUpsertArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItems
     * 
    **/
    select?: PropertyMenuItemsSelect | null
    /**
     * The filter to search for the PropertyMenuItems to update in case it exists.
     * 
    **/
    where: PropertyMenuItemsWhereUniqueInput
    /**
     * In case the PropertyMenuItems found by the `where` argument doesn't exist, create a new PropertyMenuItems with this data.
     * 
    **/
    create: XOR<PropertyMenuItemsCreateInput, PropertyMenuItemsUncheckedCreateInput>
    /**
     * In case the PropertyMenuItems was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PropertyMenuItemsUpdateInput, PropertyMenuItemsUncheckedUpdateInput>
  }


  /**
   * PropertyMenuItems delete
   */
  export type PropertyMenuItemsDeleteArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItems
     * 
    **/
    select?: PropertyMenuItemsSelect | null
    /**
     * Filter which PropertyMenuItems to delete.
     * 
    **/
    where: PropertyMenuItemsWhereUniqueInput
  }


  /**
   * PropertyMenuItems deleteMany
   */
  export type PropertyMenuItemsDeleteManyArgs = {
    where?: PropertyMenuItemsWhereInput
  }


  /**
   * PropertyMenuItems without action
   */
  export type PropertyMenuItemsArgs = {
    /**
     * Select specific fields to fetch from the PropertyMenuItems
     * 
    **/
    select?: PropertyMenuItemsSelect | null
  }



  /**
   * Model Repositories
   */


  export type AggregateRepositories = {
    _count: RepositoriesCountAggregateOutputType | null
    _avg: RepositoriesAvgAggregateOutputType | null
    _sum: RepositoriesSumAggregateOutputType | null
    _min: RepositoriesMinAggregateOutputType | null
    _max: RepositoriesMaxAggregateOutputType | null
  }

  export type RepositoriesAvgAggregateOutputType = {
    IsCacheEnabled: number | null
    AuthRequired: number | null
    IsEnabled: number | null
    InstanceCount: number | null
    EAUserAuth: number | null
    DBType: number | null
  }

  export type RepositoriesSumAggregateOutputType = {
    IsCacheEnabled: number | null
    AuthRequired: number | null
    IsEnabled: number | null
    InstanceCount: number | null
    EAUserAuth: number | null
    DBType: number | null
  }

  export type RepositoriesMinAggregateOutputType = {
    Id: string | null
    Name: string | null
    Alias: string | null
    Description: string | null
    EAPFile: string | null
    IsCacheEnabled: number | null
    AuthRequired: number | null
    UserName: string | null
    Password: string | null
    IsEnabled: number | null
    InstanceCount: number | null
    Created: Date | null
    Modified: Date | null
    Status: string | null
    Protocol: string | null
    Server: string | null
    Port: string | null
    Model: string | null
    OslcAccessCode: string | null
    EAUserAuth: number | null
    UserIdentifier: string | null
    DBType: number | null
  }

  export type RepositoriesMaxAggregateOutputType = {
    Id: string | null
    Name: string | null
    Alias: string | null
    Description: string | null
    EAPFile: string | null
    IsCacheEnabled: number | null
    AuthRequired: number | null
    UserName: string | null
    Password: string | null
    IsEnabled: number | null
    InstanceCount: number | null
    Created: Date | null
    Modified: Date | null
    Status: string | null
    Protocol: string | null
    Server: string | null
    Port: string | null
    Model: string | null
    OslcAccessCode: string | null
    EAUserAuth: number | null
    UserIdentifier: string | null
    DBType: number | null
  }

  export type RepositoriesCountAggregateOutputType = {
    Id: number
    Name: number
    Alias: number
    Description: number
    EAPFile: number
    IsCacheEnabled: number
    AuthRequired: number
    UserName: number
    Password: number
    IsEnabled: number
    InstanceCount: number
    Created: number
    Modified: number
    Status: number
    Protocol: number
    Server: number
    Port: number
    Model: number
    OslcAccessCode: number
    EAUserAuth: number
    UserIdentifier: number
    DBType: number
    _all: number
  }


  export type RepositoriesAvgAggregateInputType = {
    IsCacheEnabled?: true
    AuthRequired?: true
    IsEnabled?: true
    InstanceCount?: true
    EAUserAuth?: true
    DBType?: true
  }

  export type RepositoriesSumAggregateInputType = {
    IsCacheEnabled?: true
    AuthRequired?: true
    IsEnabled?: true
    InstanceCount?: true
    EAUserAuth?: true
    DBType?: true
  }

  export type RepositoriesMinAggregateInputType = {
    Id?: true
    Name?: true
    Alias?: true
    Description?: true
    EAPFile?: true
    IsCacheEnabled?: true
    AuthRequired?: true
    UserName?: true
    Password?: true
    IsEnabled?: true
    InstanceCount?: true
    Created?: true
    Modified?: true
    Status?: true
    Protocol?: true
    Server?: true
    Port?: true
    Model?: true
    OslcAccessCode?: true
    EAUserAuth?: true
    UserIdentifier?: true
    DBType?: true
  }

  export type RepositoriesMaxAggregateInputType = {
    Id?: true
    Name?: true
    Alias?: true
    Description?: true
    EAPFile?: true
    IsCacheEnabled?: true
    AuthRequired?: true
    UserName?: true
    Password?: true
    IsEnabled?: true
    InstanceCount?: true
    Created?: true
    Modified?: true
    Status?: true
    Protocol?: true
    Server?: true
    Port?: true
    Model?: true
    OslcAccessCode?: true
    EAUserAuth?: true
    UserIdentifier?: true
    DBType?: true
  }

  export type RepositoriesCountAggregateInputType = {
    Id?: true
    Name?: true
    Alias?: true
    Description?: true
    EAPFile?: true
    IsCacheEnabled?: true
    AuthRequired?: true
    UserName?: true
    Password?: true
    IsEnabled?: true
    InstanceCount?: true
    Created?: true
    Modified?: true
    Status?: true
    Protocol?: true
    Server?: true
    Port?: true
    Model?: true
    OslcAccessCode?: true
    EAUserAuth?: true
    UserIdentifier?: true
    DBType?: true
    _all?: true
  }

  export type RepositoriesAggregateArgs = {
    /**
     * Filter which Repositories to aggregate.
     * 
    **/
    where?: RepositoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repositories to fetch.
     * 
    **/
    orderBy?: Enumerable<RepositoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RepositoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repositories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repositories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Repositories
    **/
    _count?: true | RepositoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepositoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepositoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepositoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepositoriesMaxAggregateInputType
  }

  export type GetRepositoriesAggregateType<T extends RepositoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateRepositories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepositories[P]>
      : GetScalarType<T[P], AggregateRepositories[P]>
  }




  export type RepositoriesGroupByArgs = {
    where?: RepositoriesWhereInput
    orderBy?: Enumerable<RepositoriesOrderByWithAggregationInput>
    by: Array<RepositoriesScalarFieldEnum>
    having?: RepositoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepositoriesCountAggregateInputType | true
    _avg?: RepositoriesAvgAggregateInputType
    _sum?: RepositoriesSumAggregateInputType
    _min?: RepositoriesMinAggregateInputType
    _max?: RepositoriesMaxAggregateInputType
  }


  export type RepositoriesGroupByOutputType = {
    Id: string
    Name: string | null
    Alias: string | null
    Description: string | null
    EAPFile: string | null
    IsCacheEnabled: number | null
    AuthRequired: number | null
    UserName: string | null
    Password: string | null
    IsEnabled: number | null
    InstanceCount: number | null
    Created: Date
    Modified: Date
    Status: string | null
    Protocol: string | null
    Server: string | null
    Port: string | null
    Model: string | null
    OslcAccessCode: string | null
    EAUserAuth: number | null
    UserIdentifier: string | null
    DBType: number | null
    _count: RepositoriesCountAggregateOutputType | null
    _avg: RepositoriesAvgAggregateOutputType | null
    _sum: RepositoriesSumAggregateOutputType | null
    _min: RepositoriesMinAggregateOutputType | null
    _max: RepositoriesMaxAggregateOutputType | null
  }

  type GetRepositoriesGroupByPayload<T extends RepositoriesGroupByArgs> = Promise<
    Array<
      PickArray<RepositoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepositoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepositoriesGroupByOutputType[P]>
            : GetScalarType<T[P], RepositoriesGroupByOutputType[P]>
        }
      >
    >


  export type RepositoriesSelect = {
    Id?: boolean
    Name?: boolean
    Alias?: boolean
    Description?: boolean
    EAPFile?: boolean
    IsCacheEnabled?: boolean
    AuthRequired?: boolean
    UserName?: boolean
    Password?: boolean
    IsEnabled?: boolean
    InstanceCount?: boolean
    Created?: boolean
    Modified?: boolean
    Status?: boolean
    Protocol?: boolean
    Server?: boolean
    Port?: boolean
    Model?: boolean
    OslcAccessCode?: boolean
    EAUserAuth?: boolean
    UserIdentifier?: boolean
    DBType?: boolean
  }

  export type RepositoriesGetPayload<
    S extends boolean | null | undefined | RepositoriesArgs,
    U = keyof S
      > = S extends true
        ? Repositories
    : S extends undefined
    ? never
    : S extends RepositoriesArgs | RepositoriesFindManyArgs
    ?'include' extends U
    ? Repositories 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Repositories ?Repositories [P]
  : 
     never
  } 
    : Repositories
  : Repositories


  type RepositoriesCountArgs = Merge<
    Omit<RepositoriesFindManyArgs, 'select' | 'include'> & {
      select?: RepositoriesCountAggregateInputType | true
    }
  >

  export interface RepositoriesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Repositories that matches the filter.
     * @param {RepositoriesFindUniqueArgs} args - Arguments to find a Repositories
     * @example
     * // Get one Repositories
     * const repositories = await prisma.repositories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RepositoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RepositoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Repositories'> extends True ? CheckSelect<T, Prisma__RepositoriesClient<Repositories>, Prisma__RepositoriesClient<RepositoriesGetPayload<T>>> : CheckSelect<T, Prisma__RepositoriesClient<Repositories | null >, Prisma__RepositoriesClient<RepositoriesGetPayload<T> | null >>

    /**
     * Find the first Repositories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoriesFindFirstArgs} args - Arguments to find a Repositories
     * @example
     * // Get one Repositories
     * const repositories = await prisma.repositories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RepositoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RepositoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Repositories'> extends True ? CheckSelect<T, Prisma__RepositoriesClient<Repositories>, Prisma__RepositoriesClient<RepositoriesGetPayload<T>>> : CheckSelect<T, Prisma__RepositoriesClient<Repositories | null >, Prisma__RepositoriesClient<RepositoriesGetPayload<T> | null >>

    /**
     * Find zero or more Repositories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Repositories
     * const repositories = await prisma.repositories.findMany()
     * 
     * // Get first 10 Repositories
     * const repositories = await prisma.repositories.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const repositoriesWithIdOnly = await prisma.repositories.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends RepositoriesFindManyArgs>(
      args?: SelectSubset<T, RepositoriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Repositories>>, PrismaPromise<Array<RepositoriesGetPayload<T>>>>

    /**
     * Create a Repositories.
     * @param {RepositoriesCreateArgs} args - Arguments to create a Repositories.
     * @example
     * // Create one Repositories
     * const Repositories = await prisma.repositories.create({
     *   data: {
     *     // ... data to create a Repositories
     *   }
     * })
     * 
    **/
    create<T extends RepositoriesCreateArgs>(
      args: SelectSubset<T, RepositoriesCreateArgs>
    ): CheckSelect<T, Prisma__RepositoriesClient<Repositories>, Prisma__RepositoriesClient<RepositoriesGetPayload<T>>>

    /**
     * Create many Repositories.
     *     @param {RepositoriesCreateManyArgs} args - Arguments to create many Repositories.
     *     @example
     *     // Create many Repositories
     *     const repositories = await prisma.repositories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RepositoriesCreateManyArgs>(
      args?: SelectSubset<T, RepositoriesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Repositories.
     * @param {RepositoriesDeleteArgs} args - Arguments to delete one Repositories.
     * @example
     * // Delete one Repositories
     * const Repositories = await prisma.repositories.delete({
     *   where: {
     *     // ... filter to delete one Repositories
     *   }
     * })
     * 
    **/
    delete<T extends RepositoriesDeleteArgs>(
      args: SelectSubset<T, RepositoriesDeleteArgs>
    ): CheckSelect<T, Prisma__RepositoriesClient<Repositories>, Prisma__RepositoriesClient<RepositoriesGetPayload<T>>>

    /**
     * Update one Repositories.
     * @param {RepositoriesUpdateArgs} args - Arguments to update one Repositories.
     * @example
     * // Update one Repositories
     * const repositories = await prisma.repositories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RepositoriesUpdateArgs>(
      args: SelectSubset<T, RepositoriesUpdateArgs>
    ): CheckSelect<T, Prisma__RepositoriesClient<Repositories>, Prisma__RepositoriesClient<RepositoriesGetPayload<T>>>

    /**
     * Delete zero or more Repositories.
     * @param {RepositoriesDeleteManyArgs} args - Arguments to filter Repositories to delete.
     * @example
     * // Delete a few Repositories
     * const { count } = await prisma.repositories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RepositoriesDeleteManyArgs>(
      args?: SelectSubset<T, RepositoriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Repositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Repositories
     * const repositories = await prisma.repositories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RepositoriesUpdateManyArgs>(
      args: SelectSubset<T, RepositoriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Repositories.
     * @param {RepositoriesUpsertArgs} args - Arguments to update or create a Repositories.
     * @example
     * // Update or create a Repositories
     * const repositories = await prisma.repositories.upsert({
     *   create: {
     *     // ... data to create a Repositories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Repositories we want to update
     *   }
     * })
    **/
    upsert<T extends RepositoriesUpsertArgs>(
      args: SelectSubset<T, RepositoriesUpsertArgs>
    ): CheckSelect<T, Prisma__RepositoriesClient<Repositories>, Prisma__RepositoriesClient<RepositoriesGetPayload<T>>>

    /**
     * Count the number of Repositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoriesCountArgs} args - Arguments to filter Repositories to count.
     * @example
     * // Count the number of Repositories
     * const count = await prisma.repositories.count({
     *   where: {
     *     // ... the filter for the Repositories we want to count
     *   }
     * })
    **/
    count<T extends RepositoriesCountArgs>(
      args?: Subset<T, RepositoriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepositoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Repositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepositoriesAggregateArgs>(args: Subset<T, RepositoriesAggregateArgs>): PrismaPromise<GetRepositoriesAggregateType<T>>

    /**
     * Group by Repositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepositoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepositoriesGroupByArgs['orderBy'] }
        : { orderBy?: RepositoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepositoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepositoriesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Repositories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RepositoriesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Repositories findUnique
   */
  export type RepositoriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Repositories
     * 
    **/
    select?: RepositoriesSelect | null
    /**
     * Throw an Error if a Repositories can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Repositories to fetch.
     * 
    **/
    where: RepositoriesWhereUniqueInput
  }


  /**
   * Repositories findFirst
   */
  export type RepositoriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Repositories
     * 
    **/
    select?: RepositoriesSelect | null
    /**
     * Throw an Error if a Repositories can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Repositories to fetch.
     * 
    **/
    where?: RepositoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repositories to fetch.
     * 
    **/
    orderBy?: Enumerable<RepositoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Repositories.
     * 
    **/
    cursor?: RepositoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repositories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repositories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Repositories.
     * 
    **/
    distinct?: Enumerable<RepositoriesScalarFieldEnum>
  }


  /**
   * Repositories findMany
   */
  export type RepositoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Repositories
     * 
    **/
    select?: RepositoriesSelect | null
    /**
     * Filter, which Repositories to fetch.
     * 
    **/
    where?: RepositoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repositories to fetch.
     * 
    **/
    orderBy?: Enumerable<RepositoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Repositories.
     * 
    **/
    cursor?: RepositoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repositories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repositories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RepositoriesScalarFieldEnum>
  }


  /**
   * Repositories create
   */
  export type RepositoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the Repositories
     * 
    **/
    select?: RepositoriesSelect | null
    /**
     * The data needed to create a Repositories.
     * 
    **/
    data: XOR<RepositoriesCreateInput, RepositoriesUncheckedCreateInput>
  }


  /**
   * Repositories createMany
   */
  export type RepositoriesCreateManyArgs = {
    data: Enumerable<RepositoriesCreateManyInput>
  }


  /**
   * Repositories update
   */
  export type RepositoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Repositories
     * 
    **/
    select?: RepositoriesSelect | null
    /**
     * The data needed to update a Repositories.
     * 
    **/
    data: XOR<RepositoriesUpdateInput, RepositoriesUncheckedUpdateInput>
    /**
     * Choose, which Repositories to update.
     * 
    **/
    where: RepositoriesWhereUniqueInput
  }


  /**
   * Repositories updateMany
   */
  export type RepositoriesUpdateManyArgs = {
    data: XOR<RepositoriesUpdateManyMutationInput, RepositoriesUncheckedUpdateManyInput>
    where?: RepositoriesWhereInput
  }


  /**
   * Repositories upsert
   */
  export type RepositoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Repositories
     * 
    **/
    select?: RepositoriesSelect | null
    /**
     * The filter to search for the Repositories to update in case it exists.
     * 
    **/
    where: RepositoriesWhereUniqueInput
    /**
     * In case the Repositories found by the `where` argument doesn't exist, create a new Repositories with this data.
     * 
    **/
    create: XOR<RepositoriesCreateInput, RepositoriesUncheckedCreateInput>
    /**
     * In case the Repositories was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RepositoriesUpdateInput, RepositoriesUncheckedUpdateInput>
  }


  /**
   * Repositories delete
   */
  export type RepositoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Repositories
     * 
    **/
    select?: RepositoriesSelect | null
    /**
     * Filter which Repositories to delete.
     * 
    **/
    where: RepositoriesWhereUniqueInput
  }


  /**
   * Repositories deleteMany
   */
  export type RepositoriesDeleteManyArgs = {
    where?: RepositoriesWhereInput
  }


  /**
   * Repositories without action
   */
  export type RepositoriesArgs = {
    /**
     * Select specific fields to fetch from the Repositories
     * 
    **/
    select?: RepositoriesSelect | null
  }



  /**
   * Model RepositoryConnectors
   */


  export type AggregateRepositoryConnectors = {
    _count: RepositoryConnectorsCountAggregateOutputType | null
    _avg: RepositoryConnectorsAvgAggregateOutputType | null
    _sum: RepositoryConnectorsSumAggregateOutputType | null
    _min: RepositoryConnectorsMinAggregateOutputType | null
    _max: RepositoryConnectorsMaxAggregateOutputType | null
  }

  export type RepositoryConnectorsAvgAggregateOutputType = {
    EAUserAuth: number | null
    IsUserDefault: number | null
  }

  export type RepositoryConnectorsSumAggregateOutputType = {
    EAUserAuth: number | null
    IsUserDefault: number | null
  }

  export type RepositoryConnectorsMinAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    User_Id: string | null
    UserGroup_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
    Dashboard_Id: string | null
    EAUserAuth: number | null
    IsUserDefault: number | null
  }

  export type RepositoryConnectorsMaxAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    User_Id: string | null
    UserGroup_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
    Dashboard_Id: string | null
    EAUserAuth: number | null
    IsUserDefault: number | null
  }

  export type RepositoryConnectorsCountAggregateOutputType = {
    Id: number
    Repository_Id: number
    User_Id: number
    UserGroup_Id: number
    CreatedDate: number
    ModifiedDate: number
    Status: number
    Dashboard_Id: number
    EAUserAuth: number
    IsUserDefault: number
    _all: number
  }


  export type RepositoryConnectorsAvgAggregateInputType = {
    EAUserAuth?: true
    IsUserDefault?: true
  }

  export type RepositoryConnectorsSumAggregateInputType = {
    EAUserAuth?: true
    IsUserDefault?: true
  }

  export type RepositoryConnectorsMinAggregateInputType = {
    Id?: true
    Repository_Id?: true
    User_Id?: true
    UserGroup_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
    Dashboard_Id?: true
    EAUserAuth?: true
    IsUserDefault?: true
  }

  export type RepositoryConnectorsMaxAggregateInputType = {
    Id?: true
    Repository_Id?: true
    User_Id?: true
    UserGroup_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
    Dashboard_Id?: true
    EAUserAuth?: true
    IsUserDefault?: true
  }

  export type RepositoryConnectorsCountAggregateInputType = {
    Id?: true
    Repository_Id?: true
    User_Id?: true
    UserGroup_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
    Dashboard_Id?: true
    EAUserAuth?: true
    IsUserDefault?: true
    _all?: true
  }

  export type RepositoryConnectorsAggregateArgs = {
    /**
     * Filter which RepositoryConnectors to aggregate.
     * 
    **/
    where?: RepositoryConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepositoryConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<RepositoryConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RepositoryConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepositoryConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepositoryConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepositoryConnectors
    **/
    _count?: true | RepositoryConnectorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepositoryConnectorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepositoryConnectorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepositoryConnectorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepositoryConnectorsMaxAggregateInputType
  }

  export type GetRepositoryConnectorsAggregateType<T extends RepositoryConnectorsAggregateArgs> = {
        [P in keyof T & keyof AggregateRepositoryConnectors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepositoryConnectors[P]>
      : GetScalarType<T[P], AggregateRepositoryConnectors[P]>
  }




  export type RepositoryConnectorsGroupByArgs = {
    where?: RepositoryConnectorsWhereInput
    orderBy?: Enumerable<RepositoryConnectorsOrderByWithAggregationInput>
    by: Array<RepositoryConnectorsScalarFieldEnum>
    having?: RepositoryConnectorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepositoryConnectorsCountAggregateInputType | true
    _avg?: RepositoryConnectorsAvgAggregateInputType
    _sum?: RepositoryConnectorsSumAggregateInputType
    _min?: RepositoryConnectorsMinAggregateInputType
    _max?: RepositoryConnectorsMaxAggregateInputType
  }


  export type RepositoryConnectorsGroupByOutputType = {
    Id: string
    Repository_Id: string
    User_Id: string | null
    UserGroup_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
    Dashboard_Id: string | null
    EAUserAuth: number | null
    IsUserDefault: number | null
    _count: RepositoryConnectorsCountAggregateOutputType | null
    _avg: RepositoryConnectorsAvgAggregateOutputType | null
    _sum: RepositoryConnectorsSumAggregateOutputType | null
    _min: RepositoryConnectorsMinAggregateOutputType | null
    _max: RepositoryConnectorsMaxAggregateOutputType | null
  }

  type GetRepositoryConnectorsGroupByPayload<T extends RepositoryConnectorsGroupByArgs> = Promise<
    Array<
      PickArray<RepositoryConnectorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepositoryConnectorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepositoryConnectorsGroupByOutputType[P]>
            : GetScalarType<T[P], RepositoryConnectorsGroupByOutputType[P]>
        }
      >
    >


  export type RepositoryConnectorsSelect = {
    Id?: boolean
    Repository_Id?: boolean
    User_Id?: boolean
    UserGroup_Id?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
    Status?: boolean
    Dashboard_Id?: boolean
    EAUserAuth?: boolean
    IsUserDefault?: boolean
  }

  export type RepositoryConnectorsGetPayload<
    S extends boolean | null | undefined | RepositoryConnectorsArgs,
    U = keyof S
      > = S extends true
        ? RepositoryConnectors
    : S extends undefined
    ? never
    : S extends RepositoryConnectorsArgs | RepositoryConnectorsFindManyArgs
    ?'include' extends U
    ? RepositoryConnectors 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RepositoryConnectors ?RepositoryConnectors [P]
  : 
     never
  } 
    : RepositoryConnectors
  : RepositoryConnectors


  type RepositoryConnectorsCountArgs = Merge<
    Omit<RepositoryConnectorsFindManyArgs, 'select' | 'include'> & {
      select?: RepositoryConnectorsCountAggregateInputType | true
    }
  >

  export interface RepositoryConnectorsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RepositoryConnectors that matches the filter.
     * @param {RepositoryConnectorsFindUniqueArgs} args - Arguments to find a RepositoryConnectors
     * @example
     * // Get one RepositoryConnectors
     * const repositoryConnectors = await prisma.repositoryConnectors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RepositoryConnectorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RepositoryConnectorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RepositoryConnectors'> extends True ? CheckSelect<T, Prisma__RepositoryConnectorsClient<RepositoryConnectors>, Prisma__RepositoryConnectorsClient<RepositoryConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__RepositoryConnectorsClient<RepositoryConnectors | null >, Prisma__RepositoryConnectorsClient<RepositoryConnectorsGetPayload<T> | null >>

    /**
     * Find the first RepositoryConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoryConnectorsFindFirstArgs} args - Arguments to find a RepositoryConnectors
     * @example
     * // Get one RepositoryConnectors
     * const repositoryConnectors = await prisma.repositoryConnectors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RepositoryConnectorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RepositoryConnectorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RepositoryConnectors'> extends True ? CheckSelect<T, Prisma__RepositoryConnectorsClient<RepositoryConnectors>, Prisma__RepositoryConnectorsClient<RepositoryConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__RepositoryConnectorsClient<RepositoryConnectors | null >, Prisma__RepositoryConnectorsClient<RepositoryConnectorsGetPayload<T> | null >>

    /**
     * Find zero or more RepositoryConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoryConnectorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepositoryConnectors
     * const repositoryConnectors = await prisma.repositoryConnectors.findMany()
     * 
     * // Get first 10 RepositoryConnectors
     * const repositoryConnectors = await prisma.repositoryConnectors.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const repositoryConnectorsWithIdOnly = await prisma.repositoryConnectors.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends RepositoryConnectorsFindManyArgs>(
      args?: SelectSubset<T, RepositoryConnectorsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RepositoryConnectors>>, PrismaPromise<Array<RepositoryConnectorsGetPayload<T>>>>

    /**
     * Create a RepositoryConnectors.
     * @param {RepositoryConnectorsCreateArgs} args - Arguments to create a RepositoryConnectors.
     * @example
     * // Create one RepositoryConnectors
     * const RepositoryConnectors = await prisma.repositoryConnectors.create({
     *   data: {
     *     // ... data to create a RepositoryConnectors
     *   }
     * })
     * 
    **/
    create<T extends RepositoryConnectorsCreateArgs>(
      args: SelectSubset<T, RepositoryConnectorsCreateArgs>
    ): CheckSelect<T, Prisma__RepositoryConnectorsClient<RepositoryConnectors>, Prisma__RepositoryConnectorsClient<RepositoryConnectorsGetPayload<T>>>

    /**
     * Create many RepositoryConnectors.
     *     @param {RepositoryConnectorsCreateManyArgs} args - Arguments to create many RepositoryConnectors.
     *     @example
     *     // Create many RepositoryConnectors
     *     const repositoryConnectors = await prisma.repositoryConnectors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RepositoryConnectorsCreateManyArgs>(
      args?: SelectSubset<T, RepositoryConnectorsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RepositoryConnectors.
     * @param {RepositoryConnectorsDeleteArgs} args - Arguments to delete one RepositoryConnectors.
     * @example
     * // Delete one RepositoryConnectors
     * const RepositoryConnectors = await prisma.repositoryConnectors.delete({
     *   where: {
     *     // ... filter to delete one RepositoryConnectors
     *   }
     * })
     * 
    **/
    delete<T extends RepositoryConnectorsDeleteArgs>(
      args: SelectSubset<T, RepositoryConnectorsDeleteArgs>
    ): CheckSelect<T, Prisma__RepositoryConnectorsClient<RepositoryConnectors>, Prisma__RepositoryConnectorsClient<RepositoryConnectorsGetPayload<T>>>

    /**
     * Update one RepositoryConnectors.
     * @param {RepositoryConnectorsUpdateArgs} args - Arguments to update one RepositoryConnectors.
     * @example
     * // Update one RepositoryConnectors
     * const repositoryConnectors = await prisma.repositoryConnectors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RepositoryConnectorsUpdateArgs>(
      args: SelectSubset<T, RepositoryConnectorsUpdateArgs>
    ): CheckSelect<T, Prisma__RepositoryConnectorsClient<RepositoryConnectors>, Prisma__RepositoryConnectorsClient<RepositoryConnectorsGetPayload<T>>>

    /**
     * Delete zero or more RepositoryConnectors.
     * @param {RepositoryConnectorsDeleteManyArgs} args - Arguments to filter RepositoryConnectors to delete.
     * @example
     * // Delete a few RepositoryConnectors
     * const { count } = await prisma.repositoryConnectors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RepositoryConnectorsDeleteManyArgs>(
      args?: SelectSubset<T, RepositoryConnectorsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepositoryConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoryConnectorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepositoryConnectors
     * const repositoryConnectors = await prisma.repositoryConnectors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RepositoryConnectorsUpdateManyArgs>(
      args: SelectSubset<T, RepositoryConnectorsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RepositoryConnectors.
     * @param {RepositoryConnectorsUpsertArgs} args - Arguments to update or create a RepositoryConnectors.
     * @example
     * // Update or create a RepositoryConnectors
     * const repositoryConnectors = await prisma.repositoryConnectors.upsert({
     *   create: {
     *     // ... data to create a RepositoryConnectors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepositoryConnectors we want to update
     *   }
     * })
    **/
    upsert<T extends RepositoryConnectorsUpsertArgs>(
      args: SelectSubset<T, RepositoryConnectorsUpsertArgs>
    ): CheckSelect<T, Prisma__RepositoryConnectorsClient<RepositoryConnectors>, Prisma__RepositoryConnectorsClient<RepositoryConnectorsGetPayload<T>>>

    /**
     * Count the number of RepositoryConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoryConnectorsCountArgs} args - Arguments to filter RepositoryConnectors to count.
     * @example
     * // Count the number of RepositoryConnectors
     * const count = await prisma.repositoryConnectors.count({
     *   where: {
     *     // ... the filter for the RepositoryConnectors we want to count
     *   }
     * })
    **/
    count<T extends RepositoryConnectorsCountArgs>(
      args?: Subset<T, RepositoryConnectorsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepositoryConnectorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepositoryConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoryConnectorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepositoryConnectorsAggregateArgs>(args: Subset<T, RepositoryConnectorsAggregateArgs>): PrismaPromise<GetRepositoryConnectorsAggregateType<T>>

    /**
     * Group by RepositoryConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoryConnectorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepositoryConnectorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepositoryConnectorsGroupByArgs['orderBy'] }
        : { orderBy?: RepositoryConnectorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepositoryConnectorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepositoryConnectorsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RepositoryConnectors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RepositoryConnectorsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RepositoryConnectors findUnique
   */
  export type RepositoryConnectorsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RepositoryConnectors
     * 
    **/
    select?: RepositoryConnectorsSelect | null
    /**
     * Throw an Error if a RepositoryConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RepositoryConnectors to fetch.
     * 
    **/
    where: RepositoryConnectorsWhereUniqueInput
  }


  /**
   * RepositoryConnectors findFirst
   */
  export type RepositoryConnectorsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RepositoryConnectors
     * 
    **/
    select?: RepositoryConnectorsSelect | null
    /**
     * Throw an Error if a RepositoryConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RepositoryConnectors to fetch.
     * 
    **/
    where?: RepositoryConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepositoryConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<RepositoryConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepositoryConnectors.
     * 
    **/
    cursor?: RepositoryConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepositoryConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepositoryConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepositoryConnectors.
     * 
    **/
    distinct?: Enumerable<RepositoryConnectorsScalarFieldEnum>
  }


  /**
   * RepositoryConnectors findMany
   */
  export type RepositoryConnectorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the RepositoryConnectors
     * 
    **/
    select?: RepositoryConnectorsSelect | null
    /**
     * Filter, which RepositoryConnectors to fetch.
     * 
    **/
    where?: RepositoryConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepositoryConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<RepositoryConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepositoryConnectors.
     * 
    **/
    cursor?: RepositoryConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepositoryConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepositoryConnectors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RepositoryConnectorsScalarFieldEnum>
  }


  /**
   * RepositoryConnectors create
   */
  export type RepositoryConnectorsCreateArgs = {
    /**
     * Select specific fields to fetch from the RepositoryConnectors
     * 
    **/
    select?: RepositoryConnectorsSelect | null
    /**
     * The data needed to create a RepositoryConnectors.
     * 
    **/
    data: XOR<RepositoryConnectorsCreateInput, RepositoryConnectorsUncheckedCreateInput>
  }


  /**
   * RepositoryConnectors createMany
   */
  export type RepositoryConnectorsCreateManyArgs = {
    data: Enumerable<RepositoryConnectorsCreateManyInput>
  }


  /**
   * RepositoryConnectors update
   */
  export type RepositoryConnectorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the RepositoryConnectors
     * 
    **/
    select?: RepositoryConnectorsSelect | null
    /**
     * The data needed to update a RepositoryConnectors.
     * 
    **/
    data: XOR<RepositoryConnectorsUpdateInput, RepositoryConnectorsUncheckedUpdateInput>
    /**
     * Choose, which RepositoryConnectors to update.
     * 
    **/
    where: RepositoryConnectorsWhereUniqueInput
  }


  /**
   * RepositoryConnectors updateMany
   */
  export type RepositoryConnectorsUpdateManyArgs = {
    data: XOR<RepositoryConnectorsUpdateManyMutationInput, RepositoryConnectorsUncheckedUpdateManyInput>
    where?: RepositoryConnectorsWhereInput
  }


  /**
   * RepositoryConnectors upsert
   */
  export type RepositoryConnectorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the RepositoryConnectors
     * 
    **/
    select?: RepositoryConnectorsSelect | null
    /**
     * The filter to search for the RepositoryConnectors to update in case it exists.
     * 
    **/
    where: RepositoryConnectorsWhereUniqueInput
    /**
     * In case the RepositoryConnectors found by the `where` argument doesn't exist, create a new RepositoryConnectors with this data.
     * 
    **/
    create: XOR<RepositoryConnectorsCreateInput, RepositoryConnectorsUncheckedCreateInput>
    /**
     * In case the RepositoryConnectors was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RepositoryConnectorsUpdateInput, RepositoryConnectorsUncheckedUpdateInput>
  }


  /**
   * RepositoryConnectors delete
   */
  export type RepositoryConnectorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the RepositoryConnectors
     * 
    **/
    select?: RepositoryConnectorsSelect | null
    /**
     * Filter which RepositoryConnectors to delete.
     * 
    **/
    where: RepositoryConnectorsWhereUniqueInput
  }


  /**
   * RepositoryConnectors deleteMany
   */
  export type RepositoryConnectorsDeleteManyArgs = {
    where?: RepositoryConnectorsWhereInput
  }


  /**
   * RepositoryConnectors without action
   */
  export type RepositoryConnectorsArgs = {
    /**
     * Select specific fields to fetch from the RepositoryConnectors
     * 
    **/
    select?: RepositoryConnectorsSelect | null
  }



  /**
   * Model RepositoryDBConnections
   */


  export type AggregateRepositoryDBConnections = {
    _count: RepositoryDBConnectionsCountAggregateOutputType | null
    _avg: RepositoryDBConnectionsAvgAggregateOutputType | null
    _sum: RepositoryDBConnectionsSumAggregateOutputType | null
    _min: RepositoryDBConnectionsMinAggregateOutputType | null
    _max: RepositoryDBConnectionsMaxAggregateOutputType | null
  }

  export type RepositoryDBConnectionsAvgAggregateOutputType = {
    CreateElement: number | null
  }

  export type RepositoryDBConnectionsSumAggregateOutputType = {
    CreateElement: number | null
  }

  export type RepositoryDBConnectionsMinAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    CreateElement: number | null
    ConnectionType: string | null
    ConnectionDetail: string | null
    DBType: string | null
    Server: string | null
    Port: string | null
    DBName: string | null
    Username: string | null
    Password: string | null
    DsnName: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type RepositoryDBConnectionsMaxAggregateOutputType = {
    Id: string | null
    Repository_Id: string | null
    CreateElement: number | null
    ConnectionType: string | null
    ConnectionDetail: string | null
    DBType: string | null
    Server: string | null
    Port: string | null
    DBName: string | null
    Username: string | null
    Password: string | null
    DsnName: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type RepositoryDBConnectionsCountAggregateOutputType = {
    Id: number
    Repository_Id: number
    CreateElement: number
    ConnectionType: number
    ConnectionDetail: number
    DBType: number
    Server: number
    Port: number
    DBName: number
    Username: number
    Password: number
    DsnName: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type RepositoryDBConnectionsAvgAggregateInputType = {
    CreateElement?: true
  }

  export type RepositoryDBConnectionsSumAggregateInputType = {
    CreateElement?: true
  }

  export type RepositoryDBConnectionsMinAggregateInputType = {
    Id?: true
    Repository_Id?: true
    CreateElement?: true
    ConnectionType?: true
    ConnectionDetail?: true
    DBType?: true
    Server?: true
    Port?: true
    DBName?: true
    Username?: true
    Password?: true
    DsnName?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type RepositoryDBConnectionsMaxAggregateInputType = {
    Id?: true
    Repository_Id?: true
    CreateElement?: true
    ConnectionType?: true
    ConnectionDetail?: true
    DBType?: true
    Server?: true
    Port?: true
    DBName?: true
    Username?: true
    Password?: true
    DsnName?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type RepositoryDBConnectionsCountAggregateInputType = {
    Id?: true
    Repository_Id?: true
    CreateElement?: true
    ConnectionType?: true
    ConnectionDetail?: true
    DBType?: true
    Server?: true
    Port?: true
    DBName?: true
    Username?: true
    Password?: true
    DsnName?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type RepositoryDBConnectionsAggregateArgs = {
    /**
     * Filter which RepositoryDBConnections to aggregate.
     * 
    **/
    where?: RepositoryDBConnectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepositoryDBConnections to fetch.
     * 
    **/
    orderBy?: Enumerable<RepositoryDBConnectionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RepositoryDBConnectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepositoryDBConnections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepositoryDBConnections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepositoryDBConnections
    **/
    _count?: true | RepositoryDBConnectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepositoryDBConnectionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepositoryDBConnectionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepositoryDBConnectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepositoryDBConnectionsMaxAggregateInputType
  }

  export type GetRepositoryDBConnectionsAggregateType<T extends RepositoryDBConnectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRepositoryDBConnections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepositoryDBConnections[P]>
      : GetScalarType<T[P], AggregateRepositoryDBConnections[P]>
  }




  export type RepositoryDBConnectionsGroupByArgs = {
    where?: RepositoryDBConnectionsWhereInput
    orderBy?: Enumerable<RepositoryDBConnectionsOrderByWithAggregationInput>
    by: Array<RepositoryDBConnectionsScalarFieldEnum>
    having?: RepositoryDBConnectionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepositoryDBConnectionsCountAggregateInputType | true
    _avg?: RepositoryDBConnectionsAvgAggregateInputType
    _sum?: RepositoryDBConnectionsSumAggregateInputType
    _min?: RepositoryDBConnectionsMinAggregateInputType
    _max?: RepositoryDBConnectionsMaxAggregateInputType
  }


  export type RepositoryDBConnectionsGroupByOutputType = {
    Id: string
    Repository_Id: string | null
    CreateElement: number | null
    ConnectionType: string | null
    ConnectionDetail: string | null
    DBType: string | null
    Server: string | null
    Port: string | null
    DBName: string | null
    Username: string | null
    Password: string | null
    DsnName: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: RepositoryDBConnectionsCountAggregateOutputType | null
    _avg: RepositoryDBConnectionsAvgAggregateOutputType | null
    _sum: RepositoryDBConnectionsSumAggregateOutputType | null
    _min: RepositoryDBConnectionsMinAggregateOutputType | null
    _max: RepositoryDBConnectionsMaxAggregateOutputType | null
  }

  type GetRepositoryDBConnectionsGroupByPayload<T extends RepositoryDBConnectionsGroupByArgs> = Promise<
    Array<
      PickArray<RepositoryDBConnectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepositoryDBConnectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepositoryDBConnectionsGroupByOutputType[P]>
            : GetScalarType<T[P], RepositoryDBConnectionsGroupByOutputType[P]>
        }
      >
    >


  export type RepositoryDBConnectionsSelect = {
    Id?: boolean
    Repository_Id?: boolean
    CreateElement?: boolean
    ConnectionType?: boolean
    ConnectionDetail?: boolean
    DBType?: boolean
    Server?: boolean
    Port?: boolean
    DBName?: boolean
    Username?: boolean
    Password?: boolean
    DsnName?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type RepositoryDBConnectionsGetPayload<
    S extends boolean | null | undefined | RepositoryDBConnectionsArgs,
    U = keyof S
      > = S extends true
        ? RepositoryDBConnections
    : S extends undefined
    ? never
    : S extends RepositoryDBConnectionsArgs | RepositoryDBConnectionsFindManyArgs
    ?'include' extends U
    ? RepositoryDBConnections 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RepositoryDBConnections ?RepositoryDBConnections [P]
  : 
     never
  } 
    : RepositoryDBConnections
  : RepositoryDBConnections


  type RepositoryDBConnectionsCountArgs = Merge<
    Omit<RepositoryDBConnectionsFindManyArgs, 'select' | 'include'> & {
      select?: RepositoryDBConnectionsCountAggregateInputType | true
    }
  >

  export interface RepositoryDBConnectionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RepositoryDBConnections that matches the filter.
     * @param {RepositoryDBConnectionsFindUniqueArgs} args - Arguments to find a RepositoryDBConnections
     * @example
     * // Get one RepositoryDBConnections
     * const repositoryDBConnections = await prisma.repositoryDBConnections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RepositoryDBConnectionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RepositoryDBConnectionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RepositoryDBConnections'> extends True ? CheckSelect<T, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnections>, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnectionsGetPayload<T>>> : CheckSelect<T, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnections | null >, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnectionsGetPayload<T> | null >>

    /**
     * Find the first RepositoryDBConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoryDBConnectionsFindFirstArgs} args - Arguments to find a RepositoryDBConnections
     * @example
     * // Get one RepositoryDBConnections
     * const repositoryDBConnections = await prisma.repositoryDBConnections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RepositoryDBConnectionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RepositoryDBConnectionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RepositoryDBConnections'> extends True ? CheckSelect<T, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnections>, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnectionsGetPayload<T>>> : CheckSelect<T, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnections | null >, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnectionsGetPayload<T> | null >>

    /**
     * Find zero or more RepositoryDBConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoryDBConnectionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepositoryDBConnections
     * const repositoryDBConnections = await prisma.repositoryDBConnections.findMany()
     * 
     * // Get first 10 RepositoryDBConnections
     * const repositoryDBConnections = await prisma.repositoryDBConnections.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const repositoryDBConnectionsWithIdOnly = await prisma.repositoryDBConnections.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends RepositoryDBConnectionsFindManyArgs>(
      args?: SelectSubset<T, RepositoryDBConnectionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RepositoryDBConnections>>, PrismaPromise<Array<RepositoryDBConnectionsGetPayload<T>>>>

    /**
     * Create a RepositoryDBConnections.
     * @param {RepositoryDBConnectionsCreateArgs} args - Arguments to create a RepositoryDBConnections.
     * @example
     * // Create one RepositoryDBConnections
     * const RepositoryDBConnections = await prisma.repositoryDBConnections.create({
     *   data: {
     *     // ... data to create a RepositoryDBConnections
     *   }
     * })
     * 
    **/
    create<T extends RepositoryDBConnectionsCreateArgs>(
      args: SelectSubset<T, RepositoryDBConnectionsCreateArgs>
    ): CheckSelect<T, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnections>, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnectionsGetPayload<T>>>

    /**
     * Create many RepositoryDBConnections.
     *     @param {RepositoryDBConnectionsCreateManyArgs} args - Arguments to create many RepositoryDBConnections.
     *     @example
     *     // Create many RepositoryDBConnections
     *     const repositoryDBConnections = await prisma.repositoryDBConnections.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RepositoryDBConnectionsCreateManyArgs>(
      args?: SelectSubset<T, RepositoryDBConnectionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RepositoryDBConnections.
     * @param {RepositoryDBConnectionsDeleteArgs} args - Arguments to delete one RepositoryDBConnections.
     * @example
     * // Delete one RepositoryDBConnections
     * const RepositoryDBConnections = await prisma.repositoryDBConnections.delete({
     *   where: {
     *     // ... filter to delete one RepositoryDBConnections
     *   }
     * })
     * 
    **/
    delete<T extends RepositoryDBConnectionsDeleteArgs>(
      args: SelectSubset<T, RepositoryDBConnectionsDeleteArgs>
    ): CheckSelect<T, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnections>, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnectionsGetPayload<T>>>

    /**
     * Update one RepositoryDBConnections.
     * @param {RepositoryDBConnectionsUpdateArgs} args - Arguments to update one RepositoryDBConnections.
     * @example
     * // Update one RepositoryDBConnections
     * const repositoryDBConnections = await prisma.repositoryDBConnections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RepositoryDBConnectionsUpdateArgs>(
      args: SelectSubset<T, RepositoryDBConnectionsUpdateArgs>
    ): CheckSelect<T, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnections>, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnectionsGetPayload<T>>>

    /**
     * Delete zero or more RepositoryDBConnections.
     * @param {RepositoryDBConnectionsDeleteManyArgs} args - Arguments to filter RepositoryDBConnections to delete.
     * @example
     * // Delete a few RepositoryDBConnections
     * const { count } = await prisma.repositoryDBConnections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RepositoryDBConnectionsDeleteManyArgs>(
      args?: SelectSubset<T, RepositoryDBConnectionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepositoryDBConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoryDBConnectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepositoryDBConnections
     * const repositoryDBConnections = await prisma.repositoryDBConnections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RepositoryDBConnectionsUpdateManyArgs>(
      args: SelectSubset<T, RepositoryDBConnectionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RepositoryDBConnections.
     * @param {RepositoryDBConnectionsUpsertArgs} args - Arguments to update or create a RepositoryDBConnections.
     * @example
     * // Update or create a RepositoryDBConnections
     * const repositoryDBConnections = await prisma.repositoryDBConnections.upsert({
     *   create: {
     *     // ... data to create a RepositoryDBConnections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepositoryDBConnections we want to update
     *   }
     * })
    **/
    upsert<T extends RepositoryDBConnectionsUpsertArgs>(
      args: SelectSubset<T, RepositoryDBConnectionsUpsertArgs>
    ): CheckSelect<T, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnections>, Prisma__RepositoryDBConnectionsClient<RepositoryDBConnectionsGetPayload<T>>>

    /**
     * Count the number of RepositoryDBConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoryDBConnectionsCountArgs} args - Arguments to filter RepositoryDBConnections to count.
     * @example
     * // Count the number of RepositoryDBConnections
     * const count = await prisma.repositoryDBConnections.count({
     *   where: {
     *     // ... the filter for the RepositoryDBConnections we want to count
     *   }
     * })
    **/
    count<T extends RepositoryDBConnectionsCountArgs>(
      args?: Subset<T, RepositoryDBConnectionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepositoryDBConnectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepositoryDBConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoryDBConnectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepositoryDBConnectionsAggregateArgs>(args: Subset<T, RepositoryDBConnectionsAggregateArgs>): PrismaPromise<GetRepositoryDBConnectionsAggregateType<T>>

    /**
     * Group by RepositoryDBConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepositoryDBConnectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepositoryDBConnectionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepositoryDBConnectionsGroupByArgs['orderBy'] }
        : { orderBy?: RepositoryDBConnectionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepositoryDBConnectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepositoryDBConnectionsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RepositoryDBConnections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RepositoryDBConnectionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RepositoryDBConnections findUnique
   */
  export type RepositoryDBConnectionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RepositoryDBConnections
     * 
    **/
    select?: RepositoryDBConnectionsSelect | null
    /**
     * Throw an Error if a RepositoryDBConnections can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RepositoryDBConnections to fetch.
     * 
    **/
    where: RepositoryDBConnectionsWhereUniqueInput
  }


  /**
   * RepositoryDBConnections findFirst
   */
  export type RepositoryDBConnectionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RepositoryDBConnections
     * 
    **/
    select?: RepositoryDBConnectionsSelect | null
    /**
     * Throw an Error if a RepositoryDBConnections can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RepositoryDBConnections to fetch.
     * 
    **/
    where?: RepositoryDBConnectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepositoryDBConnections to fetch.
     * 
    **/
    orderBy?: Enumerable<RepositoryDBConnectionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepositoryDBConnections.
     * 
    **/
    cursor?: RepositoryDBConnectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepositoryDBConnections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepositoryDBConnections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepositoryDBConnections.
     * 
    **/
    distinct?: Enumerable<RepositoryDBConnectionsScalarFieldEnum>
  }


  /**
   * RepositoryDBConnections findMany
   */
  export type RepositoryDBConnectionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the RepositoryDBConnections
     * 
    **/
    select?: RepositoryDBConnectionsSelect | null
    /**
     * Filter, which RepositoryDBConnections to fetch.
     * 
    **/
    where?: RepositoryDBConnectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepositoryDBConnections to fetch.
     * 
    **/
    orderBy?: Enumerable<RepositoryDBConnectionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepositoryDBConnections.
     * 
    **/
    cursor?: RepositoryDBConnectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepositoryDBConnections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepositoryDBConnections.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RepositoryDBConnectionsScalarFieldEnum>
  }


  /**
   * RepositoryDBConnections create
   */
  export type RepositoryDBConnectionsCreateArgs = {
    /**
     * Select specific fields to fetch from the RepositoryDBConnections
     * 
    **/
    select?: RepositoryDBConnectionsSelect | null
    /**
     * The data needed to create a RepositoryDBConnections.
     * 
    **/
    data: XOR<RepositoryDBConnectionsCreateInput, RepositoryDBConnectionsUncheckedCreateInput>
  }


  /**
   * RepositoryDBConnections createMany
   */
  export type RepositoryDBConnectionsCreateManyArgs = {
    data: Enumerable<RepositoryDBConnectionsCreateManyInput>
  }


  /**
   * RepositoryDBConnections update
   */
  export type RepositoryDBConnectionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the RepositoryDBConnections
     * 
    **/
    select?: RepositoryDBConnectionsSelect | null
    /**
     * The data needed to update a RepositoryDBConnections.
     * 
    **/
    data: XOR<RepositoryDBConnectionsUpdateInput, RepositoryDBConnectionsUncheckedUpdateInput>
    /**
     * Choose, which RepositoryDBConnections to update.
     * 
    **/
    where: RepositoryDBConnectionsWhereUniqueInput
  }


  /**
   * RepositoryDBConnections updateMany
   */
  export type RepositoryDBConnectionsUpdateManyArgs = {
    data: XOR<RepositoryDBConnectionsUpdateManyMutationInput, RepositoryDBConnectionsUncheckedUpdateManyInput>
    where?: RepositoryDBConnectionsWhereInput
  }


  /**
   * RepositoryDBConnections upsert
   */
  export type RepositoryDBConnectionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the RepositoryDBConnections
     * 
    **/
    select?: RepositoryDBConnectionsSelect | null
    /**
     * The filter to search for the RepositoryDBConnections to update in case it exists.
     * 
    **/
    where: RepositoryDBConnectionsWhereUniqueInput
    /**
     * In case the RepositoryDBConnections found by the `where` argument doesn't exist, create a new RepositoryDBConnections with this data.
     * 
    **/
    create: XOR<RepositoryDBConnectionsCreateInput, RepositoryDBConnectionsUncheckedCreateInput>
    /**
     * In case the RepositoryDBConnections was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RepositoryDBConnectionsUpdateInput, RepositoryDBConnectionsUncheckedUpdateInput>
  }


  /**
   * RepositoryDBConnections delete
   */
  export type RepositoryDBConnectionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the RepositoryDBConnections
     * 
    **/
    select?: RepositoryDBConnectionsSelect | null
    /**
     * Filter which RepositoryDBConnections to delete.
     * 
    **/
    where: RepositoryDBConnectionsWhereUniqueInput
  }


  /**
   * RepositoryDBConnections deleteMany
   */
  export type RepositoryDBConnectionsDeleteManyArgs = {
    where?: RepositoryDBConnectionsWhereInput
  }


  /**
   * RepositoryDBConnections without action
   */
  export type RepositoryDBConnectionsArgs = {
    /**
     * Select specific fields to fetch from the RepositoryDBConnections
     * 
    **/
    select?: RepositoryDBConnectionsSelect | null
  }



  /**
   * Model RequestLogs
   */


  export type AggregateRequestLogs = {
    _count: RequestLogsCountAggregateOutputType | null
    _avg: RequestLogsAvgAggregateOutputType | null
    _sum: RequestLogsSumAggregateOutputType | null
    _min: RequestLogsMinAggregateOutputType | null
    _max: RequestLogsMaxAggregateOutputType | null
  }

  export type RequestLogsAvgAggregateOutputType = {
    Status: number | null
  }

  export type RequestLogsSumAggregateOutputType = {
    Status: number | null
  }

  export type RequestLogsMinAggregateOutputType = {
    Id: string | null
    RequestedUserId: string | null
    DesignatedUserId: string | null
    Url: string | null
    UrlType: string | null
    RequestedUserAgent: string | null
    RequestedUserIpAddress: string | null
    DesignatedUserAgent: string | null
    DesignatedUserIpAddress: string | null
    Created: Date | null
    Modified: Date | null
    LastVisited: Date | null
    Status: number | null
    Validity: Date | null
  }

  export type RequestLogsMaxAggregateOutputType = {
    Id: string | null
    RequestedUserId: string | null
    DesignatedUserId: string | null
    Url: string | null
    UrlType: string | null
    RequestedUserAgent: string | null
    RequestedUserIpAddress: string | null
    DesignatedUserAgent: string | null
    DesignatedUserIpAddress: string | null
    Created: Date | null
    Modified: Date | null
    LastVisited: Date | null
    Status: number | null
    Validity: Date | null
  }

  export type RequestLogsCountAggregateOutputType = {
    Id: number
    RequestedUserId: number
    DesignatedUserId: number
    Url: number
    UrlType: number
    RequestedUserAgent: number
    RequestedUserIpAddress: number
    DesignatedUserAgent: number
    DesignatedUserIpAddress: number
    Created: number
    Modified: number
    LastVisited: number
    Status: number
    Validity: number
    _all: number
  }


  export type RequestLogsAvgAggregateInputType = {
    Status?: true
  }

  export type RequestLogsSumAggregateInputType = {
    Status?: true
  }

  export type RequestLogsMinAggregateInputType = {
    Id?: true
    RequestedUserId?: true
    DesignatedUserId?: true
    Url?: true
    UrlType?: true
    RequestedUserAgent?: true
    RequestedUserIpAddress?: true
    DesignatedUserAgent?: true
    DesignatedUserIpAddress?: true
    Created?: true
    Modified?: true
    LastVisited?: true
    Status?: true
    Validity?: true
  }

  export type RequestLogsMaxAggregateInputType = {
    Id?: true
    RequestedUserId?: true
    DesignatedUserId?: true
    Url?: true
    UrlType?: true
    RequestedUserAgent?: true
    RequestedUserIpAddress?: true
    DesignatedUserAgent?: true
    DesignatedUserIpAddress?: true
    Created?: true
    Modified?: true
    LastVisited?: true
    Status?: true
    Validity?: true
  }

  export type RequestLogsCountAggregateInputType = {
    Id?: true
    RequestedUserId?: true
    DesignatedUserId?: true
    Url?: true
    UrlType?: true
    RequestedUserAgent?: true
    RequestedUserIpAddress?: true
    DesignatedUserAgent?: true
    DesignatedUserIpAddress?: true
    Created?: true
    Modified?: true
    LastVisited?: true
    Status?: true
    Validity?: true
    _all?: true
  }

  export type RequestLogsAggregateArgs = {
    /**
     * Filter which RequestLogs to aggregate.
     * 
    **/
    where?: RequestLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestLogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestLogs
    **/
    _count?: true | RequestLogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestLogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestLogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestLogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestLogsMaxAggregateInputType
  }

  export type GetRequestLogsAggregateType<T extends RequestLogsAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestLogs[P]>
      : GetScalarType<T[P], AggregateRequestLogs[P]>
  }




  export type RequestLogsGroupByArgs = {
    where?: RequestLogsWhereInput
    orderBy?: Enumerable<RequestLogsOrderByWithAggregationInput>
    by: Array<RequestLogsScalarFieldEnum>
    having?: RequestLogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestLogsCountAggregateInputType | true
    _avg?: RequestLogsAvgAggregateInputType
    _sum?: RequestLogsSumAggregateInputType
    _min?: RequestLogsMinAggregateInputType
    _max?: RequestLogsMaxAggregateInputType
  }


  export type RequestLogsGroupByOutputType = {
    Id: string
    RequestedUserId: string | null
    DesignatedUserId: string | null
    Url: string | null
    UrlType: string | null
    RequestedUserAgent: string | null
    RequestedUserIpAddress: string | null
    DesignatedUserAgent: string | null
    DesignatedUserIpAddress: string | null
    Created: Date | null
    Modified: Date | null
    LastVisited: Date | null
    Status: number | null
    Validity: Date | null
    _count: RequestLogsCountAggregateOutputType | null
    _avg: RequestLogsAvgAggregateOutputType | null
    _sum: RequestLogsSumAggregateOutputType | null
    _min: RequestLogsMinAggregateOutputType | null
    _max: RequestLogsMaxAggregateOutputType | null
  }

  type GetRequestLogsGroupByPayload<T extends RequestLogsGroupByArgs> = Promise<
    Array<
      PickArray<RequestLogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestLogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestLogsGroupByOutputType[P]>
            : GetScalarType<T[P], RequestLogsGroupByOutputType[P]>
        }
      >
    >


  export type RequestLogsSelect = {
    Id?: boolean
    RequestedUserId?: boolean
    DesignatedUserId?: boolean
    Url?: boolean
    UrlType?: boolean
    RequestedUserAgent?: boolean
    RequestedUserIpAddress?: boolean
    DesignatedUserAgent?: boolean
    DesignatedUserIpAddress?: boolean
    Created?: boolean
    Modified?: boolean
    LastVisited?: boolean
    Status?: boolean
    Validity?: boolean
  }

  export type RequestLogsGetPayload<
    S extends boolean | null | undefined | RequestLogsArgs,
    U = keyof S
      > = S extends true
        ? RequestLogs
    : S extends undefined
    ? never
    : S extends RequestLogsArgs | RequestLogsFindManyArgs
    ?'include' extends U
    ? RequestLogs 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RequestLogs ?RequestLogs [P]
  : 
     never
  } 
    : RequestLogs
  : RequestLogs


  type RequestLogsCountArgs = Merge<
    Omit<RequestLogsFindManyArgs, 'select' | 'include'> & {
      select?: RequestLogsCountAggregateInputType | true
    }
  >

  export interface RequestLogsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RequestLogs that matches the filter.
     * @param {RequestLogsFindUniqueArgs} args - Arguments to find a RequestLogs
     * @example
     * // Get one RequestLogs
     * const requestLogs = await prisma.requestLogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestLogsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestLogsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestLogs'> extends True ? CheckSelect<T, Prisma__RequestLogsClient<RequestLogs>, Prisma__RequestLogsClient<RequestLogsGetPayload<T>>> : CheckSelect<T, Prisma__RequestLogsClient<RequestLogs | null >, Prisma__RequestLogsClient<RequestLogsGetPayload<T> | null >>

    /**
     * Find the first RequestLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsFindFirstArgs} args - Arguments to find a RequestLogs
     * @example
     * // Get one RequestLogs
     * const requestLogs = await prisma.requestLogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestLogsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestLogsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestLogs'> extends True ? CheckSelect<T, Prisma__RequestLogsClient<RequestLogs>, Prisma__RequestLogsClient<RequestLogsGetPayload<T>>> : CheckSelect<T, Prisma__RequestLogsClient<RequestLogs | null >, Prisma__RequestLogsClient<RequestLogsGetPayload<T> | null >>

    /**
     * Find zero or more RequestLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestLogs
     * const requestLogs = await prisma.requestLogs.findMany()
     * 
     * // Get first 10 RequestLogs
     * const requestLogs = await prisma.requestLogs.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const requestLogsWithIdOnly = await prisma.requestLogs.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends RequestLogsFindManyArgs>(
      args?: SelectSubset<T, RequestLogsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestLogs>>, PrismaPromise<Array<RequestLogsGetPayload<T>>>>

    /**
     * Create a RequestLogs.
     * @param {RequestLogsCreateArgs} args - Arguments to create a RequestLogs.
     * @example
     * // Create one RequestLogs
     * const RequestLogs = await prisma.requestLogs.create({
     *   data: {
     *     // ... data to create a RequestLogs
     *   }
     * })
     * 
    **/
    create<T extends RequestLogsCreateArgs>(
      args: SelectSubset<T, RequestLogsCreateArgs>
    ): CheckSelect<T, Prisma__RequestLogsClient<RequestLogs>, Prisma__RequestLogsClient<RequestLogsGetPayload<T>>>

    /**
     * Create many RequestLogs.
     *     @param {RequestLogsCreateManyArgs} args - Arguments to create many RequestLogs.
     *     @example
     *     // Create many RequestLogs
     *     const requestLogs = await prisma.requestLogs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestLogsCreateManyArgs>(
      args?: SelectSubset<T, RequestLogsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestLogs.
     * @param {RequestLogsDeleteArgs} args - Arguments to delete one RequestLogs.
     * @example
     * // Delete one RequestLogs
     * const RequestLogs = await prisma.requestLogs.delete({
     *   where: {
     *     // ... filter to delete one RequestLogs
     *   }
     * })
     * 
    **/
    delete<T extends RequestLogsDeleteArgs>(
      args: SelectSubset<T, RequestLogsDeleteArgs>
    ): CheckSelect<T, Prisma__RequestLogsClient<RequestLogs>, Prisma__RequestLogsClient<RequestLogsGetPayload<T>>>

    /**
     * Update one RequestLogs.
     * @param {RequestLogsUpdateArgs} args - Arguments to update one RequestLogs.
     * @example
     * // Update one RequestLogs
     * const requestLogs = await prisma.requestLogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestLogsUpdateArgs>(
      args: SelectSubset<T, RequestLogsUpdateArgs>
    ): CheckSelect<T, Prisma__RequestLogsClient<RequestLogs>, Prisma__RequestLogsClient<RequestLogsGetPayload<T>>>

    /**
     * Delete zero or more RequestLogs.
     * @param {RequestLogsDeleteManyArgs} args - Arguments to filter RequestLogs to delete.
     * @example
     * // Delete a few RequestLogs
     * const { count } = await prisma.requestLogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestLogsDeleteManyArgs>(
      args?: SelectSubset<T, RequestLogsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestLogs
     * const requestLogs = await prisma.requestLogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestLogsUpdateManyArgs>(
      args: SelectSubset<T, RequestLogsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestLogs.
     * @param {RequestLogsUpsertArgs} args - Arguments to update or create a RequestLogs.
     * @example
     * // Update or create a RequestLogs
     * const requestLogs = await prisma.requestLogs.upsert({
     *   create: {
     *     // ... data to create a RequestLogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestLogs we want to update
     *   }
     * })
    **/
    upsert<T extends RequestLogsUpsertArgs>(
      args: SelectSubset<T, RequestLogsUpsertArgs>
    ): CheckSelect<T, Prisma__RequestLogsClient<RequestLogs>, Prisma__RequestLogsClient<RequestLogsGetPayload<T>>>

    /**
     * Count the number of RequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsCountArgs} args - Arguments to filter RequestLogs to count.
     * @example
     * // Count the number of RequestLogs
     * const count = await prisma.requestLogs.count({
     *   where: {
     *     // ... the filter for the RequestLogs we want to count
     *   }
     * })
    **/
    count<T extends RequestLogsCountArgs>(
      args?: Subset<T, RequestLogsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestLogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestLogsAggregateArgs>(args: Subset<T, RequestLogsAggregateArgs>): PrismaPromise<GetRequestLogsAggregateType<T>>

    /**
     * Group by RequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestLogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestLogsGroupByArgs['orderBy'] }
        : { orderBy?: RequestLogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestLogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestLogsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestLogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestLogsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RequestLogs findUnique
   */
  export type RequestLogsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RequestLogs
     * 
    **/
    select?: RequestLogsSelect | null
    /**
     * Throw an Error if a RequestLogs can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RequestLogs to fetch.
     * 
    **/
    where: RequestLogsWhereUniqueInput
  }


  /**
   * RequestLogs findFirst
   */
  export type RequestLogsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RequestLogs
     * 
    **/
    select?: RequestLogsSelect | null
    /**
     * Throw an Error if a RequestLogs can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RequestLogs to fetch.
     * 
    **/
    where?: RequestLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestLogs.
     * 
    **/
    cursor?: RequestLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestLogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestLogs.
     * 
    **/
    distinct?: Enumerable<RequestLogsScalarFieldEnum>
  }


  /**
   * RequestLogs findMany
   */
  export type RequestLogsFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestLogs
     * 
    **/
    select?: RequestLogsSelect | null
    /**
     * Filter, which RequestLogs to fetch.
     * 
    **/
    where?: RequestLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestLogs.
     * 
    **/
    cursor?: RequestLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestLogs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestLogsScalarFieldEnum>
  }


  /**
   * RequestLogs create
   */
  export type RequestLogsCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestLogs
     * 
    **/
    select?: RequestLogsSelect | null
    /**
     * The data needed to create a RequestLogs.
     * 
    **/
    data: XOR<RequestLogsCreateInput, RequestLogsUncheckedCreateInput>
  }


  /**
   * RequestLogs createMany
   */
  export type RequestLogsCreateManyArgs = {
    data: Enumerable<RequestLogsCreateManyInput>
  }


  /**
   * RequestLogs update
   */
  export type RequestLogsUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestLogs
     * 
    **/
    select?: RequestLogsSelect | null
    /**
     * The data needed to update a RequestLogs.
     * 
    **/
    data: XOR<RequestLogsUpdateInput, RequestLogsUncheckedUpdateInput>
    /**
     * Choose, which RequestLogs to update.
     * 
    **/
    where: RequestLogsWhereUniqueInput
  }


  /**
   * RequestLogs updateMany
   */
  export type RequestLogsUpdateManyArgs = {
    data: XOR<RequestLogsUpdateManyMutationInput, RequestLogsUncheckedUpdateManyInput>
    where?: RequestLogsWhereInput
  }


  /**
   * RequestLogs upsert
   */
  export type RequestLogsUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestLogs
     * 
    **/
    select?: RequestLogsSelect | null
    /**
     * The filter to search for the RequestLogs to update in case it exists.
     * 
    **/
    where: RequestLogsWhereUniqueInput
    /**
     * In case the RequestLogs found by the `where` argument doesn't exist, create a new RequestLogs with this data.
     * 
    **/
    create: XOR<RequestLogsCreateInput, RequestLogsUncheckedCreateInput>
    /**
     * In case the RequestLogs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestLogsUpdateInput, RequestLogsUncheckedUpdateInput>
  }


  /**
   * RequestLogs delete
   */
  export type RequestLogsDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestLogs
     * 
    **/
    select?: RequestLogsSelect | null
    /**
     * Filter which RequestLogs to delete.
     * 
    **/
    where: RequestLogsWhereUniqueInput
  }


  /**
   * RequestLogs deleteMany
   */
  export type RequestLogsDeleteManyArgs = {
    where?: RequestLogsWhereInput
  }


  /**
   * RequestLogs without action
   */
  export type RequestLogsArgs = {
    /**
     * Select specific fields to fetch from the RequestLogs
     * 
    **/
    select?: RequestLogsSelect | null
  }



  /**
   * Model ReservedUsers
   */


  export type AggregateReservedUsers = {
    _count: ReservedUsersCountAggregateOutputType | null
    _min: ReservedUsersMinAggregateOutputType | null
    _max: ReservedUsersMaxAggregateOutputType | null
  }

  export type ReservedUsersMinAggregateOutputType = {
    Id: string | null
    User_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type ReservedUsersMaxAggregateOutputType = {
    Id: string | null
    User_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type ReservedUsersCountAggregateOutputType = {
    Id: number
    User_Id: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type ReservedUsersMinAggregateInputType = {
    Id?: true
    User_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type ReservedUsersMaxAggregateInputType = {
    Id?: true
    User_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type ReservedUsersCountAggregateInputType = {
    Id?: true
    User_Id?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type ReservedUsersAggregateArgs = {
    /**
     * Filter which ReservedUsers to aggregate.
     * 
    **/
    where?: ReservedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservedUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<ReservedUsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReservedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservedUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservedUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReservedUsers
    **/
    _count?: true | ReservedUsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservedUsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservedUsersMaxAggregateInputType
  }

  export type GetReservedUsersAggregateType<T extends ReservedUsersAggregateArgs> = {
        [P in keyof T & keyof AggregateReservedUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservedUsers[P]>
      : GetScalarType<T[P], AggregateReservedUsers[P]>
  }




  export type ReservedUsersGroupByArgs = {
    where?: ReservedUsersWhereInput
    orderBy?: Enumerable<ReservedUsersOrderByWithAggregationInput>
    by: Array<ReservedUsersScalarFieldEnum>
    having?: ReservedUsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservedUsersCountAggregateInputType | true
    _min?: ReservedUsersMinAggregateInputType
    _max?: ReservedUsersMaxAggregateInputType
  }


  export type ReservedUsersGroupByOutputType = {
    Id: string
    User_Id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: ReservedUsersCountAggregateOutputType | null
    _min: ReservedUsersMinAggregateOutputType | null
    _max: ReservedUsersMaxAggregateOutputType | null
  }

  type GetReservedUsersGroupByPayload<T extends ReservedUsersGroupByArgs> = Promise<
    Array<
      PickArray<ReservedUsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservedUsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservedUsersGroupByOutputType[P]>
            : GetScalarType<T[P], ReservedUsersGroupByOutputType[P]>
        }
      >
    >


  export type ReservedUsersSelect = {
    Id?: boolean
    User_Id?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type ReservedUsersGetPayload<
    S extends boolean | null | undefined | ReservedUsersArgs,
    U = keyof S
      > = S extends true
        ? ReservedUsers
    : S extends undefined
    ? never
    : S extends ReservedUsersArgs | ReservedUsersFindManyArgs
    ?'include' extends U
    ? ReservedUsers 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ReservedUsers ?ReservedUsers [P]
  : 
     never
  } 
    : ReservedUsers
  : ReservedUsers


  type ReservedUsersCountArgs = Merge<
    Omit<ReservedUsersFindManyArgs, 'select' | 'include'> & {
      select?: ReservedUsersCountAggregateInputType | true
    }
  >

  export interface ReservedUsersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ReservedUsers that matches the filter.
     * @param {ReservedUsersFindUniqueArgs} args - Arguments to find a ReservedUsers
     * @example
     * // Get one ReservedUsers
     * const reservedUsers = await prisma.reservedUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReservedUsersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReservedUsersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReservedUsers'> extends True ? CheckSelect<T, Prisma__ReservedUsersClient<ReservedUsers>, Prisma__ReservedUsersClient<ReservedUsersGetPayload<T>>> : CheckSelect<T, Prisma__ReservedUsersClient<ReservedUsers | null >, Prisma__ReservedUsersClient<ReservedUsersGetPayload<T> | null >>

    /**
     * Find the first ReservedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservedUsersFindFirstArgs} args - Arguments to find a ReservedUsers
     * @example
     * // Get one ReservedUsers
     * const reservedUsers = await prisma.reservedUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReservedUsersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReservedUsersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReservedUsers'> extends True ? CheckSelect<T, Prisma__ReservedUsersClient<ReservedUsers>, Prisma__ReservedUsersClient<ReservedUsersGetPayload<T>>> : CheckSelect<T, Prisma__ReservedUsersClient<ReservedUsers | null >, Prisma__ReservedUsersClient<ReservedUsersGetPayload<T> | null >>

    /**
     * Find zero or more ReservedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservedUsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReservedUsers
     * const reservedUsers = await prisma.reservedUsers.findMany()
     * 
     * // Get first 10 ReservedUsers
     * const reservedUsers = await prisma.reservedUsers.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const reservedUsersWithIdOnly = await prisma.reservedUsers.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ReservedUsersFindManyArgs>(
      args?: SelectSubset<T, ReservedUsersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ReservedUsers>>, PrismaPromise<Array<ReservedUsersGetPayload<T>>>>

    /**
     * Create a ReservedUsers.
     * @param {ReservedUsersCreateArgs} args - Arguments to create a ReservedUsers.
     * @example
     * // Create one ReservedUsers
     * const ReservedUsers = await prisma.reservedUsers.create({
     *   data: {
     *     // ... data to create a ReservedUsers
     *   }
     * })
     * 
    **/
    create<T extends ReservedUsersCreateArgs>(
      args: SelectSubset<T, ReservedUsersCreateArgs>
    ): CheckSelect<T, Prisma__ReservedUsersClient<ReservedUsers>, Prisma__ReservedUsersClient<ReservedUsersGetPayload<T>>>

    /**
     * Create many ReservedUsers.
     *     @param {ReservedUsersCreateManyArgs} args - Arguments to create many ReservedUsers.
     *     @example
     *     // Create many ReservedUsers
     *     const reservedUsers = await prisma.reservedUsers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReservedUsersCreateManyArgs>(
      args?: SelectSubset<T, ReservedUsersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ReservedUsers.
     * @param {ReservedUsersDeleteArgs} args - Arguments to delete one ReservedUsers.
     * @example
     * // Delete one ReservedUsers
     * const ReservedUsers = await prisma.reservedUsers.delete({
     *   where: {
     *     // ... filter to delete one ReservedUsers
     *   }
     * })
     * 
    **/
    delete<T extends ReservedUsersDeleteArgs>(
      args: SelectSubset<T, ReservedUsersDeleteArgs>
    ): CheckSelect<T, Prisma__ReservedUsersClient<ReservedUsers>, Prisma__ReservedUsersClient<ReservedUsersGetPayload<T>>>

    /**
     * Update one ReservedUsers.
     * @param {ReservedUsersUpdateArgs} args - Arguments to update one ReservedUsers.
     * @example
     * // Update one ReservedUsers
     * const reservedUsers = await prisma.reservedUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReservedUsersUpdateArgs>(
      args: SelectSubset<T, ReservedUsersUpdateArgs>
    ): CheckSelect<T, Prisma__ReservedUsersClient<ReservedUsers>, Prisma__ReservedUsersClient<ReservedUsersGetPayload<T>>>

    /**
     * Delete zero or more ReservedUsers.
     * @param {ReservedUsersDeleteManyArgs} args - Arguments to filter ReservedUsers to delete.
     * @example
     * // Delete a few ReservedUsers
     * const { count } = await prisma.reservedUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReservedUsersDeleteManyArgs>(
      args?: SelectSubset<T, ReservedUsersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReservedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservedUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReservedUsers
     * const reservedUsers = await prisma.reservedUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReservedUsersUpdateManyArgs>(
      args: SelectSubset<T, ReservedUsersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ReservedUsers.
     * @param {ReservedUsersUpsertArgs} args - Arguments to update or create a ReservedUsers.
     * @example
     * // Update or create a ReservedUsers
     * const reservedUsers = await prisma.reservedUsers.upsert({
     *   create: {
     *     // ... data to create a ReservedUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReservedUsers we want to update
     *   }
     * })
    **/
    upsert<T extends ReservedUsersUpsertArgs>(
      args: SelectSubset<T, ReservedUsersUpsertArgs>
    ): CheckSelect<T, Prisma__ReservedUsersClient<ReservedUsers>, Prisma__ReservedUsersClient<ReservedUsersGetPayload<T>>>

    /**
     * Count the number of ReservedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservedUsersCountArgs} args - Arguments to filter ReservedUsers to count.
     * @example
     * // Count the number of ReservedUsers
     * const count = await prisma.reservedUsers.count({
     *   where: {
     *     // ... the filter for the ReservedUsers we want to count
     *   }
     * })
    **/
    count<T extends ReservedUsersCountArgs>(
      args?: Subset<T, ReservedUsersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservedUsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReservedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservedUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservedUsersAggregateArgs>(args: Subset<T, ReservedUsersAggregateArgs>): PrismaPromise<GetReservedUsersAggregateType<T>>

    /**
     * Group by ReservedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservedUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservedUsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservedUsersGroupByArgs['orderBy'] }
        : { orderBy?: ReservedUsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservedUsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservedUsersGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReservedUsers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReservedUsersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ReservedUsers findUnique
   */
  export type ReservedUsersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ReservedUsers
     * 
    **/
    select?: ReservedUsersSelect | null
    /**
     * Throw an Error if a ReservedUsers can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReservedUsers to fetch.
     * 
    **/
    where: ReservedUsersWhereUniqueInput
  }


  /**
   * ReservedUsers findFirst
   */
  export type ReservedUsersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ReservedUsers
     * 
    **/
    select?: ReservedUsersSelect | null
    /**
     * Throw an Error if a ReservedUsers can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReservedUsers to fetch.
     * 
    **/
    where?: ReservedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservedUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<ReservedUsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReservedUsers.
     * 
    **/
    cursor?: ReservedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservedUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservedUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReservedUsers.
     * 
    **/
    distinct?: Enumerable<ReservedUsersScalarFieldEnum>
  }


  /**
   * ReservedUsers findMany
   */
  export type ReservedUsersFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReservedUsers
     * 
    **/
    select?: ReservedUsersSelect | null
    /**
     * Filter, which ReservedUsers to fetch.
     * 
    **/
    where?: ReservedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservedUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<ReservedUsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReservedUsers.
     * 
    **/
    cursor?: ReservedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservedUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservedUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReservedUsersScalarFieldEnum>
  }


  /**
   * ReservedUsers create
   */
  export type ReservedUsersCreateArgs = {
    /**
     * Select specific fields to fetch from the ReservedUsers
     * 
    **/
    select?: ReservedUsersSelect | null
    /**
     * The data needed to create a ReservedUsers.
     * 
    **/
    data: XOR<ReservedUsersCreateInput, ReservedUsersUncheckedCreateInput>
  }


  /**
   * ReservedUsers createMany
   */
  export type ReservedUsersCreateManyArgs = {
    data: Enumerable<ReservedUsersCreateManyInput>
  }


  /**
   * ReservedUsers update
   */
  export type ReservedUsersUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReservedUsers
     * 
    **/
    select?: ReservedUsersSelect | null
    /**
     * The data needed to update a ReservedUsers.
     * 
    **/
    data: XOR<ReservedUsersUpdateInput, ReservedUsersUncheckedUpdateInput>
    /**
     * Choose, which ReservedUsers to update.
     * 
    **/
    where: ReservedUsersWhereUniqueInput
  }


  /**
   * ReservedUsers updateMany
   */
  export type ReservedUsersUpdateManyArgs = {
    data: XOR<ReservedUsersUpdateManyMutationInput, ReservedUsersUncheckedUpdateManyInput>
    where?: ReservedUsersWhereInput
  }


  /**
   * ReservedUsers upsert
   */
  export type ReservedUsersUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReservedUsers
     * 
    **/
    select?: ReservedUsersSelect | null
    /**
     * The filter to search for the ReservedUsers to update in case it exists.
     * 
    **/
    where: ReservedUsersWhereUniqueInput
    /**
     * In case the ReservedUsers found by the `where` argument doesn't exist, create a new ReservedUsers with this data.
     * 
    **/
    create: XOR<ReservedUsersCreateInput, ReservedUsersUncheckedCreateInput>
    /**
     * In case the ReservedUsers was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReservedUsersUpdateInput, ReservedUsersUncheckedUpdateInput>
  }


  /**
   * ReservedUsers delete
   */
  export type ReservedUsersDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReservedUsers
     * 
    **/
    select?: ReservedUsersSelect | null
    /**
     * Filter which ReservedUsers to delete.
     * 
    **/
    where: ReservedUsersWhereUniqueInput
  }


  /**
   * ReservedUsers deleteMany
   */
  export type ReservedUsersDeleteManyArgs = {
    where?: ReservedUsersWhereInput
  }


  /**
   * ReservedUsers without action
   */
  export type ReservedUsersArgs = {
    /**
     * Select specific fields to fetch from the ReservedUsers
     * 
    **/
    select?: ReservedUsersSelect | null
  }



  /**
   * Model ResourceFiles
   */


  export type AggregateResourceFiles = {
    _count: ResourceFilesCountAggregateOutputType | null
    _min: ResourceFilesMinAggregateOutputType | null
    _max: ResourceFilesMaxAggregateOutputType | null
  }

  export type ResourceFilesMinAggregateOutputType = {
    Id: string | null
    MapItemId: string | null
    FileContent: Buffer | null
    FilePath: string | null
    Extension: string | null
    Name: string | null
    ModifiedDate: Date | null
    CreatedDate: Date | null
  }

  export type ResourceFilesMaxAggregateOutputType = {
    Id: string | null
    MapItemId: string | null
    FileContent: Buffer | null
    FilePath: string | null
    Extension: string | null
    Name: string | null
    ModifiedDate: Date | null
    CreatedDate: Date | null
  }

  export type ResourceFilesCountAggregateOutputType = {
    Id: number
    MapItemId: number
    FileContent: number
    FilePath: number
    Extension: number
    Name: number
    ModifiedDate: number
    CreatedDate: number
    _all: number
  }


  export type ResourceFilesMinAggregateInputType = {
    Id?: true
    MapItemId?: true
    FileContent?: true
    FilePath?: true
    Extension?: true
    Name?: true
    ModifiedDate?: true
    CreatedDate?: true
  }

  export type ResourceFilesMaxAggregateInputType = {
    Id?: true
    MapItemId?: true
    FileContent?: true
    FilePath?: true
    Extension?: true
    Name?: true
    ModifiedDate?: true
    CreatedDate?: true
  }

  export type ResourceFilesCountAggregateInputType = {
    Id?: true
    MapItemId?: true
    FileContent?: true
    FilePath?: true
    Extension?: true
    Name?: true
    ModifiedDate?: true
    CreatedDate?: true
    _all?: true
  }

  export type ResourceFilesAggregateArgs = {
    /**
     * Filter which ResourceFiles to aggregate.
     * 
    **/
    where?: ResourceFilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceFiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ResourceFilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ResourceFilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceFiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceFiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResourceFiles
    **/
    _count?: true | ResourceFilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceFilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceFilesMaxAggregateInputType
  }

  export type GetResourceFilesAggregateType<T extends ResourceFilesAggregateArgs> = {
        [P in keyof T & keyof AggregateResourceFiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResourceFiles[P]>
      : GetScalarType<T[P], AggregateResourceFiles[P]>
  }




  export type ResourceFilesGroupByArgs = {
    where?: ResourceFilesWhereInput
    orderBy?: Enumerable<ResourceFilesOrderByWithAggregationInput>
    by: Array<ResourceFilesScalarFieldEnum>
    having?: ResourceFilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceFilesCountAggregateInputType | true
    _min?: ResourceFilesMinAggregateInputType
    _max?: ResourceFilesMaxAggregateInputType
  }


  export type ResourceFilesGroupByOutputType = {
    Id: string
    MapItemId: string | null
    FileContent: Buffer | null
    FilePath: string | null
    Extension: string | null
    Name: string | null
    ModifiedDate: Date
    CreatedDate: Date
    _count: ResourceFilesCountAggregateOutputType | null
    _min: ResourceFilesMinAggregateOutputType | null
    _max: ResourceFilesMaxAggregateOutputType | null
  }

  type GetResourceFilesGroupByPayload<T extends ResourceFilesGroupByArgs> = Promise<
    Array<
      PickArray<ResourceFilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceFilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceFilesGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceFilesGroupByOutputType[P]>
        }
      >
    >


  export type ResourceFilesSelect = {
    Id?: boolean
    MapItemId?: boolean
    FileContent?: boolean
    FilePath?: boolean
    Extension?: boolean
    Name?: boolean
    ModifiedDate?: boolean
    CreatedDate?: boolean
  }

  export type ResourceFilesGetPayload<
    S extends boolean | null | undefined | ResourceFilesArgs,
    U = keyof S
      > = S extends true
        ? ResourceFiles
    : S extends undefined
    ? never
    : S extends ResourceFilesArgs | ResourceFilesFindManyArgs
    ?'include' extends U
    ? ResourceFiles 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ResourceFiles ?ResourceFiles [P]
  : 
     never
  } 
    : ResourceFiles
  : ResourceFiles


  type ResourceFilesCountArgs = Merge<
    Omit<ResourceFilesFindManyArgs, 'select' | 'include'> & {
      select?: ResourceFilesCountAggregateInputType | true
    }
  >

  export interface ResourceFilesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ResourceFiles that matches the filter.
     * @param {ResourceFilesFindUniqueArgs} args - Arguments to find a ResourceFiles
     * @example
     * // Get one ResourceFiles
     * const resourceFiles = await prisma.resourceFiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResourceFilesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ResourceFilesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ResourceFiles'> extends True ? CheckSelect<T, Prisma__ResourceFilesClient<ResourceFiles>, Prisma__ResourceFilesClient<ResourceFilesGetPayload<T>>> : CheckSelect<T, Prisma__ResourceFilesClient<ResourceFiles | null >, Prisma__ResourceFilesClient<ResourceFilesGetPayload<T> | null >>

    /**
     * Find the first ResourceFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFilesFindFirstArgs} args - Arguments to find a ResourceFiles
     * @example
     * // Get one ResourceFiles
     * const resourceFiles = await prisma.resourceFiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResourceFilesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ResourceFilesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ResourceFiles'> extends True ? CheckSelect<T, Prisma__ResourceFilesClient<ResourceFiles>, Prisma__ResourceFilesClient<ResourceFilesGetPayload<T>>> : CheckSelect<T, Prisma__ResourceFilesClient<ResourceFiles | null >, Prisma__ResourceFilesClient<ResourceFilesGetPayload<T> | null >>

    /**
     * Find zero or more ResourceFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFilesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResourceFiles
     * const resourceFiles = await prisma.resourceFiles.findMany()
     * 
     * // Get first 10 ResourceFiles
     * const resourceFiles = await prisma.resourceFiles.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const resourceFilesWithIdOnly = await prisma.resourceFiles.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ResourceFilesFindManyArgs>(
      args?: SelectSubset<T, ResourceFilesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ResourceFiles>>, PrismaPromise<Array<ResourceFilesGetPayload<T>>>>

    /**
     * Create a ResourceFiles.
     * @param {ResourceFilesCreateArgs} args - Arguments to create a ResourceFiles.
     * @example
     * // Create one ResourceFiles
     * const ResourceFiles = await prisma.resourceFiles.create({
     *   data: {
     *     // ... data to create a ResourceFiles
     *   }
     * })
     * 
    **/
    create<T extends ResourceFilesCreateArgs>(
      args: SelectSubset<T, ResourceFilesCreateArgs>
    ): CheckSelect<T, Prisma__ResourceFilesClient<ResourceFiles>, Prisma__ResourceFilesClient<ResourceFilesGetPayload<T>>>

    /**
     * Create many ResourceFiles.
     *     @param {ResourceFilesCreateManyArgs} args - Arguments to create many ResourceFiles.
     *     @example
     *     // Create many ResourceFiles
     *     const resourceFiles = await prisma.resourceFiles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResourceFilesCreateManyArgs>(
      args?: SelectSubset<T, ResourceFilesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ResourceFiles.
     * @param {ResourceFilesDeleteArgs} args - Arguments to delete one ResourceFiles.
     * @example
     * // Delete one ResourceFiles
     * const ResourceFiles = await prisma.resourceFiles.delete({
     *   where: {
     *     // ... filter to delete one ResourceFiles
     *   }
     * })
     * 
    **/
    delete<T extends ResourceFilesDeleteArgs>(
      args: SelectSubset<T, ResourceFilesDeleteArgs>
    ): CheckSelect<T, Prisma__ResourceFilesClient<ResourceFiles>, Prisma__ResourceFilesClient<ResourceFilesGetPayload<T>>>

    /**
     * Update one ResourceFiles.
     * @param {ResourceFilesUpdateArgs} args - Arguments to update one ResourceFiles.
     * @example
     * // Update one ResourceFiles
     * const resourceFiles = await prisma.resourceFiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResourceFilesUpdateArgs>(
      args: SelectSubset<T, ResourceFilesUpdateArgs>
    ): CheckSelect<T, Prisma__ResourceFilesClient<ResourceFiles>, Prisma__ResourceFilesClient<ResourceFilesGetPayload<T>>>

    /**
     * Delete zero or more ResourceFiles.
     * @param {ResourceFilesDeleteManyArgs} args - Arguments to filter ResourceFiles to delete.
     * @example
     * // Delete a few ResourceFiles
     * const { count } = await prisma.resourceFiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResourceFilesDeleteManyArgs>(
      args?: SelectSubset<T, ResourceFilesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResourceFiles
     * const resourceFiles = await prisma.resourceFiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResourceFilesUpdateManyArgs>(
      args: SelectSubset<T, ResourceFilesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ResourceFiles.
     * @param {ResourceFilesUpsertArgs} args - Arguments to update or create a ResourceFiles.
     * @example
     * // Update or create a ResourceFiles
     * const resourceFiles = await prisma.resourceFiles.upsert({
     *   create: {
     *     // ... data to create a ResourceFiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResourceFiles we want to update
     *   }
     * })
    **/
    upsert<T extends ResourceFilesUpsertArgs>(
      args: SelectSubset<T, ResourceFilesUpsertArgs>
    ): CheckSelect<T, Prisma__ResourceFilesClient<ResourceFiles>, Prisma__ResourceFilesClient<ResourceFilesGetPayload<T>>>

    /**
     * Count the number of ResourceFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFilesCountArgs} args - Arguments to filter ResourceFiles to count.
     * @example
     * // Count the number of ResourceFiles
     * const count = await prisma.resourceFiles.count({
     *   where: {
     *     // ... the filter for the ResourceFiles we want to count
     *   }
     * })
    **/
    count<T extends ResourceFilesCountArgs>(
      args?: Subset<T, ResourceFilesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceFilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResourceFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceFilesAggregateArgs>(args: Subset<T, ResourceFilesAggregateArgs>): PrismaPromise<GetResourceFilesAggregateType<T>>

    /**
     * Group by ResourceFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceFilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceFilesGroupByArgs['orderBy'] }
        : { orderBy?: ResourceFilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceFilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceFilesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResourceFiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ResourceFilesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ResourceFiles findUnique
   */
  export type ResourceFilesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ResourceFiles
     * 
    **/
    select?: ResourceFilesSelect | null
    /**
     * Throw an Error if a ResourceFiles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ResourceFiles to fetch.
     * 
    **/
    where: ResourceFilesWhereUniqueInput
  }


  /**
   * ResourceFiles findFirst
   */
  export type ResourceFilesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ResourceFiles
     * 
    **/
    select?: ResourceFilesSelect | null
    /**
     * Throw an Error if a ResourceFiles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ResourceFiles to fetch.
     * 
    **/
    where?: ResourceFilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceFiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ResourceFilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceFiles.
     * 
    **/
    cursor?: ResourceFilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceFiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceFiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceFiles.
     * 
    **/
    distinct?: Enumerable<ResourceFilesScalarFieldEnum>
  }


  /**
   * ResourceFiles findMany
   */
  export type ResourceFilesFindManyArgs = {
    /**
     * Select specific fields to fetch from the ResourceFiles
     * 
    **/
    select?: ResourceFilesSelect | null
    /**
     * Filter, which ResourceFiles to fetch.
     * 
    **/
    where?: ResourceFilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceFiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ResourceFilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResourceFiles.
     * 
    **/
    cursor?: ResourceFilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceFiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceFiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ResourceFilesScalarFieldEnum>
  }


  /**
   * ResourceFiles create
   */
  export type ResourceFilesCreateArgs = {
    /**
     * Select specific fields to fetch from the ResourceFiles
     * 
    **/
    select?: ResourceFilesSelect | null
    /**
     * The data needed to create a ResourceFiles.
     * 
    **/
    data: XOR<ResourceFilesCreateInput, ResourceFilesUncheckedCreateInput>
  }


  /**
   * ResourceFiles createMany
   */
  export type ResourceFilesCreateManyArgs = {
    data: Enumerable<ResourceFilesCreateManyInput>
  }


  /**
   * ResourceFiles update
   */
  export type ResourceFilesUpdateArgs = {
    /**
     * Select specific fields to fetch from the ResourceFiles
     * 
    **/
    select?: ResourceFilesSelect | null
    /**
     * The data needed to update a ResourceFiles.
     * 
    **/
    data: XOR<ResourceFilesUpdateInput, ResourceFilesUncheckedUpdateInput>
    /**
     * Choose, which ResourceFiles to update.
     * 
    **/
    where: ResourceFilesWhereUniqueInput
  }


  /**
   * ResourceFiles updateMany
   */
  export type ResourceFilesUpdateManyArgs = {
    data: XOR<ResourceFilesUpdateManyMutationInput, ResourceFilesUncheckedUpdateManyInput>
    where?: ResourceFilesWhereInput
  }


  /**
   * ResourceFiles upsert
   */
  export type ResourceFilesUpsertArgs = {
    /**
     * Select specific fields to fetch from the ResourceFiles
     * 
    **/
    select?: ResourceFilesSelect | null
    /**
     * The filter to search for the ResourceFiles to update in case it exists.
     * 
    **/
    where: ResourceFilesWhereUniqueInput
    /**
     * In case the ResourceFiles found by the `where` argument doesn't exist, create a new ResourceFiles with this data.
     * 
    **/
    create: XOR<ResourceFilesCreateInput, ResourceFilesUncheckedCreateInput>
    /**
     * In case the ResourceFiles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ResourceFilesUpdateInput, ResourceFilesUncheckedUpdateInput>
  }


  /**
   * ResourceFiles delete
   */
  export type ResourceFilesDeleteArgs = {
    /**
     * Select specific fields to fetch from the ResourceFiles
     * 
    **/
    select?: ResourceFilesSelect | null
    /**
     * Filter which ResourceFiles to delete.
     * 
    **/
    where: ResourceFilesWhereUniqueInput
  }


  /**
   * ResourceFiles deleteMany
   */
  export type ResourceFilesDeleteManyArgs = {
    where?: ResourceFilesWhereInput
  }


  /**
   * ResourceFiles without action
   */
  export type ResourceFilesArgs = {
    /**
     * Select specific fields to fetch from the ResourceFiles
     * 
    **/
    select?: ResourceFilesSelect | null
  }



  /**
   * Model Resources
   */


  export type AggregateResources = {
    _count: ResourcesCountAggregateOutputType | null
    _min: ResourcesMinAggregateOutputType | null
    _max: ResourcesMaxAggregateOutputType | null
  }

  export type ResourcesMinAggregateOutputType = {
    Id: string | null
    ResourceName: string | null
  }

  export type ResourcesMaxAggregateOutputType = {
    Id: string | null
    ResourceName: string | null
  }

  export type ResourcesCountAggregateOutputType = {
    Id: number
    ResourceName: number
    _all: number
  }


  export type ResourcesMinAggregateInputType = {
    Id?: true
    ResourceName?: true
  }

  export type ResourcesMaxAggregateInputType = {
    Id?: true
    ResourceName?: true
  }

  export type ResourcesCountAggregateInputType = {
    Id?: true
    ResourceName?: true
    _all?: true
  }

  export type ResourcesAggregateArgs = {
    /**
     * Filter which Resources to aggregate.
     * 
    **/
    where?: ResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     * 
    **/
    orderBy?: Enumerable<ResourcesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourcesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourcesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourcesMaxAggregateInputType
  }

  export type GetResourcesAggregateType<T extends ResourcesAggregateArgs> = {
        [P in keyof T & keyof AggregateResources]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResources[P]>
      : GetScalarType<T[P], AggregateResources[P]>
  }




  export type ResourcesGroupByArgs = {
    where?: ResourcesWhereInput
    orderBy?: Enumerable<ResourcesOrderByWithAggregationInput>
    by: Array<ResourcesScalarFieldEnum>
    having?: ResourcesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourcesCountAggregateInputType | true
    _min?: ResourcesMinAggregateInputType
    _max?: ResourcesMaxAggregateInputType
  }


  export type ResourcesGroupByOutputType = {
    Id: string
    ResourceName: string | null
    _count: ResourcesCountAggregateOutputType | null
    _min: ResourcesMinAggregateOutputType | null
    _max: ResourcesMaxAggregateOutputType | null
  }

  type GetResourcesGroupByPayload<T extends ResourcesGroupByArgs> = Promise<
    Array<
      PickArray<ResourcesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourcesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourcesGroupByOutputType[P]>
            : GetScalarType<T[P], ResourcesGroupByOutputType[P]>
        }
      >
    >


  export type ResourcesSelect = {
    Id?: boolean
    ResourceName?: boolean
  }

  export type ResourcesGetPayload<
    S extends boolean | null | undefined | ResourcesArgs,
    U = keyof S
      > = S extends true
        ? Resources
    : S extends undefined
    ? never
    : S extends ResourcesArgs | ResourcesFindManyArgs
    ?'include' extends U
    ? Resources 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Resources ?Resources [P]
  : 
     never
  } 
    : Resources
  : Resources


  type ResourcesCountArgs = Merge<
    Omit<ResourcesFindManyArgs, 'select' | 'include'> & {
      select?: ResourcesCountAggregateInputType | true
    }
  >

  export interface ResourcesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Resources that matches the filter.
     * @param {ResourcesFindUniqueArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResourcesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ResourcesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Resources'> extends True ? CheckSelect<T, Prisma__ResourcesClient<Resources>, Prisma__ResourcesClient<ResourcesGetPayload<T>>> : CheckSelect<T, Prisma__ResourcesClient<Resources | null >, Prisma__ResourcesClient<ResourcesGetPayload<T> | null >>

    /**
     * Find the first Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesFindFirstArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResourcesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ResourcesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Resources'> extends True ? CheckSelect<T, Prisma__ResourcesClient<Resources>, Prisma__ResourcesClient<ResourcesGetPayload<T>>> : CheckSelect<T, Prisma__ResourcesClient<Resources | null >, Prisma__ResourcesClient<ResourcesGetPayload<T> | null >>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resources.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resources.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const resourcesWithIdOnly = await prisma.resources.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ResourcesFindManyArgs>(
      args?: SelectSubset<T, ResourcesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Resources>>, PrismaPromise<Array<ResourcesGetPayload<T>>>>

    /**
     * Create a Resources.
     * @param {ResourcesCreateArgs} args - Arguments to create a Resources.
     * @example
     * // Create one Resources
     * const Resources = await prisma.resources.create({
     *   data: {
     *     // ... data to create a Resources
     *   }
     * })
     * 
    **/
    create<T extends ResourcesCreateArgs>(
      args: SelectSubset<T, ResourcesCreateArgs>
    ): CheckSelect<T, Prisma__ResourcesClient<Resources>, Prisma__ResourcesClient<ResourcesGetPayload<T>>>

    /**
     * Create many Resources.
     *     @param {ResourcesCreateManyArgs} args - Arguments to create many Resources.
     *     @example
     *     // Create many Resources
     *     const resources = await prisma.resources.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResourcesCreateManyArgs>(
      args?: SelectSubset<T, ResourcesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Resources.
     * @param {ResourcesDeleteArgs} args - Arguments to delete one Resources.
     * @example
     * // Delete one Resources
     * const Resources = await prisma.resources.delete({
     *   where: {
     *     // ... filter to delete one Resources
     *   }
     * })
     * 
    **/
    delete<T extends ResourcesDeleteArgs>(
      args: SelectSubset<T, ResourcesDeleteArgs>
    ): CheckSelect<T, Prisma__ResourcesClient<Resources>, Prisma__ResourcesClient<ResourcesGetPayload<T>>>

    /**
     * Update one Resources.
     * @param {ResourcesUpdateArgs} args - Arguments to update one Resources.
     * @example
     * // Update one Resources
     * const resources = await prisma.resources.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResourcesUpdateArgs>(
      args: SelectSubset<T, ResourcesUpdateArgs>
    ): CheckSelect<T, Prisma__ResourcesClient<Resources>, Prisma__ResourcesClient<ResourcesGetPayload<T>>>

    /**
     * Delete zero or more Resources.
     * @param {ResourcesDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resources.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResourcesDeleteManyArgs>(
      args?: SelectSubset<T, ResourcesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resources = await prisma.resources.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResourcesUpdateManyArgs>(
      args: SelectSubset<T, ResourcesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Resources.
     * @param {ResourcesUpsertArgs} args - Arguments to update or create a Resources.
     * @example
     * // Update or create a Resources
     * const resources = await prisma.resources.upsert({
     *   create: {
     *     // ... data to create a Resources
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resources we want to update
     *   }
     * })
    **/
    upsert<T extends ResourcesUpsertArgs>(
      args: SelectSubset<T, ResourcesUpsertArgs>
    ): CheckSelect<T, Prisma__ResourcesClient<Resources>, Prisma__ResourcesClient<ResourcesGetPayload<T>>>

    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resources.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourcesCountArgs>(
      args?: Subset<T, ResourcesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourcesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourcesAggregateArgs>(args: Subset<T, ResourcesAggregateArgs>): PrismaPromise<GetResourcesAggregateType<T>>

    /**
     * Group by Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourcesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourcesGroupByArgs['orderBy'] }
        : { orderBy?: ResourcesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourcesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourcesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resources.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ResourcesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Resources findUnique
   */
  export type ResourcesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Resources
     * 
    **/
    select?: ResourcesSelect | null
    /**
     * Throw an Error if a Resources can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Resources to fetch.
     * 
    **/
    where: ResourcesWhereUniqueInput
  }


  /**
   * Resources findFirst
   */
  export type ResourcesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Resources
     * 
    **/
    select?: ResourcesSelect | null
    /**
     * Throw an Error if a Resources can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Resources to fetch.
     * 
    **/
    where?: ResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     * 
    **/
    orderBy?: Enumerable<ResourcesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     * 
    **/
    cursor?: ResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     * 
    **/
    distinct?: Enumerable<ResourcesScalarFieldEnum>
  }


  /**
   * Resources findMany
   */
  export type ResourcesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Resources
     * 
    **/
    select?: ResourcesSelect | null
    /**
     * Filter, which Resources to fetch.
     * 
    **/
    where?: ResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     * 
    **/
    orderBy?: Enumerable<ResourcesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     * 
    **/
    cursor?: ResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ResourcesScalarFieldEnum>
  }


  /**
   * Resources create
   */
  export type ResourcesCreateArgs = {
    /**
     * Select specific fields to fetch from the Resources
     * 
    **/
    select?: ResourcesSelect | null
    /**
     * The data needed to create a Resources.
     * 
    **/
    data: XOR<ResourcesCreateInput, ResourcesUncheckedCreateInput>
  }


  /**
   * Resources createMany
   */
  export type ResourcesCreateManyArgs = {
    data: Enumerable<ResourcesCreateManyInput>
  }


  /**
   * Resources update
   */
  export type ResourcesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Resources
     * 
    **/
    select?: ResourcesSelect | null
    /**
     * The data needed to update a Resources.
     * 
    **/
    data: XOR<ResourcesUpdateInput, ResourcesUncheckedUpdateInput>
    /**
     * Choose, which Resources to update.
     * 
    **/
    where: ResourcesWhereUniqueInput
  }


  /**
   * Resources updateMany
   */
  export type ResourcesUpdateManyArgs = {
    data: XOR<ResourcesUpdateManyMutationInput, ResourcesUncheckedUpdateManyInput>
    where?: ResourcesWhereInput
  }


  /**
   * Resources upsert
   */
  export type ResourcesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Resources
     * 
    **/
    select?: ResourcesSelect | null
    /**
     * The filter to search for the Resources to update in case it exists.
     * 
    **/
    where: ResourcesWhereUniqueInput
    /**
     * In case the Resources found by the `where` argument doesn't exist, create a new Resources with this data.
     * 
    **/
    create: XOR<ResourcesCreateInput, ResourcesUncheckedCreateInput>
    /**
     * In case the Resources was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ResourcesUpdateInput, ResourcesUncheckedUpdateInput>
  }


  /**
   * Resources delete
   */
  export type ResourcesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Resources
     * 
    **/
    select?: ResourcesSelect | null
    /**
     * Filter which Resources to delete.
     * 
    **/
    where: ResourcesWhereUniqueInput
  }


  /**
   * Resources deleteMany
   */
  export type ResourcesDeleteManyArgs = {
    where?: ResourcesWhereInput
  }


  /**
   * Resources without action
   */
  export type ResourcesArgs = {
    /**
     * Select specific fields to fetch from the Resources
     * 
    **/
    select?: ResourcesSelect | null
  }



  /**
   * Model ReviewProcesses
   */


  export type AggregateReviewProcesses = {
    _count: ReviewProcessesCountAggregateOutputType | null
    _avg: ReviewProcessesAvgAggregateOutputType | null
    _sum: ReviewProcessesSumAggregateOutputType | null
    _min: ReviewProcessesMinAggregateOutputType | null
    _max: ReviewProcessesMaxAggregateOutputType | null
  }

  export type ReviewProcessesAvgAggregateOutputType = {
    WorkFlow: number | null
    AutoStatusUpdate: number | null
    ReviewStartType: number | null
    ElementRecursiveSelection: number | null
    ExternalUsersInvite: number | null
    EnableShare: number | null
    EmailNotification: number | null
  }

  export type ReviewProcessesSumAggregateOutputType = {
    WorkFlow: number | null
    AutoStatusUpdate: number | null
    ReviewStartType: number | null
    ElementRecursiveSelection: number | null
    ExternalUsersInvite: number | null
    EnableShare: number | null
    EmailNotification: number | null
  }

  export type ReviewProcessesMinAggregateOutputType = {
    Id: string | null
    Name: string | null
    Notes: string | null
    ReviewStartDate: Date | null
    ReviewEndDate: Date | null
    ApproveStartDate: Date | null
    ApproveEndDate: Date | null
    WorkFlow: number | null
    AutoStatusUpdate: number | null
    ReviewStartType: number | null
    ElementRecursiveSelection: number | null
    ExternalUsersInvite: number | null
    EnableShare: number | null
    EmailNotification: number | null
    Mode: string | null
    Repository_Id: string | null
    User_Id: string | null
    Status: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type ReviewProcessesMaxAggregateOutputType = {
    Id: string | null
    Name: string | null
    Notes: string | null
    ReviewStartDate: Date | null
    ReviewEndDate: Date | null
    ApproveStartDate: Date | null
    ApproveEndDate: Date | null
    WorkFlow: number | null
    AutoStatusUpdate: number | null
    ReviewStartType: number | null
    ElementRecursiveSelection: number | null
    ExternalUsersInvite: number | null
    EnableShare: number | null
    EmailNotification: number | null
    Mode: string | null
    Repository_Id: string | null
    User_Id: string | null
    Status: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type ReviewProcessesCountAggregateOutputType = {
    Id: number
    Name: number
    Notes: number
    ReviewStartDate: number
    ReviewEndDate: number
    ApproveStartDate: number
    ApproveEndDate: number
    WorkFlow: number
    AutoStatusUpdate: number
    ReviewStartType: number
    ElementRecursiveSelection: number
    ExternalUsersInvite: number
    EnableShare: number
    EmailNotification: number
    Mode: number
    Repository_Id: number
    User_Id: number
    Status: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type ReviewProcessesAvgAggregateInputType = {
    WorkFlow?: true
    AutoStatusUpdate?: true
    ReviewStartType?: true
    ElementRecursiveSelection?: true
    ExternalUsersInvite?: true
    EnableShare?: true
    EmailNotification?: true
  }

  export type ReviewProcessesSumAggregateInputType = {
    WorkFlow?: true
    AutoStatusUpdate?: true
    ReviewStartType?: true
    ElementRecursiveSelection?: true
    ExternalUsersInvite?: true
    EnableShare?: true
    EmailNotification?: true
  }

  export type ReviewProcessesMinAggregateInputType = {
    Id?: true
    Name?: true
    Notes?: true
    ReviewStartDate?: true
    ReviewEndDate?: true
    ApproveStartDate?: true
    ApproveEndDate?: true
    WorkFlow?: true
    AutoStatusUpdate?: true
    ReviewStartType?: true
    ElementRecursiveSelection?: true
    ExternalUsersInvite?: true
    EnableShare?: true
    EmailNotification?: true
    Mode?: true
    Repository_Id?: true
    User_Id?: true
    Status?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type ReviewProcessesMaxAggregateInputType = {
    Id?: true
    Name?: true
    Notes?: true
    ReviewStartDate?: true
    ReviewEndDate?: true
    ApproveStartDate?: true
    ApproveEndDate?: true
    WorkFlow?: true
    AutoStatusUpdate?: true
    ReviewStartType?: true
    ElementRecursiveSelection?: true
    ExternalUsersInvite?: true
    EnableShare?: true
    EmailNotification?: true
    Mode?: true
    Repository_Id?: true
    User_Id?: true
    Status?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type ReviewProcessesCountAggregateInputType = {
    Id?: true
    Name?: true
    Notes?: true
    ReviewStartDate?: true
    ReviewEndDate?: true
    ApproveStartDate?: true
    ApproveEndDate?: true
    WorkFlow?: true
    AutoStatusUpdate?: true
    ReviewStartType?: true
    ElementRecursiveSelection?: true
    ExternalUsersInvite?: true
    EnableShare?: true
    EmailNotification?: true
    Mode?: true
    Repository_Id?: true
    User_Id?: true
    Status?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type ReviewProcessesAggregateArgs = {
    /**
     * Filter which ReviewProcesses to aggregate.
     * 
    **/
    where?: ReviewProcessesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewProcesses to fetch.
     * 
    **/
    orderBy?: Enumerable<ReviewProcessesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReviewProcessesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewProcesses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewProcesses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewProcesses
    **/
    _count?: true | ReviewProcessesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewProcessesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewProcessesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewProcessesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewProcessesMaxAggregateInputType
  }

  export type GetReviewProcessesAggregateType<T extends ReviewProcessesAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewProcesses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewProcesses[P]>
      : GetScalarType<T[P], AggregateReviewProcesses[P]>
  }




  export type ReviewProcessesGroupByArgs = {
    where?: ReviewProcessesWhereInput
    orderBy?: Enumerable<ReviewProcessesOrderByWithAggregationInput>
    by: Array<ReviewProcessesScalarFieldEnum>
    having?: ReviewProcessesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewProcessesCountAggregateInputType | true
    _avg?: ReviewProcessesAvgAggregateInputType
    _sum?: ReviewProcessesSumAggregateInputType
    _min?: ReviewProcessesMinAggregateInputType
    _max?: ReviewProcessesMaxAggregateInputType
  }


  export type ReviewProcessesGroupByOutputType = {
    Id: string
    Name: string | null
    Notes: string | null
    ReviewStartDate: Date | null
    ReviewEndDate: Date | null
    ApproveStartDate: Date | null
    ApproveEndDate: Date | null
    WorkFlow: number | null
    AutoStatusUpdate: number | null
    ReviewStartType: number | null
    ElementRecursiveSelection: number | null
    ExternalUsersInvite: number | null
    EnableShare: number | null
    EmailNotification: number | null
    Mode: string | null
    Repository_Id: string | null
    User_Id: string | null
    Status: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: ReviewProcessesCountAggregateOutputType | null
    _avg: ReviewProcessesAvgAggregateOutputType | null
    _sum: ReviewProcessesSumAggregateOutputType | null
    _min: ReviewProcessesMinAggregateOutputType | null
    _max: ReviewProcessesMaxAggregateOutputType | null
  }

  type GetReviewProcessesGroupByPayload<T extends ReviewProcessesGroupByArgs> = Promise<
    Array<
      PickArray<ReviewProcessesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewProcessesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewProcessesGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewProcessesGroupByOutputType[P]>
        }
      >
    >


  export type ReviewProcessesSelect = {
    Id?: boolean
    Name?: boolean
    Notes?: boolean
    ReviewStartDate?: boolean
    ReviewEndDate?: boolean
    ApproveStartDate?: boolean
    ApproveEndDate?: boolean
    WorkFlow?: boolean
    AutoStatusUpdate?: boolean
    ReviewStartType?: boolean
    ElementRecursiveSelection?: boolean
    ExternalUsersInvite?: boolean
    EnableShare?: boolean
    EmailNotification?: boolean
    Mode?: boolean
    Repository_Id?: boolean
    User_Id?: boolean
    Status?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type ReviewProcessesGetPayload<
    S extends boolean | null | undefined | ReviewProcessesArgs,
    U = keyof S
      > = S extends true
        ? ReviewProcesses
    : S extends undefined
    ? never
    : S extends ReviewProcessesArgs | ReviewProcessesFindManyArgs
    ?'include' extends U
    ? ReviewProcesses 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ReviewProcesses ?ReviewProcesses [P]
  : 
     never
  } 
    : ReviewProcesses
  : ReviewProcesses


  type ReviewProcessesCountArgs = Merge<
    Omit<ReviewProcessesFindManyArgs, 'select' | 'include'> & {
      select?: ReviewProcessesCountAggregateInputType | true
    }
  >

  export interface ReviewProcessesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ReviewProcesses that matches the filter.
     * @param {ReviewProcessesFindUniqueArgs} args - Arguments to find a ReviewProcesses
     * @example
     * // Get one ReviewProcesses
     * const reviewProcesses = await prisma.reviewProcesses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReviewProcessesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReviewProcessesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReviewProcesses'> extends True ? CheckSelect<T, Prisma__ReviewProcessesClient<ReviewProcesses>, Prisma__ReviewProcessesClient<ReviewProcessesGetPayload<T>>> : CheckSelect<T, Prisma__ReviewProcessesClient<ReviewProcesses | null >, Prisma__ReviewProcessesClient<ReviewProcessesGetPayload<T> | null >>

    /**
     * Find the first ReviewProcesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewProcessesFindFirstArgs} args - Arguments to find a ReviewProcesses
     * @example
     * // Get one ReviewProcesses
     * const reviewProcesses = await prisma.reviewProcesses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReviewProcessesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReviewProcessesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReviewProcesses'> extends True ? CheckSelect<T, Prisma__ReviewProcessesClient<ReviewProcesses>, Prisma__ReviewProcessesClient<ReviewProcessesGetPayload<T>>> : CheckSelect<T, Prisma__ReviewProcessesClient<ReviewProcesses | null >, Prisma__ReviewProcessesClient<ReviewProcessesGetPayload<T> | null >>

    /**
     * Find zero or more ReviewProcesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewProcessesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewProcesses
     * const reviewProcesses = await prisma.reviewProcesses.findMany()
     * 
     * // Get first 10 ReviewProcesses
     * const reviewProcesses = await prisma.reviewProcesses.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const reviewProcessesWithIdOnly = await prisma.reviewProcesses.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ReviewProcessesFindManyArgs>(
      args?: SelectSubset<T, ReviewProcessesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ReviewProcesses>>, PrismaPromise<Array<ReviewProcessesGetPayload<T>>>>

    /**
     * Create a ReviewProcesses.
     * @param {ReviewProcessesCreateArgs} args - Arguments to create a ReviewProcesses.
     * @example
     * // Create one ReviewProcesses
     * const ReviewProcesses = await prisma.reviewProcesses.create({
     *   data: {
     *     // ... data to create a ReviewProcesses
     *   }
     * })
     * 
    **/
    create<T extends ReviewProcessesCreateArgs>(
      args: SelectSubset<T, ReviewProcessesCreateArgs>
    ): CheckSelect<T, Prisma__ReviewProcessesClient<ReviewProcesses>, Prisma__ReviewProcessesClient<ReviewProcessesGetPayload<T>>>

    /**
     * Create many ReviewProcesses.
     *     @param {ReviewProcessesCreateManyArgs} args - Arguments to create many ReviewProcesses.
     *     @example
     *     // Create many ReviewProcesses
     *     const reviewProcesses = await prisma.reviewProcesses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReviewProcessesCreateManyArgs>(
      args?: SelectSubset<T, ReviewProcessesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ReviewProcesses.
     * @param {ReviewProcessesDeleteArgs} args - Arguments to delete one ReviewProcesses.
     * @example
     * // Delete one ReviewProcesses
     * const ReviewProcesses = await prisma.reviewProcesses.delete({
     *   where: {
     *     // ... filter to delete one ReviewProcesses
     *   }
     * })
     * 
    **/
    delete<T extends ReviewProcessesDeleteArgs>(
      args: SelectSubset<T, ReviewProcessesDeleteArgs>
    ): CheckSelect<T, Prisma__ReviewProcessesClient<ReviewProcesses>, Prisma__ReviewProcessesClient<ReviewProcessesGetPayload<T>>>

    /**
     * Update one ReviewProcesses.
     * @param {ReviewProcessesUpdateArgs} args - Arguments to update one ReviewProcesses.
     * @example
     * // Update one ReviewProcesses
     * const reviewProcesses = await prisma.reviewProcesses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReviewProcessesUpdateArgs>(
      args: SelectSubset<T, ReviewProcessesUpdateArgs>
    ): CheckSelect<T, Prisma__ReviewProcessesClient<ReviewProcesses>, Prisma__ReviewProcessesClient<ReviewProcessesGetPayload<T>>>

    /**
     * Delete zero or more ReviewProcesses.
     * @param {ReviewProcessesDeleteManyArgs} args - Arguments to filter ReviewProcesses to delete.
     * @example
     * // Delete a few ReviewProcesses
     * const { count } = await prisma.reviewProcesses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReviewProcessesDeleteManyArgs>(
      args?: SelectSubset<T, ReviewProcessesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewProcessesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewProcesses
     * const reviewProcesses = await prisma.reviewProcesses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReviewProcessesUpdateManyArgs>(
      args: SelectSubset<T, ReviewProcessesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ReviewProcesses.
     * @param {ReviewProcessesUpsertArgs} args - Arguments to update or create a ReviewProcesses.
     * @example
     * // Update or create a ReviewProcesses
     * const reviewProcesses = await prisma.reviewProcesses.upsert({
     *   create: {
     *     // ... data to create a ReviewProcesses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewProcesses we want to update
     *   }
     * })
    **/
    upsert<T extends ReviewProcessesUpsertArgs>(
      args: SelectSubset<T, ReviewProcessesUpsertArgs>
    ): CheckSelect<T, Prisma__ReviewProcessesClient<ReviewProcesses>, Prisma__ReviewProcessesClient<ReviewProcessesGetPayload<T>>>

    /**
     * Count the number of ReviewProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewProcessesCountArgs} args - Arguments to filter ReviewProcesses to count.
     * @example
     * // Count the number of ReviewProcesses
     * const count = await prisma.reviewProcesses.count({
     *   where: {
     *     // ... the filter for the ReviewProcesses we want to count
     *   }
     * })
    **/
    count<T extends ReviewProcessesCountArgs>(
      args?: Subset<T, ReviewProcessesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewProcessesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewProcessesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewProcessesAggregateArgs>(args: Subset<T, ReviewProcessesAggregateArgs>): PrismaPromise<GetReviewProcessesAggregateType<T>>

    /**
     * Group by ReviewProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewProcessesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewProcessesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewProcessesGroupByArgs['orderBy'] }
        : { orderBy?: ReviewProcessesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewProcessesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewProcessesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewProcesses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReviewProcessesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ReviewProcesses findUnique
   */
  export type ReviewProcessesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ReviewProcesses
     * 
    **/
    select?: ReviewProcessesSelect | null
    /**
     * Throw an Error if a ReviewProcesses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReviewProcesses to fetch.
     * 
    **/
    where: ReviewProcessesWhereUniqueInput
  }


  /**
   * ReviewProcesses findFirst
   */
  export type ReviewProcessesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ReviewProcesses
     * 
    **/
    select?: ReviewProcessesSelect | null
    /**
     * Throw an Error if a ReviewProcesses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReviewProcesses to fetch.
     * 
    **/
    where?: ReviewProcessesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewProcesses to fetch.
     * 
    **/
    orderBy?: Enumerable<ReviewProcessesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewProcesses.
     * 
    **/
    cursor?: ReviewProcessesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewProcesses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewProcesses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewProcesses.
     * 
    **/
    distinct?: Enumerable<ReviewProcessesScalarFieldEnum>
  }


  /**
   * ReviewProcesses findMany
   */
  export type ReviewProcessesFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReviewProcesses
     * 
    **/
    select?: ReviewProcessesSelect | null
    /**
     * Filter, which ReviewProcesses to fetch.
     * 
    **/
    where?: ReviewProcessesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewProcesses to fetch.
     * 
    **/
    orderBy?: Enumerable<ReviewProcessesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewProcesses.
     * 
    **/
    cursor?: ReviewProcessesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewProcesses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewProcesses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReviewProcessesScalarFieldEnum>
  }


  /**
   * ReviewProcesses create
   */
  export type ReviewProcessesCreateArgs = {
    /**
     * Select specific fields to fetch from the ReviewProcesses
     * 
    **/
    select?: ReviewProcessesSelect | null
    /**
     * The data needed to create a ReviewProcesses.
     * 
    **/
    data: XOR<ReviewProcessesCreateInput, ReviewProcessesUncheckedCreateInput>
  }


  /**
   * ReviewProcesses createMany
   */
  export type ReviewProcessesCreateManyArgs = {
    data: Enumerable<ReviewProcessesCreateManyInput>
  }


  /**
   * ReviewProcesses update
   */
  export type ReviewProcessesUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReviewProcesses
     * 
    **/
    select?: ReviewProcessesSelect | null
    /**
     * The data needed to update a ReviewProcesses.
     * 
    **/
    data: XOR<ReviewProcessesUpdateInput, ReviewProcessesUncheckedUpdateInput>
    /**
     * Choose, which ReviewProcesses to update.
     * 
    **/
    where: ReviewProcessesWhereUniqueInput
  }


  /**
   * ReviewProcesses updateMany
   */
  export type ReviewProcessesUpdateManyArgs = {
    data: XOR<ReviewProcessesUpdateManyMutationInput, ReviewProcessesUncheckedUpdateManyInput>
    where?: ReviewProcessesWhereInput
  }


  /**
   * ReviewProcesses upsert
   */
  export type ReviewProcessesUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReviewProcesses
     * 
    **/
    select?: ReviewProcessesSelect | null
    /**
     * The filter to search for the ReviewProcesses to update in case it exists.
     * 
    **/
    where: ReviewProcessesWhereUniqueInput
    /**
     * In case the ReviewProcesses found by the `where` argument doesn't exist, create a new ReviewProcesses with this data.
     * 
    **/
    create: XOR<ReviewProcessesCreateInput, ReviewProcessesUncheckedCreateInput>
    /**
     * In case the ReviewProcesses was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReviewProcessesUpdateInput, ReviewProcessesUncheckedUpdateInput>
  }


  /**
   * ReviewProcesses delete
   */
  export type ReviewProcessesDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReviewProcesses
     * 
    **/
    select?: ReviewProcessesSelect | null
    /**
     * Filter which ReviewProcesses to delete.
     * 
    **/
    where: ReviewProcessesWhereUniqueInput
  }


  /**
   * ReviewProcesses deleteMany
   */
  export type ReviewProcessesDeleteManyArgs = {
    where?: ReviewProcessesWhereInput
  }


  /**
   * ReviewProcesses without action
   */
  export type ReviewProcessesArgs = {
    /**
     * Select specific fields to fetch from the ReviewProcesses
     * 
    **/
    select?: ReviewProcessesSelect | null
  }



  /**
   * Model TaggedValues
   */


  export type AggregateTaggedValues = {
    _count: TaggedValuesCountAggregateOutputType | null
    _avg: TaggedValuesAvgAggregateOutputType | null
    _sum: TaggedValuesSumAggregateOutputType | null
    _min: TaggedValuesMinAggregateOutputType | null
    _max: TaggedValuesMaxAggregateOutputType | null
  }

  export type TaggedValuesAvgAggregateOutputType = {
    LowerBound: number | null
    UpperBound: number | null
  }

  export type TaggedValuesSumAggregateOutputType = {
    LowerBound: number | null
    UpperBound: number | null
  }

  export type TaggedValuesMinAggregateOutputType = {
    Id: string | null
    RepositoryId: string | null
    Name: string | null
    Description: string | null
    Type: string | null
    DefaultValue: string | null
    AttributeValues: string | null
    LowerBound: number | null
    UpperBound: number | null
    Stereotypes: string | null
    AppliesTo: string | null
    BaseStereotype: string | null
  }

  export type TaggedValuesMaxAggregateOutputType = {
    Id: string | null
    RepositoryId: string | null
    Name: string | null
    Description: string | null
    Type: string | null
    DefaultValue: string | null
    AttributeValues: string | null
    LowerBound: number | null
    UpperBound: number | null
    Stereotypes: string | null
    AppliesTo: string | null
    BaseStereotype: string | null
  }

  export type TaggedValuesCountAggregateOutputType = {
    Id: number
    RepositoryId: number
    Name: number
    Description: number
    Type: number
    DefaultValue: number
    AttributeValues: number
    LowerBound: number
    UpperBound: number
    Stereotypes: number
    AppliesTo: number
    BaseStereotype: number
    _all: number
  }


  export type TaggedValuesAvgAggregateInputType = {
    LowerBound?: true
    UpperBound?: true
  }

  export type TaggedValuesSumAggregateInputType = {
    LowerBound?: true
    UpperBound?: true
  }

  export type TaggedValuesMinAggregateInputType = {
    Id?: true
    RepositoryId?: true
    Name?: true
    Description?: true
    Type?: true
    DefaultValue?: true
    AttributeValues?: true
    LowerBound?: true
    UpperBound?: true
    Stereotypes?: true
    AppliesTo?: true
    BaseStereotype?: true
  }

  export type TaggedValuesMaxAggregateInputType = {
    Id?: true
    RepositoryId?: true
    Name?: true
    Description?: true
    Type?: true
    DefaultValue?: true
    AttributeValues?: true
    LowerBound?: true
    UpperBound?: true
    Stereotypes?: true
    AppliesTo?: true
    BaseStereotype?: true
  }

  export type TaggedValuesCountAggregateInputType = {
    Id?: true
    RepositoryId?: true
    Name?: true
    Description?: true
    Type?: true
    DefaultValue?: true
    AttributeValues?: true
    LowerBound?: true
    UpperBound?: true
    Stereotypes?: true
    AppliesTo?: true
    BaseStereotype?: true
    _all?: true
  }

  export type TaggedValuesAggregateArgs = {
    /**
     * Filter which TaggedValues to aggregate.
     * 
    **/
    where?: TaggedValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaggedValues to fetch.
     * 
    **/
    orderBy?: Enumerable<TaggedValuesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TaggedValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaggedValues from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaggedValues.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaggedValues
    **/
    _count?: true | TaggedValuesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaggedValuesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaggedValuesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaggedValuesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaggedValuesMaxAggregateInputType
  }

  export type GetTaggedValuesAggregateType<T extends TaggedValuesAggregateArgs> = {
        [P in keyof T & keyof AggregateTaggedValues]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaggedValues[P]>
      : GetScalarType<T[P], AggregateTaggedValues[P]>
  }




  export type TaggedValuesGroupByArgs = {
    where?: TaggedValuesWhereInput
    orderBy?: Enumerable<TaggedValuesOrderByWithAggregationInput>
    by: Array<TaggedValuesScalarFieldEnum>
    having?: TaggedValuesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaggedValuesCountAggregateInputType | true
    _avg?: TaggedValuesAvgAggregateInputType
    _sum?: TaggedValuesSumAggregateInputType
    _min?: TaggedValuesMinAggregateInputType
    _max?: TaggedValuesMaxAggregateInputType
  }


  export type TaggedValuesGroupByOutputType = {
    Id: string
    RepositoryId: string
    Name: string
    Description: string | null
    Type: string
    DefaultValue: string | null
    AttributeValues: string | null
    LowerBound: number | null
    UpperBound: number | null
    Stereotypes: string | null
    AppliesTo: string | null
    BaseStereotype: string | null
    _count: TaggedValuesCountAggregateOutputType | null
    _avg: TaggedValuesAvgAggregateOutputType | null
    _sum: TaggedValuesSumAggregateOutputType | null
    _min: TaggedValuesMinAggregateOutputType | null
    _max: TaggedValuesMaxAggregateOutputType | null
  }

  type GetTaggedValuesGroupByPayload<T extends TaggedValuesGroupByArgs> = Promise<
    Array<
      PickArray<TaggedValuesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaggedValuesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaggedValuesGroupByOutputType[P]>
            : GetScalarType<T[P], TaggedValuesGroupByOutputType[P]>
        }
      >
    >


  export type TaggedValuesSelect = {
    Id?: boolean
    RepositoryId?: boolean
    Name?: boolean
    Description?: boolean
    Type?: boolean
    DefaultValue?: boolean
    AttributeValues?: boolean
    LowerBound?: boolean
    UpperBound?: boolean
    Stereotypes?: boolean
    AppliesTo?: boolean
    BaseStereotype?: boolean
  }

  export type TaggedValuesGetPayload<
    S extends boolean | null | undefined | TaggedValuesArgs,
    U = keyof S
      > = S extends true
        ? TaggedValues
    : S extends undefined
    ? never
    : S extends TaggedValuesArgs | TaggedValuesFindManyArgs
    ?'include' extends U
    ? TaggedValues 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TaggedValues ?TaggedValues [P]
  : 
     never
  } 
    : TaggedValues
  : TaggedValues


  type TaggedValuesCountArgs = Merge<
    Omit<TaggedValuesFindManyArgs, 'select' | 'include'> & {
      select?: TaggedValuesCountAggregateInputType | true
    }
  >

  export interface TaggedValuesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TaggedValues that matches the filter.
     * @param {TaggedValuesFindUniqueArgs} args - Arguments to find a TaggedValues
     * @example
     * // Get one TaggedValues
     * const taggedValues = await prisma.taggedValues.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaggedValuesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TaggedValuesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TaggedValues'> extends True ? CheckSelect<T, Prisma__TaggedValuesClient<TaggedValues>, Prisma__TaggedValuesClient<TaggedValuesGetPayload<T>>> : CheckSelect<T, Prisma__TaggedValuesClient<TaggedValues | null >, Prisma__TaggedValuesClient<TaggedValuesGetPayload<T> | null >>

    /**
     * Find the first TaggedValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaggedValuesFindFirstArgs} args - Arguments to find a TaggedValues
     * @example
     * // Get one TaggedValues
     * const taggedValues = await prisma.taggedValues.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaggedValuesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TaggedValuesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TaggedValues'> extends True ? CheckSelect<T, Prisma__TaggedValuesClient<TaggedValues>, Prisma__TaggedValuesClient<TaggedValuesGetPayload<T>>> : CheckSelect<T, Prisma__TaggedValuesClient<TaggedValues | null >, Prisma__TaggedValuesClient<TaggedValuesGetPayload<T> | null >>

    /**
     * Find zero or more TaggedValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaggedValuesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaggedValues
     * const taggedValues = await prisma.taggedValues.findMany()
     * 
     * // Get first 10 TaggedValues
     * const taggedValues = await prisma.taggedValues.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const taggedValuesWithIdOnly = await prisma.taggedValues.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends TaggedValuesFindManyArgs>(
      args?: SelectSubset<T, TaggedValuesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TaggedValues>>, PrismaPromise<Array<TaggedValuesGetPayload<T>>>>

    /**
     * Create a TaggedValues.
     * @param {TaggedValuesCreateArgs} args - Arguments to create a TaggedValues.
     * @example
     * // Create one TaggedValues
     * const TaggedValues = await prisma.taggedValues.create({
     *   data: {
     *     // ... data to create a TaggedValues
     *   }
     * })
     * 
    **/
    create<T extends TaggedValuesCreateArgs>(
      args: SelectSubset<T, TaggedValuesCreateArgs>
    ): CheckSelect<T, Prisma__TaggedValuesClient<TaggedValues>, Prisma__TaggedValuesClient<TaggedValuesGetPayload<T>>>

    /**
     * Create many TaggedValues.
     *     @param {TaggedValuesCreateManyArgs} args - Arguments to create many TaggedValues.
     *     @example
     *     // Create many TaggedValues
     *     const taggedValues = await prisma.taggedValues.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TaggedValuesCreateManyArgs>(
      args?: SelectSubset<T, TaggedValuesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TaggedValues.
     * @param {TaggedValuesDeleteArgs} args - Arguments to delete one TaggedValues.
     * @example
     * // Delete one TaggedValues
     * const TaggedValues = await prisma.taggedValues.delete({
     *   where: {
     *     // ... filter to delete one TaggedValues
     *   }
     * })
     * 
    **/
    delete<T extends TaggedValuesDeleteArgs>(
      args: SelectSubset<T, TaggedValuesDeleteArgs>
    ): CheckSelect<T, Prisma__TaggedValuesClient<TaggedValues>, Prisma__TaggedValuesClient<TaggedValuesGetPayload<T>>>

    /**
     * Update one TaggedValues.
     * @param {TaggedValuesUpdateArgs} args - Arguments to update one TaggedValues.
     * @example
     * // Update one TaggedValues
     * const taggedValues = await prisma.taggedValues.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaggedValuesUpdateArgs>(
      args: SelectSubset<T, TaggedValuesUpdateArgs>
    ): CheckSelect<T, Prisma__TaggedValuesClient<TaggedValues>, Prisma__TaggedValuesClient<TaggedValuesGetPayload<T>>>

    /**
     * Delete zero or more TaggedValues.
     * @param {TaggedValuesDeleteManyArgs} args - Arguments to filter TaggedValues to delete.
     * @example
     * // Delete a few TaggedValues
     * const { count } = await prisma.taggedValues.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaggedValuesDeleteManyArgs>(
      args?: SelectSubset<T, TaggedValuesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaggedValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaggedValuesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaggedValues
     * const taggedValues = await prisma.taggedValues.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaggedValuesUpdateManyArgs>(
      args: SelectSubset<T, TaggedValuesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TaggedValues.
     * @param {TaggedValuesUpsertArgs} args - Arguments to update or create a TaggedValues.
     * @example
     * // Update or create a TaggedValues
     * const taggedValues = await prisma.taggedValues.upsert({
     *   create: {
     *     // ... data to create a TaggedValues
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaggedValues we want to update
     *   }
     * })
    **/
    upsert<T extends TaggedValuesUpsertArgs>(
      args: SelectSubset<T, TaggedValuesUpsertArgs>
    ): CheckSelect<T, Prisma__TaggedValuesClient<TaggedValues>, Prisma__TaggedValuesClient<TaggedValuesGetPayload<T>>>

    /**
     * Count the number of TaggedValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaggedValuesCountArgs} args - Arguments to filter TaggedValues to count.
     * @example
     * // Count the number of TaggedValues
     * const count = await prisma.taggedValues.count({
     *   where: {
     *     // ... the filter for the TaggedValues we want to count
     *   }
     * })
    **/
    count<T extends TaggedValuesCountArgs>(
      args?: Subset<T, TaggedValuesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaggedValuesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaggedValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaggedValuesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaggedValuesAggregateArgs>(args: Subset<T, TaggedValuesAggregateArgs>): PrismaPromise<GetTaggedValuesAggregateType<T>>

    /**
     * Group by TaggedValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaggedValuesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaggedValuesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaggedValuesGroupByArgs['orderBy'] }
        : { orderBy?: TaggedValuesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaggedValuesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaggedValuesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaggedValues.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TaggedValuesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TaggedValues findUnique
   */
  export type TaggedValuesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TaggedValues
     * 
    **/
    select?: TaggedValuesSelect | null
    /**
     * Throw an Error if a TaggedValues can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TaggedValues to fetch.
     * 
    **/
    where: TaggedValuesWhereUniqueInput
  }


  /**
   * TaggedValues findFirst
   */
  export type TaggedValuesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TaggedValues
     * 
    **/
    select?: TaggedValuesSelect | null
    /**
     * Throw an Error if a TaggedValues can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TaggedValues to fetch.
     * 
    **/
    where?: TaggedValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaggedValues to fetch.
     * 
    **/
    orderBy?: Enumerable<TaggedValuesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaggedValues.
     * 
    **/
    cursor?: TaggedValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaggedValues from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaggedValues.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaggedValues.
     * 
    **/
    distinct?: Enumerable<TaggedValuesScalarFieldEnum>
  }


  /**
   * TaggedValues findMany
   */
  export type TaggedValuesFindManyArgs = {
    /**
     * Select specific fields to fetch from the TaggedValues
     * 
    **/
    select?: TaggedValuesSelect | null
    /**
     * Filter, which TaggedValues to fetch.
     * 
    **/
    where?: TaggedValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaggedValues to fetch.
     * 
    **/
    orderBy?: Enumerable<TaggedValuesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaggedValues.
     * 
    **/
    cursor?: TaggedValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaggedValues from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaggedValues.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TaggedValuesScalarFieldEnum>
  }


  /**
   * TaggedValues create
   */
  export type TaggedValuesCreateArgs = {
    /**
     * Select specific fields to fetch from the TaggedValues
     * 
    **/
    select?: TaggedValuesSelect | null
    /**
     * The data needed to create a TaggedValues.
     * 
    **/
    data: XOR<TaggedValuesCreateInput, TaggedValuesUncheckedCreateInput>
  }


  /**
   * TaggedValues createMany
   */
  export type TaggedValuesCreateManyArgs = {
    data: Enumerable<TaggedValuesCreateManyInput>
  }


  /**
   * TaggedValues update
   */
  export type TaggedValuesUpdateArgs = {
    /**
     * Select specific fields to fetch from the TaggedValues
     * 
    **/
    select?: TaggedValuesSelect | null
    /**
     * The data needed to update a TaggedValues.
     * 
    **/
    data: XOR<TaggedValuesUpdateInput, TaggedValuesUncheckedUpdateInput>
    /**
     * Choose, which TaggedValues to update.
     * 
    **/
    where: TaggedValuesWhereUniqueInput
  }


  /**
   * TaggedValues updateMany
   */
  export type TaggedValuesUpdateManyArgs = {
    data: XOR<TaggedValuesUpdateManyMutationInput, TaggedValuesUncheckedUpdateManyInput>
    where?: TaggedValuesWhereInput
  }


  /**
   * TaggedValues upsert
   */
  export type TaggedValuesUpsertArgs = {
    /**
     * Select specific fields to fetch from the TaggedValues
     * 
    **/
    select?: TaggedValuesSelect | null
    /**
     * The filter to search for the TaggedValues to update in case it exists.
     * 
    **/
    where: TaggedValuesWhereUniqueInput
    /**
     * In case the TaggedValues found by the `where` argument doesn't exist, create a new TaggedValues with this data.
     * 
    **/
    create: XOR<TaggedValuesCreateInput, TaggedValuesUncheckedCreateInput>
    /**
     * In case the TaggedValues was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TaggedValuesUpdateInput, TaggedValuesUncheckedUpdateInput>
  }


  /**
   * TaggedValues delete
   */
  export type TaggedValuesDeleteArgs = {
    /**
     * Select specific fields to fetch from the TaggedValues
     * 
    **/
    select?: TaggedValuesSelect | null
    /**
     * Filter which TaggedValues to delete.
     * 
    **/
    where: TaggedValuesWhereUniqueInput
  }


  /**
   * TaggedValues deleteMany
   */
  export type TaggedValuesDeleteManyArgs = {
    where?: TaggedValuesWhereInput
  }


  /**
   * TaggedValues without action
   */
  export type TaggedValuesArgs = {
    /**
     * Select specific fields to fetch from the TaggedValues
     * 
    **/
    select?: TaggedValuesSelect | null
  }



  /**
   * Model TraceabilityTreeProfiles
   */


  export type AggregateTraceabilityTreeProfiles = {
    _count: TraceabilityTreeProfilesCountAggregateOutputType | null
    _avg: TraceabilityTreeProfilesAvgAggregateOutputType | null
    _sum: TraceabilityTreeProfilesSumAggregateOutputType | null
    _min: TraceabilityTreeProfilesMinAggregateOutputType | null
    _max: TraceabilityTreeProfilesMaxAggregateOutputType | null
  }

  export type TraceabilityTreeProfilesAvgAggregateOutputType = {
    Status: number | null
    IsApplytoAll: number | null
    IsApplytoType: number | null
    IsApplytoSteroType: number | null
  }

  export type TraceabilityTreeProfilesSumAggregateOutputType = {
    Status: number | null
    IsApplytoAll: number | null
    IsApplytoType: number | null
    IsApplytoSteroType: number | null
  }

  export type TraceabilityTreeProfilesMinAggregateOutputType = {
    Id: string | null
    ProfileName: string | null
    RepositoryId: string | null
    ElementGuid: string | null
    Type: string | null
    SteroType: string | null
    FQName: string | null
    Technology: string | null
    TemplateOptions: string | null
    User_Id: string | null
    Status: number | null
    IsApplytoAll: number | null
    IsApplytoType: number | null
    IsApplytoSteroType: number | null
    Created: Date | null
    Modified: Date | null
    ElementTypeList: string | null
    ConnectorTypeList: string | null
    FlowDirectionTypeList: string | null
    TreeType: string | null
  }

  export type TraceabilityTreeProfilesMaxAggregateOutputType = {
    Id: string | null
    ProfileName: string | null
    RepositoryId: string | null
    ElementGuid: string | null
    Type: string | null
    SteroType: string | null
    FQName: string | null
    Technology: string | null
    TemplateOptions: string | null
    User_Id: string | null
    Status: number | null
    IsApplytoAll: number | null
    IsApplytoType: number | null
    IsApplytoSteroType: number | null
    Created: Date | null
    Modified: Date | null
    ElementTypeList: string | null
    ConnectorTypeList: string | null
    FlowDirectionTypeList: string | null
    TreeType: string | null
  }

  export type TraceabilityTreeProfilesCountAggregateOutputType = {
    Id: number
    ProfileName: number
    RepositoryId: number
    ElementGuid: number
    Type: number
    SteroType: number
    FQName: number
    Technology: number
    TemplateOptions: number
    User_Id: number
    Status: number
    IsApplytoAll: number
    IsApplytoType: number
    IsApplytoSteroType: number
    Created: number
    Modified: number
    ElementTypeList: number
    ConnectorTypeList: number
    FlowDirectionTypeList: number
    TreeType: number
    _all: number
  }


  export type TraceabilityTreeProfilesAvgAggregateInputType = {
    Status?: true
    IsApplytoAll?: true
    IsApplytoType?: true
    IsApplytoSteroType?: true
  }

  export type TraceabilityTreeProfilesSumAggregateInputType = {
    Status?: true
    IsApplytoAll?: true
    IsApplytoType?: true
    IsApplytoSteroType?: true
  }

  export type TraceabilityTreeProfilesMinAggregateInputType = {
    Id?: true
    ProfileName?: true
    RepositoryId?: true
    ElementGuid?: true
    Type?: true
    SteroType?: true
    FQName?: true
    Technology?: true
    TemplateOptions?: true
    User_Id?: true
    Status?: true
    IsApplytoAll?: true
    IsApplytoType?: true
    IsApplytoSteroType?: true
    Created?: true
    Modified?: true
    ElementTypeList?: true
    ConnectorTypeList?: true
    FlowDirectionTypeList?: true
    TreeType?: true
  }

  export type TraceabilityTreeProfilesMaxAggregateInputType = {
    Id?: true
    ProfileName?: true
    RepositoryId?: true
    ElementGuid?: true
    Type?: true
    SteroType?: true
    FQName?: true
    Technology?: true
    TemplateOptions?: true
    User_Id?: true
    Status?: true
    IsApplytoAll?: true
    IsApplytoType?: true
    IsApplytoSteroType?: true
    Created?: true
    Modified?: true
    ElementTypeList?: true
    ConnectorTypeList?: true
    FlowDirectionTypeList?: true
    TreeType?: true
  }

  export type TraceabilityTreeProfilesCountAggregateInputType = {
    Id?: true
    ProfileName?: true
    RepositoryId?: true
    ElementGuid?: true
    Type?: true
    SteroType?: true
    FQName?: true
    Technology?: true
    TemplateOptions?: true
    User_Id?: true
    Status?: true
    IsApplytoAll?: true
    IsApplytoType?: true
    IsApplytoSteroType?: true
    Created?: true
    Modified?: true
    ElementTypeList?: true
    ConnectorTypeList?: true
    FlowDirectionTypeList?: true
    TreeType?: true
    _all?: true
  }

  export type TraceabilityTreeProfilesAggregateArgs = {
    /**
     * Filter which TraceabilityTreeProfiles to aggregate.
     * 
    **/
    where?: TraceabilityTreeProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceabilityTreeProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<TraceabilityTreeProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TraceabilityTreeProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceabilityTreeProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceabilityTreeProfiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TraceabilityTreeProfiles
    **/
    _count?: true | TraceabilityTreeProfilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TraceabilityTreeProfilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TraceabilityTreeProfilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TraceabilityTreeProfilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TraceabilityTreeProfilesMaxAggregateInputType
  }

  export type GetTraceabilityTreeProfilesAggregateType<T extends TraceabilityTreeProfilesAggregateArgs> = {
        [P in keyof T & keyof AggregateTraceabilityTreeProfiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraceabilityTreeProfiles[P]>
      : GetScalarType<T[P], AggregateTraceabilityTreeProfiles[P]>
  }




  export type TraceabilityTreeProfilesGroupByArgs = {
    where?: TraceabilityTreeProfilesWhereInput
    orderBy?: Enumerable<TraceabilityTreeProfilesOrderByWithAggregationInput>
    by: Array<TraceabilityTreeProfilesScalarFieldEnum>
    having?: TraceabilityTreeProfilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TraceabilityTreeProfilesCountAggregateInputType | true
    _avg?: TraceabilityTreeProfilesAvgAggregateInputType
    _sum?: TraceabilityTreeProfilesSumAggregateInputType
    _min?: TraceabilityTreeProfilesMinAggregateInputType
    _max?: TraceabilityTreeProfilesMaxAggregateInputType
  }


  export type TraceabilityTreeProfilesGroupByOutputType = {
    Id: string
    ProfileName: string | null
    RepositoryId: string | null
    ElementGuid: string | null
    Type: string | null
    SteroType: string | null
    FQName: string | null
    Technology: string | null
    TemplateOptions: string | null
    User_Id: string | null
    Status: number | null
    IsApplytoAll: number | null
    IsApplytoType: number | null
    IsApplytoSteroType: number | null
    Created: Date | null
    Modified: Date | null
    ElementTypeList: string | null
    ConnectorTypeList: string | null
    FlowDirectionTypeList: string | null
    TreeType: string | null
    _count: TraceabilityTreeProfilesCountAggregateOutputType | null
    _avg: TraceabilityTreeProfilesAvgAggregateOutputType | null
    _sum: TraceabilityTreeProfilesSumAggregateOutputType | null
    _min: TraceabilityTreeProfilesMinAggregateOutputType | null
    _max: TraceabilityTreeProfilesMaxAggregateOutputType | null
  }

  type GetTraceabilityTreeProfilesGroupByPayload<T extends TraceabilityTreeProfilesGroupByArgs> = Promise<
    Array<
      PickArray<TraceabilityTreeProfilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TraceabilityTreeProfilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TraceabilityTreeProfilesGroupByOutputType[P]>
            : GetScalarType<T[P], TraceabilityTreeProfilesGroupByOutputType[P]>
        }
      >
    >


  export type TraceabilityTreeProfilesSelect = {
    Id?: boolean
    ProfileName?: boolean
    RepositoryId?: boolean
    ElementGuid?: boolean
    Type?: boolean
    SteroType?: boolean
    FQName?: boolean
    Technology?: boolean
    TemplateOptions?: boolean
    User_Id?: boolean
    Status?: boolean
    IsApplytoAll?: boolean
    IsApplytoType?: boolean
    IsApplytoSteroType?: boolean
    Created?: boolean
    Modified?: boolean
    ElementTypeList?: boolean
    ConnectorTypeList?: boolean
    FlowDirectionTypeList?: boolean
    TreeType?: boolean
  }

  export type TraceabilityTreeProfilesGetPayload<
    S extends boolean | null | undefined | TraceabilityTreeProfilesArgs,
    U = keyof S
      > = S extends true
        ? TraceabilityTreeProfiles
    : S extends undefined
    ? never
    : S extends TraceabilityTreeProfilesArgs | TraceabilityTreeProfilesFindManyArgs
    ?'include' extends U
    ? TraceabilityTreeProfiles 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TraceabilityTreeProfiles ?TraceabilityTreeProfiles [P]
  : 
     never
  } 
    : TraceabilityTreeProfiles
  : TraceabilityTreeProfiles


  type TraceabilityTreeProfilesCountArgs = Merge<
    Omit<TraceabilityTreeProfilesFindManyArgs, 'select' | 'include'> & {
      select?: TraceabilityTreeProfilesCountAggregateInputType | true
    }
  >

  export interface TraceabilityTreeProfilesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TraceabilityTreeProfiles that matches the filter.
     * @param {TraceabilityTreeProfilesFindUniqueArgs} args - Arguments to find a TraceabilityTreeProfiles
     * @example
     * // Get one TraceabilityTreeProfiles
     * const traceabilityTreeProfiles = await prisma.traceabilityTreeProfiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TraceabilityTreeProfilesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TraceabilityTreeProfilesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TraceabilityTreeProfiles'> extends True ? CheckSelect<T, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfiles>, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfilesGetPayload<T>>> : CheckSelect<T, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfiles | null >, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfilesGetPayload<T> | null >>

    /**
     * Find the first TraceabilityTreeProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceabilityTreeProfilesFindFirstArgs} args - Arguments to find a TraceabilityTreeProfiles
     * @example
     * // Get one TraceabilityTreeProfiles
     * const traceabilityTreeProfiles = await prisma.traceabilityTreeProfiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TraceabilityTreeProfilesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TraceabilityTreeProfilesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TraceabilityTreeProfiles'> extends True ? CheckSelect<T, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfiles>, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfilesGetPayload<T>>> : CheckSelect<T, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfiles | null >, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfilesGetPayload<T> | null >>

    /**
     * Find zero or more TraceabilityTreeProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceabilityTreeProfilesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TraceabilityTreeProfiles
     * const traceabilityTreeProfiles = await prisma.traceabilityTreeProfiles.findMany()
     * 
     * // Get first 10 TraceabilityTreeProfiles
     * const traceabilityTreeProfiles = await prisma.traceabilityTreeProfiles.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const traceabilityTreeProfilesWithIdOnly = await prisma.traceabilityTreeProfiles.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends TraceabilityTreeProfilesFindManyArgs>(
      args?: SelectSubset<T, TraceabilityTreeProfilesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TraceabilityTreeProfiles>>, PrismaPromise<Array<TraceabilityTreeProfilesGetPayload<T>>>>

    /**
     * Create a TraceabilityTreeProfiles.
     * @param {TraceabilityTreeProfilesCreateArgs} args - Arguments to create a TraceabilityTreeProfiles.
     * @example
     * // Create one TraceabilityTreeProfiles
     * const TraceabilityTreeProfiles = await prisma.traceabilityTreeProfiles.create({
     *   data: {
     *     // ... data to create a TraceabilityTreeProfiles
     *   }
     * })
     * 
    **/
    create<T extends TraceabilityTreeProfilesCreateArgs>(
      args: SelectSubset<T, TraceabilityTreeProfilesCreateArgs>
    ): CheckSelect<T, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfiles>, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfilesGetPayload<T>>>

    /**
     * Create many TraceabilityTreeProfiles.
     *     @param {TraceabilityTreeProfilesCreateManyArgs} args - Arguments to create many TraceabilityTreeProfiles.
     *     @example
     *     // Create many TraceabilityTreeProfiles
     *     const traceabilityTreeProfiles = await prisma.traceabilityTreeProfiles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TraceabilityTreeProfilesCreateManyArgs>(
      args?: SelectSubset<T, TraceabilityTreeProfilesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TraceabilityTreeProfiles.
     * @param {TraceabilityTreeProfilesDeleteArgs} args - Arguments to delete one TraceabilityTreeProfiles.
     * @example
     * // Delete one TraceabilityTreeProfiles
     * const TraceabilityTreeProfiles = await prisma.traceabilityTreeProfiles.delete({
     *   where: {
     *     // ... filter to delete one TraceabilityTreeProfiles
     *   }
     * })
     * 
    **/
    delete<T extends TraceabilityTreeProfilesDeleteArgs>(
      args: SelectSubset<T, TraceabilityTreeProfilesDeleteArgs>
    ): CheckSelect<T, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfiles>, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfilesGetPayload<T>>>

    /**
     * Update one TraceabilityTreeProfiles.
     * @param {TraceabilityTreeProfilesUpdateArgs} args - Arguments to update one TraceabilityTreeProfiles.
     * @example
     * // Update one TraceabilityTreeProfiles
     * const traceabilityTreeProfiles = await prisma.traceabilityTreeProfiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TraceabilityTreeProfilesUpdateArgs>(
      args: SelectSubset<T, TraceabilityTreeProfilesUpdateArgs>
    ): CheckSelect<T, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfiles>, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfilesGetPayload<T>>>

    /**
     * Delete zero or more TraceabilityTreeProfiles.
     * @param {TraceabilityTreeProfilesDeleteManyArgs} args - Arguments to filter TraceabilityTreeProfiles to delete.
     * @example
     * // Delete a few TraceabilityTreeProfiles
     * const { count } = await prisma.traceabilityTreeProfiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TraceabilityTreeProfilesDeleteManyArgs>(
      args?: SelectSubset<T, TraceabilityTreeProfilesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TraceabilityTreeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceabilityTreeProfilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TraceabilityTreeProfiles
     * const traceabilityTreeProfiles = await prisma.traceabilityTreeProfiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TraceabilityTreeProfilesUpdateManyArgs>(
      args: SelectSubset<T, TraceabilityTreeProfilesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TraceabilityTreeProfiles.
     * @param {TraceabilityTreeProfilesUpsertArgs} args - Arguments to update or create a TraceabilityTreeProfiles.
     * @example
     * // Update or create a TraceabilityTreeProfiles
     * const traceabilityTreeProfiles = await prisma.traceabilityTreeProfiles.upsert({
     *   create: {
     *     // ... data to create a TraceabilityTreeProfiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TraceabilityTreeProfiles we want to update
     *   }
     * })
    **/
    upsert<T extends TraceabilityTreeProfilesUpsertArgs>(
      args: SelectSubset<T, TraceabilityTreeProfilesUpsertArgs>
    ): CheckSelect<T, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfiles>, Prisma__TraceabilityTreeProfilesClient<TraceabilityTreeProfilesGetPayload<T>>>

    /**
     * Count the number of TraceabilityTreeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceabilityTreeProfilesCountArgs} args - Arguments to filter TraceabilityTreeProfiles to count.
     * @example
     * // Count the number of TraceabilityTreeProfiles
     * const count = await prisma.traceabilityTreeProfiles.count({
     *   where: {
     *     // ... the filter for the TraceabilityTreeProfiles we want to count
     *   }
     * })
    **/
    count<T extends TraceabilityTreeProfilesCountArgs>(
      args?: Subset<T, TraceabilityTreeProfilesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TraceabilityTreeProfilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TraceabilityTreeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceabilityTreeProfilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TraceabilityTreeProfilesAggregateArgs>(args: Subset<T, TraceabilityTreeProfilesAggregateArgs>): PrismaPromise<GetTraceabilityTreeProfilesAggregateType<T>>

    /**
     * Group by TraceabilityTreeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceabilityTreeProfilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TraceabilityTreeProfilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TraceabilityTreeProfilesGroupByArgs['orderBy'] }
        : { orderBy?: TraceabilityTreeProfilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TraceabilityTreeProfilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraceabilityTreeProfilesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TraceabilityTreeProfiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TraceabilityTreeProfilesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TraceabilityTreeProfiles findUnique
   */
  export type TraceabilityTreeProfilesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeProfiles
     * 
    **/
    select?: TraceabilityTreeProfilesSelect | null
    /**
     * Throw an Error if a TraceabilityTreeProfiles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TraceabilityTreeProfiles to fetch.
     * 
    **/
    where: TraceabilityTreeProfilesWhereUniqueInput
  }


  /**
   * TraceabilityTreeProfiles findFirst
   */
  export type TraceabilityTreeProfilesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeProfiles
     * 
    **/
    select?: TraceabilityTreeProfilesSelect | null
    /**
     * Throw an Error if a TraceabilityTreeProfiles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TraceabilityTreeProfiles to fetch.
     * 
    **/
    where?: TraceabilityTreeProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceabilityTreeProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<TraceabilityTreeProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraceabilityTreeProfiles.
     * 
    **/
    cursor?: TraceabilityTreeProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceabilityTreeProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceabilityTreeProfiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraceabilityTreeProfiles.
     * 
    **/
    distinct?: Enumerable<TraceabilityTreeProfilesScalarFieldEnum>
  }


  /**
   * TraceabilityTreeProfiles findMany
   */
  export type TraceabilityTreeProfilesFindManyArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeProfiles
     * 
    **/
    select?: TraceabilityTreeProfilesSelect | null
    /**
     * Filter, which TraceabilityTreeProfiles to fetch.
     * 
    **/
    where?: TraceabilityTreeProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceabilityTreeProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<TraceabilityTreeProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TraceabilityTreeProfiles.
     * 
    **/
    cursor?: TraceabilityTreeProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceabilityTreeProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceabilityTreeProfiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TraceabilityTreeProfilesScalarFieldEnum>
  }


  /**
   * TraceabilityTreeProfiles create
   */
  export type TraceabilityTreeProfilesCreateArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeProfiles
     * 
    **/
    select?: TraceabilityTreeProfilesSelect | null
    /**
     * The data needed to create a TraceabilityTreeProfiles.
     * 
    **/
    data: XOR<TraceabilityTreeProfilesCreateInput, TraceabilityTreeProfilesUncheckedCreateInput>
  }


  /**
   * TraceabilityTreeProfiles createMany
   */
  export type TraceabilityTreeProfilesCreateManyArgs = {
    data: Enumerable<TraceabilityTreeProfilesCreateManyInput>
  }


  /**
   * TraceabilityTreeProfiles update
   */
  export type TraceabilityTreeProfilesUpdateArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeProfiles
     * 
    **/
    select?: TraceabilityTreeProfilesSelect | null
    /**
     * The data needed to update a TraceabilityTreeProfiles.
     * 
    **/
    data: XOR<TraceabilityTreeProfilesUpdateInput, TraceabilityTreeProfilesUncheckedUpdateInput>
    /**
     * Choose, which TraceabilityTreeProfiles to update.
     * 
    **/
    where: TraceabilityTreeProfilesWhereUniqueInput
  }


  /**
   * TraceabilityTreeProfiles updateMany
   */
  export type TraceabilityTreeProfilesUpdateManyArgs = {
    data: XOR<TraceabilityTreeProfilesUpdateManyMutationInput, TraceabilityTreeProfilesUncheckedUpdateManyInput>
    where?: TraceabilityTreeProfilesWhereInput
  }


  /**
   * TraceabilityTreeProfiles upsert
   */
  export type TraceabilityTreeProfilesUpsertArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeProfiles
     * 
    **/
    select?: TraceabilityTreeProfilesSelect | null
    /**
     * The filter to search for the TraceabilityTreeProfiles to update in case it exists.
     * 
    **/
    where: TraceabilityTreeProfilesWhereUniqueInput
    /**
     * In case the TraceabilityTreeProfiles found by the `where` argument doesn't exist, create a new TraceabilityTreeProfiles with this data.
     * 
    **/
    create: XOR<TraceabilityTreeProfilesCreateInput, TraceabilityTreeProfilesUncheckedCreateInput>
    /**
     * In case the TraceabilityTreeProfiles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TraceabilityTreeProfilesUpdateInput, TraceabilityTreeProfilesUncheckedUpdateInput>
  }


  /**
   * TraceabilityTreeProfiles delete
   */
  export type TraceabilityTreeProfilesDeleteArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeProfiles
     * 
    **/
    select?: TraceabilityTreeProfilesSelect | null
    /**
     * Filter which TraceabilityTreeProfiles to delete.
     * 
    **/
    where: TraceabilityTreeProfilesWhereUniqueInput
  }


  /**
   * TraceabilityTreeProfiles deleteMany
   */
  export type TraceabilityTreeProfilesDeleteManyArgs = {
    where?: TraceabilityTreeProfilesWhereInput
  }


  /**
   * TraceabilityTreeProfiles without action
   */
  export type TraceabilityTreeProfilesArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeProfiles
     * 
    **/
    select?: TraceabilityTreeProfilesSelect | null
  }



  /**
   * Model TraceabilityTreeViews
   */


  export type AggregateTraceabilityTreeViews = {
    _count: TraceabilityTreeViewsCountAggregateOutputType | null
    _min: TraceabilityTreeViewsMinAggregateOutputType | null
    _max: TraceabilityTreeViewsMaxAggregateOutputType | null
  }

  export type TraceabilityTreeViewsMinAggregateOutputType = {
    Id: string | null
    RepositoryId: string | null
    ElementGuid: string | null
    TreeViewData: string | null
    User_Id: string | null
    Created: Date | null
    Modified: Date | null
    FilterItems: string | null
    Tittle: string | null
    Revision: string | null
    ViewId: string | null
    TemplateOptions: string | null
    Description: string | null
    NlFilterItems: string | null
    NlTreeData: string | null
    NlFilterItemStatus: string | null
    FilterAppliedNodeList: string | null
    TotForceLinks: string | null
  }

  export type TraceabilityTreeViewsMaxAggregateOutputType = {
    Id: string | null
    RepositoryId: string | null
    ElementGuid: string | null
    TreeViewData: string | null
    User_Id: string | null
    Created: Date | null
    Modified: Date | null
    FilterItems: string | null
    Tittle: string | null
    Revision: string | null
    ViewId: string | null
    TemplateOptions: string | null
    Description: string | null
    NlFilterItems: string | null
    NlTreeData: string | null
    NlFilterItemStatus: string | null
    FilterAppliedNodeList: string | null
    TotForceLinks: string | null
  }

  export type TraceabilityTreeViewsCountAggregateOutputType = {
    Id: number
    RepositoryId: number
    ElementGuid: number
    TreeViewData: number
    User_Id: number
    Created: number
    Modified: number
    FilterItems: number
    Tittle: number
    Revision: number
    ViewId: number
    TemplateOptions: number
    Description: number
    NlFilterItems: number
    NlTreeData: number
    NlFilterItemStatus: number
    FilterAppliedNodeList: number
    TotForceLinks: number
    _all: number
  }


  export type TraceabilityTreeViewsMinAggregateInputType = {
    Id?: true
    RepositoryId?: true
    ElementGuid?: true
    TreeViewData?: true
    User_Id?: true
    Created?: true
    Modified?: true
    FilterItems?: true
    Tittle?: true
    Revision?: true
    ViewId?: true
    TemplateOptions?: true
    Description?: true
    NlFilterItems?: true
    NlTreeData?: true
    NlFilterItemStatus?: true
    FilterAppliedNodeList?: true
    TotForceLinks?: true
  }

  export type TraceabilityTreeViewsMaxAggregateInputType = {
    Id?: true
    RepositoryId?: true
    ElementGuid?: true
    TreeViewData?: true
    User_Id?: true
    Created?: true
    Modified?: true
    FilterItems?: true
    Tittle?: true
    Revision?: true
    ViewId?: true
    TemplateOptions?: true
    Description?: true
    NlFilterItems?: true
    NlTreeData?: true
    NlFilterItemStatus?: true
    FilterAppliedNodeList?: true
    TotForceLinks?: true
  }

  export type TraceabilityTreeViewsCountAggregateInputType = {
    Id?: true
    RepositoryId?: true
    ElementGuid?: true
    TreeViewData?: true
    User_Id?: true
    Created?: true
    Modified?: true
    FilterItems?: true
    Tittle?: true
    Revision?: true
    ViewId?: true
    TemplateOptions?: true
    Description?: true
    NlFilterItems?: true
    NlTreeData?: true
    NlFilterItemStatus?: true
    FilterAppliedNodeList?: true
    TotForceLinks?: true
    _all?: true
  }

  export type TraceabilityTreeViewsAggregateArgs = {
    /**
     * Filter which TraceabilityTreeViews to aggregate.
     * 
    **/
    where?: TraceabilityTreeViewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceabilityTreeViews to fetch.
     * 
    **/
    orderBy?: Enumerable<TraceabilityTreeViewsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TraceabilityTreeViewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceabilityTreeViews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceabilityTreeViews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TraceabilityTreeViews
    **/
    _count?: true | TraceabilityTreeViewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TraceabilityTreeViewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TraceabilityTreeViewsMaxAggregateInputType
  }

  export type GetTraceabilityTreeViewsAggregateType<T extends TraceabilityTreeViewsAggregateArgs> = {
        [P in keyof T & keyof AggregateTraceabilityTreeViews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraceabilityTreeViews[P]>
      : GetScalarType<T[P], AggregateTraceabilityTreeViews[P]>
  }




  export type TraceabilityTreeViewsGroupByArgs = {
    where?: TraceabilityTreeViewsWhereInput
    orderBy?: Enumerable<TraceabilityTreeViewsOrderByWithAggregationInput>
    by: Array<TraceabilityTreeViewsScalarFieldEnum>
    having?: TraceabilityTreeViewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TraceabilityTreeViewsCountAggregateInputType | true
    _min?: TraceabilityTreeViewsMinAggregateInputType
    _max?: TraceabilityTreeViewsMaxAggregateInputType
  }


  export type TraceabilityTreeViewsGroupByOutputType = {
    Id: string
    RepositoryId: string | null
    ElementGuid: string | null
    TreeViewData: string | null
    User_Id: string | null
    Created: Date | null
    Modified: Date | null
    FilterItems: string | null
    Tittle: string | null
    Revision: string | null
    ViewId: string | null
    TemplateOptions: string | null
    Description: string | null
    NlFilterItems: string | null
    NlTreeData: string | null
    NlFilterItemStatus: string | null
    FilterAppliedNodeList: string | null
    TotForceLinks: string | null
    _count: TraceabilityTreeViewsCountAggregateOutputType | null
    _min: TraceabilityTreeViewsMinAggregateOutputType | null
    _max: TraceabilityTreeViewsMaxAggregateOutputType | null
  }

  type GetTraceabilityTreeViewsGroupByPayload<T extends TraceabilityTreeViewsGroupByArgs> = Promise<
    Array<
      PickArray<TraceabilityTreeViewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TraceabilityTreeViewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TraceabilityTreeViewsGroupByOutputType[P]>
            : GetScalarType<T[P], TraceabilityTreeViewsGroupByOutputType[P]>
        }
      >
    >


  export type TraceabilityTreeViewsSelect = {
    Id?: boolean
    RepositoryId?: boolean
    ElementGuid?: boolean
    TreeViewData?: boolean
    User_Id?: boolean
    Created?: boolean
    Modified?: boolean
    FilterItems?: boolean
    Tittle?: boolean
    Revision?: boolean
    ViewId?: boolean
    TemplateOptions?: boolean
    Description?: boolean
    NlFilterItems?: boolean
    NlTreeData?: boolean
    NlFilterItemStatus?: boolean
    FilterAppliedNodeList?: boolean
    TotForceLinks?: boolean
  }

  export type TraceabilityTreeViewsGetPayload<
    S extends boolean | null | undefined | TraceabilityTreeViewsArgs,
    U = keyof S
      > = S extends true
        ? TraceabilityTreeViews
    : S extends undefined
    ? never
    : S extends TraceabilityTreeViewsArgs | TraceabilityTreeViewsFindManyArgs
    ?'include' extends U
    ? TraceabilityTreeViews 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TraceabilityTreeViews ?TraceabilityTreeViews [P]
  : 
     never
  } 
    : TraceabilityTreeViews
  : TraceabilityTreeViews


  type TraceabilityTreeViewsCountArgs = Merge<
    Omit<TraceabilityTreeViewsFindManyArgs, 'select' | 'include'> & {
      select?: TraceabilityTreeViewsCountAggregateInputType | true
    }
  >

  export interface TraceabilityTreeViewsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TraceabilityTreeViews that matches the filter.
     * @param {TraceabilityTreeViewsFindUniqueArgs} args - Arguments to find a TraceabilityTreeViews
     * @example
     * // Get one TraceabilityTreeViews
     * const traceabilityTreeViews = await prisma.traceabilityTreeViews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TraceabilityTreeViewsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TraceabilityTreeViewsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TraceabilityTreeViews'> extends True ? CheckSelect<T, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViews>, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViewsGetPayload<T>>> : CheckSelect<T, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViews | null >, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViewsGetPayload<T> | null >>

    /**
     * Find the first TraceabilityTreeViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceabilityTreeViewsFindFirstArgs} args - Arguments to find a TraceabilityTreeViews
     * @example
     * // Get one TraceabilityTreeViews
     * const traceabilityTreeViews = await prisma.traceabilityTreeViews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TraceabilityTreeViewsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TraceabilityTreeViewsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TraceabilityTreeViews'> extends True ? CheckSelect<T, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViews>, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViewsGetPayload<T>>> : CheckSelect<T, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViews | null >, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViewsGetPayload<T> | null >>

    /**
     * Find zero or more TraceabilityTreeViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceabilityTreeViewsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TraceabilityTreeViews
     * const traceabilityTreeViews = await prisma.traceabilityTreeViews.findMany()
     * 
     * // Get first 10 TraceabilityTreeViews
     * const traceabilityTreeViews = await prisma.traceabilityTreeViews.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const traceabilityTreeViewsWithIdOnly = await prisma.traceabilityTreeViews.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends TraceabilityTreeViewsFindManyArgs>(
      args?: SelectSubset<T, TraceabilityTreeViewsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TraceabilityTreeViews>>, PrismaPromise<Array<TraceabilityTreeViewsGetPayload<T>>>>

    /**
     * Create a TraceabilityTreeViews.
     * @param {TraceabilityTreeViewsCreateArgs} args - Arguments to create a TraceabilityTreeViews.
     * @example
     * // Create one TraceabilityTreeViews
     * const TraceabilityTreeViews = await prisma.traceabilityTreeViews.create({
     *   data: {
     *     // ... data to create a TraceabilityTreeViews
     *   }
     * })
     * 
    **/
    create<T extends TraceabilityTreeViewsCreateArgs>(
      args: SelectSubset<T, TraceabilityTreeViewsCreateArgs>
    ): CheckSelect<T, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViews>, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViewsGetPayload<T>>>

    /**
     * Create many TraceabilityTreeViews.
     *     @param {TraceabilityTreeViewsCreateManyArgs} args - Arguments to create many TraceabilityTreeViews.
     *     @example
     *     // Create many TraceabilityTreeViews
     *     const traceabilityTreeViews = await prisma.traceabilityTreeViews.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TraceabilityTreeViewsCreateManyArgs>(
      args?: SelectSubset<T, TraceabilityTreeViewsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TraceabilityTreeViews.
     * @param {TraceabilityTreeViewsDeleteArgs} args - Arguments to delete one TraceabilityTreeViews.
     * @example
     * // Delete one TraceabilityTreeViews
     * const TraceabilityTreeViews = await prisma.traceabilityTreeViews.delete({
     *   where: {
     *     // ... filter to delete one TraceabilityTreeViews
     *   }
     * })
     * 
    **/
    delete<T extends TraceabilityTreeViewsDeleteArgs>(
      args: SelectSubset<T, TraceabilityTreeViewsDeleteArgs>
    ): CheckSelect<T, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViews>, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViewsGetPayload<T>>>

    /**
     * Update one TraceabilityTreeViews.
     * @param {TraceabilityTreeViewsUpdateArgs} args - Arguments to update one TraceabilityTreeViews.
     * @example
     * // Update one TraceabilityTreeViews
     * const traceabilityTreeViews = await prisma.traceabilityTreeViews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TraceabilityTreeViewsUpdateArgs>(
      args: SelectSubset<T, TraceabilityTreeViewsUpdateArgs>
    ): CheckSelect<T, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViews>, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViewsGetPayload<T>>>

    /**
     * Delete zero or more TraceabilityTreeViews.
     * @param {TraceabilityTreeViewsDeleteManyArgs} args - Arguments to filter TraceabilityTreeViews to delete.
     * @example
     * // Delete a few TraceabilityTreeViews
     * const { count } = await prisma.traceabilityTreeViews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TraceabilityTreeViewsDeleteManyArgs>(
      args?: SelectSubset<T, TraceabilityTreeViewsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TraceabilityTreeViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceabilityTreeViewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TraceabilityTreeViews
     * const traceabilityTreeViews = await prisma.traceabilityTreeViews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TraceabilityTreeViewsUpdateManyArgs>(
      args: SelectSubset<T, TraceabilityTreeViewsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TraceabilityTreeViews.
     * @param {TraceabilityTreeViewsUpsertArgs} args - Arguments to update or create a TraceabilityTreeViews.
     * @example
     * // Update or create a TraceabilityTreeViews
     * const traceabilityTreeViews = await prisma.traceabilityTreeViews.upsert({
     *   create: {
     *     // ... data to create a TraceabilityTreeViews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TraceabilityTreeViews we want to update
     *   }
     * })
    **/
    upsert<T extends TraceabilityTreeViewsUpsertArgs>(
      args: SelectSubset<T, TraceabilityTreeViewsUpsertArgs>
    ): CheckSelect<T, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViews>, Prisma__TraceabilityTreeViewsClient<TraceabilityTreeViewsGetPayload<T>>>

    /**
     * Count the number of TraceabilityTreeViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceabilityTreeViewsCountArgs} args - Arguments to filter TraceabilityTreeViews to count.
     * @example
     * // Count the number of TraceabilityTreeViews
     * const count = await prisma.traceabilityTreeViews.count({
     *   where: {
     *     // ... the filter for the TraceabilityTreeViews we want to count
     *   }
     * })
    **/
    count<T extends TraceabilityTreeViewsCountArgs>(
      args?: Subset<T, TraceabilityTreeViewsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TraceabilityTreeViewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TraceabilityTreeViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceabilityTreeViewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TraceabilityTreeViewsAggregateArgs>(args: Subset<T, TraceabilityTreeViewsAggregateArgs>): PrismaPromise<GetTraceabilityTreeViewsAggregateType<T>>

    /**
     * Group by TraceabilityTreeViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceabilityTreeViewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TraceabilityTreeViewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TraceabilityTreeViewsGroupByArgs['orderBy'] }
        : { orderBy?: TraceabilityTreeViewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TraceabilityTreeViewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraceabilityTreeViewsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TraceabilityTreeViews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TraceabilityTreeViewsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TraceabilityTreeViews findUnique
   */
  export type TraceabilityTreeViewsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeViews
     * 
    **/
    select?: TraceabilityTreeViewsSelect | null
    /**
     * Throw an Error if a TraceabilityTreeViews can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TraceabilityTreeViews to fetch.
     * 
    **/
    where: TraceabilityTreeViewsWhereUniqueInput
  }


  /**
   * TraceabilityTreeViews findFirst
   */
  export type TraceabilityTreeViewsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeViews
     * 
    **/
    select?: TraceabilityTreeViewsSelect | null
    /**
     * Throw an Error if a TraceabilityTreeViews can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TraceabilityTreeViews to fetch.
     * 
    **/
    where?: TraceabilityTreeViewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceabilityTreeViews to fetch.
     * 
    **/
    orderBy?: Enumerable<TraceabilityTreeViewsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraceabilityTreeViews.
     * 
    **/
    cursor?: TraceabilityTreeViewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceabilityTreeViews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceabilityTreeViews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraceabilityTreeViews.
     * 
    **/
    distinct?: Enumerable<TraceabilityTreeViewsScalarFieldEnum>
  }


  /**
   * TraceabilityTreeViews findMany
   */
  export type TraceabilityTreeViewsFindManyArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeViews
     * 
    **/
    select?: TraceabilityTreeViewsSelect | null
    /**
     * Filter, which TraceabilityTreeViews to fetch.
     * 
    **/
    where?: TraceabilityTreeViewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceabilityTreeViews to fetch.
     * 
    **/
    orderBy?: Enumerable<TraceabilityTreeViewsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TraceabilityTreeViews.
     * 
    **/
    cursor?: TraceabilityTreeViewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceabilityTreeViews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceabilityTreeViews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TraceabilityTreeViewsScalarFieldEnum>
  }


  /**
   * TraceabilityTreeViews create
   */
  export type TraceabilityTreeViewsCreateArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeViews
     * 
    **/
    select?: TraceabilityTreeViewsSelect | null
    /**
     * The data needed to create a TraceabilityTreeViews.
     * 
    **/
    data: XOR<TraceabilityTreeViewsCreateInput, TraceabilityTreeViewsUncheckedCreateInput>
  }


  /**
   * TraceabilityTreeViews createMany
   */
  export type TraceabilityTreeViewsCreateManyArgs = {
    data: Enumerable<TraceabilityTreeViewsCreateManyInput>
  }


  /**
   * TraceabilityTreeViews update
   */
  export type TraceabilityTreeViewsUpdateArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeViews
     * 
    **/
    select?: TraceabilityTreeViewsSelect | null
    /**
     * The data needed to update a TraceabilityTreeViews.
     * 
    **/
    data: XOR<TraceabilityTreeViewsUpdateInput, TraceabilityTreeViewsUncheckedUpdateInput>
    /**
     * Choose, which TraceabilityTreeViews to update.
     * 
    **/
    where: TraceabilityTreeViewsWhereUniqueInput
  }


  /**
   * TraceabilityTreeViews updateMany
   */
  export type TraceabilityTreeViewsUpdateManyArgs = {
    data: XOR<TraceabilityTreeViewsUpdateManyMutationInput, TraceabilityTreeViewsUncheckedUpdateManyInput>
    where?: TraceabilityTreeViewsWhereInput
  }


  /**
   * TraceabilityTreeViews upsert
   */
  export type TraceabilityTreeViewsUpsertArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeViews
     * 
    **/
    select?: TraceabilityTreeViewsSelect | null
    /**
     * The filter to search for the TraceabilityTreeViews to update in case it exists.
     * 
    **/
    where: TraceabilityTreeViewsWhereUniqueInput
    /**
     * In case the TraceabilityTreeViews found by the `where` argument doesn't exist, create a new TraceabilityTreeViews with this data.
     * 
    **/
    create: XOR<TraceabilityTreeViewsCreateInput, TraceabilityTreeViewsUncheckedCreateInput>
    /**
     * In case the TraceabilityTreeViews was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TraceabilityTreeViewsUpdateInput, TraceabilityTreeViewsUncheckedUpdateInput>
  }


  /**
   * TraceabilityTreeViews delete
   */
  export type TraceabilityTreeViewsDeleteArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeViews
     * 
    **/
    select?: TraceabilityTreeViewsSelect | null
    /**
     * Filter which TraceabilityTreeViews to delete.
     * 
    **/
    where: TraceabilityTreeViewsWhereUniqueInput
  }


  /**
   * TraceabilityTreeViews deleteMany
   */
  export type TraceabilityTreeViewsDeleteManyArgs = {
    where?: TraceabilityTreeViewsWhereInput
  }


  /**
   * TraceabilityTreeViews without action
   */
  export type TraceabilityTreeViewsArgs = {
    /**
     * Select specific fields to fetch from the TraceabilityTreeViews
     * 
    **/
    select?: TraceabilityTreeViewsSelect | null
  }



  /**
   * Model URLMap
   */


  export type AggregateURLMap = {
    _count: URLMapCountAggregateOutputType | null
    _avg: URLMapAvgAggregateOutputType | null
    _sum: URLMapSumAggregateOutputType | null
    _min: URLMapMinAggregateOutputType | null
    _max: URLMapMaxAggregateOutputType | null
  }

  export type URLMapAvgAggregateOutputType = {
    Id: number | null
  }

  export type URLMapSumAggregateOutputType = {
    Id: bigint | null
  }

  export type URLMapMinAggregateOutputType = {
    Id: bigint | null
    URL: string | null
    URLType: string | null
    HashCode: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Repository_Id: string | null
    LinkType: string | null
    MapurlId: string | null
  }

  export type URLMapMaxAggregateOutputType = {
    Id: bigint | null
    URL: string | null
    URLType: string | null
    HashCode: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Repository_Id: string | null
    LinkType: string | null
    MapurlId: string | null
  }

  export type URLMapCountAggregateOutputType = {
    Id: number
    URL: number
    URLType: number
    HashCode: number
    CreatedDate: number
    ModifiedDate: number
    Repository_Id: number
    LinkType: number
    MapurlId: number
    _all: number
  }


  export type URLMapAvgAggregateInputType = {
    Id?: true
  }

  export type URLMapSumAggregateInputType = {
    Id?: true
  }

  export type URLMapMinAggregateInputType = {
    Id?: true
    URL?: true
    URLType?: true
    HashCode?: true
    CreatedDate?: true
    ModifiedDate?: true
    Repository_Id?: true
    LinkType?: true
    MapurlId?: true
  }

  export type URLMapMaxAggregateInputType = {
    Id?: true
    URL?: true
    URLType?: true
    HashCode?: true
    CreatedDate?: true
    ModifiedDate?: true
    Repository_Id?: true
    LinkType?: true
    MapurlId?: true
  }

  export type URLMapCountAggregateInputType = {
    Id?: true
    URL?: true
    URLType?: true
    HashCode?: true
    CreatedDate?: true
    ModifiedDate?: true
    Repository_Id?: true
    LinkType?: true
    MapurlId?: true
    _all?: true
  }

  export type URLMapAggregateArgs = {
    /**
     * Filter which URLMap to aggregate.
     * 
    **/
    where?: URLMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of URLMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<URLMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: URLMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` URLMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` URLMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned URLMaps
    **/
    _count?: true | URLMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: URLMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: URLMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: URLMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: URLMapMaxAggregateInputType
  }

  export type GetURLMapAggregateType<T extends URLMapAggregateArgs> = {
        [P in keyof T & keyof AggregateURLMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateURLMap[P]>
      : GetScalarType<T[P], AggregateURLMap[P]>
  }




  export type URLMapGroupByArgs = {
    where?: URLMapWhereInput
    orderBy?: Enumerable<URLMapOrderByWithAggregationInput>
    by: Array<URLMapScalarFieldEnum>
    having?: URLMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: URLMapCountAggregateInputType | true
    _avg?: URLMapAvgAggregateInputType
    _sum?: URLMapSumAggregateInputType
    _min?: URLMapMinAggregateInputType
    _max?: URLMapMaxAggregateInputType
  }


  export type URLMapGroupByOutputType = {
    Id: bigint
    URL: string
    URLType: string | null
    HashCode: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Repository_Id: string | null
    LinkType: string | null
    MapurlId: string | null
    _count: URLMapCountAggregateOutputType | null
    _avg: URLMapAvgAggregateOutputType | null
    _sum: URLMapSumAggregateOutputType | null
    _min: URLMapMinAggregateOutputType | null
    _max: URLMapMaxAggregateOutputType | null
  }

  type GetURLMapGroupByPayload<T extends URLMapGroupByArgs> = Promise<
    Array<
      PickArray<URLMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof URLMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], URLMapGroupByOutputType[P]>
            : GetScalarType<T[P], URLMapGroupByOutputType[P]>
        }
      >
    >


  export type URLMapSelect = {
    Id?: boolean
    URL?: boolean
    URLType?: boolean
    HashCode?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
    Repository_Id?: boolean
    LinkType?: boolean
    MapurlId?: boolean
  }

  export type URLMapGetPayload<
    S extends boolean | null | undefined | URLMapArgs,
    U = keyof S
      > = S extends true
        ? URLMap
    : S extends undefined
    ? never
    : S extends URLMapArgs | URLMapFindManyArgs
    ?'include' extends U
    ? URLMap 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof URLMap ?URLMap [P]
  : 
     never
  } 
    : URLMap
  : URLMap


  type URLMapCountArgs = Merge<
    Omit<URLMapFindManyArgs, 'select' | 'include'> & {
      select?: URLMapCountAggregateInputType | true
    }
  >

  export interface URLMapDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one URLMap that matches the filter.
     * @param {URLMapFindUniqueArgs} args - Arguments to find a URLMap
     * @example
     * // Get one URLMap
     * const uRLMap = await prisma.uRLMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends URLMapFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, URLMapFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'URLMap'> extends True ? CheckSelect<T, Prisma__URLMapClient<URLMap>, Prisma__URLMapClient<URLMapGetPayload<T>>> : CheckSelect<T, Prisma__URLMapClient<URLMap | null >, Prisma__URLMapClient<URLMapGetPayload<T> | null >>

    /**
     * Find the first URLMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {URLMapFindFirstArgs} args - Arguments to find a URLMap
     * @example
     * // Get one URLMap
     * const uRLMap = await prisma.uRLMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends URLMapFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, URLMapFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'URLMap'> extends True ? CheckSelect<T, Prisma__URLMapClient<URLMap>, Prisma__URLMapClient<URLMapGetPayload<T>>> : CheckSelect<T, Prisma__URLMapClient<URLMap | null >, Prisma__URLMapClient<URLMapGetPayload<T> | null >>

    /**
     * Find zero or more URLMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {URLMapFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all URLMaps
     * const uRLMaps = await prisma.uRLMap.findMany()
     * 
     * // Get first 10 URLMaps
     * const uRLMaps = await prisma.uRLMap.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const uRLMapWithIdOnly = await prisma.uRLMap.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends URLMapFindManyArgs>(
      args?: SelectSubset<T, URLMapFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<URLMap>>, PrismaPromise<Array<URLMapGetPayload<T>>>>

    /**
     * Create a URLMap.
     * @param {URLMapCreateArgs} args - Arguments to create a URLMap.
     * @example
     * // Create one URLMap
     * const URLMap = await prisma.uRLMap.create({
     *   data: {
     *     // ... data to create a URLMap
     *   }
     * })
     * 
    **/
    create<T extends URLMapCreateArgs>(
      args: SelectSubset<T, URLMapCreateArgs>
    ): CheckSelect<T, Prisma__URLMapClient<URLMap>, Prisma__URLMapClient<URLMapGetPayload<T>>>

    /**
     * Create many URLMaps.
     *     @param {URLMapCreateManyArgs} args - Arguments to create many URLMaps.
     *     @example
     *     // Create many URLMaps
     *     const uRLMap = await prisma.uRLMap.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends URLMapCreateManyArgs>(
      args?: SelectSubset<T, URLMapCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a URLMap.
     * @param {URLMapDeleteArgs} args - Arguments to delete one URLMap.
     * @example
     * // Delete one URLMap
     * const URLMap = await prisma.uRLMap.delete({
     *   where: {
     *     // ... filter to delete one URLMap
     *   }
     * })
     * 
    **/
    delete<T extends URLMapDeleteArgs>(
      args: SelectSubset<T, URLMapDeleteArgs>
    ): CheckSelect<T, Prisma__URLMapClient<URLMap>, Prisma__URLMapClient<URLMapGetPayload<T>>>

    /**
     * Update one URLMap.
     * @param {URLMapUpdateArgs} args - Arguments to update one URLMap.
     * @example
     * // Update one URLMap
     * const uRLMap = await prisma.uRLMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends URLMapUpdateArgs>(
      args: SelectSubset<T, URLMapUpdateArgs>
    ): CheckSelect<T, Prisma__URLMapClient<URLMap>, Prisma__URLMapClient<URLMapGetPayload<T>>>

    /**
     * Delete zero or more URLMaps.
     * @param {URLMapDeleteManyArgs} args - Arguments to filter URLMaps to delete.
     * @example
     * // Delete a few URLMaps
     * const { count } = await prisma.uRLMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends URLMapDeleteManyArgs>(
      args?: SelectSubset<T, URLMapDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more URLMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {URLMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many URLMaps
     * const uRLMap = await prisma.uRLMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends URLMapUpdateManyArgs>(
      args: SelectSubset<T, URLMapUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one URLMap.
     * @param {URLMapUpsertArgs} args - Arguments to update or create a URLMap.
     * @example
     * // Update or create a URLMap
     * const uRLMap = await prisma.uRLMap.upsert({
     *   create: {
     *     // ... data to create a URLMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the URLMap we want to update
     *   }
     * })
    **/
    upsert<T extends URLMapUpsertArgs>(
      args: SelectSubset<T, URLMapUpsertArgs>
    ): CheckSelect<T, Prisma__URLMapClient<URLMap>, Prisma__URLMapClient<URLMapGetPayload<T>>>

    /**
     * Count the number of URLMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {URLMapCountArgs} args - Arguments to filter URLMaps to count.
     * @example
     * // Count the number of URLMaps
     * const count = await prisma.uRLMap.count({
     *   where: {
     *     // ... the filter for the URLMaps we want to count
     *   }
     * })
    **/
    count<T extends URLMapCountArgs>(
      args?: Subset<T, URLMapCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], URLMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a URLMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {URLMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends URLMapAggregateArgs>(args: Subset<T, URLMapAggregateArgs>): PrismaPromise<GetURLMapAggregateType<T>>

    /**
     * Group by URLMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {URLMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends URLMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: URLMapGroupByArgs['orderBy'] }
        : { orderBy?: URLMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, URLMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetURLMapGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for URLMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__URLMapClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * URLMap findUnique
   */
  export type URLMapFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the URLMap
     * 
    **/
    select?: URLMapSelect | null
    /**
     * Throw an Error if a URLMap can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which URLMap to fetch.
     * 
    **/
    where: URLMapWhereUniqueInput
  }


  /**
   * URLMap findFirst
   */
  export type URLMapFindFirstArgs = {
    /**
     * Select specific fields to fetch from the URLMap
     * 
    **/
    select?: URLMapSelect | null
    /**
     * Throw an Error if a URLMap can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which URLMap to fetch.
     * 
    **/
    where?: URLMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of URLMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<URLMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for URLMaps.
     * 
    **/
    cursor?: URLMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` URLMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` URLMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of URLMaps.
     * 
    **/
    distinct?: Enumerable<URLMapScalarFieldEnum>
  }


  /**
   * URLMap findMany
   */
  export type URLMapFindManyArgs = {
    /**
     * Select specific fields to fetch from the URLMap
     * 
    **/
    select?: URLMapSelect | null
    /**
     * Filter, which URLMaps to fetch.
     * 
    **/
    where?: URLMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of URLMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<URLMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing URLMaps.
     * 
    **/
    cursor?: URLMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` URLMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` URLMaps.
     * 
    **/
    skip?: number
    distinct?: Enumerable<URLMapScalarFieldEnum>
  }


  /**
   * URLMap create
   */
  export type URLMapCreateArgs = {
    /**
     * Select specific fields to fetch from the URLMap
     * 
    **/
    select?: URLMapSelect | null
    /**
     * The data needed to create a URLMap.
     * 
    **/
    data: XOR<URLMapCreateInput, URLMapUncheckedCreateInput>
  }


  /**
   * URLMap createMany
   */
  export type URLMapCreateManyArgs = {
    data: Enumerable<URLMapCreateManyInput>
  }


  /**
   * URLMap update
   */
  export type URLMapUpdateArgs = {
    /**
     * Select specific fields to fetch from the URLMap
     * 
    **/
    select?: URLMapSelect | null
    /**
     * The data needed to update a URLMap.
     * 
    **/
    data: XOR<URLMapUpdateInput, URLMapUncheckedUpdateInput>
    /**
     * Choose, which URLMap to update.
     * 
    **/
    where: URLMapWhereUniqueInput
  }


  /**
   * URLMap updateMany
   */
  export type URLMapUpdateManyArgs = {
    data: XOR<URLMapUpdateManyMutationInput, URLMapUncheckedUpdateManyInput>
    where?: URLMapWhereInput
  }


  /**
   * URLMap upsert
   */
  export type URLMapUpsertArgs = {
    /**
     * Select specific fields to fetch from the URLMap
     * 
    **/
    select?: URLMapSelect | null
    /**
     * The filter to search for the URLMap to update in case it exists.
     * 
    **/
    where: URLMapWhereUniqueInput
    /**
     * In case the URLMap found by the `where` argument doesn't exist, create a new URLMap with this data.
     * 
    **/
    create: XOR<URLMapCreateInput, URLMapUncheckedCreateInput>
    /**
     * In case the URLMap was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<URLMapUpdateInput, URLMapUncheckedUpdateInput>
  }


  /**
   * URLMap delete
   */
  export type URLMapDeleteArgs = {
    /**
     * Select specific fields to fetch from the URLMap
     * 
    **/
    select?: URLMapSelect | null
    /**
     * Filter which URLMap to delete.
     * 
    **/
    where: URLMapWhereUniqueInput
  }


  /**
   * URLMap deleteMany
   */
  export type URLMapDeleteManyArgs = {
    where?: URLMapWhereInput
  }


  /**
   * URLMap without action
   */
  export type URLMapArgs = {
    /**
     * Select specific fields to fetch from the URLMap
     * 
    **/
    select?: URLMapSelect | null
  }



  /**
   * Model UserActions
   */


  export type AggregateUserActions = {
    _count: UserActionsCountAggregateOutputType | null
    _min: UserActionsMinAggregateOutputType | null
    _max: UserActionsMaxAggregateOutputType | null
  }

  export type UserActionsMinAggregateOutputType = {
    Id: string | null
    ActionName: string | null
    Actionkey: string | null
    Resource_id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
  }

  export type UserActionsMaxAggregateOutputType = {
    Id: string | null
    ActionName: string | null
    Actionkey: string | null
    Resource_id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
  }

  export type UserActionsCountAggregateOutputType = {
    Id: number
    ActionName: number
    Actionkey: number
    Resource_id: number
    CreatedDate: number
    ModifiedDate: number
    Status: number
    _all: number
  }


  export type UserActionsMinAggregateInputType = {
    Id?: true
    ActionName?: true
    Actionkey?: true
    Resource_id?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
  }

  export type UserActionsMaxAggregateInputType = {
    Id?: true
    ActionName?: true
    Actionkey?: true
    Resource_id?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
  }

  export type UserActionsCountAggregateInputType = {
    Id?: true
    ActionName?: true
    Actionkey?: true
    Resource_id?: true
    CreatedDate?: true
    ModifiedDate?: true
    Status?: true
    _all?: true
  }

  export type UserActionsAggregateArgs = {
    /**
     * Filter which UserActions to aggregate.
     * 
    **/
    where?: UserActionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActions to fetch.
     * 
    **/
    orderBy?: Enumerable<UserActionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserActionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserActions
    **/
    _count?: true | UserActionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserActionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserActionsMaxAggregateInputType
  }

  export type GetUserActionsAggregateType<T extends UserActionsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserActions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserActions[P]>
      : GetScalarType<T[P], AggregateUserActions[P]>
  }




  export type UserActionsGroupByArgs = {
    where?: UserActionsWhereInput
    orderBy?: Enumerable<UserActionsOrderByWithAggregationInput>
    by: Array<UserActionsScalarFieldEnum>
    having?: UserActionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserActionsCountAggregateInputType | true
    _min?: UserActionsMinAggregateInputType
    _max?: UserActionsMaxAggregateInputType
  }


  export type UserActionsGroupByOutputType = {
    Id: string
    ActionName: string | null
    Actionkey: string | null
    Resource_id: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Status: string | null
    _count: UserActionsCountAggregateOutputType | null
    _min: UserActionsMinAggregateOutputType | null
    _max: UserActionsMaxAggregateOutputType | null
  }

  type GetUserActionsGroupByPayload<T extends UserActionsGroupByArgs> = Promise<
    Array<
      PickArray<UserActionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserActionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserActionsGroupByOutputType[P]>
            : GetScalarType<T[P], UserActionsGroupByOutputType[P]>
        }
      >
    >


  export type UserActionsSelect = {
    Id?: boolean
    ActionName?: boolean
    Actionkey?: boolean
    Resource_id?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
    Status?: boolean
  }

  export type UserActionsGetPayload<
    S extends boolean | null | undefined | UserActionsArgs,
    U = keyof S
      > = S extends true
        ? UserActions
    : S extends undefined
    ? never
    : S extends UserActionsArgs | UserActionsFindManyArgs
    ?'include' extends U
    ? UserActions 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserActions ?UserActions [P]
  : 
     never
  } 
    : UserActions
  : UserActions


  type UserActionsCountArgs = Merge<
    Omit<UserActionsFindManyArgs, 'select' | 'include'> & {
      select?: UserActionsCountAggregateInputType | true
    }
  >

  export interface UserActionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserActions that matches the filter.
     * @param {UserActionsFindUniqueArgs} args - Arguments to find a UserActions
     * @example
     * // Get one UserActions
     * const userActions = await prisma.userActions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserActionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserActionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserActions'> extends True ? CheckSelect<T, Prisma__UserActionsClient<UserActions>, Prisma__UserActionsClient<UserActionsGetPayload<T>>> : CheckSelect<T, Prisma__UserActionsClient<UserActions | null >, Prisma__UserActionsClient<UserActionsGetPayload<T> | null >>

    /**
     * Find the first UserActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActionsFindFirstArgs} args - Arguments to find a UserActions
     * @example
     * // Get one UserActions
     * const userActions = await prisma.userActions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserActionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserActionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserActions'> extends True ? CheckSelect<T, Prisma__UserActionsClient<UserActions>, Prisma__UserActionsClient<UserActionsGetPayload<T>>> : CheckSelect<T, Prisma__UserActionsClient<UserActions | null >, Prisma__UserActionsClient<UserActionsGetPayload<T> | null >>

    /**
     * Find zero or more UserActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserActions
     * const userActions = await prisma.userActions.findMany()
     * 
     * // Get first 10 UserActions
     * const userActions = await prisma.userActions.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userActionsWithIdOnly = await prisma.userActions.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserActionsFindManyArgs>(
      args?: SelectSubset<T, UserActionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserActions>>, PrismaPromise<Array<UserActionsGetPayload<T>>>>

    /**
     * Create a UserActions.
     * @param {UserActionsCreateArgs} args - Arguments to create a UserActions.
     * @example
     * // Create one UserActions
     * const UserActions = await prisma.userActions.create({
     *   data: {
     *     // ... data to create a UserActions
     *   }
     * })
     * 
    **/
    create<T extends UserActionsCreateArgs>(
      args: SelectSubset<T, UserActionsCreateArgs>
    ): CheckSelect<T, Prisma__UserActionsClient<UserActions>, Prisma__UserActionsClient<UserActionsGetPayload<T>>>

    /**
     * Create many UserActions.
     *     @param {UserActionsCreateManyArgs} args - Arguments to create many UserActions.
     *     @example
     *     // Create many UserActions
     *     const userActions = await prisma.userActions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserActionsCreateManyArgs>(
      args?: SelectSubset<T, UserActionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserActions.
     * @param {UserActionsDeleteArgs} args - Arguments to delete one UserActions.
     * @example
     * // Delete one UserActions
     * const UserActions = await prisma.userActions.delete({
     *   where: {
     *     // ... filter to delete one UserActions
     *   }
     * })
     * 
    **/
    delete<T extends UserActionsDeleteArgs>(
      args: SelectSubset<T, UserActionsDeleteArgs>
    ): CheckSelect<T, Prisma__UserActionsClient<UserActions>, Prisma__UserActionsClient<UserActionsGetPayload<T>>>

    /**
     * Update one UserActions.
     * @param {UserActionsUpdateArgs} args - Arguments to update one UserActions.
     * @example
     * // Update one UserActions
     * const userActions = await prisma.userActions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserActionsUpdateArgs>(
      args: SelectSubset<T, UserActionsUpdateArgs>
    ): CheckSelect<T, Prisma__UserActionsClient<UserActions>, Prisma__UserActionsClient<UserActionsGetPayload<T>>>

    /**
     * Delete zero or more UserActions.
     * @param {UserActionsDeleteManyArgs} args - Arguments to filter UserActions to delete.
     * @example
     * // Delete a few UserActions
     * const { count } = await prisma.userActions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserActionsDeleteManyArgs>(
      args?: SelectSubset<T, UserActionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserActions
     * const userActions = await prisma.userActions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserActionsUpdateManyArgs>(
      args: SelectSubset<T, UserActionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserActions.
     * @param {UserActionsUpsertArgs} args - Arguments to update or create a UserActions.
     * @example
     * // Update or create a UserActions
     * const userActions = await prisma.userActions.upsert({
     *   create: {
     *     // ... data to create a UserActions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserActions we want to update
     *   }
     * })
    **/
    upsert<T extends UserActionsUpsertArgs>(
      args: SelectSubset<T, UserActionsUpsertArgs>
    ): CheckSelect<T, Prisma__UserActionsClient<UserActions>, Prisma__UserActionsClient<UserActionsGetPayload<T>>>

    /**
     * Count the number of UserActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActionsCountArgs} args - Arguments to filter UserActions to count.
     * @example
     * // Count the number of UserActions
     * const count = await prisma.userActions.count({
     *   where: {
     *     // ... the filter for the UserActions we want to count
     *   }
     * })
    **/
    count<T extends UserActionsCountArgs>(
      args?: Subset<T, UserActionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserActionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserActionsAggregateArgs>(args: Subset<T, UserActionsAggregateArgs>): PrismaPromise<GetUserActionsAggregateType<T>>

    /**
     * Group by UserActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserActionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserActionsGroupByArgs['orderBy'] }
        : { orderBy?: UserActionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserActionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserActionsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserActions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserActionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserActions findUnique
   */
  export type UserActionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserActions
     * 
    **/
    select?: UserActionsSelect | null
    /**
     * Throw an Error if a UserActions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserActions to fetch.
     * 
    **/
    where: UserActionsWhereUniqueInput
  }


  /**
   * UserActions findFirst
   */
  export type UserActionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserActions
     * 
    **/
    select?: UserActionsSelect | null
    /**
     * Throw an Error if a UserActions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserActions to fetch.
     * 
    **/
    where?: UserActionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActions to fetch.
     * 
    **/
    orderBy?: Enumerable<UserActionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActions.
     * 
    **/
    cursor?: UserActionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActions.
     * 
    **/
    distinct?: Enumerable<UserActionsScalarFieldEnum>
  }


  /**
   * UserActions findMany
   */
  export type UserActionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserActions
     * 
    **/
    select?: UserActionsSelect | null
    /**
     * Filter, which UserActions to fetch.
     * 
    **/
    where?: UserActionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActions to fetch.
     * 
    **/
    orderBy?: Enumerable<UserActionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserActions.
     * 
    **/
    cursor?: UserActionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserActionsScalarFieldEnum>
  }


  /**
   * UserActions create
   */
  export type UserActionsCreateArgs = {
    /**
     * Select specific fields to fetch from the UserActions
     * 
    **/
    select?: UserActionsSelect | null
    /**
     * The data needed to create a UserActions.
     * 
    **/
    data: XOR<UserActionsCreateInput, UserActionsUncheckedCreateInput>
  }


  /**
   * UserActions createMany
   */
  export type UserActionsCreateManyArgs = {
    data: Enumerable<UserActionsCreateManyInput>
  }


  /**
   * UserActions update
   */
  export type UserActionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserActions
     * 
    **/
    select?: UserActionsSelect | null
    /**
     * The data needed to update a UserActions.
     * 
    **/
    data: XOR<UserActionsUpdateInput, UserActionsUncheckedUpdateInput>
    /**
     * Choose, which UserActions to update.
     * 
    **/
    where: UserActionsWhereUniqueInput
  }


  /**
   * UserActions updateMany
   */
  export type UserActionsUpdateManyArgs = {
    data: XOR<UserActionsUpdateManyMutationInput, UserActionsUncheckedUpdateManyInput>
    where?: UserActionsWhereInput
  }


  /**
   * UserActions upsert
   */
  export type UserActionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserActions
     * 
    **/
    select?: UserActionsSelect | null
    /**
     * The filter to search for the UserActions to update in case it exists.
     * 
    **/
    where: UserActionsWhereUniqueInput
    /**
     * In case the UserActions found by the `where` argument doesn't exist, create a new UserActions with this data.
     * 
    **/
    create: XOR<UserActionsCreateInput, UserActionsUncheckedCreateInput>
    /**
     * In case the UserActions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserActionsUpdateInput, UserActionsUncheckedUpdateInput>
  }


  /**
   * UserActions delete
   */
  export type UserActionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserActions
     * 
    **/
    select?: UserActionsSelect | null
    /**
     * Filter which UserActions to delete.
     * 
    **/
    where: UserActionsWhereUniqueInput
  }


  /**
   * UserActions deleteMany
   */
  export type UserActionsDeleteManyArgs = {
    where?: UserActionsWhereInput
  }


  /**
   * UserActions without action
   */
  export type UserActionsArgs = {
    /**
     * Select specific fields to fetch from the UserActions
     * 
    **/
    select?: UserActionsSelect | null
  }



  /**
   * Model UserGroupConnectors
   */


  export type AggregateUserGroupConnectors = {
    _count: UserGroupConnectorsCountAggregateOutputType | null
    _min: UserGroupConnectorsMinAggregateOutputType | null
    _max: UserGroupConnectorsMaxAggregateOutputType | null
  }

  export type UserGroupConnectorsMinAggregateOutputType = {
    Id: string | null
    UserGroup_Id: string | null
    User_Id: string | null
    Status: string | null
    CreatedDate: Date | null
  }

  export type UserGroupConnectorsMaxAggregateOutputType = {
    Id: string | null
    UserGroup_Id: string | null
    User_Id: string | null
    Status: string | null
    CreatedDate: Date | null
  }

  export type UserGroupConnectorsCountAggregateOutputType = {
    Id: number
    UserGroup_Id: number
    User_Id: number
    Status: number
    CreatedDate: number
    _all: number
  }


  export type UserGroupConnectorsMinAggregateInputType = {
    Id?: true
    UserGroup_Id?: true
    User_Id?: true
    Status?: true
    CreatedDate?: true
  }

  export type UserGroupConnectorsMaxAggregateInputType = {
    Id?: true
    UserGroup_Id?: true
    User_Id?: true
    Status?: true
    CreatedDate?: true
  }

  export type UserGroupConnectorsCountAggregateInputType = {
    Id?: true
    UserGroup_Id?: true
    User_Id?: true
    Status?: true
    CreatedDate?: true
    _all?: true
  }

  export type UserGroupConnectorsAggregateArgs = {
    /**
     * Filter which UserGroupConnectors to aggregate.
     * 
    **/
    where?: UserGroupConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroupConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<UserGroupConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserGroupConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroupConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroupConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGroupConnectors
    **/
    _count?: true | UserGroupConnectorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGroupConnectorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGroupConnectorsMaxAggregateInputType
  }

  export type GetUserGroupConnectorsAggregateType<T extends UserGroupConnectorsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGroupConnectors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGroupConnectors[P]>
      : GetScalarType<T[P], AggregateUserGroupConnectors[P]>
  }




  export type UserGroupConnectorsGroupByArgs = {
    where?: UserGroupConnectorsWhereInput
    orderBy?: Enumerable<UserGroupConnectorsOrderByWithAggregationInput>
    by: Array<UserGroupConnectorsScalarFieldEnum>
    having?: UserGroupConnectorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGroupConnectorsCountAggregateInputType | true
    _min?: UserGroupConnectorsMinAggregateInputType
    _max?: UserGroupConnectorsMaxAggregateInputType
  }


  export type UserGroupConnectorsGroupByOutputType = {
    Id: string
    UserGroup_Id: string | null
    User_Id: string | null
    Status: string | null
    CreatedDate: Date | null
    _count: UserGroupConnectorsCountAggregateOutputType | null
    _min: UserGroupConnectorsMinAggregateOutputType | null
    _max: UserGroupConnectorsMaxAggregateOutputType | null
  }

  type GetUserGroupConnectorsGroupByPayload<T extends UserGroupConnectorsGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupConnectorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupConnectorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupConnectorsGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupConnectorsGroupByOutputType[P]>
        }
      >
    >


  export type UserGroupConnectorsSelect = {
    Id?: boolean
    UserGroup_Id?: boolean
    User_Id?: boolean
    Status?: boolean
    CreatedDate?: boolean
  }

  export type UserGroupConnectorsGetPayload<
    S extends boolean | null | undefined | UserGroupConnectorsArgs,
    U = keyof S
      > = S extends true
        ? UserGroupConnectors
    : S extends undefined
    ? never
    : S extends UserGroupConnectorsArgs | UserGroupConnectorsFindManyArgs
    ?'include' extends U
    ? UserGroupConnectors 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserGroupConnectors ?UserGroupConnectors [P]
  : 
     never
  } 
    : UserGroupConnectors
  : UserGroupConnectors


  type UserGroupConnectorsCountArgs = Merge<
    Omit<UserGroupConnectorsFindManyArgs, 'select' | 'include'> & {
      select?: UserGroupConnectorsCountAggregateInputType | true
    }
  >

  export interface UserGroupConnectorsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserGroupConnectors that matches the filter.
     * @param {UserGroupConnectorsFindUniqueArgs} args - Arguments to find a UserGroupConnectors
     * @example
     * // Get one UserGroupConnectors
     * const userGroupConnectors = await prisma.userGroupConnectors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserGroupConnectorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserGroupConnectorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserGroupConnectors'> extends True ? CheckSelect<T, Prisma__UserGroupConnectorsClient<UserGroupConnectors>, Prisma__UserGroupConnectorsClient<UserGroupConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__UserGroupConnectorsClient<UserGroupConnectors | null >, Prisma__UserGroupConnectorsClient<UserGroupConnectorsGetPayload<T> | null >>

    /**
     * Find the first UserGroupConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupConnectorsFindFirstArgs} args - Arguments to find a UserGroupConnectors
     * @example
     * // Get one UserGroupConnectors
     * const userGroupConnectors = await prisma.userGroupConnectors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserGroupConnectorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserGroupConnectorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserGroupConnectors'> extends True ? CheckSelect<T, Prisma__UserGroupConnectorsClient<UserGroupConnectors>, Prisma__UserGroupConnectorsClient<UserGroupConnectorsGetPayload<T>>> : CheckSelect<T, Prisma__UserGroupConnectorsClient<UserGroupConnectors | null >, Prisma__UserGroupConnectorsClient<UserGroupConnectorsGetPayload<T> | null >>

    /**
     * Find zero or more UserGroupConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupConnectorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGroupConnectors
     * const userGroupConnectors = await prisma.userGroupConnectors.findMany()
     * 
     * // Get first 10 UserGroupConnectors
     * const userGroupConnectors = await prisma.userGroupConnectors.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userGroupConnectorsWithIdOnly = await prisma.userGroupConnectors.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserGroupConnectorsFindManyArgs>(
      args?: SelectSubset<T, UserGroupConnectorsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserGroupConnectors>>, PrismaPromise<Array<UserGroupConnectorsGetPayload<T>>>>

    /**
     * Create a UserGroupConnectors.
     * @param {UserGroupConnectorsCreateArgs} args - Arguments to create a UserGroupConnectors.
     * @example
     * // Create one UserGroupConnectors
     * const UserGroupConnectors = await prisma.userGroupConnectors.create({
     *   data: {
     *     // ... data to create a UserGroupConnectors
     *   }
     * })
     * 
    **/
    create<T extends UserGroupConnectorsCreateArgs>(
      args: SelectSubset<T, UserGroupConnectorsCreateArgs>
    ): CheckSelect<T, Prisma__UserGroupConnectorsClient<UserGroupConnectors>, Prisma__UserGroupConnectorsClient<UserGroupConnectorsGetPayload<T>>>

    /**
     * Create many UserGroupConnectors.
     *     @param {UserGroupConnectorsCreateManyArgs} args - Arguments to create many UserGroupConnectors.
     *     @example
     *     // Create many UserGroupConnectors
     *     const userGroupConnectors = await prisma.userGroupConnectors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserGroupConnectorsCreateManyArgs>(
      args?: SelectSubset<T, UserGroupConnectorsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserGroupConnectors.
     * @param {UserGroupConnectorsDeleteArgs} args - Arguments to delete one UserGroupConnectors.
     * @example
     * // Delete one UserGroupConnectors
     * const UserGroupConnectors = await prisma.userGroupConnectors.delete({
     *   where: {
     *     // ... filter to delete one UserGroupConnectors
     *   }
     * })
     * 
    **/
    delete<T extends UserGroupConnectorsDeleteArgs>(
      args: SelectSubset<T, UserGroupConnectorsDeleteArgs>
    ): CheckSelect<T, Prisma__UserGroupConnectorsClient<UserGroupConnectors>, Prisma__UserGroupConnectorsClient<UserGroupConnectorsGetPayload<T>>>

    /**
     * Update one UserGroupConnectors.
     * @param {UserGroupConnectorsUpdateArgs} args - Arguments to update one UserGroupConnectors.
     * @example
     * // Update one UserGroupConnectors
     * const userGroupConnectors = await prisma.userGroupConnectors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserGroupConnectorsUpdateArgs>(
      args: SelectSubset<T, UserGroupConnectorsUpdateArgs>
    ): CheckSelect<T, Prisma__UserGroupConnectorsClient<UserGroupConnectors>, Prisma__UserGroupConnectorsClient<UserGroupConnectorsGetPayload<T>>>

    /**
     * Delete zero or more UserGroupConnectors.
     * @param {UserGroupConnectorsDeleteManyArgs} args - Arguments to filter UserGroupConnectors to delete.
     * @example
     * // Delete a few UserGroupConnectors
     * const { count } = await prisma.userGroupConnectors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserGroupConnectorsDeleteManyArgs>(
      args?: SelectSubset<T, UserGroupConnectorsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroupConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupConnectorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGroupConnectors
     * const userGroupConnectors = await prisma.userGroupConnectors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserGroupConnectorsUpdateManyArgs>(
      args: SelectSubset<T, UserGroupConnectorsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserGroupConnectors.
     * @param {UserGroupConnectorsUpsertArgs} args - Arguments to update or create a UserGroupConnectors.
     * @example
     * // Update or create a UserGroupConnectors
     * const userGroupConnectors = await prisma.userGroupConnectors.upsert({
     *   create: {
     *     // ... data to create a UserGroupConnectors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGroupConnectors we want to update
     *   }
     * })
    **/
    upsert<T extends UserGroupConnectorsUpsertArgs>(
      args: SelectSubset<T, UserGroupConnectorsUpsertArgs>
    ): CheckSelect<T, Prisma__UserGroupConnectorsClient<UserGroupConnectors>, Prisma__UserGroupConnectorsClient<UserGroupConnectorsGetPayload<T>>>

    /**
     * Count the number of UserGroupConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupConnectorsCountArgs} args - Arguments to filter UserGroupConnectors to count.
     * @example
     * // Count the number of UserGroupConnectors
     * const count = await prisma.userGroupConnectors.count({
     *   where: {
     *     // ... the filter for the UserGroupConnectors we want to count
     *   }
     * })
    **/
    count<T extends UserGroupConnectorsCountArgs>(
      args?: Subset<T, UserGroupConnectorsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGroupConnectorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGroupConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupConnectorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGroupConnectorsAggregateArgs>(args: Subset<T, UserGroupConnectorsAggregateArgs>): PrismaPromise<GetUserGroupConnectorsAggregateType<T>>

    /**
     * Group by UserGroupConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupConnectorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupConnectorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupConnectorsGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupConnectorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupConnectorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupConnectorsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGroupConnectors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserGroupConnectorsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserGroupConnectors findUnique
   */
  export type UserGroupConnectorsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserGroupConnectors
     * 
    **/
    select?: UserGroupConnectorsSelect | null
    /**
     * Throw an Error if a UserGroupConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserGroupConnectors to fetch.
     * 
    **/
    where: UserGroupConnectorsWhereUniqueInput
  }


  /**
   * UserGroupConnectors findFirst
   */
  export type UserGroupConnectorsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserGroupConnectors
     * 
    **/
    select?: UserGroupConnectorsSelect | null
    /**
     * Throw an Error if a UserGroupConnectors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserGroupConnectors to fetch.
     * 
    **/
    where?: UserGroupConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroupConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<UserGroupConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroupConnectors.
     * 
    **/
    cursor?: UserGroupConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroupConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroupConnectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroupConnectors.
     * 
    **/
    distinct?: Enumerable<UserGroupConnectorsScalarFieldEnum>
  }


  /**
   * UserGroupConnectors findMany
   */
  export type UserGroupConnectorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserGroupConnectors
     * 
    **/
    select?: UserGroupConnectorsSelect | null
    /**
     * Filter, which UserGroupConnectors to fetch.
     * 
    **/
    where?: UserGroupConnectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroupConnectors to fetch.
     * 
    **/
    orderBy?: Enumerable<UserGroupConnectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGroupConnectors.
     * 
    **/
    cursor?: UserGroupConnectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroupConnectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroupConnectors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserGroupConnectorsScalarFieldEnum>
  }


  /**
   * UserGroupConnectors create
   */
  export type UserGroupConnectorsCreateArgs = {
    /**
     * Select specific fields to fetch from the UserGroupConnectors
     * 
    **/
    select?: UserGroupConnectorsSelect | null
    /**
     * The data needed to create a UserGroupConnectors.
     * 
    **/
    data: XOR<UserGroupConnectorsCreateInput, UserGroupConnectorsUncheckedCreateInput>
  }


  /**
   * UserGroupConnectors createMany
   */
  export type UserGroupConnectorsCreateManyArgs = {
    data: Enumerable<UserGroupConnectorsCreateManyInput>
  }


  /**
   * UserGroupConnectors update
   */
  export type UserGroupConnectorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserGroupConnectors
     * 
    **/
    select?: UserGroupConnectorsSelect | null
    /**
     * The data needed to update a UserGroupConnectors.
     * 
    **/
    data: XOR<UserGroupConnectorsUpdateInput, UserGroupConnectorsUncheckedUpdateInput>
    /**
     * Choose, which UserGroupConnectors to update.
     * 
    **/
    where: UserGroupConnectorsWhereUniqueInput
  }


  /**
   * UserGroupConnectors updateMany
   */
  export type UserGroupConnectorsUpdateManyArgs = {
    data: XOR<UserGroupConnectorsUpdateManyMutationInput, UserGroupConnectorsUncheckedUpdateManyInput>
    where?: UserGroupConnectorsWhereInput
  }


  /**
   * UserGroupConnectors upsert
   */
  export type UserGroupConnectorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserGroupConnectors
     * 
    **/
    select?: UserGroupConnectorsSelect | null
    /**
     * The filter to search for the UserGroupConnectors to update in case it exists.
     * 
    **/
    where: UserGroupConnectorsWhereUniqueInput
    /**
     * In case the UserGroupConnectors found by the `where` argument doesn't exist, create a new UserGroupConnectors with this data.
     * 
    **/
    create: XOR<UserGroupConnectorsCreateInput, UserGroupConnectorsUncheckedCreateInput>
    /**
     * In case the UserGroupConnectors was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserGroupConnectorsUpdateInput, UserGroupConnectorsUncheckedUpdateInput>
  }


  /**
   * UserGroupConnectors delete
   */
  export type UserGroupConnectorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserGroupConnectors
     * 
    **/
    select?: UserGroupConnectorsSelect | null
    /**
     * Filter which UserGroupConnectors to delete.
     * 
    **/
    where: UserGroupConnectorsWhereUniqueInput
  }


  /**
   * UserGroupConnectors deleteMany
   */
  export type UserGroupConnectorsDeleteManyArgs = {
    where?: UserGroupConnectorsWhereInput
  }


  /**
   * UserGroupConnectors without action
   */
  export type UserGroupConnectorsArgs = {
    /**
     * Select specific fields to fetch from the UserGroupConnectors
     * 
    **/
    select?: UserGroupConnectorsSelect | null
  }



  /**
   * Model UserGroups
   */


  export type AggregateUserGroups = {
    _count: UserGroupsCountAggregateOutputType | null
    _avg: UserGroupsAvgAggregateOutputType | null
    _sum: UserGroupsSumAggregateOutputType | null
    _min: UserGroupsMinAggregateOutputType | null
    _max: UserGroupsMaxAggregateOutputType | null
  }

  export type UserGroupsAvgAggregateOutputType = {
    EditFeatures: number | null
    IsReadOnly: number | null
  }

  export type UserGroupsSumAggregateOutputType = {
    EditFeatures: number | null
    IsReadOnly: number | null
  }

  export type UserGroupsMinAggregateOutputType = {
    Id: string | null
    GroupName: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    EditFeatures: number | null
    Status: string | null
    UserGroups_Role_Id: string | null
    IsReadOnly: number | null
  }

  export type UserGroupsMaxAggregateOutputType = {
    Id: string | null
    GroupName: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    EditFeatures: number | null
    Status: string | null
    UserGroups_Role_Id: string | null
    IsReadOnly: number | null
  }

  export type UserGroupsCountAggregateOutputType = {
    Id: number
    GroupName: number
    CreatedDate: number
    ModifiedDate: number
    EditFeatures: number
    Status: number
    UserGroups_Role_Id: number
    IsReadOnly: number
    _all: number
  }


  export type UserGroupsAvgAggregateInputType = {
    EditFeatures?: true
    IsReadOnly?: true
  }

  export type UserGroupsSumAggregateInputType = {
    EditFeatures?: true
    IsReadOnly?: true
  }

  export type UserGroupsMinAggregateInputType = {
    Id?: true
    GroupName?: true
    CreatedDate?: true
    ModifiedDate?: true
    EditFeatures?: true
    Status?: true
    UserGroups_Role_Id?: true
    IsReadOnly?: true
  }

  export type UserGroupsMaxAggregateInputType = {
    Id?: true
    GroupName?: true
    CreatedDate?: true
    ModifiedDate?: true
    EditFeatures?: true
    Status?: true
    UserGroups_Role_Id?: true
    IsReadOnly?: true
  }

  export type UserGroupsCountAggregateInputType = {
    Id?: true
    GroupName?: true
    CreatedDate?: true
    ModifiedDate?: true
    EditFeatures?: true
    Status?: true
    UserGroups_Role_Id?: true
    IsReadOnly?: true
    _all?: true
  }

  export type UserGroupsAggregateArgs = {
    /**
     * Filter which UserGroups to aggregate.
     * 
    **/
    where?: UserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<UserGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGroups
    **/
    _count?: true | UserGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserGroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserGroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGroupsMaxAggregateInputType
  }

  export type GetUserGroupsAggregateType<T extends UserGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGroups[P]>
      : GetScalarType<T[P], AggregateUserGroups[P]>
  }




  export type UserGroupsGroupByArgs = {
    where?: UserGroupsWhereInput
    orderBy?: Enumerable<UserGroupsOrderByWithAggregationInput>
    by: Array<UserGroupsScalarFieldEnum>
    having?: UserGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGroupsCountAggregateInputType | true
    _avg?: UserGroupsAvgAggregateInputType
    _sum?: UserGroupsSumAggregateInputType
    _min?: UserGroupsMinAggregateInputType
    _max?: UserGroupsMaxAggregateInputType
  }


  export type UserGroupsGroupByOutputType = {
    Id: string
    GroupName: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    EditFeatures: number | null
    Status: string | null
    UserGroups_Role_Id: string | null
    IsReadOnly: number
    _count: UserGroupsCountAggregateOutputType | null
    _avg: UserGroupsAvgAggregateOutputType | null
    _sum: UserGroupsSumAggregateOutputType | null
    _min: UserGroupsMinAggregateOutputType | null
    _max: UserGroupsMaxAggregateOutputType | null
  }

  type GetUserGroupsGroupByPayload<T extends UserGroupsGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupsGroupByOutputType[P]>
        }
      >
    >


  export type UserGroupsSelect = {
    Id?: boolean
    GroupName?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
    EditFeatures?: boolean
    Status?: boolean
    UserGroups_Role_Id?: boolean
    IsReadOnly?: boolean
  }

  export type UserGroupsGetPayload<
    S extends boolean | null | undefined | UserGroupsArgs,
    U = keyof S
      > = S extends true
        ? UserGroups
    : S extends undefined
    ? never
    : S extends UserGroupsArgs | UserGroupsFindManyArgs
    ?'include' extends U
    ? UserGroups 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserGroups ?UserGroups [P]
  : 
     never
  } 
    : UserGroups
  : UserGroups


  type UserGroupsCountArgs = Merge<
    Omit<UserGroupsFindManyArgs, 'select' | 'include'> & {
      select?: UserGroupsCountAggregateInputType | true
    }
  >

  export interface UserGroupsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserGroups that matches the filter.
     * @param {UserGroupsFindUniqueArgs} args - Arguments to find a UserGroups
     * @example
     * // Get one UserGroups
     * const userGroups = await prisma.userGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserGroupsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserGroupsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserGroups'> extends True ? CheckSelect<T, Prisma__UserGroupsClient<UserGroups>, Prisma__UserGroupsClient<UserGroupsGetPayload<T>>> : CheckSelect<T, Prisma__UserGroupsClient<UserGroups | null >, Prisma__UserGroupsClient<UserGroupsGetPayload<T> | null >>

    /**
     * Find the first UserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsFindFirstArgs} args - Arguments to find a UserGroups
     * @example
     * // Get one UserGroups
     * const userGroups = await prisma.userGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserGroupsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserGroupsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserGroups'> extends True ? CheckSelect<T, Prisma__UserGroupsClient<UserGroups>, Prisma__UserGroupsClient<UserGroupsGetPayload<T>>> : CheckSelect<T, Prisma__UserGroupsClient<UserGroups | null >, Prisma__UserGroupsClient<UserGroupsGetPayload<T> | null >>

    /**
     * Find zero or more UserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGroups
     * const userGroups = await prisma.userGroups.findMany()
     * 
     * // Get first 10 UserGroups
     * const userGroups = await prisma.userGroups.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userGroupsWithIdOnly = await prisma.userGroups.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserGroupsFindManyArgs>(
      args?: SelectSubset<T, UserGroupsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserGroups>>, PrismaPromise<Array<UserGroupsGetPayload<T>>>>

    /**
     * Create a UserGroups.
     * @param {UserGroupsCreateArgs} args - Arguments to create a UserGroups.
     * @example
     * // Create one UserGroups
     * const UserGroups = await prisma.userGroups.create({
     *   data: {
     *     // ... data to create a UserGroups
     *   }
     * })
     * 
    **/
    create<T extends UserGroupsCreateArgs>(
      args: SelectSubset<T, UserGroupsCreateArgs>
    ): CheckSelect<T, Prisma__UserGroupsClient<UserGroups>, Prisma__UserGroupsClient<UserGroupsGetPayload<T>>>

    /**
     * Create many UserGroups.
     *     @param {UserGroupsCreateManyArgs} args - Arguments to create many UserGroups.
     *     @example
     *     // Create many UserGroups
     *     const userGroups = await prisma.userGroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserGroupsCreateManyArgs>(
      args?: SelectSubset<T, UserGroupsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserGroups.
     * @param {UserGroupsDeleteArgs} args - Arguments to delete one UserGroups.
     * @example
     * // Delete one UserGroups
     * const UserGroups = await prisma.userGroups.delete({
     *   where: {
     *     // ... filter to delete one UserGroups
     *   }
     * })
     * 
    **/
    delete<T extends UserGroupsDeleteArgs>(
      args: SelectSubset<T, UserGroupsDeleteArgs>
    ): CheckSelect<T, Prisma__UserGroupsClient<UserGroups>, Prisma__UserGroupsClient<UserGroupsGetPayload<T>>>

    /**
     * Update one UserGroups.
     * @param {UserGroupsUpdateArgs} args - Arguments to update one UserGroups.
     * @example
     * // Update one UserGroups
     * const userGroups = await prisma.userGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserGroupsUpdateArgs>(
      args: SelectSubset<T, UserGroupsUpdateArgs>
    ): CheckSelect<T, Prisma__UserGroupsClient<UserGroups>, Prisma__UserGroupsClient<UserGroupsGetPayload<T>>>

    /**
     * Delete zero or more UserGroups.
     * @param {UserGroupsDeleteManyArgs} args - Arguments to filter UserGroups to delete.
     * @example
     * // Delete a few UserGroups
     * const { count } = await prisma.userGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserGroupsDeleteManyArgs>(
      args?: SelectSubset<T, UserGroupsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGroups
     * const userGroups = await prisma.userGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserGroupsUpdateManyArgs>(
      args: SelectSubset<T, UserGroupsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserGroups.
     * @param {UserGroupsUpsertArgs} args - Arguments to update or create a UserGroups.
     * @example
     * // Update or create a UserGroups
     * const userGroups = await prisma.userGroups.upsert({
     *   create: {
     *     // ... data to create a UserGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGroups we want to update
     *   }
     * })
    **/
    upsert<T extends UserGroupsUpsertArgs>(
      args: SelectSubset<T, UserGroupsUpsertArgs>
    ): CheckSelect<T, Prisma__UserGroupsClient<UserGroups>, Prisma__UserGroupsClient<UserGroupsGetPayload<T>>>

    /**
     * Count the number of UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsCountArgs} args - Arguments to filter UserGroups to count.
     * @example
     * // Count the number of UserGroups
     * const count = await prisma.userGroups.count({
     *   where: {
     *     // ... the filter for the UserGroups we want to count
     *   }
     * })
    **/
    count<T extends UserGroupsCountArgs>(
      args?: Subset<T, UserGroupsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGroupsAggregateArgs>(args: Subset<T, UserGroupsAggregateArgs>): PrismaPromise<GetUserGroupsAggregateType<T>>

    /**
     * Group by UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupsGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserGroupsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserGroups findUnique
   */
  export type UserGroupsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserGroups
     * 
    **/
    select?: UserGroupsSelect | null
    /**
     * Throw an Error if a UserGroups can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserGroups to fetch.
     * 
    **/
    where: UserGroupsWhereUniqueInput
  }


  /**
   * UserGroups findFirst
   */
  export type UserGroupsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserGroups
     * 
    **/
    select?: UserGroupsSelect | null
    /**
     * Throw an Error if a UserGroups can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserGroups to fetch.
     * 
    **/
    where?: UserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<UserGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroups.
     * 
    **/
    cursor?: UserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroups.
     * 
    **/
    distinct?: Enumerable<UserGroupsScalarFieldEnum>
  }


  /**
   * UserGroups findMany
   */
  export type UserGroupsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserGroups
     * 
    **/
    select?: UserGroupsSelect | null
    /**
     * Filter, which UserGroups to fetch.
     * 
    **/
    where?: UserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<UserGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGroups.
     * 
    **/
    cursor?: UserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserGroupsScalarFieldEnum>
  }


  /**
   * UserGroups create
   */
  export type UserGroupsCreateArgs = {
    /**
     * Select specific fields to fetch from the UserGroups
     * 
    **/
    select?: UserGroupsSelect | null
    /**
     * The data needed to create a UserGroups.
     * 
    **/
    data: XOR<UserGroupsCreateInput, UserGroupsUncheckedCreateInput>
  }


  /**
   * UserGroups createMany
   */
  export type UserGroupsCreateManyArgs = {
    data: Enumerable<UserGroupsCreateManyInput>
  }


  /**
   * UserGroups update
   */
  export type UserGroupsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserGroups
     * 
    **/
    select?: UserGroupsSelect | null
    /**
     * The data needed to update a UserGroups.
     * 
    **/
    data: XOR<UserGroupsUpdateInput, UserGroupsUncheckedUpdateInput>
    /**
     * Choose, which UserGroups to update.
     * 
    **/
    where: UserGroupsWhereUniqueInput
  }


  /**
   * UserGroups updateMany
   */
  export type UserGroupsUpdateManyArgs = {
    data: XOR<UserGroupsUpdateManyMutationInput, UserGroupsUncheckedUpdateManyInput>
    where?: UserGroupsWhereInput
  }


  /**
   * UserGroups upsert
   */
  export type UserGroupsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserGroups
     * 
    **/
    select?: UserGroupsSelect | null
    /**
     * The filter to search for the UserGroups to update in case it exists.
     * 
    **/
    where: UserGroupsWhereUniqueInput
    /**
     * In case the UserGroups found by the `where` argument doesn't exist, create a new UserGroups with this data.
     * 
    **/
    create: XOR<UserGroupsCreateInput, UserGroupsUncheckedCreateInput>
    /**
     * In case the UserGroups was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserGroupsUpdateInput, UserGroupsUncheckedUpdateInput>
  }


  /**
   * UserGroups delete
   */
  export type UserGroupsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserGroups
     * 
    **/
    select?: UserGroupsSelect | null
    /**
     * Filter which UserGroups to delete.
     * 
    **/
    where: UserGroupsWhereUniqueInput
  }


  /**
   * UserGroups deleteMany
   */
  export type UserGroupsDeleteManyArgs = {
    where?: UserGroupsWhereInput
  }


  /**
   * UserGroups without action
   */
  export type UserGroupsArgs = {
    /**
     * Select specific fields to fetch from the UserGroups
     * 
    **/
    select?: UserGroupsSelect | null
  }



  /**
   * Model UserIdentityClaims
   */


  export type AggregateUserIdentityClaims = {
    _count: UserIdentityClaimsCountAggregateOutputType | null
    _avg: UserIdentityClaimsAvgAggregateOutputType | null
    _sum: UserIdentityClaimsSumAggregateOutputType | null
    _min: UserIdentityClaimsMinAggregateOutputType | null
    _max: UserIdentityClaimsMaxAggregateOutputType | null
  }

  export type UserIdentityClaimsAvgAggregateOutputType = {
    Id: number | null
  }

  export type UserIdentityClaimsSumAggregateOutputType = {
    Id: number | null
  }

  export type UserIdentityClaimsMinAggregateOutputType = {
    Id: number | null
    UserId: string | null
    ClaimType: string | null
    ClaimValue: string | null
  }

  export type UserIdentityClaimsMaxAggregateOutputType = {
    Id: number | null
    UserId: string | null
    ClaimType: string | null
    ClaimValue: string | null
  }

  export type UserIdentityClaimsCountAggregateOutputType = {
    Id: number
    UserId: number
    ClaimType: number
    ClaimValue: number
    _all: number
  }


  export type UserIdentityClaimsAvgAggregateInputType = {
    Id?: true
  }

  export type UserIdentityClaimsSumAggregateInputType = {
    Id?: true
  }

  export type UserIdentityClaimsMinAggregateInputType = {
    Id?: true
    UserId?: true
    ClaimType?: true
    ClaimValue?: true
  }

  export type UserIdentityClaimsMaxAggregateInputType = {
    Id?: true
    UserId?: true
    ClaimType?: true
    ClaimValue?: true
  }

  export type UserIdentityClaimsCountAggregateInputType = {
    Id?: true
    UserId?: true
    ClaimType?: true
    ClaimValue?: true
    _all?: true
  }

  export type UserIdentityClaimsAggregateArgs = {
    /**
     * Filter which UserIdentityClaims to aggregate.
     * 
    **/
    where?: UserIdentityClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityClaims to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityClaimsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserIdentityClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityClaims from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityClaims.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserIdentityClaims
    **/
    _count?: true | UserIdentityClaimsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserIdentityClaimsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserIdentityClaimsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserIdentityClaimsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserIdentityClaimsMaxAggregateInputType
  }

  export type GetUserIdentityClaimsAggregateType<T extends UserIdentityClaimsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserIdentityClaims]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserIdentityClaims[P]>
      : GetScalarType<T[P], AggregateUserIdentityClaims[P]>
  }




  export type UserIdentityClaimsGroupByArgs = {
    where?: UserIdentityClaimsWhereInput
    orderBy?: Enumerable<UserIdentityClaimsOrderByWithAggregationInput>
    by: Array<UserIdentityClaimsScalarFieldEnum>
    having?: UserIdentityClaimsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserIdentityClaimsCountAggregateInputType | true
    _avg?: UserIdentityClaimsAvgAggregateInputType
    _sum?: UserIdentityClaimsSumAggregateInputType
    _min?: UserIdentityClaimsMinAggregateInputType
    _max?: UserIdentityClaimsMaxAggregateInputType
  }


  export type UserIdentityClaimsGroupByOutputType = {
    Id: number
    UserId: string
    ClaimType: string | null
    ClaimValue: string | null
    _count: UserIdentityClaimsCountAggregateOutputType | null
    _avg: UserIdentityClaimsAvgAggregateOutputType | null
    _sum: UserIdentityClaimsSumAggregateOutputType | null
    _min: UserIdentityClaimsMinAggregateOutputType | null
    _max: UserIdentityClaimsMaxAggregateOutputType | null
  }

  type GetUserIdentityClaimsGroupByPayload<T extends UserIdentityClaimsGroupByArgs> = Promise<
    Array<
      PickArray<UserIdentityClaimsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserIdentityClaimsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserIdentityClaimsGroupByOutputType[P]>
            : GetScalarType<T[P], UserIdentityClaimsGroupByOutputType[P]>
        }
      >
    >


  export type UserIdentityClaimsSelect = {
    Id?: boolean
    UserId?: boolean
    ClaimType?: boolean
    ClaimValue?: boolean
    Users?: boolean | UsersArgs
  }

  export type UserIdentityClaimsInclude = {
    Users?: boolean | UsersArgs
  }

  export type UserIdentityClaimsGetPayload<
    S extends boolean | null | undefined | UserIdentityClaimsArgs,
    U = keyof S
      > = S extends true
        ? UserIdentityClaims
    : S extends undefined
    ? never
    : S extends UserIdentityClaimsArgs | UserIdentityClaimsFindManyArgs
    ?'include' extends U
    ? UserIdentityClaims  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Users'
        ? UsersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserIdentityClaims ?UserIdentityClaims [P]
  : 
          P extends 'Users'
        ? UsersGetPayload<S['select'][P]> : never
  } 
    : UserIdentityClaims
  : UserIdentityClaims


  type UserIdentityClaimsCountArgs = Merge<
    Omit<UserIdentityClaimsFindManyArgs, 'select' | 'include'> & {
      select?: UserIdentityClaimsCountAggregateInputType | true
    }
  >

  export interface UserIdentityClaimsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserIdentityClaims that matches the filter.
     * @param {UserIdentityClaimsFindUniqueArgs} args - Arguments to find a UserIdentityClaims
     * @example
     * // Get one UserIdentityClaims
     * const userIdentityClaims = await prisma.userIdentityClaims.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserIdentityClaimsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserIdentityClaimsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserIdentityClaims'> extends True ? CheckSelect<T, Prisma__UserIdentityClaimsClient<UserIdentityClaims>, Prisma__UserIdentityClaimsClient<UserIdentityClaimsGetPayload<T>>> : CheckSelect<T, Prisma__UserIdentityClaimsClient<UserIdentityClaims | null >, Prisma__UserIdentityClaimsClient<UserIdentityClaimsGetPayload<T> | null >>

    /**
     * Find the first UserIdentityClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityClaimsFindFirstArgs} args - Arguments to find a UserIdentityClaims
     * @example
     * // Get one UserIdentityClaims
     * const userIdentityClaims = await prisma.userIdentityClaims.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserIdentityClaimsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserIdentityClaimsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserIdentityClaims'> extends True ? CheckSelect<T, Prisma__UserIdentityClaimsClient<UserIdentityClaims>, Prisma__UserIdentityClaimsClient<UserIdentityClaimsGetPayload<T>>> : CheckSelect<T, Prisma__UserIdentityClaimsClient<UserIdentityClaims | null >, Prisma__UserIdentityClaimsClient<UserIdentityClaimsGetPayload<T> | null >>

    /**
     * Find zero or more UserIdentityClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityClaimsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserIdentityClaims
     * const userIdentityClaims = await prisma.userIdentityClaims.findMany()
     * 
     * // Get first 10 UserIdentityClaims
     * const userIdentityClaims = await prisma.userIdentityClaims.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userIdentityClaimsWithIdOnly = await prisma.userIdentityClaims.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserIdentityClaimsFindManyArgs>(
      args?: SelectSubset<T, UserIdentityClaimsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserIdentityClaims>>, PrismaPromise<Array<UserIdentityClaimsGetPayload<T>>>>

    /**
     * Create a UserIdentityClaims.
     * @param {UserIdentityClaimsCreateArgs} args - Arguments to create a UserIdentityClaims.
     * @example
     * // Create one UserIdentityClaims
     * const UserIdentityClaims = await prisma.userIdentityClaims.create({
     *   data: {
     *     // ... data to create a UserIdentityClaims
     *   }
     * })
     * 
    **/
    create<T extends UserIdentityClaimsCreateArgs>(
      args: SelectSubset<T, UserIdentityClaimsCreateArgs>
    ): CheckSelect<T, Prisma__UserIdentityClaimsClient<UserIdentityClaims>, Prisma__UserIdentityClaimsClient<UserIdentityClaimsGetPayload<T>>>

    /**
     * Create many UserIdentityClaims.
     *     @param {UserIdentityClaimsCreateManyArgs} args - Arguments to create many UserIdentityClaims.
     *     @example
     *     // Create many UserIdentityClaims
     *     const userIdentityClaims = await prisma.userIdentityClaims.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserIdentityClaimsCreateManyArgs>(
      args?: SelectSubset<T, UserIdentityClaimsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserIdentityClaims.
     * @param {UserIdentityClaimsDeleteArgs} args - Arguments to delete one UserIdentityClaims.
     * @example
     * // Delete one UserIdentityClaims
     * const UserIdentityClaims = await prisma.userIdentityClaims.delete({
     *   where: {
     *     // ... filter to delete one UserIdentityClaims
     *   }
     * })
     * 
    **/
    delete<T extends UserIdentityClaimsDeleteArgs>(
      args: SelectSubset<T, UserIdentityClaimsDeleteArgs>
    ): CheckSelect<T, Prisma__UserIdentityClaimsClient<UserIdentityClaims>, Prisma__UserIdentityClaimsClient<UserIdentityClaimsGetPayload<T>>>

    /**
     * Update one UserIdentityClaims.
     * @param {UserIdentityClaimsUpdateArgs} args - Arguments to update one UserIdentityClaims.
     * @example
     * // Update one UserIdentityClaims
     * const userIdentityClaims = await prisma.userIdentityClaims.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserIdentityClaimsUpdateArgs>(
      args: SelectSubset<T, UserIdentityClaimsUpdateArgs>
    ): CheckSelect<T, Prisma__UserIdentityClaimsClient<UserIdentityClaims>, Prisma__UserIdentityClaimsClient<UserIdentityClaimsGetPayload<T>>>

    /**
     * Delete zero or more UserIdentityClaims.
     * @param {UserIdentityClaimsDeleteManyArgs} args - Arguments to filter UserIdentityClaims to delete.
     * @example
     * // Delete a few UserIdentityClaims
     * const { count } = await prisma.userIdentityClaims.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserIdentityClaimsDeleteManyArgs>(
      args?: SelectSubset<T, UserIdentityClaimsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserIdentityClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityClaimsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserIdentityClaims
     * const userIdentityClaims = await prisma.userIdentityClaims.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserIdentityClaimsUpdateManyArgs>(
      args: SelectSubset<T, UserIdentityClaimsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserIdentityClaims.
     * @param {UserIdentityClaimsUpsertArgs} args - Arguments to update or create a UserIdentityClaims.
     * @example
     * // Update or create a UserIdentityClaims
     * const userIdentityClaims = await prisma.userIdentityClaims.upsert({
     *   create: {
     *     // ... data to create a UserIdentityClaims
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserIdentityClaims we want to update
     *   }
     * })
    **/
    upsert<T extends UserIdentityClaimsUpsertArgs>(
      args: SelectSubset<T, UserIdentityClaimsUpsertArgs>
    ): CheckSelect<T, Prisma__UserIdentityClaimsClient<UserIdentityClaims>, Prisma__UserIdentityClaimsClient<UserIdentityClaimsGetPayload<T>>>

    /**
     * Count the number of UserIdentityClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityClaimsCountArgs} args - Arguments to filter UserIdentityClaims to count.
     * @example
     * // Count the number of UserIdentityClaims
     * const count = await prisma.userIdentityClaims.count({
     *   where: {
     *     // ... the filter for the UserIdentityClaims we want to count
     *   }
     * })
    **/
    count<T extends UserIdentityClaimsCountArgs>(
      args?: Subset<T, UserIdentityClaimsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserIdentityClaimsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserIdentityClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityClaimsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserIdentityClaimsAggregateArgs>(args: Subset<T, UserIdentityClaimsAggregateArgs>): PrismaPromise<GetUserIdentityClaimsAggregateType<T>>

    /**
     * Group by UserIdentityClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityClaimsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserIdentityClaimsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserIdentityClaimsGroupByArgs['orderBy'] }
        : { orderBy?: UserIdentityClaimsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserIdentityClaimsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserIdentityClaimsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserIdentityClaims.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserIdentityClaimsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Users<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserIdentityClaims findUnique
   */
  export type UserIdentityClaimsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityClaims
     * 
    **/
    select?: UserIdentityClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityClaimsInclude | null
    /**
     * Throw an Error if a UserIdentityClaims can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserIdentityClaims to fetch.
     * 
    **/
    where: UserIdentityClaimsWhereUniqueInput
  }


  /**
   * UserIdentityClaims findFirst
   */
  export type UserIdentityClaimsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityClaims
     * 
    **/
    select?: UserIdentityClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityClaimsInclude | null
    /**
     * Throw an Error if a UserIdentityClaims can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserIdentityClaims to fetch.
     * 
    **/
    where?: UserIdentityClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityClaims to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityClaimsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserIdentityClaims.
     * 
    **/
    cursor?: UserIdentityClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityClaims from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityClaims.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserIdentityClaims.
     * 
    **/
    distinct?: Enumerable<UserIdentityClaimsScalarFieldEnum>
  }


  /**
   * UserIdentityClaims findMany
   */
  export type UserIdentityClaimsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityClaims
     * 
    **/
    select?: UserIdentityClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityClaimsInclude | null
    /**
     * Filter, which UserIdentityClaims to fetch.
     * 
    **/
    where?: UserIdentityClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityClaims to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityClaimsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserIdentityClaims.
     * 
    **/
    cursor?: UserIdentityClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityClaims from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityClaims.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserIdentityClaimsScalarFieldEnum>
  }


  /**
   * UserIdentityClaims create
   */
  export type UserIdentityClaimsCreateArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityClaims
     * 
    **/
    select?: UserIdentityClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityClaimsInclude | null
    /**
     * The data needed to create a UserIdentityClaims.
     * 
    **/
    data: XOR<UserIdentityClaimsCreateInput, UserIdentityClaimsUncheckedCreateInput>
  }


  /**
   * UserIdentityClaims createMany
   */
  export type UserIdentityClaimsCreateManyArgs = {
    data: Enumerable<UserIdentityClaimsCreateManyInput>
  }


  /**
   * UserIdentityClaims update
   */
  export type UserIdentityClaimsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityClaims
     * 
    **/
    select?: UserIdentityClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityClaimsInclude | null
    /**
     * The data needed to update a UserIdentityClaims.
     * 
    **/
    data: XOR<UserIdentityClaimsUpdateInput, UserIdentityClaimsUncheckedUpdateInput>
    /**
     * Choose, which UserIdentityClaims to update.
     * 
    **/
    where: UserIdentityClaimsWhereUniqueInput
  }


  /**
   * UserIdentityClaims updateMany
   */
  export type UserIdentityClaimsUpdateManyArgs = {
    data: XOR<UserIdentityClaimsUpdateManyMutationInput, UserIdentityClaimsUncheckedUpdateManyInput>
    where?: UserIdentityClaimsWhereInput
  }


  /**
   * UserIdentityClaims upsert
   */
  export type UserIdentityClaimsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityClaims
     * 
    **/
    select?: UserIdentityClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityClaimsInclude | null
    /**
     * The filter to search for the UserIdentityClaims to update in case it exists.
     * 
    **/
    where: UserIdentityClaimsWhereUniqueInput
    /**
     * In case the UserIdentityClaims found by the `where` argument doesn't exist, create a new UserIdentityClaims with this data.
     * 
    **/
    create: XOR<UserIdentityClaimsCreateInput, UserIdentityClaimsUncheckedCreateInput>
    /**
     * In case the UserIdentityClaims was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserIdentityClaimsUpdateInput, UserIdentityClaimsUncheckedUpdateInput>
  }


  /**
   * UserIdentityClaims delete
   */
  export type UserIdentityClaimsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityClaims
     * 
    **/
    select?: UserIdentityClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityClaimsInclude | null
    /**
     * Filter which UserIdentityClaims to delete.
     * 
    **/
    where: UserIdentityClaimsWhereUniqueInput
  }


  /**
   * UserIdentityClaims deleteMany
   */
  export type UserIdentityClaimsDeleteManyArgs = {
    where?: UserIdentityClaimsWhereInput
  }


  /**
   * UserIdentityClaims without action
   */
  export type UserIdentityClaimsArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityClaims
     * 
    **/
    select?: UserIdentityClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityClaimsInclude | null
  }



  /**
   * Model UserIdentityLogins
   */


  export type AggregateUserIdentityLogins = {
    _count: UserIdentityLoginsCountAggregateOutputType | null
    _min: UserIdentityLoginsMinAggregateOutputType | null
    _max: UserIdentityLoginsMaxAggregateOutputType | null
  }

  export type UserIdentityLoginsMinAggregateOutputType = {
    LoginProvider: string | null
    ProviderKey: string | null
    ProviderDisplayName: string | null
    UserId: string | null
  }

  export type UserIdentityLoginsMaxAggregateOutputType = {
    LoginProvider: string | null
    ProviderKey: string | null
    ProviderDisplayName: string | null
    UserId: string | null
  }

  export type UserIdentityLoginsCountAggregateOutputType = {
    LoginProvider: number
    ProviderKey: number
    ProviderDisplayName: number
    UserId: number
    _all: number
  }


  export type UserIdentityLoginsMinAggregateInputType = {
    LoginProvider?: true
    ProviderKey?: true
    ProviderDisplayName?: true
    UserId?: true
  }

  export type UserIdentityLoginsMaxAggregateInputType = {
    LoginProvider?: true
    ProviderKey?: true
    ProviderDisplayName?: true
    UserId?: true
  }

  export type UserIdentityLoginsCountAggregateInputType = {
    LoginProvider?: true
    ProviderKey?: true
    ProviderDisplayName?: true
    UserId?: true
    _all?: true
  }

  export type UserIdentityLoginsAggregateArgs = {
    /**
     * Filter which UserIdentityLogins to aggregate.
     * 
    **/
    where?: UserIdentityLoginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityLogins to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityLoginsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserIdentityLoginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityLogins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityLogins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserIdentityLogins
    **/
    _count?: true | UserIdentityLoginsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserIdentityLoginsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserIdentityLoginsMaxAggregateInputType
  }

  export type GetUserIdentityLoginsAggregateType<T extends UserIdentityLoginsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserIdentityLogins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserIdentityLogins[P]>
      : GetScalarType<T[P], AggregateUserIdentityLogins[P]>
  }




  export type UserIdentityLoginsGroupByArgs = {
    where?: UserIdentityLoginsWhereInput
    orderBy?: Enumerable<UserIdentityLoginsOrderByWithAggregationInput>
    by: Array<UserIdentityLoginsScalarFieldEnum>
    having?: UserIdentityLoginsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserIdentityLoginsCountAggregateInputType | true
    _min?: UserIdentityLoginsMinAggregateInputType
    _max?: UserIdentityLoginsMaxAggregateInputType
  }


  export type UserIdentityLoginsGroupByOutputType = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName: string | null
    UserId: string
    _count: UserIdentityLoginsCountAggregateOutputType | null
    _min: UserIdentityLoginsMinAggregateOutputType | null
    _max: UserIdentityLoginsMaxAggregateOutputType | null
  }

  type GetUserIdentityLoginsGroupByPayload<T extends UserIdentityLoginsGroupByArgs> = Promise<
    Array<
      PickArray<UserIdentityLoginsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserIdentityLoginsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserIdentityLoginsGroupByOutputType[P]>
            : GetScalarType<T[P], UserIdentityLoginsGroupByOutputType[P]>
        }
      >
    >


  export type UserIdentityLoginsSelect = {
    LoginProvider?: boolean
    ProviderKey?: boolean
    ProviderDisplayName?: boolean
    UserId?: boolean
    Users?: boolean | UsersArgs
  }

  export type UserIdentityLoginsInclude = {
    Users?: boolean | UsersArgs
  }

  export type UserIdentityLoginsGetPayload<
    S extends boolean | null | undefined | UserIdentityLoginsArgs,
    U = keyof S
      > = S extends true
        ? UserIdentityLogins
    : S extends undefined
    ? never
    : S extends UserIdentityLoginsArgs | UserIdentityLoginsFindManyArgs
    ?'include' extends U
    ? UserIdentityLogins  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Users'
        ? UsersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserIdentityLogins ?UserIdentityLogins [P]
  : 
          P extends 'Users'
        ? UsersGetPayload<S['select'][P]> : never
  } 
    : UserIdentityLogins
  : UserIdentityLogins


  type UserIdentityLoginsCountArgs = Merge<
    Omit<UserIdentityLoginsFindManyArgs, 'select' | 'include'> & {
      select?: UserIdentityLoginsCountAggregateInputType | true
    }
  >

  export interface UserIdentityLoginsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserIdentityLogins that matches the filter.
     * @param {UserIdentityLoginsFindUniqueArgs} args - Arguments to find a UserIdentityLogins
     * @example
     * // Get one UserIdentityLogins
     * const userIdentityLogins = await prisma.userIdentityLogins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserIdentityLoginsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserIdentityLoginsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserIdentityLogins'> extends True ? CheckSelect<T, Prisma__UserIdentityLoginsClient<UserIdentityLogins>, Prisma__UserIdentityLoginsClient<UserIdentityLoginsGetPayload<T>>> : CheckSelect<T, Prisma__UserIdentityLoginsClient<UserIdentityLogins | null >, Prisma__UserIdentityLoginsClient<UserIdentityLoginsGetPayload<T> | null >>

    /**
     * Find the first UserIdentityLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityLoginsFindFirstArgs} args - Arguments to find a UserIdentityLogins
     * @example
     * // Get one UserIdentityLogins
     * const userIdentityLogins = await prisma.userIdentityLogins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserIdentityLoginsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserIdentityLoginsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserIdentityLogins'> extends True ? CheckSelect<T, Prisma__UserIdentityLoginsClient<UserIdentityLogins>, Prisma__UserIdentityLoginsClient<UserIdentityLoginsGetPayload<T>>> : CheckSelect<T, Prisma__UserIdentityLoginsClient<UserIdentityLogins | null >, Prisma__UserIdentityLoginsClient<UserIdentityLoginsGetPayload<T> | null >>

    /**
     * Find zero or more UserIdentityLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityLoginsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserIdentityLogins
     * const userIdentityLogins = await prisma.userIdentityLogins.findMany()
     * 
     * // Get first 10 UserIdentityLogins
     * const userIdentityLogins = await prisma.userIdentityLogins.findMany({ take: 10 })
     * 
     * // Only select the `LoginProvider`
     * const userIdentityLoginsWithLoginProviderOnly = await prisma.userIdentityLogins.findMany({ select: { LoginProvider: true } })
     * 
    **/
    findMany<T extends UserIdentityLoginsFindManyArgs>(
      args?: SelectSubset<T, UserIdentityLoginsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserIdentityLogins>>, PrismaPromise<Array<UserIdentityLoginsGetPayload<T>>>>

    /**
     * Create a UserIdentityLogins.
     * @param {UserIdentityLoginsCreateArgs} args - Arguments to create a UserIdentityLogins.
     * @example
     * // Create one UserIdentityLogins
     * const UserIdentityLogins = await prisma.userIdentityLogins.create({
     *   data: {
     *     // ... data to create a UserIdentityLogins
     *   }
     * })
     * 
    **/
    create<T extends UserIdentityLoginsCreateArgs>(
      args: SelectSubset<T, UserIdentityLoginsCreateArgs>
    ): CheckSelect<T, Prisma__UserIdentityLoginsClient<UserIdentityLogins>, Prisma__UserIdentityLoginsClient<UserIdentityLoginsGetPayload<T>>>

    /**
     * Create many UserIdentityLogins.
     *     @param {UserIdentityLoginsCreateManyArgs} args - Arguments to create many UserIdentityLogins.
     *     @example
     *     // Create many UserIdentityLogins
     *     const userIdentityLogins = await prisma.userIdentityLogins.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserIdentityLoginsCreateManyArgs>(
      args?: SelectSubset<T, UserIdentityLoginsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserIdentityLogins.
     * @param {UserIdentityLoginsDeleteArgs} args - Arguments to delete one UserIdentityLogins.
     * @example
     * // Delete one UserIdentityLogins
     * const UserIdentityLogins = await prisma.userIdentityLogins.delete({
     *   where: {
     *     // ... filter to delete one UserIdentityLogins
     *   }
     * })
     * 
    **/
    delete<T extends UserIdentityLoginsDeleteArgs>(
      args: SelectSubset<T, UserIdentityLoginsDeleteArgs>
    ): CheckSelect<T, Prisma__UserIdentityLoginsClient<UserIdentityLogins>, Prisma__UserIdentityLoginsClient<UserIdentityLoginsGetPayload<T>>>

    /**
     * Update one UserIdentityLogins.
     * @param {UserIdentityLoginsUpdateArgs} args - Arguments to update one UserIdentityLogins.
     * @example
     * // Update one UserIdentityLogins
     * const userIdentityLogins = await prisma.userIdentityLogins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserIdentityLoginsUpdateArgs>(
      args: SelectSubset<T, UserIdentityLoginsUpdateArgs>
    ): CheckSelect<T, Prisma__UserIdentityLoginsClient<UserIdentityLogins>, Prisma__UserIdentityLoginsClient<UserIdentityLoginsGetPayload<T>>>

    /**
     * Delete zero or more UserIdentityLogins.
     * @param {UserIdentityLoginsDeleteManyArgs} args - Arguments to filter UserIdentityLogins to delete.
     * @example
     * // Delete a few UserIdentityLogins
     * const { count } = await prisma.userIdentityLogins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserIdentityLoginsDeleteManyArgs>(
      args?: SelectSubset<T, UserIdentityLoginsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserIdentityLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityLoginsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserIdentityLogins
     * const userIdentityLogins = await prisma.userIdentityLogins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserIdentityLoginsUpdateManyArgs>(
      args: SelectSubset<T, UserIdentityLoginsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserIdentityLogins.
     * @param {UserIdentityLoginsUpsertArgs} args - Arguments to update or create a UserIdentityLogins.
     * @example
     * // Update or create a UserIdentityLogins
     * const userIdentityLogins = await prisma.userIdentityLogins.upsert({
     *   create: {
     *     // ... data to create a UserIdentityLogins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserIdentityLogins we want to update
     *   }
     * })
    **/
    upsert<T extends UserIdentityLoginsUpsertArgs>(
      args: SelectSubset<T, UserIdentityLoginsUpsertArgs>
    ): CheckSelect<T, Prisma__UserIdentityLoginsClient<UserIdentityLogins>, Prisma__UserIdentityLoginsClient<UserIdentityLoginsGetPayload<T>>>

    /**
     * Count the number of UserIdentityLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityLoginsCountArgs} args - Arguments to filter UserIdentityLogins to count.
     * @example
     * // Count the number of UserIdentityLogins
     * const count = await prisma.userIdentityLogins.count({
     *   where: {
     *     // ... the filter for the UserIdentityLogins we want to count
     *   }
     * })
    **/
    count<T extends UserIdentityLoginsCountArgs>(
      args?: Subset<T, UserIdentityLoginsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserIdentityLoginsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserIdentityLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityLoginsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserIdentityLoginsAggregateArgs>(args: Subset<T, UserIdentityLoginsAggregateArgs>): PrismaPromise<GetUserIdentityLoginsAggregateType<T>>

    /**
     * Group by UserIdentityLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityLoginsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserIdentityLoginsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserIdentityLoginsGroupByArgs['orderBy'] }
        : { orderBy?: UserIdentityLoginsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserIdentityLoginsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserIdentityLoginsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserIdentityLogins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserIdentityLoginsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Users<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserIdentityLogins findUnique
   */
  export type UserIdentityLoginsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityLogins
     * 
    **/
    select?: UserIdentityLoginsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityLoginsInclude | null
    /**
     * Throw an Error if a UserIdentityLogins can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserIdentityLogins to fetch.
     * 
    **/
    where: UserIdentityLoginsWhereUniqueInput
  }


  /**
   * UserIdentityLogins findFirst
   */
  export type UserIdentityLoginsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityLogins
     * 
    **/
    select?: UserIdentityLoginsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityLoginsInclude | null
    /**
     * Throw an Error if a UserIdentityLogins can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserIdentityLogins to fetch.
     * 
    **/
    where?: UserIdentityLoginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityLogins to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityLoginsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserIdentityLogins.
     * 
    **/
    cursor?: UserIdentityLoginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityLogins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityLogins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserIdentityLogins.
     * 
    **/
    distinct?: Enumerable<UserIdentityLoginsScalarFieldEnum>
  }


  /**
   * UserIdentityLogins findMany
   */
  export type UserIdentityLoginsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityLogins
     * 
    **/
    select?: UserIdentityLoginsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityLoginsInclude | null
    /**
     * Filter, which UserIdentityLogins to fetch.
     * 
    **/
    where?: UserIdentityLoginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityLogins to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityLoginsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserIdentityLogins.
     * 
    **/
    cursor?: UserIdentityLoginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityLogins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityLogins.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserIdentityLoginsScalarFieldEnum>
  }


  /**
   * UserIdentityLogins create
   */
  export type UserIdentityLoginsCreateArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityLogins
     * 
    **/
    select?: UserIdentityLoginsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityLoginsInclude | null
    /**
     * The data needed to create a UserIdentityLogins.
     * 
    **/
    data: XOR<UserIdentityLoginsCreateInput, UserIdentityLoginsUncheckedCreateInput>
  }


  /**
   * UserIdentityLogins createMany
   */
  export type UserIdentityLoginsCreateManyArgs = {
    data: Enumerable<UserIdentityLoginsCreateManyInput>
  }


  /**
   * UserIdentityLogins update
   */
  export type UserIdentityLoginsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityLogins
     * 
    **/
    select?: UserIdentityLoginsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityLoginsInclude | null
    /**
     * The data needed to update a UserIdentityLogins.
     * 
    **/
    data: XOR<UserIdentityLoginsUpdateInput, UserIdentityLoginsUncheckedUpdateInput>
    /**
     * Choose, which UserIdentityLogins to update.
     * 
    **/
    where: UserIdentityLoginsWhereUniqueInput
  }


  /**
   * UserIdentityLogins updateMany
   */
  export type UserIdentityLoginsUpdateManyArgs = {
    data: XOR<UserIdentityLoginsUpdateManyMutationInput, UserIdentityLoginsUncheckedUpdateManyInput>
    where?: UserIdentityLoginsWhereInput
  }


  /**
   * UserIdentityLogins upsert
   */
  export type UserIdentityLoginsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityLogins
     * 
    **/
    select?: UserIdentityLoginsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityLoginsInclude | null
    /**
     * The filter to search for the UserIdentityLogins to update in case it exists.
     * 
    **/
    where: UserIdentityLoginsWhereUniqueInput
    /**
     * In case the UserIdentityLogins found by the `where` argument doesn't exist, create a new UserIdentityLogins with this data.
     * 
    **/
    create: XOR<UserIdentityLoginsCreateInput, UserIdentityLoginsUncheckedCreateInput>
    /**
     * In case the UserIdentityLogins was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserIdentityLoginsUpdateInput, UserIdentityLoginsUncheckedUpdateInput>
  }


  /**
   * UserIdentityLogins delete
   */
  export type UserIdentityLoginsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityLogins
     * 
    **/
    select?: UserIdentityLoginsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityLoginsInclude | null
    /**
     * Filter which UserIdentityLogins to delete.
     * 
    **/
    where: UserIdentityLoginsWhereUniqueInput
  }


  /**
   * UserIdentityLogins deleteMany
   */
  export type UserIdentityLoginsDeleteManyArgs = {
    where?: UserIdentityLoginsWhereInput
  }


  /**
   * UserIdentityLogins without action
   */
  export type UserIdentityLoginsArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityLogins
     * 
    **/
    select?: UserIdentityLoginsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityLoginsInclude | null
  }



  /**
   * Model UserIdentityRoleClaims
   */


  export type AggregateUserIdentityRoleClaims = {
    _count: UserIdentityRoleClaimsCountAggregateOutputType | null
    _avg: UserIdentityRoleClaimsAvgAggregateOutputType | null
    _sum: UserIdentityRoleClaimsSumAggregateOutputType | null
    _min: UserIdentityRoleClaimsMinAggregateOutputType | null
    _max: UserIdentityRoleClaimsMaxAggregateOutputType | null
  }

  export type UserIdentityRoleClaimsAvgAggregateOutputType = {
    Id: number | null
  }

  export type UserIdentityRoleClaimsSumAggregateOutputType = {
    Id: number | null
  }

  export type UserIdentityRoleClaimsMinAggregateOutputType = {
    Id: number | null
    RoleId: string | null
    ClaimType: string | null
    ClaimValue: string | null
  }

  export type UserIdentityRoleClaimsMaxAggregateOutputType = {
    Id: number | null
    RoleId: string | null
    ClaimType: string | null
    ClaimValue: string | null
  }

  export type UserIdentityRoleClaimsCountAggregateOutputType = {
    Id: number
    RoleId: number
    ClaimType: number
    ClaimValue: number
    _all: number
  }


  export type UserIdentityRoleClaimsAvgAggregateInputType = {
    Id?: true
  }

  export type UserIdentityRoleClaimsSumAggregateInputType = {
    Id?: true
  }

  export type UserIdentityRoleClaimsMinAggregateInputType = {
    Id?: true
    RoleId?: true
    ClaimType?: true
    ClaimValue?: true
  }

  export type UserIdentityRoleClaimsMaxAggregateInputType = {
    Id?: true
    RoleId?: true
    ClaimType?: true
    ClaimValue?: true
  }

  export type UserIdentityRoleClaimsCountAggregateInputType = {
    Id?: true
    RoleId?: true
    ClaimType?: true
    ClaimValue?: true
    _all?: true
  }

  export type UserIdentityRoleClaimsAggregateArgs = {
    /**
     * Filter which UserIdentityRoleClaims to aggregate.
     * 
    **/
    where?: UserIdentityRoleClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityRoleClaims to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityRoleClaimsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserIdentityRoleClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityRoleClaims from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityRoleClaims.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserIdentityRoleClaims
    **/
    _count?: true | UserIdentityRoleClaimsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserIdentityRoleClaimsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserIdentityRoleClaimsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserIdentityRoleClaimsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserIdentityRoleClaimsMaxAggregateInputType
  }

  export type GetUserIdentityRoleClaimsAggregateType<T extends UserIdentityRoleClaimsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserIdentityRoleClaims]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserIdentityRoleClaims[P]>
      : GetScalarType<T[P], AggregateUserIdentityRoleClaims[P]>
  }




  export type UserIdentityRoleClaimsGroupByArgs = {
    where?: UserIdentityRoleClaimsWhereInput
    orderBy?: Enumerable<UserIdentityRoleClaimsOrderByWithAggregationInput>
    by: Array<UserIdentityRoleClaimsScalarFieldEnum>
    having?: UserIdentityRoleClaimsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserIdentityRoleClaimsCountAggregateInputType | true
    _avg?: UserIdentityRoleClaimsAvgAggregateInputType
    _sum?: UserIdentityRoleClaimsSumAggregateInputType
    _min?: UserIdentityRoleClaimsMinAggregateInputType
    _max?: UserIdentityRoleClaimsMaxAggregateInputType
  }


  export type UserIdentityRoleClaimsGroupByOutputType = {
    Id: number
    RoleId: string
    ClaimType: string | null
    ClaimValue: string | null
    _count: UserIdentityRoleClaimsCountAggregateOutputType | null
    _avg: UserIdentityRoleClaimsAvgAggregateOutputType | null
    _sum: UserIdentityRoleClaimsSumAggregateOutputType | null
    _min: UserIdentityRoleClaimsMinAggregateOutputType | null
    _max: UserIdentityRoleClaimsMaxAggregateOutputType | null
  }

  type GetUserIdentityRoleClaimsGroupByPayload<T extends UserIdentityRoleClaimsGroupByArgs> = Promise<
    Array<
      PickArray<UserIdentityRoleClaimsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserIdentityRoleClaimsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserIdentityRoleClaimsGroupByOutputType[P]>
            : GetScalarType<T[P], UserIdentityRoleClaimsGroupByOutputType[P]>
        }
      >
    >


  export type UserIdentityRoleClaimsSelect = {
    Id?: boolean
    RoleId?: boolean
    ClaimType?: boolean
    ClaimValue?: boolean
    AppIdentityRoles?: boolean | AppIdentityRolesArgs
  }

  export type UserIdentityRoleClaimsInclude = {
    AppIdentityRoles?: boolean | AppIdentityRolesArgs
  }

  export type UserIdentityRoleClaimsGetPayload<
    S extends boolean | null | undefined | UserIdentityRoleClaimsArgs,
    U = keyof S
      > = S extends true
        ? UserIdentityRoleClaims
    : S extends undefined
    ? never
    : S extends UserIdentityRoleClaimsArgs | UserIdentityRoleClaimsFindManyArgs
    ?'include' extends U
    ? UserIdentityRoleClaims  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'AppIdentityRoles'
        ? AppIdentityRolesGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserIdentityRoleClaims ?UserIdentityRoleClaims [P]
  : 
          P extends 'AppIdentityRoles'
        ? AppIdentityRolesGetPayload<S['select'][P]> : never
  } 
    : UserIdentityRoleClaims
  : UserIdentityRoleClaims


  type UserIdentityRoleClaimsCountArgs = Merge<
    Omit<UserIdentityRoleClaimsFindManyArgs, 'select' | 'include'> & {
      select?: UserIdentityRoleClaimsCountAggregateInputType | true
    }
  >

  export interface UserIdentityRoleClaimsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserIdentityRoleClaims that matches the filter.
     * @param {UserIdentityRoleClaimsFindUniqueArgs} args - Arguments to find a UserIdentityRoleClaims
     * @example
     * // Get one UserIdentityRoleClaims
     * const userIdentityRoleClaims = await prisma.userIdentityRoleClaims.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserIdentityRoleClaimsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserIdentityRoleClaimsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserIdentityRoleClaims'> extends True ? CheckSelect<T, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaims>, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaimsGetPayload<T>>> : CheckSelect<T, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaims | null >, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaimsGetPayload<T> | null >>

    /**
     * Find the first UserIdentityRoleClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityRoleClaimsFindFirstArgs} args - Arguments to find a UserIdentityRoleClaims
     * @example
     * // Get one UserIdentityRoleClaims
     * const userIdentityRoleClaims = await prisma.userIdentityRoleClaims.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserIdentityRoleClaimsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserIdentityRoleClaimsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserIdentityRoleClaims'> extends True ? CheckSelect<T, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaims>, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaimsGetPayload<T>>> : CheckSelect<T, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaims | null >, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaimsGetPayload<T> | null >>

    /**
     * Find zero or more UserIdentityRoleClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityRoleClaimsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserIdentityRoleClaims
     * const userIdentityRoleClaims = await prisma.userIdentityRoleClaims.findMany()
     * 
     * // Get first 10 UserIdentityRoleClaims
     * const userIdentityRoleClaims = await prisma.userIdentityRoleClaims.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userIdentityRoleClaimsWithIdOnly = await prisma.userIdentityRoleClaims.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserIdentityRoleClaimsFindManyArgs>(
      args?: SelectSubset<T, UserIdentityRoleClaimsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserIdentityRoleClaims>>, PrismaPromise<Array<UserIdentityRoleClaimsGetPayload<T>>>>

    /**
     * Create a UserIdentityRoleClaims.
     * @param {UserIdentityRoleClaimsCreateArgs} args - Arguments to create a UserIdentityRoleClaims.
     * @example
     * // Create one UserIdentityRoleClaims
     * const UserIdentityRoleClaims = await prisma.userIdentityRoleClaims.create({
     *   data: {
     *     // ... data to create a UserIdentityRoleClaims
     *   }
     * })
     * 
    **/
    create<T extends UserIdentityRoleClaimsCreateArgs>(
      args: SelectSubset<T, UserIdentityRoleClaimsCreateArgs>
    ): CheckSelect<T, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaims>, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaimsGetPayload<T>>>

    /**
     * Create many UserIdentityRoleClaims.
     *     @param {UserIdentityRoleClaimsCreateManyArgs} args - Arguments to create many UserIdentityRoleClaims.
     *     @example
     *     // Create many UserIdentityRoleClaims
     *     const userIdentityRoleClaims = await prisma.userIdentityRoleClaims.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserIdentityRoleClaimsCreateManyArgs>(
      args?: SelectSubset<T, UserIdentityRoleClaimsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserIdentityRoleClaims.
     * @param {UserIdentityRoleClaimsDeleteArgs} args - Arguments to delete one UserIdentityRoleClaims.
     * @example
     * // Delete one UserIdentityRoleClaims
     * const UserIdentityRoleClaims = await prisma.userIdentityRoleClaims.delete({
     *   where: {
     *     // ... filter to delete one UserIdentityRoleClaims
     *   }
     * })
     * 
    **/
    delete<T extends UserIdentityRoleClaimsDeleteArgs>(
      args: SelectSubset<T, UserIdentityRoleClaimsDeleteArgs>
    ): CheckSelect<T, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaims>, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaimsGetPayload<T>>>

    /**
     * Update one UserIdentityRoleClaims.
     * @param {UserIdentityRoleClaimsUpdateArgs} args - Arguments to update one UserIdentityRoleClaims.
     * @example
     * // Update one UserIdentityRoleClaims
     * const userIdentityRoleClaims = await prisma.userIdentityRoleClaims.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserIdentityRoleClaimsUpdateArgs>(
      args: SelectSubset<T, UserIdentityRoleClaimsUpdateArgs>
    ): CheckSelect<T, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaims>, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaimsGetPayload<T>>>

    /**
     * Delete zero or more UserIdentityRoleClaims.
     * @param {UserIdentityRoleClaimsDeleteManyArgs} args - Arguments to filter UserIdentityRoleClaims to delete.
     * @example
     * // Delete a few UserIdentityRoleClaims
     * const { count } = await prisma.userIdentityRoleClaims.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserIdentityRoleClaimsDeleteManyArgs>(
      args?: SelectSubset<T, UserIdentityRoleClaimsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserIdentityRoleClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityRoleClaimsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserIdentityRoleClaims
     * const userIdentityRoleClaims = await prisma.userIdentityRoleClaims.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserIdentityRoleClaimsUpdateManyArgs>(
      args: SelectSubset<T, UserIdentityRoleClaimsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserIdentityRoleClaims.
     * @param {UserIdentityRoleClaimsUpsertArgs} args - Arguments to update or create a UserIdentityRoleClaims.
     * @example
     * // Update or create a UserIdentityRoleClaims
     * const userIdentityRoleClaims = await prisma.userIdentityRoleClaims.upsert({
     *   create: {
     *     // ... data to create a UserIdentityRoleClaims
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserIdentityRoleClaims we want to update
     *   }
     * })
    **/
    upsert<T extends UserIdentityRoleClaimsUpsertArgs>(
      args: SelectSubset<T, UserIdentityRoleClaimsUpsertArgs>
    ): CheckSelect<T, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaims>, Prisma__UserIdentityRoleClaimsClient<UserIdentityRoleClaimsGetPayload<T>>>

    /**
     * Count the number of UserIdentityRoleClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityRoleClaimsCountArgs} args - Arguments to filter UserIdentityRoleClaims to count.
     * @example
     * // Count the number of UserIdentityRoleClaims
     * const count = await prisma.userIdentityRoleClaims.count({
     *   where: {
     *     // ... the filter for the UserIdentityRoleClaims we want to count
     *   }
     * })
    **/
    count<T extends UserIdentityRoleClaimsCountArgs>(
      args?: Subset<T, UserIdentityRoleClaimsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserIdentityRoleClaimsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserIdentityRoleClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityRoleClaimsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserIdentityRoleClaimsAggregateArgs>(args: Subset<T, UserIdentityRoleClaimsAggregateArgs>): PrismaPromise<GetUserIdentityRoleClaimsAggregateType<T>>

    /**
     * Group by UserIdentityRoleClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityRoleClaimsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserIdentityRoleClaimsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserIdentityRoleClaimsGroupByArgs['orderBy'] }
        : { orderBy?: UserIdentityRoleClaimsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserIdentityRoleClaimsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserIdentityRoleClaimsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserIdentityRoleClaims.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserIdentityRoleClaimsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    AppIdentityRoles<T extends AppIdentityRolesArgs = {}>(args?: Subset<T, AppIdentityRolesArgs>): CheckSelect<T, Prisma__AppIdentityRolesClient<AppIdentityRoles | null >, Prisma__AppIdentityRolesClient<AppIdentityRolesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserIdentityRoleClaims findUnique
   */
  export type UserIdentityRoleClaimsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoleClaims
     * 
    **/
    select?: UserIdentityRoleClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRoleClaimsInclude | null
    /**
     * Throw an Error if a UserIdentityRoleClaims can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserIdentityRoleClaims to fetch.
     * 
    **/
    where: UserIdentityRoleClaimsWhereUniqueInput
  }


  /**
   * UserIdentityRoleClaims findFirst
   */
  export type UserIdentityRoleClaimsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoleClaims
     * 
    **/
    select?: UserIdentityRoleClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRoleClaimsInclude | null
    /**
     * Throw an Error if a UserIdentityRoleClaims can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserIdentityRoleClaims to fetch.
     * 
    **/
    where?: UserIdentityRoleClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityRoleClaims to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityRoleClaimsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserIdentityRoleClaims.
     * 
    **/
    cursor?: UserIdentityRoleClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityRoleClaims from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityRoleClaims.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserIdentityRoleClaims.
     * 
    **/
    distinct?: Enumerable<UserIdentityRoleClaimsScalarFieldEnum>
  }


  /**
   * UserIdentityRoleClaims findMany
   */
  export type UserIdentityRoleClaimsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoleClaims
     * 
    **/
    select?: UserIdentityRoleClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRoleClaimsInclude | null
    /**
     * Filter, which UserIdentityRoleClaims to fetch.
     * 
    **/
    where?: UserIdentityRoleClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityRoleClaims to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityRoleClaimsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserIdentityRoleClaims.
     * 
    **/
    cursor?: UserIdentityRoleClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityRoleClaims from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityRoleClaims.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserIdentityRoleClaimsScalarFieldEnum>
  }


  /**
   * UserIdentityRoleClaims create
   */
  export type UserIdentityRoleClaimsCreateArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoleClaims
     * 
    **/
    select?: UserIdentityRoleClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRoleClaimsInclude | null
    /**
     * The data needed to create a UserIdentityRoleClaims.
     * 
    **/
    data: XOR<UserIdentityRoleClaimsCreateInput, UserIdentityRoleClaimsUncheckedCreateInput>
  }


  /**
   * UserIdentityRoleClaims createMany
   */
  export type UserIdentityRoleClaimsCreateManyArgs = {
    data: Enumerable<UserIdentityRoleClaimsCreateManyInput>
  }


  /**
   * UserIdentityRoleClaims update
   */
  export type UserIdentityRoleClaimsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoleClaims
     * 
    **/
    select?: UserIdentityRoleClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRoleClaimsInclude | null
    /**
     * The data needed to update a UserIdentityRoleClaims.
     * 
    **/
    data: XOR<UserIdentityRoleClaimsUpdateInput, UserIdentityRoleClaimsUncheckedUpdateInput>
    /**
     * Choose, which UserIdentityRoleClaims to update.
     * 
    **/
    where: UserIdentityRoleClaimsWhereUniqueInput
  }


  /**
   * UserIdentityRoleClaims updateMany
   */
  export type UserIdentityRoleClaimsUpdateManyArgs = {
    data: XOR<UserIdentityRoleClaimsUpdateManyMutationInput, UserIdentityRoleClaimsUncheckedUpdateManyInput>
    where?: UserIdentityRoleClaimsWhereInput
  }


  /**
   * UserIdentityRoleClaims upsert
   */
  export type UserIdentityRoleClaimsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoleClaims
     * 
    **/
    select?: UserIdentityRoleClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRoleClaimsInclude | null
    /**
     * The filter to search for the UserIdentityRoleClaims to update in case it exists.
     * 
    **/
    where: UserIdentityRoleClaimsWhereUniqueInput
    /**
     * In case the UserIdentityRoleClaims found by the `where` argument doesn't exist, create a new UserIdentityRoleClaims with this data.
     * 
    **/
    create: XOR<UserIdentityRoleClaimsCreateInput, UserIdentityRoleClaimsUncheckedCreateInput>
    /**
     * In case the UserIdentityRoleClaims was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserIdentityRoleClaimsUpdateInput, UserIdentityRoleClaimsUncheckedUpdateInput>
  }


  /**
   * UserIdentityRoleClaims delete
   */
  export type UserIdentityRoleClaimsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoleClaims
     * 
    **/
    select?: UserIdentityRoleClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRoleClaimsInclude | null
    /**
     * Filter which UserIdentityRoleClaims to delete.
     * 
    **/
    where: UserIdentityRoleClaimsWhereUniqueInput
  }


  /**
   * UserIdentityRoleClaims deleteMany
   */
  export type UserIdentityRoleClaimsDeleteManyArgs = {
    where?: UserIdentityRoleClaimsWhereInput
  }


  /**
   * UserIdentityRoleClaims without action
   */
  export type UserIdentityRoleClaimsArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoleClaims
     * 
    **/
    select?: UserIdentityRoleClaimsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRoleClaimsInclude | null
  }



  /**
   * Model UserIdentityRoles
   */


  export type AggregateUserIdentityRoles = {
    _count: UserIdentityRolesCountAggregateOutputType | null
    _min: UserIdentityRolesMinAggregateOutputType | null
    _max: UserIdentityRolesMaxAggregateOutputType | null
  }

  export type UserIdentityRolesMinAggregateOutputType = {
    UserId: string | null
    RoleId: string | null
  }

  export type UserIdentityRolesMaxAggregateOutputType = {
    UserId: string | null
    RoleId: string | null
  }

  export type UserIdentityRolesCountAggregateOutputType = {
    UserId: number
    RoleId: number
    _all: number
  }


  export type UserIdentityRolesMinAggregateInputType = {
    UserId?: true
    RoleId?: true
  }

  export type UserIdentityRolesMaxAggregateInputType = {
    UserId?: true
    RoleId?: true
  }

  export type UserIdentityRolesCountAggregateInputType = {
    UserId?: true
    RoleId?: true
    _all?: true
  }

  export type UserIdentityRolesAggregateArgs = {
    /**
     * Filter which UserIdentityRoles to aggregate.
     * 
    **/
    where?: UserIdentityRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserIdentityRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserIdentityRoles
    **/
    _count?: true | UserIdentityRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserIdentityRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserIdentityRolesMaxAggregateInputType
  }

  export type GetUserIdentityRolesAggregateType<T extends UserIdentityRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserIdentityRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserIdentityRoles[P]>
      : GetScalarType<T[P], AggregateUserIdentityRoles[P]>
  }




  export type UserIdentityRolesGroupByArgs = {
    where?: UserIdentityRolesWhereInput
    orderBy?: Enumerable<UserIdentityRolesOrderByWithAggregationInput>
    by: Array<UserIdentityRolesScalarFieldEnum>
    having?: UserIdentityRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserIdentityRolesCountAggregateInputType | true
    _min?: UserIdentityRolesMinAggregateInputType
    _max?: UserIdentityRolesMaxAggregateInputType
  }


  export type UserIdentityRolesGroupByOutputType = {
    UserId: string
    RoleId: string
    _count: UserIdentityRolesCountAggregateOutputType | null
    _min: UserIdentityRolesMinAggregateOutputType | null
    _max: UserIdentityRolesMaxAggregateOutputType | null
  }

  type GetUserIdentityRolesGroupByPayload<T extends UserIdentityRolesGroupByArgs> = Promise<
    Array<
      PickArray<UserIdentityRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserIdentityRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserIdentityRolesGroupByOutputType[P]>
            : GetScalarType<T[P], UserIdentityRolesGroupByOutputType[P]>
        }
      >
    >


  export type UserIdentityRolesSelect = {
    UserId?: boolean
    RoleId?: boolean
    AppIdentityRoles?: boolean | AppIdentityRolesArgs
    Users?: boolean | UsersArgs
  }

  export type UserIdentityRolesInclude = {
    AppIdentityRoles?: boolean | AppIdentityRolesArgs
    Users?: boolean | UsersArgs
  }

  export type UserIdentityRolesGetPayload<
    S extends boolean | null | undefined | UserIdentityRolesArgs,
    U = keyof S
      > = S extends true
        ? UserIdentityRoles
    : S extends undefined
    ? never
    : S extends UserIdentityRolesArgs | UserIdentityRolesFindManyArgs
    ?'include' extends U
    ? UserIdentityRoles  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'AppIdentityRoles'
        ? AppIdentityRolesGetPayload<S['include'][P]> :
        P extends 'Users'
        ? UsersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserIdentityRoles ?UserIdentityRoles [P]
  : 
          P extends 'AppIdentityRoles'
        ? AppIdentityRolesGetPayload<S['select'][P]> :
        P extends 'Users'
        ? UsersGetPayload<S['select'][P]> : never
  } 
    : UserIdentityRoles
  : UserIdentityRoles


  type UserIdentityRolesCountArgs = Merge<
    Omit<UserIdentityRolesFindManyArgs, 'select' | 'include'> & {
      select?: UserIdentityRolesCountAggregateInputType | true
    }
  >

  export interface UserIdentityRolesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserIdentityRoles that matches the filter.
     * @param {UserIdentityRolesFindUniqueArgs} args - Arguments to find a UserIdentityRoles
     * @example
     * // Get one UserIdentityRoles
     * const userIdentityRoles = await prisma.userIdentityRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserIdentityRolesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserIdentityRolesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserIdentityRoles'> extends True ? CheckSelect<T, Prisma__UserIdentityRolesClient<UserIdentityRoles>, Prisma__UserIdentityRolesClient<UserIdentityRolesGetPayload<T>>> : CheckSelect<T, Prisma__UserIdentityRolesClient<UserIdentityRoles | null >, Prisma__UserIdentityRolesClient<UserIdentityRolesGetPayload<T> | null >>

    /**
     * Find the first UserIdentityRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityRolesFindFirstArgs} args - Arguments to find a UserIdentityRoles
     * @example
     * // Get one UserIdentityRoles
     * const userIdentityRoles = await prisma.userIdentityRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserIdentityRolesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserIdentityRolesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserIdentityRoles'> extends True ? CheckSelect<T, Prisma__UserIdentityRolesClient<UserIdentityRoles>, Prisma__UserIdentityRolesClient<UserIdentityRolesGetPayload<T>>> : CheckSelect<T, Prisma__UserIdentityRolesClient<UserIdentityRoles | null >, Prisma__UserIdentityRolesClient<UserIdentityRolesGetPayload<T> | null >>

    /**
     * Find zero or more UserIdentityRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityRolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserIdentityRoles
     * const userIdentityRoles = await prisma.userIdentityRoles.findMany()
     * 
     * // Get first 10 UserIdentityRoles
     * const userIdentityRoles = await prisma.userIdentityRoles.findMany({ take: 10 })
     * 
     * // Only select the `UserId`
     * const userIdentityRolesWithUserIdOnly = await prisma.userIdentityRoles.findMany({ select: { UserId: true } })
     * 
    **/
    findMany<T extends UserIdentityRolesFindManyArgs>(
      args?: SelectSubset<T, UserIdentityRolesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserIdentityRoles>>, PrismaPromise<Array<UserIdentityRolesGetPayload<T>>>>

    /**
     * Create a UserIdentityRoles.
     * @param {UserIdentityRolesCreateArgs} args - Arguments to create a UserIdentityRoles.
     * @example
     * // Create one UserIdentityRoles
     * const UserIdentityRoles = await prisma.userIdentityRoles.create({
     *   data: {
     *     // ... data to create a UserIdentityRoles
     *   }
     * })
     * 
    **/
    create<T extends UserIdentityRolesCreateArgs>(
      args: SelectSubset<T, UserIdentityRolesCreateArgs>
    ): CheckSelect<T, Prisma__UserIdentityRolesClient<UserIdentityRoles>, Prisma__UserIdentityRolesClient<UserIdentityRolesGetPayload<T>>>

    /**
     * Create many UserIdentityRoles.
     *     @param {UserIdentityRolesCreateManyArgs} args - Arguments to create many UserIdentityRoles.
     *     @example
     *     // Create many UserIdentityRoles
     *     const userIdentityRoles = await prisma.userIdentityRoles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserIdentityRolesCreateManyArgs>(
      args?: SelectSubset<T, UserIdentityRolesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserIdentityRoles.
     * @param {UserIdentityRolesDeleteArgs} args - Arguments to delete one UserIdentityRoles.
     * @example
     * // Delete one UserIdentityRoles
     * const UserIdentityRoles = await prisma.userIdentityRoles.delete({
     *   where: {
     *     // ... filter to delete one UserIdentityRoles
     *   }
     * })
     * 
    **/
    delete<T extends UserIdentityRolesDeleteArgs>(
      args: SelectSubset<T, UserIdentityRolesDeleteArgs>
    ): CheckSelect<T, Prisma__UserIdentityRolesClient<UserIdentityRoles>, Prisma__UserIdentityRolesClient<UserIdentityRolesGetPayload<T>>>

    /**
     * Update one UserIdentityRoles.
     * @param {UserIdentityRolesUpdateArgs} args - Arguments to update one UserIdentityRoles.
     * @example
     * // Update one UserIdentityRoles
     * const userIdentityRoles = await prisma.userIdentityRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserIdentityRolesUpdateArgs>(
      args: SelectSubset<T, UserIdentityRolesUpdateArgs>
    ): CheckSelect<T, Prisma__UserIdentityRolesClient<UserIdentityRoles>, Prisma__UserIdentityRolesClient<UserIdentityRolesGetPayload<T>>>

    /**
     * Delete zero or more UserIdentityRoles.
     * @param {UserIdentityRolesDeleteManyArgs} args - Arguments to filter UserIdentityRoles to delete.
     * @example
     * // Delete a few UserIdentityRoles
     * const { count } = await prisma.userIdentityRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserIdentityRolesDeleteManyArgs>(
      args?: SelectSubset<T, UserIdentityRolesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserIdentityRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserIdentityRoles
     * const userIdentityRoles = await prisma.userIdentityRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserIdentityRolesUpdateManyArgs>(
      args: SelectSubset<T, UserIdentityRolesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserIdentityRoles.
     * @param {UserIdentityRolesUpsertArgs} args - Arguments to update or create a UserIdentityRoles.
     * @example
     * // Update or create a UserIdentityRoles
     * const userIdentityRoles = await prisma.userIdentityRoles.upsert({
     *   create: {
     *     // ... data to create a UserIdentityRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserIdentityRoles we want to update
     *   }
     * })
    **/
    upsert<T extends UserIdentityRolesUpsertArgs>(
      args: SelectSubset<T, UserIdentityRolesUpsertArgs>
    ): CheckSelect<T, Prisma__UserIdentityRolesClient<UserIdentityRoles>, Prisma__UserIdentityRolesClient<UserIdentityRolesGetPayload<T>>>

    /**
     * Count the number of UserIdentityRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityRolesCountArgs} args - Arguments to filter UserIdentityRoles to count.
     * @example
     * // Count the number of UserIdentityRoles
     * const count = await prisma.userIdentityRoles.count({
     *   where: {
     *     // ... the filter for the UserIdentityRoles we want to count
     *   }
     * })
    **/
    count<T extends UserIdentityRolesCountArgs>(
      args?: Subset<T, UserIdentityRolesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserIdentityRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserIdentityRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserIdentityRolesAggregateArgs>(args: Subset<T, UserIdentityRolesAggregateArgs>): PrismaPromise<GetUserIdentityRolesAggregateType<T>>

    /**
     * Group by UserIdentityRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserIdentityRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserIdentityRolesGroupByArgs['orderBy'] }
        : { orderBy?: UserIdentityRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserIdentityRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserIdentityRolesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserIdentityRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserIdentityRolesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    AppIdentityRoles<T extends AppIdentityRolesArgs = {}>(args?: Subset<T, AppIdentityRolesArgs>): CheckSelect<T, Prisma__AppIdentityRolesClient<AppIdentityRoles | null >, Prisma__AppIdentityRolesClient<AppIdentityRolesGetPayload<T> | null >>;

    Users<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserIdentityRoles findUnique
   */
  export type UserIdentityRolesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoles
     * 
    **/
    select?: UserIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRolesInclude | null
    /**
     * Throw an Error if a UserIdentityRoles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserIdentityRoles to fetch.
     * 
    **/
    where: UserIdentityRolesWhereUniqueInput
  }


  /**
   * UserIdentityRoles findFirst
   */
  export type UserIdentityRolesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoles
     * 
    **/
    select?: UserIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRolesInclude | null
    /**
     * Throw an Error if a UserIdentityRoles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserIdentityRoles to fetch.
     * 
    **/
    where?: UserIdentityRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserIdentityRoles.
     * 
    **/
    cursor?: UserIdentityRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserIdentityRoles.
     * 
    **/
    distinct?: Enumerable<UserIdentityRolesScalarFieldEnum>
  }


  /**
   * UserIdentityRoles findMany
   */
  export type UserIdentityRolesFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoles
     * 
    **/
    select?: UserIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRolesInclude | null
    /**
     * Filter, which UserIdentityRoles to fetch.
     * 
    **/
    where?: UserIdentityRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserIdentityRoles.
     * 
    **/
    cursor?: UserIdentityRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityRoles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserIdentityRolesScalarFieldEnum>
  }


  /**
   * UserIdentityRoles create
   */
  export type UserIdentityRolesCreateArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoles
     * 
    **/
    select?: UserIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRolesInclude | null
    /**
     * The data needed to create a UserIdentityRoles.
     * 
    **/
    data: XOR<UserIdentityRolesCreateInput, UserIdentityRolesUncheckedCreateInput>
  }


  /**
   * UserIdentityRoles createMany
   */
  export type UserIdentityRolesCreateManyArgs = {
    data: Enumerable<UserIdentityRolesCreateManyInput>
  }


  /**
   * UserIdentityRoles update
   */
  export type UserIdentityRolesUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoles
     * 
    **/
    select?: UserIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRolesInclude | null
    /**
     * The data needed to update a UserIdentityRoles.
     * 
    **/
    data: XOR<UserIdentityRolesUpdateInput, UserIdentityRolesUncheckedUpdateInput>
    /**
     * Choose, which UserIdentityRoles to update.
     * 
    **/
    where: UserIdentityRolesWhereUniqueInput
  }


  /**
   * UserIdentityRoles updateMany
   */
  export type UserIdentityRolesUpdateManyArgs = {
    data: XOR<UserIdentityRolesUpdateManyMutationInput, UserIdentityRolesUncheckedUpdateManyInput>
    where?: UserIdentityRolesWhereInput
  }


  /**
   * UserIdentityRoles upsert
   */
  export type UserIdentityRolesUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoles
     * 
    **/
    select?: UserIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRolesInclude | null
    /**
     * The filter to search for the UserIdentityRoles to update in case it exists.
     * 
    **/
    where: UserIdentityRolesWhereUniqueInput
    /**
     * In case the UserIdentityRoles found by the `where` argument doesn't exist, create a new UserIdentityRoles with this data.
     * 
    **/
    create: XOR<UserIdentityRolesCreateInput, UserIdentityRolesUncheckedCreateInput>
    /**
     * In case the UserIdentityRoles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserIdentityRolesUpdateInput, UserIdentityRolesUncheckedUpdateInput>
  }


  /**
   * UserIdentityRoles delete
   */
  export type UserIdentityRolesDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoles
     * 
    **/
    select?: UserIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRolesInclude | null
    /**
     * Filter which UserIdentityRoles to delete.
     * 
    **/
    where: UserIdentityRolesWhereUniqueInput
  }


  /**
   * UserIdentityRoles deleteMany
   */
  export type UserIdentityRolesDeleteManyArgs = {
    where?: UserIdentityRolesWhereInput
  }


  /**
   * UserIdentityRoles without action
   */
  export type UserIdentityRolesArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityRoles
     * 
    **/
    select?: UserIdentityRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityRolesInclude | null
  }



  /**
   * Model UserIdentityTokens
   */


  export type AggregateUserIdentityTokens = {
    _count: UserIdentityTokensCountAggregateOutputType | null
    _min: UserIdentityTokensMinAggregateOutputType | null
    _max: UserIdentityTokensMaxAggregateOutputType | null
  }

  export type UserIdentityTokensMinAggregateOutputType = {
    UserId: string | null
    LoginProvider: string | null
    Name: string | null
    Value: string | null
  }

  export type UserIdentityTokensMaxAggregateOutputType = {
    UserId: string | null
    LoginProvider: string | null
    Name: string | null
    Value: string | null
  }

  export type UserIdentityTokensCountAggregateOutputType = {
    UserId: number
    LoginProvider: number
    Name: number
    Value: number
    _all: number
  }


  export type UserIdentityTokensMinAggregateInputType = {
    UserId?: true
    LoginProvider?: true
    Name?: true
    Value?: true
  }

  export type UserIdentityTokensMaxAggregateInputType = {
    UserId?: true
    LoginProvider?: true
    Name?: true
    Value?: true
  }

  export type UserIdentityTokensCountAggregateInputType = {
    UserId?: true
    LoginProvider?: true
    Name?: true
    Value?: true
    _all?: true
  }

  export type UserIdentityTokensAggregateArgs = {
    /**
     * Filter which UserIdentityTokens to aggregate.
     * 
    **/
    where?: UserIdentityTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserIdentityTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserIdentityTokens
    **/
    _count?: true | UserIdentityTokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserIdentityTokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserIdentityTokensMaxAggregateInputType
  }

  export type GetUserIdentityTokensAggregateType<T extends UserIdentityTokensAggregateArgs> = {
        [P in keyof T & keyof AggregateUserIdentityTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserIdentityTokens[P]>
      : GetScalarType<T[P], AggregateUserIdentityTokens[P]>
  }




  export type UserIdentityTokensGroupByArgs = {
    where?: UserIdentityTokensWhereInput
    orderBy?: Enumerable<UserIdentityTokensOrderByWithAggregationInput>
    by: Array<UserIdentityTokensScalarFieldEnum>
    having?: UserIdentityTokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserIdentityTokensCountAggregateInputType | true
    _min?: UserIdentityTokensMinAggregateInputType
    _max?: UserIdentityTokensMaxAggregateInputType
  }


  export type UserIdentityTokensGroupByOutputType = {
    UserId: string
    LoginProvider: string
    Name: string
    Value: string | null
    _count: UserIdentityTokensCountAggregateOutputType | null
    _min: UserIdentityTokensMinAggregateOutputType | null
    _max: UserIdentityTokensMaxAggregateOutputType | null
  }

  type GetUserIdentityTokensGroupByPayload<T extends UserIdentityTokensGroupByArgs> = Promise<
    Array<
      PickArray<UserIdentityTokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserIdentityTokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserIdentityTokensGroupByOutputType[P]>
            : GetScalarType<T[P], UserIdentityTokensGroupByOutputType[P]>
        }
      >
    >


  export type UserIdentityTokensSelect = {
    UserId?: boolean
    LoginProvider?: boolean
    Name?: boolean
    Value?: boolean
    Users?: boolean | UsersArgs
  }

  export type UserIdentityTokensInclude = {
    Users?: boolean | UsersArgs
  }

  export type UserIdentityTokensGetPayload<
    S extends boolean | null | undefined | UserIdentityTokensArgs,
    U = keyof S
      > = S extends true
        ? UserIdentityTokens
    : S extends undefined
    ? never
    : S extends UserIdentityTokensArgs | UserIdentityTokensFindManyArgs
    ?'include' extends U
    ? UserIdentityTokens  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Users'
        ? UsersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserIdentityTokens ?UserIdentityTokens [P]
  : 
          P extends 'Users'
        ? UsersGetPayload<S['select'][P]> : never
  } 
    : UserIdentityTokens
  : UserIdentityTokens


  type UserIdentityTokensCountArgs = Merge<
    Omit<UserIdentityTokensFindManyArgs, 'select' | 'include'> & {
      select?: UserIdentityTokensCountAggregateInputType | true
    }
  >

  export interface UserIdentityTokensDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserIdentityTokens that matches the filter.
     * @param {UserIdentityTokensFindUniqueArgs} args - Arguments to find a UserIdentityTokens
     * @example
     * // Get one UserIdentityTokens
     * const userIdentityTokens = await prisma.userIdentityTokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserIdentityTokensFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserIdentityTokensFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserIdentityTokens'> extends True ? CheckSelect<T, Prisma__UserIdentityTokensClient<UserIdentityTokens>, Prisma__UserIdentityTokensClient<UserIdentityTokensGetPayload<T>>> : CheckSelect<T, Prisma__UserIdentityTokensClient<UserIdentityTokens | null >, Prisma__UserIdentityTokensClient<UserIdentityTokensGetPayload<T> | null >>

    /**
     * Find the first UserIdentityTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityTokensFindFirstArgs} args - Arguments to find a UserIdentityTokens
     * @example
     * // Get one UserIdentityTokens
     * const userIdentityTokens = await prisma.userIdentityTokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserIdentityTokensFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserIdentityTokensFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserIdentityTokens'> extends True ? CheckSelect<T, Prisma__UserIdentityTokensClient<UserIdentityTokens>, Prisma__UserIdentityTokensClient<UserIdentityTokensGetPayload<T>>> : CheckSelect<T, Prisma__UserIdentityTokensClient<UserIdentityTokens | null >, Prisma__UserIdentityTokensClient<UserIdentityTokensGetPayload<T> | null >>

    /**
     * Find zero or more UserIdentityTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityTokensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserIdentityTokens
     * const userIdentityTokens = await prisma.userIdentityTokens.findMany()
     * 
     * // Get first 10 UserIdentityTokens
     * const userIdentityTokens = await prisma.userIdentityTokens.findMany({ take: 10 })
     * 
     * // Only select the `UserId`
     * const userIdentityTokensWithUserIdOnly = await prisma.userIdentityTokens.findMany({ select: { UserId: true } })
     * 
    **/
    findMany<T extends UserIdentityTokensFindManyArgs>(
      args?: SelectSubset<T, UserIdentityTokensFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserIdentityTokens>>, PrismaPromise<Array<UserIdentityTokensGetPayload<T>>>>

    /**
     * Create a UserIdentityTokens.
     * @param {UserIdentityTokensCreateArgs} args - Arguments to create a UserIdentityTokens.
     * @example
     * // Create one UserIdentityTokens
     * const UserIdentityTokens = await prisma.userIdentityTokens.create({
     *   data: {
     *     // ... data to create a UserIdentityTokens
     *   }
     * })
     * 
    **/
    create<T extends UserIdentityTokensCreateArgs>(
      args: SelectSubset<T, UserIdentityTokensCreateArgs>
    ): CheckSelect<T, Prisma__UserIdentityTokensClient<UserIdentityTokens>, Prisma__UserIdentityTokensClient<UserIdentityTokensGetPayload<T>>>

    /**
     * Create many UserIdentityTokens.
     *     @param {UserIdentityTokensCreateManyArgs} args - Arguments to create many UserIdentityTokens.
     *     @example
     *     // Create many UserIdentityTokens
     *     const userIdentityTokens = await prisma.userIdentityTokens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserIdentityTokensCreateManyArgs>(
      args?: SelectSubset<T, UserIdentityTokensCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserIdentityTokens.
     * @param {UserIdentityTokensDeleteArgs} args - Arguments to delete one UserIdentityTokens.
     * @example
     * // Delete one UserIdentityTokens
     * const UserIdentityTokens = await prisma.userIdentityTokens.delete({
     *   where: {
     *     // ... filter to delete one UserIdentityTokens
     *   }
     * })
     * 
    **/
    delete<T extends UserIdentityTokensDeleteArgs>(
      args: SelectSubset<T, UserIdentityTokensDeleteArgs>
    ): CheckSelect<T, Prisma__UserIdentityTokensClient<UserIdentityTokens>, Prisma__UserIdentityTokensClient<UserIdentityTokensGetPayload<T>>>

    /**
     * Update one UserIdentityTokens.
     * @param {UserIdentityTokensUpdateArgs} args - Arguments to update one UserIdentityTokens.
     * @example
     * // Update one UserIdentityTokens
     * const userIdentityTokens = await prisma.userIdentityTokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserIdentityTokensUpdateArgs>(
      args: SelectSubset<T, UserIdentityTokensUpdateArgs>
    ): CheckSelect<T, Prisma__UserIdentityTokensClient<UserIdentityTokens>, Prisma__UserIdentityTokensClient<UserIdentityTokensGetPayload<T>>>

    /**
     * Delete zero or more UserIdentityTokens.
     * @param {UserIdentityTokensDeleteManyArgs} args - Arguments to filter UserIdentityTokens to delete.
     * @example
     * // Delete a few UserIdentityTokens
     * const { count } = await prisma.userIdentityTokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserIdentityTokensDeleteManyArgs>(
      args?: SelectSubset<T, UserIdentityTokensDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserIdentityTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityTokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserIdentityTokens
     * const userIdentityTokens = await prisma.userIdentityTokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserIdentityTokensUpdateManyArgs>(
      args: SelectSubset<T, UserIdentityTokensUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserIdentityTokens.
     * @param {UserIdentityTokensUpsertArgs} args - Arguments to update or create a UserIdentityTokens.
     * @example
     * // Update or create a UserIdentityTokens
     * const userIdentityTokens = await prisma.userIdentityTokens.upsert({
     *   create: {
     *     // ... data to create a UserIdentityTokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserIdentityTokens we want to update
     *   }
     * })
    **/
    upsert<T extends UserIdentityTokensUpsertArgs>(
      args: SelectSubset<T, UserIdentityTokensUpsertArgs>
    ): CheckSelect<T, Prisma__UserIdentityTokensClient<UserIdentityTokens>, Prisma__UserIdentityTokensClient<UserIdentityTokensGetPayload<T>>>

    /**
     * Count the number of UserIdentityTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityTokensCountArgs} args - Arguments to filter UserIdentityTokens to count.
     * @example
     * // Count the number of UserIdentityTokens
     * const count = await prisma.userIdentityTokens.count({
     *   where: {
     *     // ... the filter for the UserIdentityTokens we want to count
     *   }
     * })
    **/
    count<T extends UserIdentityTokensCountArgs>(
      args?: Subset<T, UserIdentityTokensCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserIdentityTokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserIdentityTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityTokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserIdentityTokensAggregateArgs>(args: Subset<T, UserIdentityTokensAggregateArgs>): PrismaPromise<GetUserIdentityTokensAggregateType<T>>

    /**
     * Group by UserIdentityTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIdentityTokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserIdentityTokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserIdentityTokensGroupByArgs['orderBy'] }
        : { orderBy?: UserIdentityTokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserIdentityTokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserIdentityTokensGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserIdentityTokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserIdentityTokensClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Users<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserIdentityTokens findUnique
   */
  export type UserIdentityTokensFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityTokens
     * 
    **/
    select?: UserIdentityTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityTokensInclude | null
    /**
     * Throw an Error if a UserIdentityTokens can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserIdentityTokens to fetch.
     * 
    **/
    where: UserIdentityTokensWhereUniqueInput
  }


  /**
   * UserIdentityTokens findFirst
   */
  export type UserIdentityTokensFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityTokens
     * 
    **/
    select?: UserIdentityTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityTokensInclude | null
    /**
     * Throw an Error if a UserIdentityTokens can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserIdentityTokens to fetch.
     * 
    **/
    where?: UserIdentityTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserIdentityTokens.
     * 
    **/
    cursor?: UserIdentityTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserIdentityTokens.
     * 
    **/
    distinct?: Enumerable<UserIdentityTokensScalarFieldEnum>
  }


  /**
   * UserIdentityTokens findMany
   */
  export type UserIdentityTokensFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityTokens
     * 
    **/
    select?: UserIdentityTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityTokensInclude | null
    /**
     * Filter, which UserIdentityTokens to fetch.
     * 
    **/
    where?: UserIdentityTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIdentityTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<UserIdentityTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserIdentityTokens.
     * 
    **/
    cursor?: UserIdentityTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIdentityTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIdentityTokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserIdentityTokensScalarFieldEnum>
  }


  /**
   * UserIdentityTokens create
   */
  export type UserIdentityTokensCreateArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityTokens
     * 
    **/
    select?: UserIdentityTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityTokensInclude | null
    /**
     * The data needed to create a UserIdentityTokens.
     * 
    **/
    data: XOR<UserIdentityTokensCreateInput, UserIdentityTokensUncheckedCreateInput>
  }


  /**
   * UserIdentityTokens createMany
   */
  export type UserIdentityTokensCreateManyArgs = {
    data: Enumerable<UserIdentityTokensCreateManyInput>
  }


  /**
   * UserIdentityTokens update
   */
  export type UserIdentityTokensUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityTokens
     * 
    **/
    select?: UserIdentityTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityTokensInclude | null
    /**
     * The data needed to update a UserIdentityTokens.
     * 
    **/
    data: XOR<UserIdentityTokensUpdateInput, UserIdentityTokensUncheckedUpdateInput>
    /**
     * Choose, which UserIdentityTokens to update.
     * 
    **/
    where: UserIdentityTokensWhereUniqueInput
  }


  /**
   * UserIdentityTokens updateMany
   */
  export type UserIdentityTokensUpdateManyArgs = {
    data: XOR<UserIdentityTokensUpdateManyMutationInput, UserIdentityTokensUncheckedUpdateManyInput>
    where?: UserIdentityTokensWhereInput
  }


  /**
   * UserIdentityTokens upsert
   */
  export type UserIdentityTokensUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityTokens
     * 
    **/
    select?: UserIdentityTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityTokensInclude | null
    /**
     * The filter to search for the UserIdentityTokens to update in case it exists.
     * 
    **/
    where: UserIdentityTokensWhereUniqueInput
    /**
     * In case the UserIdentityTokens found by the `where` argument doesn't exist, create a new UserIdentityTokens with this data.
     * 
    **/
    create: XOR<UserIdentityTokensCreateInput, UserIdentityTokensUncheckedCreateInput>
    /**
     * In case the UserIdentityTokens was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserIdentityTokensUpdateInput, UserIdentityTokensUncheckedUpdateInput>
  }


  /**
   * UserIdentityTokens delete
   */
  export type UserIdentityTokensDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityTokens
     * 
    **/
    select?: UserIdentityTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityTokensInclude | null
    /**
     * Filter which UserIdentityTokens to delete.
     * 
    **/
    where: UserIdentityTokensWhereUniqueInput
  }


  /**
   * UserIdentityTokens deleteMany
   */
  export type UserIdentityTokensDeleteManyArgs = {
    where?: UserIdentityTokensWhereInput
  }


  /**
   * UserIdentityTokens without action
   */
  export type UserIdentityTokensArgs = {
    /**
     * Select specific fields to fetch from the UserIdentityTokens
     * 
    **/
    select?: UserIdentityTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserIdentityTokensInclude | null
  }



  /**
   * Model UserProfileSetting
   */


  export type AggregateUserProfileSetting = {
    _count: UserProfileSettingCountAggregateOutputType | null
    _min: UserProfileSettingMinAggregateOutputType | null
    _max: UserProfileSettingMaxAggregateOutputType | null
  }

  export type UserProfileSettingMinAggregateOutputType = {
    Id: string | null
    UserId: string | null
    RepositoryTechnologyConfiguration: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type UserProfileSettingMaxAggregateOutputType = {
    Id: string | null
    UserId: string | null
    RepositoryTechnologyConfiguration: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
  }

  export type UserProfileSettingCountAggregateOutputType = {
    Id: number
    UserId: number
    RepositoryTechnologyConfiguration: number
    CreatedDate: number
    ModifiedDate: number
    _all: number
  }


  export type UserProfileSettingMinAggregateInputType = {
    Id?: true
    UserId?: true
    RepositoryTechnologyConfiguration?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type UserProfileSettingMaxAggregateInputType = {
    Id?: true
    UserId?: true
    RepositoryTechnologyConfiguration?: true
    CreatedDate?: true
    ModifiedDate?: true
  }

  export type UserProfileSettingCountAggregateInputType = {
    Id?: true
    UserId?: true
    RepositoryTechnologyConfiguration?: true
    CreatedDate?: true
    ModifiedDate?: true
    _all?: true
  }

  export type UserProfileSettingAggregateArgs = {
    /**
     * Filter which UserProfileSetting to aggregate.
     * 
    **/
    where?: UserProfileSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfileSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<UserProfileSettingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserProfileSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfileSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfileSettings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfileSettings
    **/
    _count?: true | UserProfileSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileSettingMaxAggregateInputType
  }

  export type GetUserProfileSettingAggregateType<T extends UserProfileSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfileSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfileSetting[P]>
      : GetScalarType<T[P], AggregateUserProfileSetting[P]>
  }




  export type UserProfileSettingGroupByArgs = {
    where?: UserProfileSettingWhereInput
    orderBy?: Enumerable<UserProfileSettingOrderByWithAggregationInput>
    by: Array<UserProfileSettingScalarFieldEnum>
    having?: UserProfileSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileSettingCountAggregateInputType | true
    _min?: UserProfileSettingMinAggregateInputType
    _max?: UserProfileSettingMaxAggregateInputType
  }


  export type UserProfileSettingGroupByOutputType = {
    Id: string
    UserId: string | null
    RepositoryTechnologyConfiguration: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    _count: UserProfileSettingCountAggregateOutputType | null
    _min: UserProfileSettingMinAggregateOutputType | null
    _max: UserProfileSettingMaxAggregateOutputType | null
  }

  type GetUserProfileSettingGroupByPayload<T extends UserProfileSettingGroupByArgs> = Promise<
    Array<
      PickArray<UserProfileSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileSettingGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileSettingGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSettingSelect = {
    Id?: boolean
    UserId?: boolean
    RepositoryTechnologyConfiguration?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
  }

  export type UserProfileSettingGetPayload<
    S extends boolean | null | undefined | UserProfileSettingArgs,
    U = keyof S
      > = S extends true
        ? UserProfileSetting
    : S extends undefined
    ? never
    : S extends UserProfileSettingArgs | UserProfileSettingFindManyArgs
    ?'include' extends U
    ? UserProfileSetting 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserProfileSetting ?UserProfileSetting [P]
  : 
     never
  } 
    : UserProfileSetting
  : UserProfileSetting


  type UserProfileSettingCountArgs = Merge<
    Omit<UserProfileSettingFindManyArgs, 'select' | 'include'> & {
      select?: UserProfileSettingCountAggregateInputType | true
    }
  >

  export interface UserProfileSettingDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserProfileSetting that matches the filter.
     * @param {UserProfileSettingFindUniqueArgs} args - Arguments to find a UserProfileSetting
     * @example
     * // Get one UserProfileSetting
     * const userProfileSetting = await prisma.userProfileSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserProfileSettingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserProfileSettingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserProfileSetting'> extends True ? CheckSelect<T, Prisma__UserProfileSettingClient<UserProfileSetting>, Prisma__UserProfileSettingClient<UserProfileSettingGetPayload<T>>> : CheckSelect<T, Prisma__UserProfileSettingClient<UserProfileSetting | null >, Prisma__UserProfileSettingClient<UserProfileSettingGetPayload<T> | null >>

    /**
     * Find the first UserProfileSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileSettingFindFirstArgs} args - Arguments to find a UserProfileSetting
     * @example
     * // Get one UserProfileSetting
     * const userProfileSetting = await prisma.userProfileSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserProfileSettingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserProfileSettingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserProfileSetting'> extends True ? CheckSelect<T, Prisma__UserProfileSettingClient<UserProfileSetting>, Prisma__UserProfileSettingClient<UserProfileSettingGetPayload<T>>> : CheckSelect<T, Prisma__UserProfileSettingClient<UserProfileSetting | null >, Prisma__UserProfileSettingClient<UserProfileSettingGetPayload<T> | null >>

    /**
     * Find zero or more UserProfileSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileSettingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfileSettings
     * const userProfileSettings = await prisma.userProfileSetting.findMany()
     * 
     * // Get first 10 UserProfileSettings
     * const userProfileSettings = await prisma.userProfileSetting.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userProfileSettingWithIdOnly = await prisma.userProfileSetting.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserProfileSettingFindManyArgs>(
      args?: SelectSubset<T, UserProfileSettingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserProfileSetting>>, PrismaPromise<Array<UserProfileSettingGetPayload<T>>>>

    /**
     * Create a UserProfileSetting.
     * @param {UserProfileSettingCreateArgs} args - Arguments to create a UserProfileSetting.
     * @example
     * // Create one UserProfileSetting
     * const UserProfileSetting = await prisma.userProfileSetting.create({
     *   data: {
     *     // ... data to create a UserProfileSetting
     *   }
     * })
     * 
    **/
    create<T extends UserProfileSettingCreateArgs>(
      args: SelectSubset<T, UserProfileSettingCreateArgs>
    ): CheckSelect<T, Prisma__UserProfileSettingClient<UserProfileSetting>, Prisma__UserProfileSettingClient<UserProfileSettingGetPayload<T>>>

    /**
     * Create many UserProfileSettings.
     *     @param {UserProfileSettingCreateManyArgs} args - Arguments to create many UserProfileSettings.
     *     @example
     *     // Create many UserProfileSettings
     *     const userProfileSetting = await prisma.userProfileSetting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserProfileSettingCreateManyArgs>(
      args?: SelectSubset<T, UserProfileSettingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserProfileSetting.
     * @param {UserProfileSettingDeleteArgs} args - Arguments to delete one UserProfileSetting.
     * @example
     * // Delete one UserProfileSetting
     * const UserProfileSetting = await prisma.userProfileSetting.delete({
     *   where: {
     *     // ... filter to delete one UserProfileSetting
     *   }
     * })
     * 
    **/
    delete<T extends UserProfileSettingDeleteArgs>(
      args: SelectSubset<T, UserProfileSettingDeleteArgs>
    ): CheckSelect<T, Prisma__UserProfileSettingClient<UserProfileSetting>, Prisma__UserProfileSettingClient<UserProfileSettingGetPayload<T>>>

    /**
     * Update one UserProfileSetting.
     * @param {UserProfileSettingUpdateArgs} args - Arguments to update one UserProfileSetting.
     * @example
     * // Update one UserProfileSetting
     * const userProfileSetting = await prisma.userProfileSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserProfileSettingUpdateArgs>(
      args: SelectSubset<T, UserProfileSettingUpdateArgs>
    ): CheckSelect<T, Prisma__UserProfileSettingClient<UserProfileSetting>, Prisma__UserProfileSettingClient<UserProfileSettingGetPayload<T>>>

    /**
     * Delete zero or more UserProfileSettings.
     * @param {UserProfileSettingDeleteManyArgs} args - Arguments to filter UserProfileSettings to delete.
     * @example
     * // Delete a few UserProfileSettings
     * const { count } = await prisma.userProfileSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserProfileSettingDeleteManyArgs>(
      args?: SelectSubset<T, UserProfileSettingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfileSettings
     * const userProfileSetting = await prisma.userProfileSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserProfileSettingUpdateManyArgs>(
      args: SelectSubset<T, UserProfileSettingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfileSetting.
     * @param {UserProfileSettingUpsertArgs} args - Arguments to update or create a UserProfileSetting.
     * @example
     * // Update or create a UserProfileSetting
     * const userProfileSetting = await prisma.userProfileSetting.upsert({
     *   create: {
     *     // ... data to create a UserProfileSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfileSetting we want to update
     *   }
     * })
    **/
    upsert<T extends UserProfileSettingUpsertArgs>(
      args: SelectSubset<T, UserProfileSettingUpsertArgs>
    ): CheckSelect<T, Prisma__UserProfileSettingClient<UserProfileSetting>, Prisma__UserProfileSettingClient<UserProfileSettingGetPayload<T>>>

    /**
     * Count the number of UserProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileSettingCountArgs} args - Arguments to filter UserProfileSettings to count.
     * @example
     * // Count the number of UserProfileSettings
     * const count = await prisma.userProfileSetting.count({
     *   where: {
     *     // ... the filter for the UserProfileSettings we want to count
     *   }
     * })
    **/
    count<T extends UserProfileSettingCountArgs>(
      args?: Subset<T, UserProfileSettingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfileSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileSettingAggregateArgs>(args: Subset<T, UserProfileSettingAggregateArgs>): PrismaPromise<GetUserProfileSettingAggregateType<T>>

    /**
     * Group by UserProfileSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileSettingGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileSettingGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfileSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserProfileSettingClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserProfileSetting findUnique
   */
  export type UserProfileSettingFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserProfileSetting
     * 
    **/
    select?: UserProfileSettingSelect | null
    /**
     * Throw an Error if a UserProfileSetting can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserProfileSetting to fetch.
     * 
    **/
    where: UserProfileSettingWhereUniqueInput
  }


  /**
   * UserProfileSetting findFirst
   */
  export type UserProfileSettingFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserProfileSetting
     * 
    **/
    select?: UserProfileSettingSelect | null
    /**
     * Throw an Error if a UserProfileSetting can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserProfileSetting to fetch.
     * 
    **/
    where?: UserProfileSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfileSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<UserProfileSettingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfileSettings.
     * 
    **/
    cursor?: UserProfileSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfileSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfileSettings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfileSettings.
     * 
    **/
    distinct?: Enumerable<UserProfileSettingScalarFieldEnum>
  }


  /**
   * UserProfileSetting findMany
   */
  export type UserProfileSettingFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserProfileSetting
     * 
    **/
    select?: UserProfileSettingSelect | null
    /**
     * Filter, which UserProfileSettings to fetch.
     * 
    **/
    where?: UserProfileSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfileSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<UserProfileSettingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfileSettings.
     * 
    **/
    cursor?: UserProfileSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfileSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfileSettings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserProfileSettingScalarFieldEnum>
  }


  /**
   * UserProfileSetting create
   */
  export type UserProfileSettingCreateArgs = {
    /**
     * Select specific fields to fetch from the UserProfileSetting
     * 
    **/
    select?: UserProfileSettingSelect | null
    /**
     * The data needed to create a UserProfileSetting.
     * 
    **/
    data: XOR<UserProfileSettingCreateInput, UserProfileSettingUncheckedCreateInput>
  }


  /**
   * UserProfileSetting createMany
   */
  export type UserProfileSettingCreateManyArgs = {
    data: Enumerable<UserProfileSettingCreateManyInput>
  }


  /**
   * UserProfileSetting update
   */
  export type UserProfileSettingUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserProfileSetting
     * 
    **/
    select?: UserProfileSettingSelect | null
    /**
     * The data needed to update a UserProfileSetting.
     * 
    **/
    data: XOR<UserProfileSettingUpdateInput, UserProfileSettingUncheckedUpdateInput>
    /**
     * Choose, which UserProfileSetting to update.
     * 
    **/
    where: UserProfileSettingWhereUniqueInput
  }


  /**
   * UserProfileSetting updateMany
   */
  export type UserProfileSettingUpdateManyArgs = {
    data: XOR<UserProfileSettingUpdateManyMutationInput, UserProfileSettingUncheckedUpdateManyInput>
    where?: UserProfileSettingWhereInput
  }


  /**
   * UserProfileSetting upsert
   */
  export type UserProfileSettingUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserProfileSetting
     * 
    **/
    select?: UserProfileSettingSelect | null
    /**
     * The filter to search for the UserProfileSetting to update in case it exists.
     * 
    **/
    where: UserProfileSettingWhereUniqueInput
    /**
     * In case the UserProfileSetting found by the `where` argument doesn't exist, create a new UserProfileSetting with this data.
     * 
    **/
    create: XOR<UserProfileSettingCreateInput, UserProfileSettingUncheckedCreateInput>
    /**
     * In case the UserProfileSetting was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserProfileSettingUpdateInput, UserProfileSettingUncheckedUpdateInput>
  }


  /**
   * UserProfileSetting delete
   */
  export type UserProfileSettingDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserProfileSetting
     * 
    **/
    select?: UserProfileSettingSelect | null
    /**
     * Filter which UserProfileSetting to delete.
     * 
    **/
    where: UserProfileSettingWhereUniqueInput
  }


  /**
   * UserProfileSetting deleteMany
   */
  export type UserProfileSettingDeleteManyArgs = {
    where?: UserProfileSettingWhereInput
  }


  /**
   * UserProfileSetting without action
   */
  export type UserProfileSettingArgs = {
    /**
     * Select specific fields to fetch from the UserProfileSetting
     * 
    **/
    select?: UserProfileSettingSelect | null
  }



  /**
   * Model UserRoleProfiles
   */


  export type AggregateUserRoleProfiles = {
    _count: UserRoleProfilesCountAggregateOutputType | null
    _min: UserRoleProfilesMinAggregateOutputType | null
    _max: UserRoleProfilesMaxAggregateOutputType | null
  }

  export type UserRoleProfilesMinAggregateOutputType = {
    Id: string | null
    UserRole_Id: string | null
    Profile_Id: string | null
    Created: Date | null
    Modified: Date | null
  }

  export type UserRoleProfilesMaxAggregateOutputType = {
    Id: string | null
    UserRole_Id: string | null
    Profile_Id: string | null
    Created: Date | null
    Modified: Date | null
  }

  export type UserRoleProfilesCountAggregateOutputType = {
    Id: number
    UserRole_Id: number
    Profile_Id: number
    Created: number
    Modified: number
    _all: number
  }


  export type UserRoleProfilesMinAggregateInputType = {
    Id?: true
    UserRole_Id?: true
    Profile_Id?: true
    Created?: true
    Modified?: true
  }

  export type UserRoleProfilesMaxAggregateInputType = {
    Id?: true
    UserRole_Id?: true
    Profile_Id?: true
    Created?: true
    Modified?: true
  }

  export type UserRoleProfilesCountAggregateInputType = {
    Id?: true
    UserRole_Id?: true
    Profile_Id?: true
    Created?: true
    Modified?: true
    _all?: true
  }

  export type UserRoleProfilesAggregateArgs = {
    /**
     * Filter which UserRoleProfiles to aggregate.
     * 
    **/
    where?: UserRoleProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserRoleProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserRoleProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleProfiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoleProfiles
    **/
    _count?: true | UserRoleProfilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleProfilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleProfilesMaxAggregateInputType
  }

  export type GetUserRoleProfilesAggregateType<T extends UserRoleProfilesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRoleProfiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRoleProfiles[P]>
      : GetScalarType<T[P], AggregateUserRoleProfiles[P]>
  }




  export type UserRoleProfilesGroupByArgs = {
    where?: UserRoleProfilesWhereInput
    orderBy?: Enumerable<UserRoleProfilesOrderByWithAggregationInput>
    by: Array<UserRoleProfilesScalarFieldEnum>
    having?: UserRoleProfilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleProfilesCountAggregateInputType | true
    _min?: UserRoleProfilesMinAggregateInputType
    _max?: UserRoleProfilesMaxAggregateInputType
  }


  export type UserRoleProfilesGroupByOutputType = {
    Id: string
    UserRole_Id: string
    Profile_Id: string
    Created: Date
    Modified: Date
    _count: UserRoleProfilesCountAggregateOutputType | null
    _min: UserRoleProfilesMinAggregateOutputType | null
    _max: UserRoleProfilesMaxAggregateOutputType | null
  }

  type GetUserRoleProfilesGroupByPayload<T extends UserRoleProfilesGroupByArgs> = Promise<
    Array<
      PickArray<UserRoleProfilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleProfilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleProfilesGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleProfilesGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleProfilesSelect = {
    Id?: boolean
    UserRole_Id?: boolean
    Profile_Id?: boolean
    Created?: boolean
    Modified?: boolean
  }

  export type UserRoleProfilesGetPayload<
    S extends boolean | null | undefined | UserRoleProfilesArgs,
    U = keyof S
      > = S extends true
        ? UserRoleProfiles
    : S extends undefined
    ? never
    : S extends UserRoleProfilesArgs | UserRoleProfilesFindManyArgs
    ?'include' extends U
    ? UserRoleProfiles 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserRoleProfiles ?UserRoleProfiles [P]
  : 
     never
  } 
    : UserRoleProfiles
  : UserRoleProfiles


  type UserRoleProfilesCountArgs = Merge<
    Omit<UserRoleProfilesFindManyArgs, 'select' | 'include'> & {
      select?: UserRoleProfilesCountAggregateInputType | true
    }
  >

  export interface UserRoleProfilesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserRoleProfiles that matches the filter.
     * @param {UserRoleProfilesFindUniqueArgs} args - Arguments to find a UserRoleProfiles
     * @example
     * // Get one UserRoleProfiles
     * const userRoleProfiles = await prisma.userRoleProfiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserRoleProfilesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserRoleProfilesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserRoleProfiles'> extends True ? CheckSelect<T, Prisma__UserRoleProfilesClient<UserRoleProfiles>, Prisma__UserRoleProfilesClient<UserRoleProfilesGetPayload<T>>> : CheckSelect<T, Prisma__UserRoleProfilesClient<UserRoleProfiles | null >, Prisma__UserRoleProfilesClient<UserRoleProfilesGetPayload<T> | null >>

    /**
     * Find the first UserRoleProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleProfilesFindFirstArgs} args - Arguments to find a UserRoleProfiles
     * @example
     * // Get one UserRoleProfiles
     * const userRoleProfiles = await prisma.userRoleProfiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserRoleProfilesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserRoleProfilesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserRoleProfiles'> extends True ? CheckSelect<T, Prisma__UserRoleProfilesClient<UserRoleProfiles>, Prisma__UserRoleProfilesClient<UserRoleProfilesGetPayload<T>>> : CheckSelect<T, Prisma__UserRoleProfilesClient<UserRoleProfiles | null >, Prisma__UserRoleProfilesClient<UserRoleProfilesGetPayload<T> | null >>

    /**
     * Find zero or more UserRoleProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleProfilesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoleProfiles
     * const userRoleProfiles = await prisma.userRoleProfiles.findMany()
     * 
     * // Get first 10 UserRoleProfiles
     * const userRoleProfiles = await prisma.userRoleProfiles.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userRoleProfilesWithIdOnly = await prisma.userRoleProfiles.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserRoleProfilesFindManyArgs>(
      args?: SelectSubset<T, UserRoleProfilesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserRoleProfiles>>, PrismaPromise<Array<UserRoleProfilesGetPayload<T>>>>

    /**
     * Create a UserRoleProfiles.
     * @param {UserRoleProfilesCreateArgs} args - Arguments to create a UserRoleProfiles.
     * @example
     * // Create one UserRoleProfiles
     * const UserRoleProfiles = await prisma.userRoleProfiles.create({
     *   data: {
     *     // ... data to create a UserRoleProfiles
     *   }
     * })
     * 
    **/
    create<T extends UserRoleProfilesCreateArgs>(
      args: SelectSubset<T, UserRoleProfilesCreateArgs>
    ): CheckSelect<T, Prisma__UserRoleProfilesClient<UserRoleProfiles>, Prisma__UserRoleProfilesClient<UserRoleProfilesGetPayload<T>>>

    /**
     * Create many UserRoleProfiles.
     *     @param {UserRoleProfilesCreateManyArgs} args - Arguments to create many UserRoleProfiles.
     *     @example
     *     // Create many UserRoleProfiles
     *     const userRoleProfiles = await prisma.userRoleProfiles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserRoleProfilesCreateManyArgs>(
      args?: SelectSubset<T, UserRoleProfilesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserRoleProfiles.
     * @param {UserRoleProfilesDeleteArgs} args - Arguments to delete one UserRoleProfiles.
     * @example
     * // Delete one UserRoleProfiles
     * const UserRoleProfiles = await prisma.userRoleProfiles.delete({
     *   where: {
     *     // ... filter to delete one UserRoleProfiles
     *   }
     * })
     * 
    **/
    delete<T extends UserRoleProfilesDeleteArgs>(
      args: SelectSubset<T, UserRoleProfilesDeleteArgs>
    ): CheckSelect<T, Prisma__UserRoleProfilesClient<UserRoleProfiles>, Prisma__UserRoleProfilesClient<UserRoleProfilesGetPayload<T>>>

    /**
     * Update one UserRoleProfiles.
     * @param {UserRoleProfilesUpdateArgs} args - Arguments to update one UserRoleProfiles.
     * @example
     * // Update one UserRoleProfiles
     * const userRoleProfiles = await prisma.userRoleProfiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserRoleProfilesUpdateArgs>(
      args: SelectSubset<T, UserRoleProfilesUpdateArgs>
    ): CheckSelect<T, Prisma__UserRoleProfilesClient<UserRoleProfiles>, Prisma__UserRoleProfilesClient<UserRoleProfilesGetPayload<T>>>

    /**
     * Delete zero or more UserRoleProfiles.
     * @param {UserRoleProfilesDeleteManyArgs} args - Arguments to filter UserRoleProfiles to delete.
     * @example
     * // Delete a few UserRoleProfiles
     * const { count } = await prisma.userRoleProfiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserRoleProfilesDeleteManyArgs>(
      args?: SelectSubset<T, UserRoleProfilesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoleProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleProfilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoleProfiles
     * const userRoleProfiles = await prisma.userRoleProfiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserRoleProfilesUpdateManyArgs>(
      args: SelectSubset<T, UserRoleProfilesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRoleProfiles.
     * @param {UserRoleProfilesUpsertArgs} args - Arguments to update or create a UserRoleProfiles.
     * @example
     * // Update or create a UserRoleProfiles
     * const userRoleProfiles = await prisma.userRoleProfiles.upsert({
     *   create: {
     *     // ... data to create a UserRoleProfiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRoleProfiles we want to update
     *   }
     * })
    **/
    upsert<T extends UserRoleProfilesUpsertArgs>(
      args: SelectSubset<T, UserRoleProfilesUpsertArgs>
    ): CheckSelect<T, Prisma__UserRoleProfilesClient<UserRoleProfiles>, Prisma__UserRoleProfilesClient<UserRoleProfilesGetPayload<T>>>

    /**
     * Count the number of UserRoleProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleProfilesCountArgs} args - Arguments to filter UserRoleProfiles to count.
     * @example
     * // Count the number of UserRoleProfiles
     * const count = await prisma.userRoleProfiles.count({
     *   where: {
     *     // ... the filter for the UserRoleProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleProfilesCountArgs>(
      args?: Subset<T, UserRoleProfilesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleProfilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRoleProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleProfilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleProfilesAggregateArgs>(args: Subset<T, UserRoleProfilesAggregateArgs>): PrismaPromise<GetUserRoleProfilesAggregateType<T>>

    /**
     * Group by UserRoleProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleProfilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleProfilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleProfilesGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleProfilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleProfilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleProfilesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRoleProfiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserRoleProfilesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserRoleProfiles findUnique
   */
  export type UserRoleProfilesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserRoleProfiles
     * 
    **/
    select?: UserRoleProfilesSelect | null
    /**
     * Throw an Error if a UserRoleProfiles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserRoleProfiles to fetch.
     * 
    **/
    where: UserRoleProfilesWhereUniqueInput
  }


  /**
   * UserRoleProfiles findFirst
   */
  export type UserRoleProfilesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserRoleProfiles
     * 
    **/
    select?: UserRoleProfilesSelect | null
    /**
     * Throw an Error if a UserRoleProfiles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserRoleProfiles to fetch.
     * 
    **/
    where?: UserRoleProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserRoleProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoleProfiles.
     * 
    **/
    cursor?: UserRoleProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleProfiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoleProfiles.
     * 
    **/
    distinct?: Enumerable<UserRoleProfilesScalarFieldEnum>
  }


  /**
   * UserRoleProfiles findMany
   */
  export type UserRoleProfilesFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserRoleProfiles
     * 
    **/
    select?: UserRoleProfilesSelect | null
    /**
     * Filter, which UserRoleProfiles to fetch.
     * 
    **/
    where?: UserRoleProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserRoleProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoleProfiles.
     * 
    **/
    cursor?: UserRoleProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleProfiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserRoleProfilesScalarFieldEnum>
  }


  /**
   * UserRoleProfiles create
   */
  export type UserRoleProfilesCreateArgs = {
    /**
     * Select specific fields to fetch from the UserRoleProfiles
     * 
    **/
    select?: UserRoleProfilesSelect | null
    /**
     * The data needed to create a UserRoleProfiles.
     * 
    **/
    data: XOR<UserRoleProfilesCreateInput, UserRoleProfilesUncheckedCreateInput>
  }


  /**
   * UserRoleProfiles createMany
   */
  export type UserRoleProfilesCreateManyArgs = {
    data: Enumerable<UserRoleProfilesCreateManyInput>
  }


  /**
   * UserRoleProfiles update
   */
  export type UserRoleProfilesUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserRoleProfiles
     * 
    **/
    select?: UserRoleProfilesSelect | null
    /**
     * The data needed to update a UserRoleProfiles.
     * 
    **/
    data: XOR<UserRoleProfilesUpdateInput, UserRoleProfilesUncheckedUpdateInput>
    /**
     * Choose, which UserRoleProfiles to update.
     * 
    **/
    where: UserRoleProfilesWhereUniqueInput
  }


  /**
   * UserRoleProfiles updateMany
   */
  export type UserRoleProfilesUpdateManyArgs = {
    data: XOR<UserRoleProfilesUpdateManyMutationInput, UserRoleProfilesUncheckedUpdateManyInput>
    where?: UserRoleProfilesWhereInput
  }


  /**
   * UserRoleProfiles upsert
   */
  export type UserRoleProfilesUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserRoleProfiles
     * 
    **/
    select?: UserRoleProfilesSelect | null
    /**
     * The filter to search for the UserRoleProfiles to update in case it exists.
     * 
    **/
    where: UserRoleProfilesWhereUniqueInput
    /**
     * In case the UserRoleProfiles found by the `where` argument doesn't exist, create a new UserRoleProfiles with this data.
     * 
    **/
    create: XOR<UserRoleProfilesCreateInput, UserRoleProfilesUncheckedCreateInput>
    /**
     * In case the UserRoleProfiles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserRoleProfilesUpdateInput, UserRoleProfilesUncheckedUpdateInput>
  }


  /**
   * UserRoleProfiles delete
   */
  export type UserRoleProfilesDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserRoleProfiles
     * 
    **/
    select?: UserRoleProfilesSelect | null
    /**
     * Filter which UserRoleProfiles to delete.
     * 
    **/
    where: UserRoleProfilesWhereUniqueInput
  }


  /**
   * UserRoleProfiles deleteMany
   */
  export type UserRoleProfilesDeleteManyArgs = {
    where?: UserRoleProfilesWhereInput
  }


  /**
   * UserRoleProfiles without action
   */
  export type UserRoleProfilesArgs = {
    /**
     * Select specific fields to fetch from the UserRoleProfiles
     * 
    **/
    select?: UserRoleProfilesSelect | null
  }



  /**
   * Model UserRoles
   */


  export type AggregateUserRoles = {
    _count: UserRolesCountAggregateOutputType | null
    _avg: UserRolesAvgAggregateOutputType | null
    _sum: UserRolesSumAggregateOutputType | null
    _min: UserRolesMinAggregateOutputType | null
    _max: UserRolesMaxAggregateOutputType | null
  }

  export type UserRolesAvgAggregateOutputType = {
    UIEnabled: number | null
  }

  export type UserRolesSumAggregateOutputType = {
    UIEnabled: number | null
  }

  export type UserRolesMinAggregateOutputType = {
    Id: string | null
    Name: string | null
    Description: string | null
    UIEnabled: number | null
  }

  export type UserRolesMaxAggregateOutputType = {
    Id: string | null
    Name: string | null
    Description: string | null
    UIEnabled: number | null
  }

  export type UserRolesCountAggregateOutputType = {
    Id: number
    Name: number
    Description: number
    UIEnabled: number
    _all: number
  }


  export type UserRolesAvgAggregateInputType = {
    UIEnabled?: true
  }

  export type UserRolesSumAggregateInputType = {
    UIEnabled?: true
  }

  export type UserRolesMinAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    UIEnabled?: true
  }

  export type UserRolesMaxAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    UIEnabled?: true
  }

  export type UserRolesCountAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    UIEnabled?: true
    _all?: true
  }

  export type UserRolesAggregateArgs = {
    /**
     * Filter which UserRoles to aggregate.
     * 
    **/
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRolesMaxAggregateInputType
  }

  export type GetUserRolesAggregateType<T extends UserRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRoles[P]>
      : GetScalarType<T[P], AggregateUserRoles[P]>
  }




  export type UserRolesGroupByArgs = {
    where?: UserRolesWhereInput
    orderBy?: Enumerable<UserRolesOrderByWithAggregationInput>
    by: Array<UserRolesScalarFieldEnum>
    having?: UserRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRolesCountAggregateInputType | true
    _avg?: UserRolesAvgAggregateInputType
    _sum?: UserRolesSumAggregateInputType
    _min?: UserRolesMinAggregateInputType
    _max?: UserRolesMaxAggregateInputType
  }


  export type UserRolesGroupByOutputType = {
    Id: string
    Name: string
    Description: string | null
    UIEnabled: number
    _count: UserRolesCountAggregateOutputType | null
    _avg: UserRolesAvgAggregateOutputType | null
    _sum: UserRolesSumAggregateOutputType | null
    _min: UserRolesMinAggregateOutputType | null
    _max: UserRolesMaxAggregateOutputType | null
  }

  type GetUserRolesGroupByPayload<T extends UserRolesGroupByArgs> = Promise<
    Array<
      PickArray<UserRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRolesGroupByOutputType[P]>
            : GetScalarType<T[P], UserRolesGroupByOutputType[P]>
        }
      >
    >


  export type UserRolesSelect = {
    Id?: boolean
    Name?: boolean
    Description?: boolean
    UIEnabled?: boolean
  }

  export type UserRolesGetPayload<
    S extends boolean | null | undefined | UserRolesArgs,
    U = keyof S
      > = S extends true
        ? UserRoles
    : S extends undefined
    ? never
    : S extends UserRolesArgs | UserRolesFindManyArgs
    ?'include' extends U
    ? UserRoles 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserRoles ?UserRoles [P]
  : 
     never
  } 
    : UserRoles
  : UserRoles


  type UserRolesCountArgs = Merge<
    Omit<UserRolesFindManyArgs, 'select' | 'include'> & {
      select?: UserRolesCountAggregateInputType | true
    }
  >

  export interface UserRolesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserRoles that matches the filter.
     * @param {UserRolesFindUniqueArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserRolesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserRolesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserRoles'> extends True ? CheckSelect<T, Prisma__UserRolesClient<UserRoles>, Prisma__UserRolesClient<UserRolesGetPayload<T>>> : CheckSelect<T, Prisma__UserRolesClient<UserRoles | null >, Prisma__UserRolesClient<UserRolesGetPayload<T> | null >>

    /**
     * Find the first UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesFindFirstArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserRolesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserRolesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserRoles'> extends True ? CheckSelect<T, Prisma__UserRolesClient<UserRoles>, Prisma__UserRolesClient<UserRolesGetPayload<T>>> : CheckSelect<T, Prisma__UserRolesClient<UserRoles | null >, Prisma__UserRolesClient<UserRolesGetPayload<T> | null >>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRoles.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRoles.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userRolesWithIdOnly = await prisma.userRoles.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserRolesFindManyArgs>(
      args?: SelectSubset<T, UserRolesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserRoles>>, PrismaPromise<Array<UserRolesGetPayload<T>>>>

    /**
     * Create a UserRoles.
     * @param {UserRolesCreateArgs} args - Arguments to create a UserRoles.
     * @example
     * // Create one UserRoles
     * const UserRoles = await prisma.userRoles.create({
     *   data: {
     *     // ... data to create a UserRoles
     *   }
     * })
     * 
    **/
    create<T extends UserRolesCreateArgs>(
      args: SelectSubset<T, UserRolesCreateArgs>
    ): CheckSelect<T, Prisma__UserRolesClient<UserRoles>, Prisma__UserRolesClient<UserRolesGetPayload<T>>>

    /**
     * Create many UserRoles.
     *     @param {UserRolesCreateManyArgs} args - Arguments to create many UserRoles.
     *     @example
     *     // Create many UserRoles
     *     const userRoles = await prisma.userRoles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserRolesCreateManyArgs>(
      args?: SelectSubset<T, UserRolesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserRoles.
     * @param {UserRolesDeleteArgs} args - Arguments to delete one UserRoles.
     * @example
     * // Delete one UserRoles
     * const UserRoles = await prisma.userRoles.delete({
     *   where: {
     *     // ... filter to delete one UserRoles
     *   }
     * })
     * 
    **/
    delete<T extends UserRolesDeleteArgs>(
      args: SelectSubset<T, UserRolesDeleteArgs>
    ): CheckSelect<T, Prisma__UserRolesClient<UserRoles>, Prisma__UserRolesClient<UserRolesGetPayload<T>>>

    /**
     * Update one UserRoles.
     * @param {UserRolesUpdateArgs} args - Arguments to update one UserRoles.
     * @example
     * // Update one UserRoles
     * const userRoles = await prisma.userRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserRolesUpdateArgs>(
      args: SelectSubset<T, UserRolesUpdateArgs>
    ): CheckSelect<T, Prisma__UserRolesClient<UserRoles>, Prisma__UserRolesClient<UserRolesGetPayload<T>>>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRolesDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserRolesDeleteManyArgs>(
      args?: SelectSubset<T, UserRolesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRoles = await prisma.userRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserRolesUpdateManyArgs>(
      args: SelectSubset<T, UserRolesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRoles.
     * @param {UserRolesUpsertArgs} args - Arguments to update or create a UserRoles.
     * @example
     * // Update or create a UserRoles
     * const userRoles = await prisma.userRoles.upsert({
     *   create: {
     *     // ... data to create a UserRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRoles we want to update
     *   }
     * })
    **/
    upsert<T extends UserRolesUpsertArgs>(
      args: SelectSubset<T, UserRolesUpsertArgs>
    ): CheckSelect<T, Prisma__UserRolesClient<UserRoles>, Prisma__UserRolesClient<UserRolesGetPayload<T>>>

    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRoles.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRolesCountArgs>(
      args?: Subset<T, UserRolesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRolesAggregateArgs>(args: Subset<T, UserRolesAggregateArgs>): PrismaPromise<GetUserRolesAggregateType<T>>

    /**
     * Group by UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRolesGroupByArgs['orderBy'] }
        : { orderBy?: UserRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRolesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserRolesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserRoles findUnique
   */
  export type UserRolesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     * 
    **/
    select?: UserRolesSelect | null
    /**
     * Throw an Error if a UserRoles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserRoles to fetch.
     * 
    **/
    where: UserRolesWhereUniqueInput
  }


  /**
   * UserRoles findFirst
   */
  export type UserRolesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     * 
    **/
    select?: UserRolesSelect | null
    /**
     * Throw an Error if a UserRoles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserRoles to fetch.
     * 
    **/
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     * 
    **/
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     * 
    **/
    distinct?: Enumerable<UserRolesScalarFieldEnum>
  }


  /**
   * UserRoles findMany
   */
  export type UserRolesFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     * 
    **/
    select?: UserRolesSelect | null
    /**
     * Filter, which UserRoles to fetch.
     * 
    **/
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     * 
    **/
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserRolesScalarFieldEnum>
  }


  /**
   * UserRoles create
   */
  export type UserRolesCreateArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     * 
    **/
    select?: UserRolesSelect | null
    /**
     * The data needed to create a UserRoles.
     * 
    **/
    data: XOR<UserRolesCreateInput, UserRolesUncheckedCreateInput>
  }


  /**
   * UserRoles createMany
   */
  export type UserRolesCreateManyArgs = {
    data: Enumerable<UserRolesCreateManyInput>
  }


  /**
   * UserRoles update
   */
  export type UserRolesUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     * 
    **/
    select?: UserRolesSelect | null
    /**
     * The data needed to update a UserRoles.
     * 
    **/
    data: XOR<UserRolesUpdateInput, UserRolesUncheckedUpdateInput>
    /**
     * Choose, which UserRoles to update.
     * 
    **/
    where: UserRolesWhereUniqueInput
  }


  /**
   * UserRoles updateMany
   */
  export type UserRolesUpdateManyArgs = {
    data: XOR<UserRolesUpdateManyMutationInput, UserRolesUncheckedUpdateManyInput>
    where?: UserRolesWhereInput
  }


  /**
   * UserRoles upsert
   */
  export type UserRolesUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     * 
    **/
    select?: UserRolesSelect | null
    /**
     * The filter to search for the UserRoles to update in case it exists.
     * 
    **/
    where: UserRolesWhereUniqueInput
    /**
     * In case the UserRoles found by the `where` argument doesn't exist, create a new UserRoles with this data.
     * 
    **/
    create: XOR<UserRolesCreateInput, UserRolesUncheckedCreateInput>
    /**
     * In case the UserRoles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserRolesUpdateInput, UserRolesUncheckedUpdateInput>
  }


  /**
   * UserRoles delete
   */
  export type UserRolesDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     * 
    **/
    select?: UserRolesSelect | null
    /**
     * Filter which UserRoles to delete.
     * 
    **/
    where: UserRolesWhereUniqueInput
  }


  /**
   * UserRoles deleteMany
   */
  export type UserRolesDeleteManyArgs = {
    where?: UserRolesWhereInput
  }


  /**
   * UserRoles without action
   */
  export type UserRolesArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     * 
    **/
    select?: UserRolesSelect | null
  }



  /**
   * Model Users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    IsPasswordSet: number | null
    IsAdmin: number | null
    ShowHelpText: number | null
    IsReadOnly: number | null
    AccessFailedCount: number | null
  }

  export type UsersSumAggregateOutputType = {
    IsPasswordSet: number | null
    IsAdmin: number | null
    ShowHelpText: number | null
    IsReadOnly: number | null
    AccessFailedCount: number | null
  }

  export type UsersMinAggregateOutputType = {
    Id: string | null
    LDAPConnection_Id: string | null
    FirstName: string | null
    LastName: string | null
    UserRole_Id: string | null
    Status: string | null
    EmailId: string | null
    Password: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Description: string | null
    ProfileImage: string | null
    CreatedBy: string | null
    ModifiedBy: string | null
    RegistrationMode: string | null
    Timezone: string | null
    IsPasswordSet: number | null
    IsAdmin: number | null
    ShowHelpText: number | null
    IdentityProvider_Id: string | null
    SecPhrase: string | null
    IsReadOnly: number | null
    UserIdentityRole: string | null
    UserName: string | null
    NormalizedUserName: string | null
    Email: string | null
    NormalizedEmail: string | null
    EmailConfirmed: boolean | null
    SecurityStamp: string | null
    ConcurrencyStamp: string | null
    PhoneNumber: string | null
    PhoneNumberConfirmed: boolean | null
    PasswordHash: string | null
    TwoFactorEnabled: boolean | null
    LockoutEnd: Date | null
    LockoutEnabled: boolean | null
    AccessFailedCount: number | null
  }

  export type UsersMaxAggregateOutputType = {
    Id: string | null
    LDAPConnection_Id: string | null
    FirstName: string | null
    LastName: string | null
    UserRole_Id: string | null
    Status: string | null
    EmailId: string | null
    Password: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Description: string | null
    ProfileImage: string | null
    CreatedBy: string | null
    ModifiedBy: string | null
    RegistrationMode: string | null
    Timezone: string | null
    IsPasswordSet: number | null
    IsAdmin: number | null
    ShowHelpText: number | null
    IdentityProvider_Id: string | null
    SecPhrase: string | null
    IsReadOnly: number | null
    UserIdentityRole: string | null
    UserName: string | null
    NormalizedUserName: string | null
    Email: string | null
    NormalizedEmail: string | null
    EmailConfirmed: boolean | null
    SecurityStamp: string | null
    ConcurrencyStamp: string | null
    PhoneNumber: string | null
    PhoneNumberConfirmed: boolean | null
    PasswordHash: string | null
    TwoFactorEnabled: boolean | null
    LockoutEnd: Date | null
    LockoutEnabled: boolean | null
    AccessFailedCount: number | null
  }

  export type UsersCountAggregateOutputType = {
    Id: number
    LDAPConnection_Id: number
    FirstName: number
    LastName: number
    UserRole_Id: number
    Status: number
    EmailId: number
    Password: number
    CreatedDate: number
    ModifiedDate: number
    Description: number
    ProfileImage: number
    CreatedBy: number
    ModifiedBy: number
    RegistrationMode: number
    Timezone: number
    IsPasswordSet: number
    IsAdmin: number
    ShowHelpText: number
    IdentityProvider_Id: number
    SecPhrase: number
    IsReadOnly: number
    UserIdentityRole: number
    UserName: number
    NormalizedUserName: number
    Email: number
    NormalizedEmail: number
    EmailConfirmed: number
    SecurityStamp: number
    ConcurrencyStamp: number
    PhoneNumber: number
    PhoneNumberConfirmed: number
    PasswordHash: number
    TwoFactorEnabled: number
    LockoutEnd: number
    LockoutEnabled: number
    AccessFailedCount: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    IsPasswordSet?: true
    IsAdmin?: true
    ShowHelpText?: true
    IsReadOnly?: true
    AccessFailedCount?: true
  }

  export type UsersSumAggregateInputType = {
    IsPasswordSet?: true
    IsAdmin?: true
    ShowHelpText?: true
    IsReadOnly?: true
    AccessFailedCount?: true
  }

  export type UsersMinAggregateInputType = {
    Id?: true
    LDAPConnection_Id?: true
    FirstName?: true
    LastName?: true
    UserRole_Id?: true
    Status?: true
    EmailId?: true
    Password?: true
    CreatedDate?: true
    ModifiedDate?: true
    Description?: true
    ProfileImage?: true
    CreatedBy?: true
    ModifiedBy?: true
    RegistrationMode?: true
    Timezone?: true
    IsPasswordSet?: true
    IsAdmin?: true
    ShowHelpText?: true
    IdentityProvider_Id?: true
    SecPhrase?: true
    IsReadOnly?: true
    UserIdentityRole?: true
    UserName?: true
    NormalizedUserName?: true
    Email?: true
    NormalizedEmail?: true
    EmailConfirmed?: true
    SecurityStamp?: true
    ConcurrencyStamp?: true
    PhoneNumber?: true
    PhoneNumberConfirmed?: true
    PasswordHash?: true
    TwoFactorEnabled?: true
    LockoutEnd?: true
    LockoutEnabled?: true
    AccessFailedCount?: true
  }

  export type UsersMaxAggregateInputType = {
    Id?: true
    LDAPConnection_Id?: true
    FirstName?: true
    LastName?: true
    UserRole_Id?: true
    Status?: true
    EmailId?: true
    Password?: true
    CreatedDate?: true
    ModifiedDate?: true
    Description?: true
    ProfileImage?: true
    CreatedBy?: true
    ModifiedBy?: true
    RegistrationMode?: true
    Timezone?: true
    IsPasswordSet?: true
    IsAdmin?: true
    ShowHelpText?: true
    IdentityProvider_Id?: true
    SecPhrase?: true
    IsReadOnly?: true
    UserIdentityRole?: true
    UserName?: true
    NormalizedUserName?: true
    Email?: true
    NormalizedEmail?: true
    EmailConfirmed?: true
    SecurityStamp?: true
    ConcurrencyStamp?: true
    PhoneNumber?: true
    PhoneNumberConfirmed?: true
    PasswordHash?: true
    TwoFactorEnabled?: true
    LockoutEnd?: true
    LockoutEnabled?: true
    AccessFailedCount?: true
  }

  export type UsersCountAggregateInputType = {
    Id?: true
    LDAPConnection_Id?: true
    FirstName?: true
    LastName?: true
    UserRole_Id?: true
    Status?: true
    EmailId?: true
    Password?: true
    CreatedDate?: true
    ModifiedDate?: true
    Description?: true
    ProfileImage?: true
    CreatedBy?: true
    ModifiedBy?: true
    RegistrationMode?: true
    Timezone?: true
    IsPasswordSet?: true
    IsAdmin?: true
    ShowHelpText?: true
    IdentityProvider_Id?: true
    SecPhrase?: true
    IsReadOnly?: true
    UserIdentityRole?: true
    UserName?: true
    NormalizedUserName?: true
    Email?: true
    NormalizedEmail?: true
    EmailConfirmed?: true
    SecurityStamp?: true
    ConcurrencyStamp?: true
    PhoneNumber?: true
    PhoneNumberConfirmed?: true
    PasswordHash?: true
    TwoFactorEnabled?: true
    LockoutEnd?: true
    LockoutEnabled?: true
    AccessFailedCount?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which Users to aggregate.
     * 
    **/
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs = {
    where?: UsersWhereInput
    orderBy?: Enumerable<UsersOrderByWithAggregationInput>
    by: Array<UsersScalarFieldEnum>
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    Id: string
    LDAPConnection_Id: string | null
    FirstName: string | null
    LastName: string | null
    UserRole_Id: string | null
    Status: string | null
    EmailId: string | null
    Password: string | null
    CreatedDate: Date | null
    ModifiedDate: Date | null
    Description: string | null
    ProfileImage: string | null
    CreatedBy: string | null
    ModifiedBy: string | null
    RegistrationMode: string | null
    Timezone: string | null
    IsPasswordSet: number | null
    IsAdmin: number | null
    ShowHelpText: number | null
    IdentityProvider_Id: string | null
    SecPhrase: string | null
    IsReadOnly: number
    UserIdentityRole: string | null
    UserName: string | null
    NormalizedUserName: string | null
    Email: string | null
    NormalizedEmail: string | null
    EmailConfirmed: boolean | null
    SecurityStamp: string | null
    ConcurrencyStamp: string | null
    PhoneNumber: string | null
    PhoneNumberConfirmed: boolean | null
    PasswordHash: string | null
    TwoFactorEnabled: boolean | null
    LockoutEnd: Date | null
    LockoutEnabled: boolean | null
    AccessFailedCount: number | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Promise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect = {
    Id?: boolean
    LDAPConnection_Id?: boolean
    FirstName?: boolean
    LastName?: boolean
    UserRole_Id?: boolean
    Status?: boolean
    EmailId?: boolean
    Password?: boolean
    CreatedDate?: boolean
    ModifiedDate?: boolean
    Description?: boolean
    ProfileImage?: boolean
    CreatedBy?: boolean
    ModifiedBy?: boolean
    RegistrationMode?: boolean
    Timezone?: boolean
    IsPasswordSet?: boolean
    IsAdmin?: boolean
    ShowHelpText?: boolean
    IdentityProvider_Id?: boolean
    SecPhrase?: boolean
    IsReadOnly?: boolean
    UserIdentityRole?: boolean
    UserName?: boolean
    NormalizedUserName?: boolean
    Email?: boolean
    NormalizedEmail?: boolean
    EmailConfirmed?: boolean
    SecurityStamp?: boolean
    ConcurrencyStamp?: boolean
    PhoneNumber?: boolean
    PhoneNumberConfirmed?: boolean
    PasswordHash?: boolean
    TwoFactorEnabled?: boolean
    LockoutEnd?: boolean
    LockoutEnabled?: boolean
    AccessFailedCount?: boolean
    UserIdentityClaims?: boolean | UserIdentityClaimsFindManyArgs
    UserIdentityLogins?: boolean | UserIdentityLoginsFindManyArgs
    UserIdentityRoles?: boolean | UserIdentityRolesFindManyArgs
    UserIdentityTokens?: boolean | UserIdentityTokensFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type UsersInclude = {
    UserIdentityClaims?: boolean | UserIdentityClaimsFindManyArgs
    UserIdentityLogins?: boolean | UserIdentityLoginsFindManyArgs
    UserIdentityRoles?: boolean | UserIdentityRolesFindManyArgs
    UserIdentityTokens?: boolean | UserIdentityTokensFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type UsersGetPayload<
    S extends boolean | null | undefined | UsersArgs,
    U = keyof S
      > = S extends true
        ? Users
    : S extends undefined
    ? never
    : S extends UsersArgs | UsersFindManyArgs
    ?'include' extends U
    ? Users  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'UserIdentityClaims'
        ? Array < UserIdentityClaimsGetPayload<S['include'][P]>>  :
        P extends 'UserIdentityLogins'
        ? Array < UserIdentityLoginsGetPayload<S['include'][P]>>  :
        P extends 'UserIdentityRoles'
        ? Array < UserIdentityRolesGetPayload<S['include'][P]>>  :
        P extends 'UserIdentityTokens'
        ? Array < UserIdentityTokensGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? UsersCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Users ?Users [P]
  : 
          P extends 'UserIdentityClaims'
        ? Array < UserIdentityClaimsGetPayload<S['select'][P]>>  :
        P extends 'UserIdentityLogins'
        ? Array < UserIdentityLoginsGetPayload<S['select'][P]>>  :
        P extends 'UserIdentityRoles'
        ? Array < UserIdentityRolesGetPayload<S['select'][P]>>  :
        P extends 'UserIdentityTokens'
        ? Array < UserIdentityTokensGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? UsersCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Users
  : Users


  type UsersCountArgs = Merge<
    Omit<UsersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }
  >

  export interface UsersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Users'> extends True ? CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>> : CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Users'> extends True ? CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>> : CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UsersFindManyArgs>(
      args?: SelectSubset<T, UsersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Users>>, PrismaPromise<Array<UsersGetPayload<T>>>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends UsersCreateArgs>(
      args: SelectSubset<T, UsersCreateArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UsersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsersCreateManyArgs>(
      args?: SelectSubset<T, UsersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends UsersDeleteArgs>(
      args: SelectSubset<T, UsersDeleteArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsersUpdateArgs>(
      args: SelectSubset<T, UsersUpdateArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsersDeleteManyArgs>(
      args?: SelectSubset<T, UsersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsersUpdateManyArgs>(
      args: SelectSubset<T, UsersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends UsersUpsertArgs>(
      args: SelectSubset<T, UsersUpsertArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    UserIdentityClaims<T extends UserIdentityClaimsFindManyArgs = {}>(args?: Subset<T, UserIdentityClaimsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserIdentityClaims>>, PrismaPromise<Array<UserIdentityClaimsGetPayload<T>>>>;

    UserIdentityLogins<T extends UserIdentityLoginsFindManyArgs = {}>(args?: Subset<T, UserIdentityLoginsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserIdentityLogins>>, PrismaPromise<Array<UserIdentityLoginsGetPayload<T>>>>;

    UserIdentityRoles<T extends UserIdentityRolesFindManyArgs = {}>(args?: Subset<T, UserIdentityRolesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserIdentityRoles>>, PrismaPromise<Array<UserIdentityRolesGetPayload<T>>>>;

    UserIdentityTokens<T extends UserIdentityTokensFindManyArgs = {}>(args?: Subset<T, UserIdentityTokensFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserIdentityTokens>>, PrismaPromise<Array<UserIdentityTokensGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * Throw an Error if a Users can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where: UsersWhereUniqueInput
  }


  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * Throw an Error if a Users can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * Users findMany
   */
  export type UsersFindManyArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * Users create
   */
  export type UsersCreateArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * The data needed to create a Users.
     * 
    **/
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }


  /**
   * Users createMany
   */
  export type UsersCreateManyArgs = {
    data: Enumerable<UsersCreateManyInput>
  }


  /**
   * Users update
   */
  export type UsersUpdateArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * The data needed to update a Users.
     * 
    **/
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     * 
    **/
    where: UsersWhereUniqueInput
  }


  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs = {
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    where?: UsersWhereInput
  }


  /**
   * Users upsert
   */
  export type UsersUpsertArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * The filter to search for the Users to update in case it exists.
     * 
    **/
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     * 
    **/
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }


  /**
   * Users delete
   */
  export type UsersDeleteArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
    /**
     * Filter which Users to delete.
     * 
    **/
    where: UsersWhereUniqueInput
  }


  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs = {
    where?: UsersWhereInput
  }


  /**
   * Users without action
   */
  export type UsersArgs = {
    /**
     * Select specific fields to fetch from the Users
     * 
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersInclude | null
  }



  /**
   * Model UserSessions
   */


  export type AggregateUserSessions = {
    _count: UserSessionsCountAggregateOutputType | null
    _avg: UserSessionsAvgAggregateOutputType | null
    _sum: UserSessionsSumAggregateOutputType | null
    _min: UserSessionsMinAggregateOutputType | null
    _max: UserSessionsMaxAggregateOutputType | null
  }

  export type UserSessionsAvgAggregateOutputType = {
    IsReservedUser: number | null
    IsActive: number | null
  }

  export type UserSessionsSumAggregateOutputType = {
    IsReservedUser: number | null
    IsActive: number | null
  }

  export type UserSessionsMinAggregateOutputType = {
    Id: string | null
    UserId: string | null
    IsReservedUser: number | null
    AccessMode: string | null
    IPAddress: string | null
    UserAgent: string | null
    IsActive: number | null
    LastRequest: Date | null
    Created: Date | null
    Modified: Date | null
    UserDisplayName: string | null
    UserType: string | null
  }

  export type UserSessionsMaxAggregateOutputType = {
    Id: string | null
    UserId: string | null
    IsReservedUser: number | null
    AccessMode: string | null
    IPAddress: string | null
    UserAgent: string | null
    IsActive: number | null
    LastRequest: Date | null
    Created: Date | null
    Modified: Date | null
    UserDisplayName: string | null
    UserType: string | null
  }

  export type UserSessionsCountAggregateOutputType = {
    Id: number
    UserId: number
    IsReservedUser: number
    AccessMode: number
    IPAddress: number
    UserAgent: number
    IsActive: number
    LastRequest: number
    Created: number
    Modified: number
    UserDisplayName: number
    UserType: number
    _all: number
  }


  export type UserSessionsAvgAggregateInputType = {
    IsReservedUser?: true
    IsActive?: true
  }

  export type UserSessionsSumAggregateInputType = {
    IsReservedUser?: true
    IsActive?: true
  }

  export type UserSessionsMinAggregateInputType = {
    Id?: true
    UserId?: true
    IsReservedUser?: true
    AccessMode?: true
    IPAddress?: true
    UserAgent?: true
    IsActive?: true
    LastRequest?: true
    Created?: true
    Modified?: true
    UserDisplayName?: true
    UserType?: true
  }

  export type UserSessionsMaxAggregateInputType = {
    Id?: true
    UserId?: true
    IsReservedUser?: true
    AccessMode?: true
    IPAddress?: true
    UserAgent?: true
    IsActive?: true
    LastRequest?: true
    Created?: true
    Modified?: true
    UserDisplayName?: true
    UserType?: true
  }

  export type UserSessionsCountAggregateInputType = {
    Id?: true
    UserId?: true
    IsReservedUser?: true
    AccessMode?: true
    IPAddress?: true
    UserAgent?: true
    IsActive?: true
    LastRequest?: true
    Created?: true
    Modified?: true
    UserDisplayName?: true
    UserType?: true
    _all?: true
  }

  export type UserSessionsAggregateArgs = {
    /**
     * Filter which UserSessions to aggregate.
     * 
    **/
    where?: UserSessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     * 
    **/
    orderBy?: Enumerable<UserSessionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserSessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionsMaxAggregateInputType
  }

  export type GetUserSessionsAggregateType<T extends UserSessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSessions[P]>
      : GetScalarType<T[P], AggregateUserSessions[P]>
  }




  export type UserSessionsGroupByArgs = {
    where?: UserSessionsWhereInput
    orderBy?: Enumerable<UserSessionsOrderByWithAggregationInput>
    by: Array<UserSessionsScalarFieldEnum>
    having?: UserSessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionsCountAggregateInputType | true
    _avg?: UserSessionsAvgAggregateInputType
    _sum?: UserSessionsSumAggregateInputType
    _min?: UserSessionsMinAggregateInputType
    _max?: UserSessionsMaxAggregateInputType
  }


  export type UserSessionsGroupByOutputType = {
    Id: string
    UserId: string
    IsReservedUser: number
    AccessMode: string
    IPAddress: string
    UserAgent: string
    IsActive: number
    LastRequest: Date
    Created: Date
    Modified: Date
    UserDisplayName: string | null
    UserType: string | null
    _count: UserSessionsCountAggregateOutputType | null
    _avg: UserSessionsAvgAggregateOutputType | null
    _sum: UserSessionsSumAggregateOutputType | null
    _min: UserSessionsMinAggregateOutputType | null
    _max: UserSessionsMaxAggregateOutputType | null
  }

  type GetUserSessionsGroupByPayload<T extends UserSessionsGroupByArgs> = Promise<
    Array<
      PickArray<UserSessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionsGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionsSelect = {
    Id?: boolean
    UserId?: boolean
    IsReservedUser?: boolean
    AccessMode?: boolean
    IPAddress?: boolean
    UserAgent?: boolean
    IsActive?: boolean
    LastRequest?: boolean
    Created?: boolean
    Modified?: boolean
    UserDisplayName?: boolean
    UserType?: boolean
  }

  export type UserSessionsGetPayload<
    S extends boolean | null | undefined | UserSessionsArgs,
    U = keyof S
      > = S extends true
        ? UserSessions
    : S extends undefined
    ? never
    : S extends UserSessionsArgs | UserSessionsFindManyArgs
    ?'include' extends U
    ? UserSessions 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserSessions ?UserSessions [P]
  : 
     never
  } 
    : UserSessions
  : UserSessions


  type UserSessionsCountArgs = Merge<
    Omit<UserSessionsFindManyArgs, 'select' | 'include'> & {
      select?: UserSessionsCountAggregateInputType | true
    }
  >

  export interface UserSessionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserSessions that matches the filter.
     * @param {UserSessionsFindUniqueArgs} args - Arguments to find a UserSessions
     * @example
     * // Get one UserSessions
     * const userSessions = await prisma.userSessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserSessionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserSessionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserSessions'> extends True ? CheckSelect<T, Prisma__UserSessionsClient<UserSessions>, Prisma__UserSessionsClient<UserSessionsGetPayload<T>>> : CheckSelect<T, Prisma__UserSessionsClient<UserSessions | null >, Prisma__UserSessionsClient<UserSessionsGetPayload<T> | null >>

    /**
     * Find the first UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionsFindFirstArgs} args - Arguments to find a UserSessions
     * @example
     * // Get one UserSessions
     * const userSessions = await prisma.userSessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserSessionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserSessionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserSessions'> extends True ? CheckSelect<T, Prisma__UserSessionsClient<UserSessions>, Prisma__UserSessionsClient<UserSessionsGetPayload<T>>> : CheckSelect<T, Prisma__UserSessionsClient<UserSessions | null >, Prisma__UserSessionsClient<UserSessionsGetPayload<T> | null >>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSessions.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSessions.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userSessionsWithIdOnly = await prisma.userSessions.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserSessionsFindManyArgs>(
      args?: SelectSubset<T, UserSessionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserSessions>>, PrismaPromise<Array<UserSessionsGetPayload<T>>>>

    /**
     * Create a UserSessions.
     * @param {UserSessionsCreateArgs} args - Arguments to create a UserSessions.
     * @example
     * // Create one UserSessions
     * const UserSessions = await prisma.userSessions.create({
     *   data: {
     *     // ... data to create a UserSessions
     *   }
     * })
     * 
    **/
    create<T extends UserSessionsCreateArgs>(
      args: SelectSubset<T, UserSessionsCreateArgs>
    ): CheckSelect<T, Prisma__UserSessionsClient<UserSessions>, Prisma__UserSessionsClient<UserSessionsGetPayload<T>>>

    /**
     * Create many UserSessions.
     *     @param {UserSessionsCreateManyArgs} args - Arguments to create many UserSessions.
     *     @example
     *     // Create many UserSessions
     *     const userSessions = await prisma.userSessions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserSessionsCreateManyArgs>(
      args?: SelectSubset<T, UserSessionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserSessions.
     * @param {UserSessionsDeleteArgs} args - Arguments to delete one UserSessions.
     * @example
     * // Delete one UserSessions
     * const UserSessions = await prisma.userSessions.delete({
     *   where: {
     *     // ... filter to delete one UserSessions
     *   }
     * })
     * 
    **/
    delete<T extends UserSessionsDeleteArgs>(
      args: SelectSubset<T, UserSessionsDeleteArgs>
    ): CheckSelect<T, Prisma__UserSessionsClient<UserSessions>, Prisma__UserSessionsClient<UserSessionsGetPayload<T>>>

    /**
     * Update one UserSessions.
     * @param {UserSessionsUpdateArgs} args - Arguments to update one UserSessions.
     * @example
     * // Update one UserSessions
     * const userSessions = await prisma.userSessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserSessionsUpdateArgs>(
      args: SelectSubset<T, UserSessionsUpdateArgs>
    ): CheckSelect<T, Prisma__UserSessionsClient<UserSessions>, Prisma__UserSessionsClient<UserSessionsGetPayload<T>>>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionsDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserSessionsDeleteManyArgs>(
      args?: SelectSubset<T, UserSessionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSessions = await prisma.userSessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserSessionsUpdateManyArgs>(
      args: SelectSubset<T, UserSessionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSessions.
     * @param {UserSessionsUpsertArgs} args - Arguments to update or create a UserSessions.
     * @example
     * // Update or create a UserSessions
     * const userSessions = await prisma.userSessions.upsert({
     *   create: {
     *     // ... data to create a UserSessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSessions we want to update
     *   }
     * })
    **/
    upsert<T extends UserSessionsUpsertArgs>(
      args: SelectSubset<T, UserSessionsUpsertArgs>
    ): CheckSelect<T, Prisma__UserSessionsClient<UserSessions>, Prisma__UserSessionsClient<UserSessionsGetPayload<T>>>

    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionsCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSessions.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionsCountArgs>(
      args?: Subset<T, UserSessionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionsAggregateArgs>(args: Subset<T, UserSessionsAggregateArgs>): PrismaPromise<GetUserSessionsAggregateType<T>>

    /**
     * Group by UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionsGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserSessionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserSessions findUnique
   */
  export type UserSessionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserSessions
     * 
    **/
    select?: UserSessionsSelect | null
    /**
     * Throw an Error if a UserSessions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserSessions to fetch.
     * 
    **/
    where: UserSessionsWhereUniqueInput
  }


  /**
   * UserSessions findFirst
   */
  export type UserSessionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserSessions
     * 
    **/
    select?: UserSessionsSelect | null
    /**
     * Throw an Error if a UserSessions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserSessions to fetch.
     * 
    **/
    where?: UserSessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     * 
    **/
    orderBy?: Enumerable<UserSessionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     * 
    **/
    cursor?: UserSessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     * 
    **/
    distinct?: Enumerable<UserSessionsScalarFieldEnum>
  }


  /**
   * UserSessions findMany
   */
  export type UserSessionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserSessions
     * 
    **/
    select?: UserSessionsSelect | null
    /**
     * Filter, which UserSessions to fetch.
     * 
    **/
    where?: UserSessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     * 
    **/
    orderBy?: Enumerable<UserSessionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     * 
    **/
    cursor?: UserSessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserSessionsScalarFieldEnum>
  }


  /**
   * UserSessions create
   */
  export type UserSessionsCreateArgs = {
    /**
     * Select specific fields to fetch from the UserSessions
     * 
    **/
    select?: UserSessionsSelect | null
    /**
     * The data needed to create a UserSessions.
     * 
    **/
    data: XOR<UserSessionsCreateInput, UserSessionsUncheckedCreateInput>
  }


  /**
   * UserSessions createMany
   */
  export type UserSessionsCreateManyArgs = {
    data: Enumerable<UserSessionsCreateManyInput>
  }


  /**
   * UserSessions update
   */
  export type UserSessionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserSessions
     * 
    **/
    select?: UserSessionsSelect | null
    /**
     * The data needed to update a UserSessions.
     * 
    **/
    data: XOR<UserSessionsUpdateInput, UserSessionsUncheckedUpdateInput>
    /**
     * Choose, which UserSessions to update.
     * 
    **/
    where: UserSessionsWhereUniqueInput
  }


  /**
   * UserSessions updateMany
   */
  export type UserSessionsUpdateManyArgs = {
    data: XOR<UserSessionsUpdateManyMutationInput, UserSessionsUncheckedUpdateManyInput>
    where?: UserSessionsWhereInput
  }


  /**
   * UserSessions upsert
   */
  export type UserSessionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserSessions
     * 
    **/
    select?: UserSessionsSelect | null
    /**
     * The filter to search for the UserSessions to update in case it exists.
     * 
    **/
    where: UserSessionsWhereUniqueInput
    /**
     * In case the UserSessions found by the `where` argument doesn't exist, create a new UserSessions with this data.
     * 
    **/
    create: XOR<UserSessionsCreateInput, UserSessionsUncheckedCreateInput>
    /**
     * In case the UserSessions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserSessionsUpdateInput, UserSessionsUncheckedUpdateInput>
  }


  /**
   * UserSessions delete
   */
  export type UserSessionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserSessions
     * 
    **/
    select?: UserSessionsSelect | null
    /**
     * Filter which UserSessions to delete.
     * 
    **/
    where: UserSessionsWhereUniqueInput
  }


  /**
   * UserSessions deleteMany
   */
  export type UserSessionsDeleteManyArgs = {
    where?: UserSessionsWhereInput
  }


  /**
   * UserSessions without action
   */
  export type UserSessionsArgs = {
    /**
     * Select specific fields to fetch from the UserSessions
     * 
    **/
    select?: UserSessionsSelect | null
  }



  /**
   * Model UserSessionsArchive
   */


  export type AggregateUserSessionsArchive = {
    _count: UserSessionsArchiveCountAggregateOutputType | null
    _avg: UserSessionsArchiveAvgAggregateOutputType | null
    _sum: UserSessionsArchiveSumAggregateOutputType | null
    _min: UserSessionsArchiveMinAggregateOutputType | null
    _max: UserSessionsArchiveMaxAggregateOutputType | null
  }

  export type UserSessionsArchiveAvgAggregateOutputType = {
    IsReservedUser: number | null
    IsActive: number | null
  }

  export type UserSessionsArchiveSumAggregateOutputType = {
    IsReservedUser: number | null
    IsActive: number | null
  }

  export type UserSessionsArchiveMinAggregateOutputType = {
    Id: string | null
    UserId: string | null
    IsReservedUser: number | null
    AccessMode: string | null
    IPAddress: string | null
    UserAgent: string | null
    IsActive: number | null
    LastRequest: Date | null
    Created: Date | null
    Modified: Date | null
    UserDisplayName: string | null
    UserType: string | null
  }

  export type UserSessionsArchiveMaxAggregateOutputType = {
    Id: string | null
    UserId: string | null
    IsReservedUser: number | null
    AccessMode: string | null
    IPAddress: string | null
    UserAgent: string | null
    IsActive: number | null
    LastRequest: Date | null
    Created: Date | null
    Modified: Date | null
    UserDisplayName: string | null
    UserType: string | null
  }

  export type UserSessionsArchiveCountAggregateOutputType = {
    Id: number
    UserId: number
    IsReservedUser: number
    AccessMode: number
    IPAddress: number
    UserAgent: number
    IsActive: number
    LastRequest: number
    Created: number
    Modified: number
    UserDisplayName: number
    UserType: number
    _all: number
  }


  export type UserSessionsArchiveAvgAggregateInputType = {
    IsReservedUser?: true
    IsActive?: true
  }

  export type UserSessionsArchiveSumAggregateInputType = {
    IsReservedUser?: true
    IsActive?: true
  }

  export type UserSessionsArchiveMinAggregateInputType = {
    Id?: true
    UserId?: true
    IsReservedUser?: true
    AccessMode?: true
    IPAddress?: true
    UserAgent?: true
    IsActive?: true
    LastRequest?: true
    Created?: true
    Modified?: true
    UserDisplayName?: true
    UserType?: true
  }

  export type UserSessionsArchiveMaxAggregateInputType = {
    Id?: true
    UserId?: true
    IsReservedUser?: true
    AccessMode?: true
    IPAddress?: true
    UserAgent?: true
    IsActive?: true
    LastRequest?: true
    Created?: true
    Modified?: true
    UserDisplayName?: true
    UserType?: true
  }

  export type UserSessionsArchiveCountAggregateInputType = {
    Id?: true
    UserId?: true
    IsReservedUser?: true
    AccessMode?: true
    IPAddress?: true
    UserAgent?: true
    IsActive?: true
    LastRequest?: true
    Created?: true
    Modified?: true
    UserDisplayName?: true
    UserType?: true
    _all?: true
  }

  export type UserSessionsArchiveAggregateArgs = {
    /**
     * Filter which UserSessionsArchive to aggregate.
     * 
    **/
    where?: UserSessionsArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessionsArchives to fetch.
     * 
    **/
    orderBy?: Enumerable<UserSessionsArchiveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserSessionsArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessionsArchives from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessionsArchives.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessionsArchives
    **/
    _count?: true | UserSessionsArchiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSessionsArchiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSessionsArchiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionsArchiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionsArchiveMaxAggregateInputType
  }

  export type GetUserSessionsArchiveAggregateType<T extends UserSessionsArchiveAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSessionsArchive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSessionsArchive[P]>
      : GetScalarType<T[P], AggregateUserSessionsArchive[P]>
  }




  export type UserSessionsArchiveGroupByArgs = {
    where?: UserSessionsArchiveWhereInput
    orderBy?: Enumerable<UserSessionsArchiveOrderByWithAggregationInput>
    by: Array<UserSessionsArchiveScalarFieldEnum>
    having?: UserSessionsArchiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionsArchiveCountAggregateInputType | true
    _avg?: UserSessionsArchiveAvgAggregateInputType
    _sum?: UserSessionsArchiveSumAggregateInputType
    _min?: UserSessionsArchiveMinAggregateInputType
    _max?: UserSessionsArchiveMaxAggregateInputType
  }


  export type UserSessionsArchiveGroupByOutputType = {
    Id: string
    UserId: string
    IsReservedUser: number
    AccessMode: string
    IPAddress: string
    UserAgent: string
    IsActive: number
    LastRequest: Date
    Created: Date
    Modified: Date
    UserDisplayName: string | null
    UserType: string | null
    _count: UserSessionsArchiveCountAggregateOutputType | null
    _avg: UserSessionsArchiveAvgAggregateOutputType | null
    _sum: UserSessionsArchiveSumAggregateOutputType | null
    _min: UserSessionsArchiveMinAggregateOutputType | null
    _max: UserSessionsArchiveMaxAggregateOutputType | null
  }

  type GetUserSessionsArchiveGroupByPayload<T extends UserSessionsArchiveGroupByArgs> = Promise<
    Array<
      PickArray<UserSessionsArchiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionsArchiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionsArchiveGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionsArchiveGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionsArchiveSelect = {
    Id?: boolean
    UserId?: boolean
    IsReservedUser?: boolean
    AccessMode?: boolean
    IPAddress?: boolean
    UserAgent?: boolean
    IsActive?: boolean
    LastRequest?: boolean
    Created?: boolean
    Modified?: boolean
    UserDisplayName?: boolean
    UserType?: boolean
  }

  export type UserSessionsArchiveGetPayload<
    S extends boolean | null | undefined | UserSessionsArchiveArgs,
    U = keyof S
      > = S extends true
        ? UserSessionsArchive
    : S extends undefined
    ? never
    : S extends UserSessionsArchiveArgs | UserSessionsArchiveFindManyArgs
    ?'include' extends U
    ? UserSessionsArchive 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserSessionsArchive ?UserSessionsArchive [P]
  : 
     never
  } 
    : UserSessionsArchive
  : UserSessionsArchive


  type UserSessionsArchiveCountArgs = Merge<
    Omit<UserSessionsArchiveFindManyArgs, 'select' | 'include'> & {
      select?: UserSessionsArchiveCountAggregateInputType | true
    }
  >

  export interface UserSessionsArchiveDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserSessionsArchive that matches the filter.
     * @param {UserSessionsArchiveFindUniqueArgs} args - Arguments to find a UserSessionsArchive
     * @example
     * // Get one UserSessionsArchive
     * const userSessionsArchive = await prisma.userSessionsArchive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserSessionsArchiveFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserSessionsArchiveFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserSessionsArchive'> extends True ? CheckSelect<T, Prisma__UserSessionsArchiveClient<UserSessionsArchive>, Prisma__UserSessionsArchiveClient<UserSessionsArchiveGetPayload<T>>> : CheckSelect<T, Prisma__UserSessionsArchiveClient<UserSessionsArchive | null >, Prisma__UserSessionsArchiveClient<UserSessionsArchiveGetPayload<T> | null >>

    /**
     * Find the first UserSessionsArchive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionsArchiveFindFirstArgs} args - Arguments to find a UserSessionsArchive
     * @example
     * // Get one UserSessionsArchive
     * const userSessionsArchive = await prisma.userSessionsArchive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserSessionsArchiveFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserSessionsArchiveFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserSessionsArchive'> extends True ? CheckSelect<T, Prisma__UserSessionsArchiveClient<UserSessionsArchive>, Prisma__UserSessionsArchiveClient<UserSessionsArchiveGetPayload<T>>> : CheckSelect<T, Prisma__UserSessionsArchiveClient<UserSessionsArchive | null >, Prisma__UserSessionsArchiveClient<UserSessionsArchiveGetPayload<T> | null >>

    /**
     * Find zero or more UserSessionsArchives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionsArchiveFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessionsArchives
     * const userSessionsArchives = await prisma.userSessionsArchive.findMany()
     * 
     * // Get first 10 UserSessionsArchives
     * const userSessionsArchives = await prisma.userSessionsArchive.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userSessionsArchiveWithIdOnly = await prisma.userSessionsArchive.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserSessionsArchiveFindManyArgs>(
      args?: SelectSubset<T, UserSessionsArchiveFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserSessionsArchive>>, PrismaPromise<Array<UserSessionsArchiveGetPayload<T>>>>

    /**
     * Create a UserSessionsArchive.
     * @param {UserSessionsArchiveCreateArgs} args - Arguments to create a UserSessionsArchive.
     * @example
     * // Create one UserSessionsArchive
     * const UserSessionsArchive = await prisma.userSessionsArchive.create({
     *   data: {
     *     // ... data to create a UserSessionsArchive
     *   }
     * })
     * 
    **/
    create<T extends UserSessionsArchiveCreateArgs>(
      args: SelectSubset<T, UserSessionsArchiveCreateArgs>
    ): CheckSelect<T, Prisma__UserSessionsArchiveClient<UserSessionsArchive>, Prisma__UserSessionsArchiveClient<UserSessionsArchiveGetPayload<T>>>

    /**
     * Create many UserSessionsArchives.
     *     @param {UserSessionsArchiveCreateManyArgs} args - Arguments to create many UserSessionsArchives.
     *     @example
     *     // Create many UserSessionsArchives
     *     const userSessionsArchive = await prisma.userSessionsArchive.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserSessionsArchiveCreateManyArgs>(
      args?: SelectSubset<T, UserSessionsArchiveCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserSessionsArchive.
     * @param {UserSessionsArchiveDeleteArgs} args - Arguments to delete one UserSessionsArchive.
     * @example
     * // Delete one UserSessionsArchive
     * const UserSessionsArchive = await prisma.userSessionsArchive.delete({
     *   where: {
     *     // ... filter to delete one UserSessionsArchive
     *   }
     * })
     * 
    **/
    delete<T extends UserSessionsArchiveDeleteArgs>(
      args: SelectSubset<T, UserSessionsArchiveDeleteArgs>
    ): CheckSelect<T, Prisma__UserSessionsArchiveClient<UserSessionsArchive>, Prisma__UserSessionsArchiveClient<UserSessionsArchiveGetPayload<T>>>

    /**
     * Update one UserSessionsArchive.
     * @param {UserSessionsArchiveUpdateArgs} args - Arguments to update one UserSessionsArchive.
     * @example
     * // Update one UserSessionsArchive
     * const userSessionsArchive = await prisma.userSessionsArchive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserSessionsArchiveUpdateArgs>(
      args: SelectSubset<T, UserSessionsArchiveUpdateArgs>
    ): CheckSelect<T, Prisma__UserSessionsArchiveClient<UserSessionsArchive>, Prisma__UserSessionsArchiveClient<UserSessionsArchiveGetPayload<T>>>

    /**
     * Delete zero or more UserSessionsArchives.
     * @param {UserSessionsArchiveDeleteManyArgs} args - Arguments to filter UserSessionsArchives to delete.
     * @example
     * // Delete a few UserSessionsArchives
     * const { count } = await prisma.userSessionsArchive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserSessionsArchiveDeleteManyArgs>(
      args?: SelectSubset<T, UserSessionsArchiveDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessionsArchives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionsArchiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessionsArchives
     * const userSessionsArchive = await prisma.userSessionsArchive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserSessionsArchiveUpdateManyArgs>(
      args: SelectSubset<T, UserSessionsArchiveUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSessionsArchive.
     * @param {UserSessionsArchiveUpsertArgs} args - Arguments to update or create a UserSessionsArchive.
     * @example
     * // Update or create a UserSessionsArchive
     * const userSessionsArchive = await prisma.userSessionsArchive.upsert({
     *   create: {
     *     // ... data to create a UserSessionsArchive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSessionsArchive we want to update
     *   }
     * })
    **/
    upsert<T extends UserSessionsArchiveUpsertArgs>(
      args: SelectSubset<T, UserSessionsArchiveUpsertArgs>
    ): CheckSelect<T, Prisma__UserSessionsArchiveClient<UserSessionsArchive>, Prisma__UserSessionsArchiveClient<UserSessionsArchiveGetPayload<T>>>

    /**
     * Count the number of UserSessionsArchives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionsArchiveCountArgs} args - Arguments to filter UserSessionsArchives to count.
     * @example
     * // Count the number of UserSessionsArchives
     * const count = await prisma.userSessionsArchive.count({
     *   where: {
     *     // ... the filter for the UserSessionsArchives we want to count
     *   }
     * })
    **/
    count<T extends UserSessionsArchiveCountArgs>(
      args?: Subset<T, UserSessionsArchiveCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionsArchiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSessionsArchive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionsArchiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionsArchiveAggregateArgs>(args: Subset<T, UserSessionsArchiveAggregateArgs>): PrismaPromise<GetUserSessionsArchiveAggregateType<T>>

    /**
     * Group by UserSessionsArchive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionsArchiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionsArchiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionsArchiveGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionsArchiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionsArchiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionsArchiveGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSessionsArchive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserSessionsArchiveClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserSessionsArchive findUnique
   */
  export type UserSessionsArchiveFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserSessionsArchive
     * 
    **/
    select?: UserSessionsArchiveSelect | null
    /**
     * Throw an Error if a UserSessionsArchive can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserSessionsArchive to fetch.
     * 
    **/
    where: UserSessionsArchiveWhereUniqueInput
  }


  /**
   * UserSessionsArchive findFirst
   */
  export type UserSessionsArchiveFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserSessionsArchive
     * 
    **/
    select?: UserSessionsArchiveSelect | null
    /**
     * Throw an Error if a UserSessionsArchive can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserSessionsArchive to fetch.
     * 
    **/
    where?: UserSessionsArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessionsArchives to fetch.
     * 
    **/
    orderBy?: Enumerable<UserSessionsArchiveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessionsArchives.
     * 
    **/
    cursor?: UserSessionsArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessionsArchives from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessionsArchives.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessionsArchives.
     * 
    **/
    distinct?: Enumerable<UserSessionsArchiveScalarFieldEnum>
  }


  /**
   * UserSessionsArchive findMany
   */
  export type UserSessionsArchiveFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserSessionsArchive
     * 
    **/
    select?: UserSessionsArchiveSelect | null
    /**
     * Filter, which UserSessionsArchives to fetch.
     * 
    **/
    where?: UserSessionsArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessionsArchives to fetch.
     * 
    **/
    orderBy?: Enumerable<UserSessionsArchiveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessionsArchives.
     * 
    **/
    cursor?: UserSessionsArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessionsArchives from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessionsArchives.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserSessionsArchiveScalarFieldEnum>
  }


  /**
   * UserSessionsArchive create
   */
  export type UserSessionsArchiveCreateArgs = {
    /**
     * Select specific fields to fetch from the UserSessionsArchive
     * 
    **/
    select?: UserSessionsArchiveSelect | null
    /**
     * The data needed to create a UserSessionsArchive.
     * 
    **/
    data: XOR<UserSessionsArchiveCreateInput, UserSessionsArchiveUncheckedCreateInput>
  }


  /**
   * UserSessionsArchive createMany
   */
  export type UserSessionsArchiveCreateManyArgs = {
    data: Enumerable<UserSessionsArchiveCreateManyInput>
  }


  /**
   * UserSessionsArchive update
   */
  export type UserSessionsArchiveUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserSessionsArchive
     * 
    **/
    select?: UserSessionsArchiveSelect | null
    /**
     * The data needed to update a UserSessionsArchive.
     * 
    **/
    data: XOR<UserSessionsArchiveUpdateInput, UserSessionsArchiveUncheckedUpdateInput>
    /**
     * Choose, which UserSessionsArchive to update.
     * 
    **/
    where: UserSessionsArchiveWhereUniqueInput
  }


  /**
   * UserSessionsArchive updateMany
   */
  export type UserSessionsArchiveUpdateManyArgs = {
    data: XOR<UserSessionsArchiveUpdateManyMutationInput, UserSessionsArchiveUncheckedUpdateManyInput>
    where?: UserSessionsArchiveWhereInput
  }


  /**
   * UserSessionsArchive upsert
   */
  export type UserSessionsArchiveUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserSessionsArchive
     * 
    **/
    select?: UserSessionsArchiveSelect | null
    /**
     * The filter to search for the UserSessionsArchive to update in case it exists.
     * 
    **/
    where: UserSessionsArchiveWhereUniqueInput
    /**
     * In case the UserSessionsArchive found by the `where` argument doesn't exist, create a new UserSessionsArchive with this data.
     * 
    **/
    create: XOR<UserSessionsArchiveCreateInput, UserSessionsArchiveUncheckedCreateInput>
    /**
     * In case the UserSessionsArchive was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserSessionsArchiveUpdateInput, UserSessionsArchiveUncheckedUpdateInput>
  }


  /**
   * UserSessionsArchive delete
   */
  export type UserSessionsArchiveDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserSessionsArchive
     * 
    **/
    select?: UserSessionsArchiveSelect | null
    /**
     * Filter which UserSessionsArchive to delete.
     * 
    **/
    where: UserSessionsArchiveWhereUniqueInput
  }


  /**
   * UserSessionsArchive deleteMany
   */
  export type UserSessionsArchiveDeleteManyArgs = {
    where?: UserSessionsArchiveWhereInput
  }


  /**
   * UserSessionsArchive without action
   */
  export type UserSessionsArchiveArgs = {
    /**
     * Select specific fields to fetch from the UserSessionsArchive
     * 
    **/
    select?: UserSessionsArchiveSelect | null
  }



  /**
   * Model UserTokens
   */


  export type AggregateUserTokens = {
    _count: UserTokensCountAggregateOutputType | null
    _min: UserTokensMinAggregateOutputType | null
    _max: UserTokensMaxAggregateOutputType | null
  }

  export type UserTokensMinAggregateOutputType = {
    Id: string | null
    UserId: string | null
    RefreshToken: string | null
    CreatedDate: Date | null
  }

  export type UserTokensMaxAggregateOutputType = {
    Id: string | null
    UserId: string | null
    RefreshToken: string | null
    CreatedDate: Date | null
  }

  export type UserTokensCountAggregateOutputType = {
    Id: number
    UserId: number
    RefreshToken: number
    CreatedDate: number
    _all: number
  }


  export type UserTokensMinAggregateInputType = {
    Id?: true
    UserId?: true
    RefreshToken?: true
    CreatedDate?: true
  }

  export type UserTokensMaxAggregateInputType = {
    Id?: true
    UserId?: true
    RefreshToken?: true
    CreatedDate?: true
  }

  export type UserTokensCountAggregateInputType = {
    Id?: true
    UserId?: true
    RefreshToken?: true
    CreatedDate?: true
    _all?: true
  }

  export type UserTokensAggregateArgs = {
    /**
     * Filter which UserTokens to aggregate.
     * 
    **/
    where?: UserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<UserTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTokens
    **/
    _count?: true | UserTokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTokensMaxAggregateInputType
  }

  export type GetUserTokensAggregateType<T extends UserTokensAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTokens[P]>
      : GetScalarType<T[P], AggregateUserTokens[P]>
  }




  export type UserTokensGroupByArgs = {
    where?: UserTokensWhereInput
    orderBy?: Enumerable<UserTokensOrderByWithAggregationInput>
    by: Array<UserTokensScalarFieldEnum>
    having?: UserTokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTokensCountAggregateInputType | true
    _min?: UserTokensMinAggregateInputType
    _max?: UserTokensMaxAggregateInputType
  }


  export type UserTokensGroupByOutputType = {
    Id: string
    UserId: string | null
    RefreshToken: string | null
    CreatedDate: Date | null
    _count: UserTokensCountAggregateOutputType | null
    _min: UserTokensMinAggregateOutputType | null
    _max: UserTokensMaxAggregateOutputType | null
  }

  type GetUserTokensGroupByPayload<T extends UserTokensGroupByArgs> = Promise<
    Array<
      PickArray<UserTokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTokensGroupByOutputType[P]>
            : GetScalarType<T[P], UserTokensGroupByOutputType[P]>
        }
      >
    >


  export type UserTokensSelect = {
    Id?: boolean
    UserId?: boolean
    RefreshToken?: boolean
    CreatedDate?: boolean
  }

  export type UserTokensGetPayload<
    S extends boolean | null | undefined | UserTokensArgs,
    U = keyof S
      > = S extends true
        ? UserTokens
    : S extends undefined
    ? never
    : S extends UserTokensArgs | UserTokensFindManyArgs
    ?'include' extends U
    ? UserTokens 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserTokens ?UserTokens [P]
  : 
     never
  } 
    : UserTokens
  : UserTokens


  type UserTokensCountArgs = Merge<
    Omit<UserTokensFindManyArgs, 'select' | 'include'> & {
      select?: UserTokensCountAggregateInputType | true
    }
  >

  export interface UserTokensDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserTokens that matches the filter.
     * @param {UserTokensFindUniqueArgs} args - Arguments to find a UserTokens
     * @example
     * // Get one UserTokens
     * const userTokens = await prisma.userTokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserTokensFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserTokensFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserTokens'> extends True ? CheckSelect<T, Prisma__UserTokensClient<UserTokens>, Prisma__UserTokensClient<UserTokensGetPayload<T>>> : CheckSelect<T, Prisma__UserTokensClient<UserTokens | null >, Prisma__UserTokensClient<UserTokensGetPayload<T> | null >>

    /**
     * Find the first UserTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensFindFirstArgs} args - Arguments to find a UserTokens
     * @example
     * // Get one UserTokens
     * const userTokens = await prisma.userTokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserTokensFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserTokensFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserTokens'> extends True ? CheckSelect<T, Prisma__UserTokensClient<UserTokens>, Prisma__UserTokensClient<UserTokensGetPayload<T>>> : CheckSelect<T, Prisma__UserTokensClient<UserTokens | null >, Prisma__UserTokensClient<UserTokensGetPayload<T> | null >>

    /**
     * Find zero or more UserTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTokens
     * const userTokens = await prisma.userTokens.findMany()
     * 
     * // Get first 10 UserTokens
     * const userTokens = await prisma.userTokens.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userTokensWithIdOnly = await prisma.userTokens.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserTokensFindManyArgs>(
      args?: SelectSubset<T, UserTokensFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserTokens>>, PrismaPromise<Array<UserTokensGetPayload<T>>>>

    /**
     * Create a UserTokens.
     * @param {UserTokensCreateArgs} args - Arguments to create a UserTokens.
     * @example
     * // Create one UserTokens
     * const UserTokens = await prisma.userTokens.create({
     *   data: {
     *     // ... data to create a UserTokens
     *   }
     * })
     * 
    **/
    create<T extends UserTokensCreateArgs>(
      args: SelectSubset<T, UserTokensCreateArgs>
    ): CheckSelect<T, Prisma__UserTokensClient<UserTokens>, Prisma__UserTokensClient<UserTokensGetPayload<T>>>

    /**
     * Create many UserTokens.
     *     @param {UserTokensCreateManyArgs} args - Arguments to create many UserTokens.
     *     @example
     *     // Create many UserTokens
     *     const userTokens = await prisma.userTokens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserTokensCreateManyArgs>(
      args?: SelectSubset<T, UserTokensCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserTokens.
     * @param {UserTokensDeleteArgs} args - Arguments to delete one UserTokens.
     * @example
     * // Delete one UserTokens
     * const UserTokens = await prisma.userTokens.delete({
     *   where: {
     *     // ... filter to delete one UserTokens
     *   }
     * })
     * 
    **/
    delete<T extends UserTokensDeleteArgs>(
      args: SelectSubset<T, UserTokensDeleteArgs>
    ): CheckSelect<T, Prisma__UserTokensClient<UserTokens>, Prisma__UserTokensClient<UserTokensGetPayload<T>>>

    /**
     * Update one UserTokens.
     * @param {UserTokensUpdateArgs} args - Arguments to update one UserTokens.
     * @example
     * // Update one UserTokens
     * const userTokens = await prisma.userTokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserTokensUpdateArgs>(
      args: SelectSubset<T, UserTokensUpdateArgs>
    ): CheckSelect<T, Prisma__UserTokensClient<UserTokens>, Prisma__UserTokensClient<UserTokensGetPayload<T>>>

    /**
     * Delete zero or more UserTokens.
     * @param {UserTokensDeleteManyArgs} args - Arguments to filter UserTokens to delete.
     * @example
     * // Delete a few UserTokens
     * const { count } = await prisma.userTokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserTokensDeleteManyArgs>(
      args?: SelectSubset<T, UserTokensDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTokens
     * const userTokens = await prisma.userTokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserTokensUpdateManyArgs>(
      args: SelectSubset<T, UserTokensUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTokens.
     * @param {UserTokensUpsertArgs} args - Arguments to update or create a UserTokens.
     * @example
     * // Update or create a UserTokens
     * const userTokens = await prisma.userTokens.upsert({
     *   create: {
     *     // ... data to create a UserTokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTokens we want to update
     *   }
     * })
    **/
    upsert<T extends UserTokensUpsertArgs>(
      args: SelectSubset<T, UserTokensUpsertArgs>
    ): CheckSelect<T, Prisma__UserTokensClient<UserTokens>, Prisma__UserTokensClient<UserTokensGetPayload<T>>>

    /**
     * Count the number of UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensCountArgs} args - Arguments to filter UserTokens to count.
     * @example
     * // Count the number of UserTokens
     * const count = await prisma.userTokens.count({
     *   where: {
     *     // ... the filter for the UserTokens we want to count
     *   }
     * })
    **/
    count<T extends UserTokensCountArgs>(
      args?: Subset<T, UserTokensCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTokensAggregateArgs>(args: Subset<T, UserTokensAggregateArgs>): PrismaPromise<GetUserTokensAggregateType<T>>

    /**
     * Group by UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTokensGroupByArgs['orderBy'] }
        : { orderBy?: UserTokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTokensGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserTokensClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserTokens findUnique
   */
  export type UserTokensFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     * 
    **/
    select?: UserTokensSelect | null
    /**
     * Throw an Error if a UserTokens can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserTokens to fetch.
     * 
    **/
    where: UserTokensWhereUniqueInput
  }


  /**
   * UserTokens findFirst
   */
  export type UserTokensFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     * 
    **/
    select?: UserTokensSelect | null
    /**
     * Throw an Error if a UserTokens can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserTokens to fetch.
     * 
    **/
    where?: UserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<UserTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTokens.
     * 
    **/
    cursor?: UserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTokens.
     * 
    **/
    distinct?: Enumerable<UserTokensScalarFieldEnum>
  }


  /**
   * UserTokens findMany
   */
  export type UserTokensFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     * 
    **/
    select?: UserTokensSelect | null
    /**
     * Filter, which UserTokens to fetch.
     * 
    **/
    where?: UserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<UserTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTokens.
     * 
    **/
    cursor?: UserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserTokensScalarFieldEnum>
  }


  /**
   * UserTokens create
   */
  export type UserTokensCreateArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     * 
    **/
    select?: UserTokensSelect | null
    /**
     * The data needed to create a UserTokens.
     * 
    **/
    data: XOR<UserTokensCreateInput, UserTokensUncheckedCreateInput>
  }


  /**
   * UserTokens createMany
   */
  export type UserTokensCreateManyArgs = {
    data: Enumerable<UserTokensCreateManyInput>
  }


  /**
   * UserTokens update
   */
  export type UserTokensUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     * 
    **/
    select?: UserTokensSelect | null
    /**
     * The data needed to update a UserTokens.
     * 
    **/
    data: XOR<UserTokensUpdateInput, UserTokensUncheckedUpdateInput>
    /**
     * Choose, which UserTokens to update.
     * 
    **/
    where: UserTokensWhereUniqueInput
  }


  /**
   * UserTokens updateMany
   */
  export type UserTokensUpdateManyArgs = {
    data: XOR<UserTokensUpdateManyMutationInput, UserTokensUncheckedUpdateManyInput>
    where?: UserTokensWhereInput
  }


  /**
   * UserTokens upsert
   */
  export type UserTokensUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     * 
    **/
    select?: UserTokensSelect | null
    /**
     * The filter to search for the UserTokens to update in case it exists.
     * 
    **/
    where: UserTokensWhereUniqueInput
    /**
     * In case the UserTokens found by the `where` argument doesn't exist, create a new UserTokens with this data.
     * 
    **/
    create: XOR<UserTokensCreateInput, UserTokensUncheckedCreateInput>
    /**
     * In case the UserTokens was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserTokensUpdateInput, UserTokensUncheckedUpdateInput>
  }


  /**
   * UserTokens delete
   */
  export type UserTokensDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     * 
    **/
    select?: UserTokensSelect | null
    /**
     * Filter which UserTokens to delete.
     * 
    **/
    where: UserTokensWhereUniqueInput
  }


  /**
   * UserTokens deleteMany
   */
  export type UserTokensDeleteManyArgs = {
    where?: UserTokensWhereInput
  }


  /**
   * UserTokens without action
   */
  export type UserTokensArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     * 
    **/
    select?: UserTokensSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccessRightsScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    AccessRightKey: 'AccessRightKey',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate',
    Status: 'Status'
  };

  export type AccessRightsScalarFieldEnum = (typeof AccessRightsScalarFieldEnum)[keyof typeof AccessRightsScalarFieldEnum]


  export const AppIdentityRolesScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    NormalizedName: 'NormalizedName',
    ConcurrencyStamp: 'ConcurrencyStamp'
  };

  export type AppIdentityRolesScalarFieldEnum = (typeof AppIdentityRolesScalarFieldEnum)[keyof typeof AppIdentityRolesScalarFieldEnum]


  export const AppStreamConfigurationsScalarFieldEnum: {
    Id: 'Id',
    RegionEndPoint: 'RegionEndPoint',
    FleetName: 'FleetName',
    StackName: 'StackName',
    ApplicationID: 'ApplicationID',
    AuthenticationType: 'AuthenticationType',
    URLValidityTime: 'URLValidityTime',
    AWSConfigurationsId: 'AWSConfigurationsId',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type AppStreamConfigurationsScalarFieldEnum = (typeof AppStreamConfigurationsScalarFieldEnum)[keyof typeof AppStreamConfigurationsScalarFieldEnum]


  export const AppStreamUserConnectorsScalarFieldEnum: {
    Id: 'Id',
    AppStreamARN: 'AppStreamARN',
    AppStreamUserName: 'AppStreamUserName',
    AppStreamEmailId: 'AppStreamEmailId',
    AppStreamConfiguration_Id: 'AppStreamConfiguration_Id',
    User_Id: 'User_Id',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type AppStreamUserConnectorsScalarFieldEnum = (typeof AppStreamUserConnectorsScalarFieldEnum)[keyof typeof AppStreamUserConnectorsScalarFieldEnum]


  export const AuditEntitiesScalarFieldEnum: {
    Id: 'Id',
    Type: 'Type',
    ActionBy: 'ActionBy',
    Details: 'Details',
    CreatedDate: 'CreatedDate',
    UserAgent: 'UserAgent',
    IPAddress: 'IPAddress'
  };

  export type AuditEntitiesScalarFieldEnum = (typeof AuditEntitiesScalarFieldEnum)[keyof typeof AuditEntitiesScalarFieldEnum]


  export const AuditLogsScalarFieldEnum: {
    Id: 'Id',
    Resource: 'Resource',
    Resource_Id: 'Resource_Id',
    UserAction_Actionkey: 'UserAction_Actionkey',
    UserType: 'UserType',
    Repository_Id: 'Repository_Id',
    ActionBy: 'ActionBy',
    Details: 'Details',
    CreatedDate: 'CreatedDate',
    UserAgent: 'UserAgent',
    IPAddress: 'IPAddress'
  };

  export type AuditLogsScalarFieldEnum = (typeof AuditLogsScalarFieldEnum)[keyof typeof AuditLogsScalarFieldEnum]


  export const AWSConfigurationsScalarFieldEnum: {
    Id: 'Id',
    AccessKey: 'AccessKey',
    Secretkey: 'Secretkey',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type AWSConfigurationsScalarFieldEnum = (typeof AWSConfigurationsScalarFieldEnum)[keyof typeof AWSConfigurationsScalarFieldEnum]


  export const CreateElementNotificationsScalarFieldEnum: {
    Id: 'Id',
    Repository_Id: 'Repository_Id',
    EnableNotification: 'EnableNotification',
    User_Id: 'User_Id',
    UserGroup_Id: 'UserGroup_Id',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type CreateElementNotificationsScalarFieldEnum = (typeof CreateElementNotificationsScalarFieldEnum)[keyof typeof CreateElementNotificationsScalarFieldEnum]


  export const DashboardReviewUserRolesScalarFieldEnum: {
    Id: 'Id',
    DashboardId: 'DashboardId',
    UserRole: 'UserRole'
  };

  export type DashboardReviewUserRolesScalarFieldEnum = (typeof DashboardReviewUserRolesScalarFieldEnum)[keyof typeof DashboardReviewUserRolesScalarFieldEnum]


  export const DashboardsScalarFieldEnum: {
    Id: 'Id',
    RepositoryId: 'RepositoryId',
    Name: 'Name',
    Notes: 'Notes',
    Logo: 'Logo',
    IsEnabled: 'IsEnabled',
    CreatedBy: 'CreatedBy',
    Created: 'Created',
    Modified: 'Modified',
    IsDefault: 'IsDefault',
    DisplayDescription: 'DisplayDescription',
    Type: 'Type',
    UserType: 'UserType',
    DashboardSettings: 'DashboardSettings',
    Template: 'Template'
  };

  export type DashboardsScalarFieldEnum = (typeof DashboardsScalarFieldEnum)[keyof typeof DashboardsScalarFieldEnum]


  export const DashboardUserDefaultScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    RepositoryId: 'RepositoryId',
    DashboardId: 'DashboardId',
    Type: 'Type'
  };

  export type DashboardUserDefaultScalarFieldEnum = (typeof DashboardUserDefaultScalarFieldEnum)[keyof typeof DashboardUserDefaultScalarFieldEnum]


  export const DashboardUserGroupsScalarFieldEnum: {
    Id: 'Id',
    DashboardId: 'DashboardId',
    UserGroupId: 'UserGroupId'
  };

  export type DashboardUserGroupsScalarFieldEnum = (typeof DashboardUserGroupsScalarFieldEnum)[keyof typeof DashboardUserGroupsScalarFieldEnum]


  export const DashboardUsersScalarFieldEnum: {
    Id: 'Id',
    DashboardId: 'DashboardId',
    UserId: 'UserId'
  };

  export type DashboardUsersScalarFieldEnum = (typeof DashboardUsersScalarFieldEnum)[keyof typeof DashboardUsersScalarFieldEnum]


  export const DashboardWidgetBlocksScalarFieldEnum: {
    Id: 'Id',
    DashboardWidgetId: 'DashboardWidgetId',
    DashboardWidgetBlockTypeId: 'DashboardWidgetBlockTypeId',
    Title: 'Title',
    Notes: 'Notes',
    EAArtifactGuid: 'EAArtifactGuid',
    IsConfigured: 'IsConfigured',
    Position: 'Position'
  };

  export type DashboardWidgetBlocksScalarFieldEnum = (typeof DashboardWidgetBlocksScalarFieldEnum)[keyof typeof DashboardWidgetBlocksScalarFieldEnum]


  export const DashboardWidgetBlockTypesScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Notes: 'Notes',
    Category: 'Category',
    Position: 'Position',
    NotSetText: 'NotSetText',
    ConfigurationRequired: 'ConfigurationRequired',
    IsEnabled: 'IsEnabled',
    Icon: 'Icon'
  };

  export type DashboardWidgetBlockTypesScalarFieldEnum = (typeof DashboardWidgetBlockTypesScalarFieldEnum)[keyof typeof DashboardWidgetBlockTypesScalarFieldEnum]


  export const DashboardWidgetsScalarFieldEnum: {
    Id: 'Id',
    DashboardId: 'DashboardId',
    Name: 'Name',
    Notes: 'Notes',
    RowId: 'RowId',
    ColumnId: 'ColumnId',
    ConfigData: 'ConfigData',
    SizeX: 'SizeX',
    SizeY: 'SizeY',
    WidgetSettings: 'WidgetSettings',
    Template: 'Template',
    X: 'X',
    Y: 'Y',
    Rows: 'Rows',
    Cols: 'Cols'
  };

  export type DashboardWidgetsScalarFieldEnum = (typeof DashboardWidgetsScalarFieldEnum)[keyof typeof DashboardWidgetsScalarFieldEnum]


  export const DocumentationRequestsScalarFieldEnum: {
    Id: 'Id',
    Repository_Id: 'Repository_Id',
    User_Id: 'User_Id',
    UserDefinedTemplate: 'UserDefinedTemplate',
    InclusionList: 'InclusionList',
    ExclusionList: 'ExclusionList',
    FileName: 'FileName',
    IsCancelled: 'IsCancelled',
    IsProcessed: 'IsProcessed',
    Created: 'Created',
    Modified: 'Modified'
  };

  export type DocumentationRequestsScalarFieldEnum = (typeof DocumentationRequestsScalarFieldEnum)[keyof typeof DocumentationRequestsScalarFieldEnum]


  export const DomainRestrictionsScalarFieldEnum: {
    Id: 'Id',
    Domain: 'Domain',
    IsEnabled: 'IsEnabled',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type DomainRestrictionsScalarFieldEnum = (typeof DomainRestrictionsScalarFieldEnum)[keyof typeof DomainRestrictionsScalarFieldEnum]


  export const EAChangelogAttributesScalarFieldEnum: {
    Id: 'Id',
    EAChangelogId: 'EAChangelogId',
    PropertyGuid: 'PropertyGuid',
    Name: 'Name',
    CurrentValue: 'CurrentValue',
    PreviousValue: 'PreviousValue',
    ActionType: 'ActionType',
    AttributeType: 'AttributeType',
    CreatedDate: 'CreatedDate'
  };

  export type EAChangelogAttributesScalarFieldEnum = (typeof EAChangelogAttributesScalarFieldEnum)[keyof typeof EAChangelogAttributesScalarFieldEnum]


  export const EAChangelogsScalarFieldEnum: {
    Id: 'Id',
    Repository_Id: 'Repository_Id',
    ArtifactGuid: 'ArtifactGuid',
    ArtifactType: 'ArtifactType',
    ActionType: 'ActionType',
    Revision: 'Revision',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type EAChangelogsScalarFieldEnum = (typeof EAChangelogsScalarFieldEnum)[keyof typeof EAChangelogsScalarFieldEnum]


  export const ElementConnectorsScalarFieldEnum: {
    Id: 'Id',
    ElementGuid: 'ElementGuid',
    ElementType: 'ElementType',
    Repository_Id: 'Repository_Id',
    User_Id: 'User_Id',
    UserGroup_Id: 'UserGroup_Id',
    AccessRight_AccessRightKey: 'AccessRight_AccessRightKey',
    InheritRight: 'InheritRight',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate',
    Status: 'Status',
    CreatedBy: 'CreatedBy',
    FeatureId: 'FeatureId',
    OtherInfo: 'OtherInfo'
  };

  export type ElementConnectorsScalarFieldEnum = (typeof ElementConnectorsScalarFieldEnum)[keyof typeof ElementConnectorsScalarFieldEnum]


  export const ExternalAppAttributeMasterScalarFieldEnum: {
    Id: 'Id',
    ExternalAppTypeId: 'ExternalAppTypeId',
    ExternalAppId: 'ExternalAppId',
    RepositoryId: 'RepositoryId',
    Name: 'Name',
    InternalName: 'InternalName',
    ExternalName: 'ExternalName',
    HelpText: 'HelpText',
    MultiSelect: 'MultiSelect',
    Filters: 'Filters',
    ConfigData: 'ConfigData',
    IsEnabled: 'IsEnabled',
    Created: 'Created',
    Modified: 'Modified',
    Description: 'Description'
  };

  export type ExternalAppAttributeMasterScalarFieldEnum = (typeof ExternalAppAttributeMasterScalarFieldEnum)[keyof typeof ExternalAppAttributeMasterScalarFieldEnum]


  export const ExternalAppAttributesScalarFieldEnum: {
    Id: 'Id',
    ExternalAppAttributeMasterId: 'ExternalAppAttributeMasterId',
    ExternalAppProjectId: 'ExternalAppProjectId',
    ArtifactId: 'ArtifactId',
    InternalValue: 'InternalValue',
    ExternalValue: 'ExternalValue',
    ConfigData: 'ConfigData',
    IsDeleted: 'IsDeleted',
    RemoteLinkId: 'RemoteLinkId',
    Created: 'Created',
    Modified: 'Modified'
  };

  export type ExternalAppAttributesScalarFieldEnum = (typeof ExternalAppAttributesScalarFieldEnum)[keyof typeof ExternalAppAttributesScalarFieldEnum]


  export const ExternalAppsScalarFieldEnum: {
    Id: 'Id',
    ExternalAppTypeId: 'ExternalAppTypeId',
    ExternalAppEnvironment: 'ExternalAppEnvironment',
    RepositoryId: 'RepositoryId',
    Name: 'Name',
    Description: 'Description',
    EndPointURL: 'EndPointURL',
    IsExternal: 'IsExternal',
    ExternalPath: 'ExternalPath',
    Username: 'Username',
    Password: 'Password',
    ProjectId: 'ProjectId',
    ProjectName: 'ProjectName',
    ConfigData: 'ConfigData',
    IsEnabled: 'IsEnabled',
    Created: 'Created',
    Modified: 'Modified'
  };

  export type ExternalAppsScalarFieldEnum = (typeof ExternalAppsScalarFieldEnum)[keyof typeof ExternalAppsScalarFieldEnum]


  export const ExternalAppTypesScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Description: 'Description',
    IsExternal: 'IsExternal',
    ExternalPath: 'ExternalPath',
    Logo: 'Logo',
    Position: 'Position',
    IsEnabled: 'IsEnabled',
    AppContent: 'AppContent'
  };

  export type ExternalAppTypesScalarFieldEnum = (typeof ExternalAppTypesScalarFieldEnum)[keyof typeof ExternalAppTypesScalarFieldEnum]


  export const FeaturesScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Status: 'Status',
    CreatedDate: 'CreatedDate',
    FeatureKey: 'FeatureKey'
  };

  export type FeaturesScalarFieldEnum = (typeof FeaturesScalarFieldEnum)[keyof typeof FeaturesScalarFieldEnum]


  export const FilterProfileConnectorsScalarFieldEnum: {
    Id: 'Id',
    RepositoryId: 'RepositoryId',
    ProfileId: 'ProfileId',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate',
    CreatedBy: 'CreatedBy',
    ModifiedBy: 'ModifiedBy'
  };

  export type FilterProfileConnectorsScalarFieldEnum = (typeof FilterProfileConnectorsScalarFieldEnum)[keyof typeof FilterProfileConnectorsScalarFieldEnum]


  export const FilterProfilesScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Type: 'Type',
    Status: 'Status',
    Configuration: 'Configuration',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate',
    CreatedBy: 'CreatedBy',
    ModifiedBy: 'ModifiedBy',
    IsCacheEnabled: 'IsCacheEnabled'
  };

  export type FilterProfilesScalarFieldEnum = (typeof FilterProfilesScalarFieldEnum)[keyof typeof FilterProfilesScalarFieldEnum]


  export const GlobalRepositoryConfigurationsScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    IsReadOnly: 'IsReadOnly',
    RepositoryConfiguration: 'RepositoryConfiguration',
    AllowAllRepository: 'AllowAllRepository',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type GlobalRepositoryConfigurationsScalarFieldEnum = (typeof GlobalRepositoryConfigurationsScalarFieldEnum)[keyof typeof GlobalRepositoryConfigurationsScalarFieldEnum]


  export const GroupFeaturesScalarFieldEnum: {
    Id: 'Id',
    UserGroup_Id: 'UserGroup_Id',
    Feature_Id: 'Feature_Id',
    CreatedDate: 'CreatedDate',
    Status: 'Status'
  };

  export type GroupFeaturesScalarFieldEnum = (typeof GroupFeaturesScalarFieldEnum)[keyof typeof GroupFeaturesScalarFieldEnum]


  export const GuestSignupSettingsScalarFieldEnum: {
    Id: 'Id',
    GlobalRepoConfigId: 'GlobalRepoConfigId',
    AllowAllRepository: 'AllowAllRepository',
    RepositoryPermissions: 'RepositoryPermissions',
    Status: 'Status',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type GuestSignupSettingsScalarFieldEnum = (typeof GuestSignupSettingsScalarFieldEnum)[keyof typeof GuestSignupSettingsScalarFieldEnum]


  export const IdPConnectionsScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    SigninUrl: 'SigninUrl',
    CertificatePath: 'CertificatePath',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate',
    Status: 'Status',
    AllowAllRepository: 'AllowAllRepository',
    RepositoryPermissions: 'RepositoryPermissions',
    RepositoryPermissionId: 'RepositoryPermissionId',
    IdPSource: 'IdPSource',
    LogoutUrl: 'LogoutUrl',
    IDPCertificateEncrypted: 'IDPCertificateEncrypted',
    SPCertificateEncrypted: 'SPCertificateEncrypted',
    SPCertificatePath: 'SPCertificatePath',
    SPCertificatePassword: 'SPCertificatePassword',
    GlobalRepoConfigId: 'GlobalRepoConfigId',
    AttributesMapping: 'AttributesMapping'
  };

  export type IdPConnectionsScalarFieldEnum = (typeof IdPConnectionsScalarFieldEnum)[keyof typeof IdPConnectionsScalarFieldEnum]


  export const LDAPConnectionsScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Server: 'Server',
    Port: 'Port',
    Domain: 'Domain',
    UserName: 'UserName',
    Password: 'Password',
    SSL: 'SSL',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate',
    Status: 'Status'
  };

  export type LDAPConnectionsScalarFieldEnum = (typeof LDAPConnectionsScalarFieldEnum)[keyof typeof LDAPConnectionsScalarFieldEnum]


  export const MDGProfileConnectorsScalarFieldEnum: {
    Id: 'Id',
    UserGroupId: 'UserGroupId',
    ProfileId: 'ProfileId',
    MdgId: 'MdgId',
    RepositoryId: 'RepositoryId',
    Status: 'Status',
    CreatedDate: 'CreatedDate'
  };

  export type MDGProfileConnectorsScalarFieldEnum = (typeof MDGProfileConnectorsScalarFieldEnum)[keyof typeof MDGProfileConnectorsScalarFieldEnum]


  export const MDGTechnologiesScalarFieldEnum: {
    Id: 'Id',
    Repository_Id: 'Repository_Id',
    Name: 'Name',
    InternalName: 'InternalName',
    Description: 'Description',
    XmlContent: 'XmlContent',
    BuiltIn: 'BuiltIn',
    IsEnabled: 'IsEnabled',
    Created: 'Created',
    Modified: 'Modified'
  };

  export type MDGTechnologiesScalarFieldEnum = (typeof MDGTechnologiesScalarFieldEnum)[keyof typeof MDGTechnologiesScalarFieldEnum]


  export const MenuItemProfileConnectorsScalarFieldEnum: {
    Id: 'Id',
    Repository_Id: 'Repository_Id',
    User_Id: 'User_Id',
    UserGroup_Id: 'UserGroup_Id',
    Profile_Id: 'Profile_Id',
    Default_Profile_Id: 'Default_Profile_Id',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type MenuItemProfileConnectorsScalarFieldEnum = (typeof MenuItemProfileConnectorsScalarFieldEnum)[keyof typeof MenuItemProfileConnectorsScalarFieldEnum]


  export const MenuItemProfilesScalarFieldEnum: {
    Id: 'Id',
    Repository_Id: 'Repository_Id',
    Name: 'Name',
    Type: 'Type',
    Status: 'Status',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type MenuItemProfilesScalarFieldEnum = (typeof MenuItemProfilesScalarFieldEnum)[keyof typeof MenuItemProfilesScalarFieldEnum]


  export const MenuItemProfileSettingsScalarFieldEnum: {
    Id: 'Id',
    Profile_Id: 'Profile_Id',
    MenuItemKey: 'MenuItemKey',
    IsVisible: 'IsVisible',
    IfShowOnlyContent: 'IfShowOnlyContent',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type MenuItemProfileSettingsScalarFieldEnum = (typeof MenuItemProfileSettingsScalarFieldEnum)[keyof typeof MenuItemProfileSettingsScalarFieldEnum]


  export const MenuViewHistoryScalarFieldEnum: {
    Id: 'Id',
    RepositoryId: 'RepositoryId',
    UserId: 'UserId',
    PageKeys: 'PageKeys',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type MenuViewHistoryScalarFieldEnum = (typeof MenuViewHistoryScalarFieldEnum)[keyof typeof MenuViewHistoryScalarFieldEnum]


  export const OIDCApplicationsScalarFieldEnum: {
    Id: 'Id',
    ClientId: 'ClientId',
    ClientSecret: 'ClientSecret',
    ConcurrencyToken: 'ConcurrencyToken',
    ConsentType: 'ConsentType',
    DisplayName: 'DisplayName',
    DisplayNames: 'DisplayNames',
    Permissions: 'Permissions',
    PostLogoutRedirectUris: 'PostLogoutRedirectUris',
    Properties: 'Properties',
    RedirectUris: 'RedirectUris',
    Requirements: 'Requirements',
    Type: 'Type'
  };

  export type OIDCApplicationsScalarFieldEnum = (typeof OIDCApplicationsScalarFieldEnum)[keyof typeof OIDCApplicationsScalarFieldEnum]


  export const OIDCAuthorizationsScalarFieldEnum: {
    Id: 'Id',
    ApplicationId: 'ApplicationId',
    ConcurrencyToken: 'ConcurrencyToken',
    CreationDate: 'CreationDate',
    Properties: 'Properties',
    Scopes: 'Scopes',
    Status: 'Status',
    Subject: 'Subject',
    Type: 'Type'
  };

  export type OIDCAuthorizationsScalarFieldEnum = (typeof OIDCAuthorizationsScalarFieldEnum)[keyof typeof OIDCAuthorizationsScalarFieldEnum]


  export const OIDCScopesScalarFieldEnum: {
    Id: 'Id',
    ConcurrencyToken: 'ConcurrencyToken',
    Description: 'Description',
    Descriptions: 'Descriptions',
    DisplayName: 'DisplayName',
    DisplayNames: 'DisplayNames',
    Name: 'Name',
    Properties: 'Properties',
    Resources: 'Resources'
  };

  export type OIDCScopesScalarFieldEnum = (typeof OIDCScopesScalarFieldEnum)[keyof typeof OIDCScopesScalarFieldEnum]


  export const OIDCTokensScalarFieldEnum: {
    Id: 'Id',
    ApplicationId: 'ApplicationId',
    AuthorizationId: 'AuthorizationId',
    ConcurrencyToken: 'ConcurrencyToken',
    CreationDate: 'CreationDate',
    ExpirationDate: 'ExpirationDate',
    Payload: 'Payload',
    Properties: 'Properties',
    RedemptionDate: 'RedemptionDate',
    ReferenceId: 'ReferenceId',
    Status: 'Status',
    Subject: 'Subject',
    Type: 'Type'
  };

  export type OIDCTokensScalarFieldEnum = (typeof OIDCTokensScalarFieldEnum)[keyof typeof OIDCTokensScalarFieldEnum]


  export const ProfilesScalarFieldEnum: {
    Id: 'Id',
    MDGTechnology_Id: 'MDGTechnology_Id',
    Name: 'Name',
    Description: 'Description',
    ProfileContent: 'ProfileContent',
    IsDefault: 'IsDefault',
    IsEnabled: 'IsEnabled',
    Created: 'Created',
    Modified: 'Modified',
    EnableTechnologyGroup: 'EnableTechnologyGroup',
    EnableInheritedGroup: 'EnableInheritedGroup',
    IncludeBaseAttributes: 'IncludeBaseAttributes'
  };

  export type ProfilesScalarFieldEnum = (typeof ProfilesScalarFieldEnum)[keyof typeof ProfilesScalarFieldEnum]


  export const PropertyMenuItemConnectorsScalarFieldEnum: {
    Id: 'Id',
    MenuItemKey: 'MenuItemKey',
    PageType: 'PageType',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type PropertyMenuItemConnectorsScalarFieldEnum = (typeof PropertyMenuItemConnectorsScalarFieldEnum)[keyof typeof PropertyMenuItemConnectorsScalarFieldEnum]


  export const PropertyMenuItemsScalarFieldEnum: {
    Id: 'Id',
    MenuItemKey: 'MenuItemKey',
    Name: 'Name',
    Description: 'Description',
    IconClass: 'IconClass',
    Position: 'Position',
    Status: 'Status',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type PropertyMenuItemsScalarFieldEnum = (typeof PropertyMenuItemsScalarFieldEnum)[keyof typeof PropertyMenuItemsScalarFieldEnum]


  export const RepositoriesScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Alias: 'Alias',
    Description: 'Description',
    EAPFile: 'EAPFile',
    IsCacheEnabled: 'IsCacheEnabled',
    AuthRequired: 'AuthRequired',
    UserName: 'UserName',
    Password: 'Password',
    IsEnabled: 'IsEnabled',
    InstanceCount: 'InstanceCount',
    Created: 'Created',
    Modified: 'Modified',
    Status: 'Status',
    Protocol: 'Protocol',
    Server: 'Server',
    Port: 'Port',
    Model: 'Model',
    OslcAccessCode: 'OslcAccessCode',
    EAUserAuth: 'EAUserAuth',
    UserIdentifier: 'UserIdentifier',
    DBType: 'DBType'
  };

  export type RepositoriesScalarFieldEnum = (typeof RepositoriesScalarFieldEnum)[keyof typeof RepositoriesScalarFieldEnum]


  export const RepositoryConnectorsScalarFieldEnum: {
    Id: 'Id',
    Repository_Id: 'Repository_Id',
    User_Id: 'User_Id',
    UserGroup_Id: 'UserGroup_Id',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate',
    Status: 'Status',
    Dashboard_Id: 'Dashboard_Id',
    EAUserAuth: 'EAUserAuth',
    IsUserDefault: 'IsUserDefault'
  };

  export type RepositoryConnectorsScalarFieldEnum = (typeof RepositoryConnectorsScalarFieldEnum)[keyof typeof RepositoryConnectorsScalarFieldEnum]


  export const RepositoryDBConnectionsScalarFieldEnum: {
    Id: 'Id',
    Repository_Id: 'Repository_Id',
    CreateElement: 'CreateElement',
    ConnectionType: 'ConnectionType',
    ConnectionDetail: 'ConnectionDetail',
    DBType: 'DBType',
    Server: 'Server',
    Port: 'Port',
    DBName: 'DBName',
    Username: 'Username',
    Password: 'Password',
    DsnName: 'DsnName',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type RepositoryDBConnectionsScalarFieldEnum = (typeof RepositoryDBConnectionsScalarFieldEnum)[keyof typeof RepositoryDBConnectionsScalarFieldEnum]


  export const RequestLogsScalarFieldEnum: {
    Id: 'Id',
    RequestedUserId: 'RequestedUserId',
    DesignatedUserId: 'DesignatedUserId',
    Url: 'Url',
    UrlType: 'UrlType',
    RequestedUserAgent: 'RequestedUserAgent',
    RequestedUserIpAddress: 'RequestedUserIpAddress',
    DesignatedUserAgent: 'DesignatedUserAgent',
    DesignatedUserIpAddress: 'DesignatedUserIpAddress',
    Created: 'Created',
    Modified: 'Modified',
    LastVisited: 'LastVisited',
    Status: 'Status',
    Validity: 'Validity'
  };

  export type RequestLogsScalarFieldEnum = (typeof RequestLogsScalarFieldEnum)[keyof typeof RequestLogsScalarFieldEnum]


  export const ReservedUsersScalarFieldEnum: {
    Id: 'Id',
    User_Id: 'User_Id',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type ReservedUsersScalarFieldEnum = (typeof ReservedUsersScalarFieldEnum)[keyof typeof ReservedUsersScalarFieldEnum]


  export const ResourceFilesScalarFieldEnum: {
    Id: 'Id',
    MapItemId: 'MapItemId',
    FileContent: 'FileContent',
    FilePath: 'FilePath',
    Extension: 'Extension',
    Name: 'Name',
    ModifiedDate: 'ModifiedDate',
    CreatedDate: 'CreatedDate'
  };

  export type ResourceFilesScalarFieldEnum = (typeof ResourceFilesScalarFieldEnum)[keyof typeof ResourceFilesScalarFieldEnum]


  export const ResourcesScalarFieldEnum: {
    Id: 'Id',
    ResourceName: 'ResourceName'
  };

  export type ResourcesScalarFieldEnum = (typeof ResourcesScalarFieldEnum)[keyof typeof ResourcesScalarFieldEnum]


  export const ReviewProcessesScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Notes: 'Notes',
    ReviewStartDate: 'ReviewStartDate',
    ReviewEndDate: 'ReviewEndDate',
    ApproveStartDate: 'ApproveStartDate',
    ApproveEndDate: 'ApproveEndDate',
    WorkFlow: 'WorkFlow',
    AutoStatusUpdate: 'AutoStatusUpdate',
    ReviewStartType: 'ReviewStartType',
    ElementRecursiveSelection: 'ElementRecursiveSelection',
    ExternalUsersInvite: 'ExternalUsersInvite',
    EnableShare: 'EnableShare',
    EmailNotification: 'EmailNotification',
    Mode: 'Mode',
    Repository_Id: 'Repository_Id',
    User_Id: 'User_Id',
    Status: 'Status',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type ReviewProcessesScalarFieldEnum = (typeof ReviewProcessesScalarFieldEnum)[keyof typeof ReviewProcessesScalarFieldEnum]


  export const TaggedValuesScalarFieldEnum: {
    Id: 'Id',
    RepositoryId: 'RepositoryId',
    Name: 'Name',
    Description: 'Description',
    Type: 'Type',
    DefaultValue: 'DefaultValue',
    AttributeValues: 'AttributeValues',
    LowerBound: 'LowerBound',
    UpperBound: 'UpperBound',
    Stereotypes: 'Stereotypes',
    AppliesTo: 'AppliesTo',
    BaseStereotype: 'BaseStereotype'
  };

  export type TaggedValuesScalarFieldEnum = (typeof TaggedValuesScalarFieldEnum)[keyof typeof TaggedValuesScalarFieldEnum]


  export const TraceabilityTreeProfilesScalarFieldEnum: {
    Id: 'Id',
    ProfileName: 'ProfileName',
    RepositoryId: 'RepositoryId',
    ElementGuid: 'ElementGuid',
    Type: 'Type',
    SteroType: 'SteroType',
    FQName: 'FQName',
    Technology: 'Technology',
    TemplateOptions: 'TemplateOptions',
    User_Id: 'User_Id',
    Status: 'Status',
    IsApplytoAll: 'IsApplytoAll',
    IsApplytoType: 'IsApplytoType',
    IsApplytoSteroType: 'IsApplytoSteroType',
    Created: 'Created',
    Modified: 'Modified',
    ElementTypeList: 'ElementTypeList',
    ConnectorTypeList: 'ConnectorTypeList',
    FlowDirectionTypeList: 'FlowDirectionTypeList',
    TreeType: 'TreeType'
  };

  export type TraceabilityTreeProfilesScalarFieldEnum = (typeof TraceabilityTreeProfilesScalarFieldEnum)[keyof typeof TraceabilityTreeProfilesScalarFieldEnum]


  export const TraceabilityTreeViewsScalarFieldEnum: {
    Id: 'Id',
    RepositoryId: 'RepositoryId',
    ElementGuid: 'ElementGuid',
    TreeViewData: 'TreeViewData',
    User_Id: 'User_Id',
    Created: 'Created',
    Modified: 'Modified',
    FilterItems: 'FilterItems',
    Tittle: 'Tittle',
    Revision: 'Revision',
    ViewId: 'ViewId',
    TemplateOptions: 'TemplateOptions',
    Description: 'Description',
    NlFilterItems: 'NlFilterItems',
    NlTreeData: 'NlTreeData',
    NlFilterItemStatus: 'NlFilterItemStatus',
    FilterAppliedNodeList: 'FilterAppliedNodeList',
    TotForceLinks: 'TotForceLinks'
  };

  export type TraceabilityTreeViewsScalarFieldEnum = (typeof TraceabilityTreeViewsScalarFieldEnum)[keyof typeof TraceabilityTreeViewsScalarFieldEnum]


  export const URLMapScalarFieldEnum: {
    Id: 'Id',
    URL: 'URL',
    URLType: 'URLType',
    HashCode: 'HashCode',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate',
    Repository_Id: 'Repository_Id',
    LinkType: 'LinkType',
    MapurlId: 'MapurlId'
  };

  export type URLMapScalarFieldEnum = (typeof URLMapScalarFieldEnum)[keyof typeof URLMapScalarFieldEnum]


  export const UserActionsScalarFieldEnum: {
    Id: 'Id',
    ActionName: 'ActionName',
    Actionkey: 'Actionkey',
    Resource_id: 'Resource_id',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate',
    Status: 'Status'
  };

  export type UserActionsScalarFieldEnum = (typeof UserActionsScalarFieldEnum)[keyof typeof UserActionsScalarFieldEnum]


  export const UserGroupConnectorsScalarFieldEnum: {
    Id: 'Id',
    UserGroup_Id: 'UserGroup_Id',
    User_Id: 'User_Id',
    Status: 'Status',
    CreatedDate: 'CreatedDate'
  };

  export type UserGroupConnectorsScalarFieldEnum = (typeof UserGroupConnectorsScalarFieldEnum)[keyof typeof UserGroupConnectorsScalarFieldEnum]


  export const UserGroupsScalarFieldEnum: {
    Id: 'Id',
    GroupName: 'GroupName',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate',
    EditFeatures: 'EditFeatures',
    Status: 'Status',
    UserGroups_Role_Id: 'UserGroups_Role_Id',
    IsReadOnly: 'IsReadOnly'
  };

  export type UserGroupsScalarFieldEnum = (typeof UserGroupsScalarFieldEnum)[keyof typeof UserGroupsScalarFieldEnum]


  export const UserIdentityClaimsScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    ClaimType: 'ClaimType',
    ClaimValue: 'ClaimValue'
  };

  export type UserIdentityClaimsScalarFieldEnum = (typeof UserIdentityClaimsScalarFieldEnum)[keyof typeof UserIdentityClaimsScalarFieldEnum]


  export const UserIdentityLoginsScalarFieldEnum: {
    LoginProvider: 'LoginProvider',
    ProviderKey: 'ProviderKey',
    ProviderDisplayName: 'ProviderDisplayName',
    UserId: 'UserId'
  };

  export type UserIdentityLoginsScalarFieldEnum = (typeof UserIdentityLoginsScalarFieldEnum)[keyof typeof UserIdentityLoginsScalarFieldEnum]


  export const UserIdentityRoleClaimsScalarFieldEnum: {
    Id: 'Id',
    RoleId: 'RoleId',
    ClaimType: 'ClaimType',
    ClaimValue: 'ClaimValue'
  };

  export type UserIdentityRoleClaimsScalarFieldEnum = (typeof UserIdentityRoleClaimsScalarFieldEnum)[keyof typeof UserIdentityRoleClaimsScalarFieldEnum]


  export const UserIdentityRolesScalarFieldEnum: {
    UserId: 'UserId',
    RoleId: 'RoleId'
  };

  export type UserIdentityRolesScalarFieldEnum = (typeof UserIdentityRolesScalarFieldEnum)[keyof typeof UserIdentityRolesScalarFieldEnum]


  export const UserIdentityTokensScalarFieldEnum: {
    UserId: 'UserId',
    LoginProvider: 'LoginProvider',
    Name: 'Name',
    Value: 'Value'
  };

  export type UserIdentityTokensScalarFieldEnum = (typeof UserIdentityTokensScalarFieldEnum)[keyof typeof UserIdentityTokensScalarFieldEnum]


  export const UserProfileSettingScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    RepositoryTechnologyConfiguration: 'RepositoryTechnologyConfiguration',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate'
  };

  export type UserProfileSettingScalarFieldEnum = (typeof UserProfileSettingScalarFieldEnum)[keyof typeof UserProfileSettingScalarFieldEnum]


  export const UserRoleProfilesScalarFieldEnum: {
    Id: 'Id',
    UserRole_Id: 'UserRole_Id',
    Profile_Id: 'Profile_Id',
    Created: 'Created',
    Modified: 'Modified'
  };

  export type UserRoleProfilesScalarFieldEnum = (typeof UserRoleProfilesScalarFieldEnum)[keyof typeof UserRoleProfilesScalarFieldEnum]


  export const UserRolesScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Description: 'Description',
    UIEnabled: 'UIEnabled'
  };

  export type UserRolesScalarFieldEnum = (typeof UserRolesScalarFieldEnum)[keyof typeof UserRolesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    Id: 'Id',
    LDAPConnection_Id: 'LDAPConnection_Id',
    FirstName: 'FirstName',
    LastName: 'LastName',
    UserRole_Id: 'UserRole_Id',
    Status: 'Status',
    EmailId: 'EmailId',
    Password: 'Password',
    CreatedDate: 'CreatedDate',
    ModifiedDate: 'ModifiedDate',
    Description: 'Description',
    ProfileImage: 'ProfileImage',
    CreatedBy: 'CreatedBy',
    ModifiedBy: 'ModifiedBy',
    RegistrationMode: 'RegistrationMode',
    Timezone: 'Timezone',
    IsPasswordSet: 'IsPasswordSet',
    IsAdmin: 'IsAdmin',
    ShowHelpText: 'ShowHelpText',
    IdentityProvider_Id: 'IdentityProvider_Id',
    SecPhrase: 'SecPhrase',
    IsReadOnly: 'IsReadOnly',
    UserIdentityRole: 'UserIdentityRole',
    UserName: 'UserName',
    NormalizedUserName: 'NormalizedUserName',
    Email: 'Email',
    NormalizedEmail: 'NormalizedEmail',
    EmailConfirmed: 'EmailConfirmed',
    SecurityStamp: 'SecurityStamp',
    ConcurrencyStamp: 'ConcurrencyStamp',
    PhoneNumber: 'PhoneNumber',
    PhoneNumberConfirmed: 'PhoneNumberConfirmed',
    PasswordHash: 'PasswordHash',
    TwoFactorEnabled: 'TwoFactorEnabled',
    LockoutEnd: 'LockoutEnd',
    LockoutEnabled: 'LockoutEnabled',
    AccessFailedCount: 'AccessFailedCount'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const UserSessionsScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    IsReservedUser: 'IsReservedUser',
    AccessMode: 'AccessMode',
    IPAddress: 'IPAddress',
    UserAgent: 'UserAgent',
    IsActive: 'IsActive',
    LastRequest: 'LastRequest',
    Created: 'Created',
    Modified: 'Modified',
    UserDisplayName: 'UserDisplayName',
    UserType: 'UserType'
  };

  export type UserSessionsScalarFieldEnum = (typeof UserSessionsScalarFieldEnum)[keyof typeof UserSessionsScalarFieldEnum]


  export const UserSessionsArchiveScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    IsReservedUser: 'IsReservedUser',
    AccessMode: 'AccessMode',
    IPAddress: 'IPAddress',
    UserAgent: 'UserAgent',
    IsActive: 'IsActive',
    LastRequest: 'LastRequest',
    Created: 'Created',
    Modified: 'Modified',
    UserDisplayName: 'UserDisplayName',
    UserType: 'UserType'
  };

  export type UserSessionsArchiveScalarFieldEnum = (typeof UserSessionsArchiveScalarFieldEnum)[keyof typeof UserSessionsArchiveScalarFieldEnum]


  export const UserTokensScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    RefreshToken: 'RefreshToken',
    CreatedDate: 'CreatedDate'
  };

  export type UserTokensScalarFieldEnum = (typeof UserTokensScalarFieldEnum)[keyof typeof UserTokensScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type AccessRightsWhereInput = {
    AND?: Enumerable<AccessRightsWhereInput>
    OR?: Enumerable<AccessRightsWhereInput>
    NOT?: Enumerable<AccessRightsWhereInput>
    Id?: StringFilter | string
    Name?: StringNullableFilter | string | null
    AccessRightKey?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
    Status?: StringNullableFilter | string | null
  }

  export type AccessRightsOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    AccessRightKey?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
  }

  export type AccessRightsWhereUniqueInput = {
    Id?: string
  }

  export type AccessRightsOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    AccessRightKey?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    _count?: AccessRightsCountOrderByAggregateInput
    _max?: AccessRightsMaxOrderByAggregateInput
    _min?: AccessRightsMinOrderByAggregateInput
  }

  export type AccessRightsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccessRightsScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccessRightsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccessRightsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Name?: StringNullableWithAggregatesFilter | string | null
    AccessRightKey?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
  }

  export type AppIdentityRolesWhereInput = {
    AND?: Enumerable<AppIdentityRolesWhereInput>
    OR?: Enumerable<AppIdentityRolesWhereInput>
    NOT?: Enumerable<AppIdentityRolesWhereInput>
    Id?: StringFilter | string
    Name?: StringNullableFilter | string | null
    NormalizedName?: StringNullableFilter | string | null
    ConcurrencyStamp?: StringNullableFilter | string | null
    UserIdentityRoleClaims?: UserIdentityRoleClaimsListRelationFilter
    UserIdentityRoles?: UserIdentityRolesListRelationFilter
  }

  export type AppIdentityRolesOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    NormalizedName?: SortOrder
    ConcurrencyStamp?: SortOrder
    UserIdentityRoleClaims?: UserIdentityRoleClaimsOrderByRelationAggregateInput
    UserIdentityRoles?: UserIdentityRolesOrderByRelationAggregateInput
  }

  export type AppIdentityRolesWhereUniqueInput = {
    Id?: string
  }

  export type AppIdentityRolesOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    NormalizedName?: SortOrder
    ConcurrencyStamp?: SortOrder
    _count?: AppIdentityRolesCountOrderByAggregateInput
    _max?: AppIdentityRolesMaxOrderByAggregateInput
    _min?: AppIdentityRolesMinOrderByAggregateInput
  }

  export type AppIdentityRolesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AppIdentityRolesScalarWhereWithAggregatesInput>
    OR?: Enumerable<AppIdentityRolesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AppIdentityRolesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Name?: StringNullableWithAggregatesFilter | string | null
    NormalizedName?: StringNullableWithAggregatesFilter | string | null
    ConcurrencyStamp?: StringNullableWithAggregatesFilter | string | null
  }

  export type AppStreamConfigurationsWhereInput = {
    AND?: Enumerable<AppStreamConfigurationsWhereInput>
    OR?: Enumerable<AppStreamConfigurationsWhereInput>
    NOT?: Enumerable<AppStreamConfigurationsWhereInput>
    Id?: StringFilter | string
    RegionEndPoint?: IntFilter | number
    FleetName?: StringFilter | string
    StackName?: StringFilter | string
    ApplicationID?: StringFilter | string
    AuthenticationType?: IntFilter | number
    URLValidityTime?: IntNullableFilter | number | null
    AWSConfigurationsId?: StringFilter | string
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type AppStreamConfigurationsOrderByWithRelationInput = {
    Id?: SortOrder
    RegionEndPoint?: SortOrder
    FleetName?: SortOrder
    StackName?: SortOrder
    ApplicationID?: SortOrder
    AuthenticationType?: SortOrder
    URLValidityTime?: SortOrder
    AWSConfigurationsId?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type AppStreamConfigurationsWhereUniqueInput = {
    Id?: string
  }

  export type AppStreamConfigurationsOrderByWithAggregationInput = {
    Id?: SortOrder
    RegionEndPoint?: SortOrder
    FleetName?: SortOrder
    StackName?: SortOrder
    ApplicationID?: SortOrder
    AuthenticationType?: SortOrder
    URLValidityTime?: SortOrder
    AWSConfigurationsId?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: AppStreamConfigurationsCountOrderByAggregateInput
    _avg?: AppStreamConfigurationsAvgOrderByAggregateInput
    _max?: AppStreamConfigurationsMaxOrderByAggregateInput
    _min?: AppStreamConfigurationsMinOrderByAggregateInput
    _sum?: AppStreamConfigurationsSumOrderByAggregateInput
  }

  export type AppStreamConfigurationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AppStreamConfigurationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<AppStreamConfigurationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AppStreamConfigurationsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    RegionEndPoint?: IntWithAggregatesFilter | number
    FleetName?: StringWithAggregatesFilter | string
    StackName?: StringWithAggregatesFilter | string
    ApplicationID?: StringWithAggregatesFilter | string
    AuthenticationType?: IntWithAggregatesFilter | number
    URLValidityTime?: IntNullableWithAggregatesFilter | number | null
    AWSConfigurationsId?: StringWithAggregatesFilter | string
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AppStreamUserConnectorsWhereInput = {
    AND?: Enumerable<AppStreamUserConnectorsWhereInput>
    OR?: Enumerable<AppStreamUserConnectorsWhereInput>
    NOT?: Enumerable<AppStreamUserConnectorsWhereInput>
    Id?: StringFilter | string
    AppStreamARN?: StringFilter | string
    AppStreamUserName?: StringNullableFilter | string | null
    AppStreamEmailId?: StringFilter | string
    AppStreamConfiguration_Id?: StringFilter | string
    User_Id?: StringFilter | string
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type AppStreamUserConnectorsOrderByWithRelationInput = {
    Id?: SortOrder
    AppStreamARN?: SortOrder
    AppStreamUserName?: SortOrder
    AppStreamEmailId?: SortOrder
    AppStreamConfiguration_Id?: SortOrder
    User_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type AppStreamUserConnectorsWhereUniqueInput = {
    Id?: string
  }

  export type AppStreamUserConnectorsOrderByWithAggregationInput = {
    Id?: SortOrder
    AppStreamARN?: SortOrder
    AppStreamUserName?: SortOrder
    AppStreamEmailId?: SortOrder
    AppStreamConfiguration_Id?: SortOrder
    User_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: AppStreamUserConnectorsCountOrderByAggregateInput
    _max?: AppStreamUserConnectorsMaxOrderByAggregateInput
    _min?: AppStreamUserConnectorsMinOrderByAggregateInput
  }

  export type AppStreamUserConnectorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AppStreamUserConnectorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<AppStreamUserConnectorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AppStreamUserConnectorsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    AppStreamARN?: StringWithAggregatesFilter | string
    AppStreamUserName?: StringNullableWithAggregatesFilter | string | null
    AppStreamEmailId?: StringWithAggregatesFilter | string
    AppStreamConfiguration_Id?: StringWithAggregatesFilter | string
    User_Id?: StringWithAggregatesFilter | string
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AuditEntitiesWhereInput = {
    AND?: Enumerable<AuditEntitiesWhereInput>
    OR?: Enumerable<AuditEntitiesWhereInput>
    NOT?: Enumerable<AuditEntitiesWhereInput>
    Id?: StringFilter | string
    Type?: StringNullableFilter | string | null
    ActionBy?: StringNullableFilter | string | null
    Details?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    UserAgent?: StringNullableFilter | string | null
    IPAddress?: StringNullableFilter | string | null
  }

  export type AuditEntitiesOrderByWithRelationInput = {
    Id?: SortOrder
    Type?: SortOrder
    ActionBy?: SortOrder
    Details?: SortOrder
    CreatedDate?: SortOrder
    UserAgent?: SortOrder
    IPAddress?: SortOrder
  }

  export type AuditEntitiesWhereUniqueInput = {
    Id?: string
  }

  export type AuditEntitiesOrderByWithAggregationInput = {
    Id?: SortOrder
    Type?: SortOrder
    ActionBy?: SortOrder
    Details?: SortOrder
    CreatedDate?: SortOrder
    UserAgent?: SortOrder
    IPAddress?: SortOrder
    _count?: AuditEntitiesCountOrderByAggregateInput
    _max?: AuditEntitiesMaxOrderByAggregateInput
    _min?: AuditEntitiesMinOrderByAggregateInput
  }

  export type AuditEntitiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AuditEntitiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<AuditEntitiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AuditEntitiesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Type?: StringNullableWithAggregatesFilter | string | null
    ActionBy?: StringNullableWithAggregatesFilter | string | null
    Details?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    UserAgent?: StringNullableWithAggregatesFilter | string | null
    IPAddress?: StringNullableWithAggregatesFilter | string | null
  }

  export type AuditLogsWhereInput = {
    AND?: Enumerable<AuditLogsWhereInput>
    OR?: Enumerable<AuditLogsWhereInput>
    NOT?: Enumerable<AuditLogsWhereInput>
    Id?: StringFilter | string
    Resource?: StringNullableFilter | string | null
    Resource_Id?: StringNullableFilter | string | null
    UserAction_Actionkey?: StringNullableFilter | string | null
    UserType?: StringNullableFilter | string | null
    Repository_Id?: StringNullableFilter | string | null
    ActionBy?: StringNullableFilter | string | null
    Details?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    UserAgent?: StringNullableFilter | string | null
    IPAddress?: StringNullableFilter | string | null
  }

  export type AuditLogsOrderByWithRelationInput = {
    Id?: SortOrder
    Resource?: SortOrder
    Resource_Id?: SortOrder
    UserAction_Actionkey?: SortOrder
    UserType?: SortOrder
    Repository_Id?: SortOrder
    ActionBy?: SortOrder
    Details?: SortOrder
    CreatedDate?: SortOrder
    UserAgent?: SortOrder
    IPAddress?: SortOrder
  }

  export type AuditLogsWhereUniqueInput = {
    Id?: string
  }

  export type AuditLogsOrderByWithAggregationInput = {
    Id?: SortOrder
    Resource?: SortOrder
    Resource_Id?: SortOrder
    UserAction_Actionkey?: SortOrder
    UserType?: SortOrder
    Repository_Id?: SortOrder
    ActionBy?: SortOrder
    Details?: SortOrder
    CreatedDate?: SortOrder
    UserAgent?: SortOrder
    IPAddress?: SortOrder
    _count?: AuditLogsCountOrderByAggregateInput
    _max?: AuditLogsMaxOrderByAggregateInput
    _min?: AuditLogsMinOrderByAggregateInput
  }

  export type AuditLogsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AuditLogsScalarWhereWithAggregatesInput>
    OR?: Enumerable<AuditLogsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AuditLogsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Resource?: StringNullableWithAggregatesFilter | string | null
    Resource_Id?: StringNullableWithAggregatesFilter | string | null
    UserAction_Actionkey?: StringNullableWithAggregatesFilter | string | null
    UserType?: StringNullableWithAggregatesFilter | string | null
    Repository_Id?: StringNullableWithAggregatesFilter | string | null
    ActionBy?: StringNullableWithAggregatesFilter | string | null
    Details?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    UserAgent?: StringNullableWithAggregatesFilter | string | null
    IPAddress?: StringNullableWithAggregatesFilter | string | null
  }

  export type AWSConfigurationsWhereInput = {
    AND?: Enumerable<AWSConfigurationsWhereInput>
    OR?: Enumerable<AWSConfigurationsWhereInput>
    NOT?: Enumerable<AWSConfigurationsWhereInput>
    Id?: StringFilter | string
    AccessKey?: StringFilter | string
    Secretkey?: StringFilter | string
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type AWSConfigurationsOrderByWithRelationInput = {
    Id?: SortOrder
    AccessKey?: SortOrder
    Secretkey?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type AWSConfigurationsWhereUniqueInput = {
    Id?: string
  }

  export type AWSConfigurationsOrderByWithAggregationInput = {
    Id?: SortOrder
    AccessKey?: SortOrder
    Secretkey?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: AWSConfigurationsCountOrderByAggregateInput
    _max?: AWSConfigurationsMaxOrderByAggregateInput
    _min?: AWSConfigurationsMinOrderByAggregateInput
  }

  export type AWSConfigurationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AWSConfigurationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<AWSConfigurationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AWSConfigurationsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    AccessKey?: StringWithAggregatesFilter | string
    Secretkey?: StringWithAggregatesFilter | string
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CreateElementNotificationsWhereInput = {
    AND?: Enumerable<CreateElementNotificationsWhereInput>
    OR?: Enumerable<CreateElementNotificationsWhereInput>
    NOT?: Enumerable<CreateElementNotificationsWhereInput>
    Id?: StringFilter | string
    Repository_Id?: StringFilter | string
    EnableNotification?: IntNullableFilter | number | null
    User_Id?: StringNullableFilter | string | null
    UserGroup_Id?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type CreateElementNotificationsOrderByWithRelationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    EnableNotification?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type CreateElementNotificationsWhereUniqueInput = {
    Id?: string
  }

  export type CreateElementNotificationsOrderByWithAggregationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    EnableNotification?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: CreateElementNotificationsCountOrderByAggregateInput
    _avg?: CreateElementNotificationsAvgOrderByAggregateInput
    _max?: CreateElementNotificationsMaxOrderByAggregateInput
    _min?: CreateElementNotificationsMinOrderByAggregateInput
    _sum?: CreateElementNotificationsSumOrderByAggregateInput
  }

  export type CreateElementNotificationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CreateElementNotificationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<CreateElementNotificationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CreateElementNotificationsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Repository_Id?: StringWithAggregatesFilter | string
    EnableNotification?: IntNullableWithAggregatesFilter | number | null
    User_Id?: StringNullableWithAggregatesFilter | string | null
    UserGroup_Id?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type DashboardReviewUserRolesWhereInput = {
    AND?: Enumerable<DashboardReviewUserRolesWhereInput>
    OR?: Enumerable<DashboardReviewUserRolesWhereInput>
    NOT?: Enumerable<DashboardReviewUserRolesWhereInput>
    Id?: StringFilter | string
    DashboardId?: StringFilter | string
    UserRole?: StringFilter | string
  }

  export type DashboardReviewUserRolesOrderByWithRelationInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserRole?: SortOrder
  }

  export type DashboardReviewUserRolesWhereUniqueInput = {
    Id?: string
  }

  export type DashboardReviewUserRolesOrderByWithAggregationInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserRole?: SortOrder
    _count?: DashboardReviewUserRolesCountOrderByAggregateInput
    _max?: DashboardReviewUserRolesMaxOrderByAggregateInput
    _min?: DashboardReviewUserRolesMinOrderByAggregateInput
  }

  export type DashboardReviewUserRolesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DashboardReviewUserRolesScalarWhereWithAggregatesInput>
    OR?: Enumerable<DashboardReviewUserRolesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DashboardReviewUserRolesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    DashboardId?: StringWithAggregatesFilter | string
    UserRole?: StringWithAggregatesFilter | string
  }

  export type DashboardsWhereInput = {
    AND?: Enumerable<DashboardsWhereInput>
    OR?: Enumerable<DashboardsWhereInput>
    NOT?: Enumerable<DashboardsWhereInput>
    Id?: StringFilter | string
    RepositoryId?: StringFilter | string
    Name?: StringFilter | string
    Notes?: StringNullableFilter | string | null
    Logo?: StringNullableFilter | string | null
    IsEnabled?: IntFilter | number
    CreatedBy?: StringFilter | string
    Created?: DateTimeFilter | Date | string
    Modified?: DateTimeFilter | Date | string
    IsDefault?: IntNullableFilter | number | null
    DisplayDescription?: IntFilter | number
    Type?: StringNullableFilter | string | null
    UserType?: StringNullableFilter | string | null
    DashboardSettings?: StringNullableFilter | string | null
    Template?: IntFilter | number
  }

  export type DashboardsOrderByWithRelationInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    Logo?: SortOrder
    IsEnabled?: SortOrder
    CreatedBy?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    IsDefault?: SortOrder
    DisplayDescription?: SortOrder
    Type?: SortOrder
    UserType?: SortOrder
    DashboardSettings?: SortOrder
    Template?: SortOrder
  }

  export type DashboardsWhereUniqueInput = {
    Id?: string
  }

  export type DashboardsOrderByWithAggregationInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    Logo?: SortOrder
    IsEnabled?: SortOrder
    CreatedBy?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    IsDefault?: SortOrder
    DisplayDescription?: SortOrder
    Type?: SortOrder
    UserType?: SortOrder
    DashboardSettings?: SortOrder
    Template?: SortOrder
    _count?: DashboardsCountOrderByAggregateInput
    _avg?: DashboardsAvgOrderByAggregateInput
    _max?: DashboardsMaxOrderByAggregateInput
    _min?: DashboardsMinOrderByAggregateInput
    _sum?: DashboardsSumOrderByAggregateInput
  }

  export type DashboardsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DashboardsScalarWhereWithAggregatesInput>
    OR?: Enumerable<DashboardsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DashboardsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    RepositoryId?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
    Notes?: StringNullableWithAggregatesFilter | string | null
    Logo?: StringNullableWithAggregatesFilter | string | null
    IsEnabled?: IntWithAggregatesFilter | number
    CreatedBy?: StringWithAggregatesFilter | string
    Created?: DateTimeWithAggregatesFilter | Date | string
    Modified?: DateTimeWithAggregatesFilter | Date | string
    IsDefault?: IntNullableWithAggregatesFilter | number | null
    DisplayDescription?: IntWithAggregatesFilter | number
    Type?: StringNullableWithAggregatesFilter | string | null
    UserType?: StringNullableWithAggregatesFilter | string | null
    DashboardSettings?: StringNullableWithAggregatesFilter | string | null
    Template?: IntWithAggregatesFilter | number
  }

  export type DashboardUserDefaultWhereInput = {
    AND?: Enumerable<DashboardUserDefaultWhereInput>
    OR?: Enumerable<DashboardUserDefaultWhereInput>
    NOT?: Enumerable<DashboardUserDefaultWhereInput>
    Id?: StringFilter | string
    UserId?: StringFilter | string
    RepositoryId?: StringFilter | string
    DashboardId?: StringFilter | string
    Type?: StringNullableFilter | string | null
  }

  export type DashboardUserDefaultOrderByWithRelationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RepositoryId?: SortOrder
    DashboardId?: SortOrder
    Type?: SortOrder
  }

  export type DashboardUserDefaultWhereUniqueInput = {
    Id?: string
  }

  export type DashboardUserDefaultOrderByWithAggregationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RepositoryId?: SortOrder
    DashboardId?: SortOrder
    Type?: SortOrder
    _count?: DashboardUserDefaultCountOrderByAggregateInput
    _max?: DashboardUserDefaultMaxOrderByAggregateInput
    _min?: DashboardUserDefaultMinOrderByAggregateInput
  }

  export type DashboardUserDefaultScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DashboardUserDefaultScalarWhereWithAggregatesInput>
    OR?: Enumerable<DashboardUserDefaultScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DashboardUserDefaultScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    UserId?: StringWithAggregatesFilter | string
    RepositoryId?: StringWithAggregatesFilter | string
    DashboardId?: StringWithAggregatesFilter | string
    Type?: StringNullableWithAggregatesFilter | string | null
  }

  export type DashboardUserGroupsWhereInput = {
    AND?: Enumerable<DashboardUserGroupsWhereInput>
    OR?: Enumerable<DashboardUserGroupsWhereInput>
    NOT?: Enumerable<DashboardUserGroupsWhereInput>
    Id?: StringFilter | string
    DashboardId?: StringFilter | string
    UserGroupId?: StringFilter | string
  }

  export type DashboardUserGroupsOrderByWithRelationInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserGroupId?: SortOrder
  }

  export type DashboardUserGroupsWhereUniqueInput = {
    Id?: string
  }

  export type DashboardUserGroupsOrderByWithAggregationInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserGroupId?: SortOrder
    _count?: DashboardUserGroupsCountOrderByAggregateInput
    _max?: DashboardUserGroupsMaxOrderByAggregateInput
    _min?: DashboardUserGroupsMinOrderByAggregateInput
  }

  export type DashboardUserGroupsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DashboardUserGroupsScalarWhereWithAggregatesInput>
    OR?: Enumerable<DashboardUserGroupsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DashboardUserGroupsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    DashboardId?: StringWithAggregatesFilter | string
    UserGroupId?: StringWithAggregatesFilter | string
  }

  export type DashboardUsersWhereInput = {
    AND?: Enumerable<DashboardUsersWhereInput>
    OR?: Enumerable<DashboardUsersWhereInput>
    NOT?: Enumerable<DashboardUsersWhereInput>
    Id?: StringFilter | string
    DashboardId?: StringFilter | string
    UserId?: StringFilter | string
  }

  export type DashboardUsersOrderByWithRelationInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserId?: SortOrder
  }

  export type DashboardUsersWhereUniqueInput = {
    Id?: string
  }

  export type DashboardUsersOrderByWithAggregationInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserId?: SortOrder
    _count?: DashboardUsersCountOrderByAggregateInput
    _max?: DashboardUsersMaxOrderByAggregateInput
    _min?: DashboardUsersMinOrderByAggregateInput
  }

  export type DashboardUsersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DashboardUsersScalarWhereWithAggregatesInput>
    OR?: Enumerable<DashboardUsersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DashboardUsersScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    DashboardId?: StringWithAggregatesFilter | string
    UserId?: StringWithAggregatesFilter | string
  }

  export type DashboardWidgetBlocksWhereInput = {
    AND?: Enumerable<DashboardWidgetBlocksWhereInput>
    OR?: Enumerable<DashboardWidgetBlocksWhereInput>
    NOT?: Enumerable<DashboardWidgetBlocksWhereInput>
    Id?: StringFilter | string
    DashboardWidgetId?: StringFilter | string
    DashboardWidgetBlockTypeId?: StringFilter | string
    Title?: StringNullableFilter | string | null
    Notes?: StringNullableFilter | string | null
    EAArtifactGuid?: StringNullableFilter | string | null
    IsConfigured?: IntFilter | number
    Position?: IntNullableFilter | number | null
  }

  export type DashboardWidgetBlocksOrderByWithRelationInput = {
    Id?: SortOrder
    DashboardWidgetId?: SortOrder
    DashboardWidgetBlockTypeId?: SortOrder
    Title?: SortOrder
    Notes?: SortOrder
    EAArtifactGuid?: SortOrder
    IsConfigured?: SortOrder
    Position?: SortOrder
  }

  export type DashboardWidgetBlocksWhereUniqueInput = {
    Id?: string
  }

  export type DashboardWidgetBlocksOrderByWithAggregationInput = {
    Id?: SortOrder
    DashboardWidgetId?: SortOrder
    DashboardWidgetBlockTypeId?: SortOrder
    Title?: SortOrder
    Notes?: SortOrder
    EAArtifactGuid?: SortOrder
    IsConfigured?: SortOrder
    Position?: SortOrder
    _count?: DashboardWidgetBlocksCountOrderByAggregateInput
    _avg?: DashboardWidgetBlocksAvgOrderByAggregateInput
    _max?: DashboardWidgetBlocksMaxOrderByAggregateInput
    _min?: DashboardWidgetBlocksMinOrderByAggregateInput
    _sum?: DashboardWidgetBlocksSumOrderByAggregateInput
  }

  export type DashboardWidgetBlocksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DashboardWidgetBlocksScalarWhereWithAggregatesInput>
    OR?: Enumerable<DashboardWidgetBlocksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DashboardWidgetBlocksScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    DashboardWidgetId?: StringWithAggregatesFilter | string
    DashboardWidgetBlockTypeId?: StringWithAggregatesFilter | string
    Title?: StringNullableWithAggregatesFilter | string | null
    Notes?: StringNullableWithAggregatesFilter | string | null
    EAArtifactGuid?: StringNullableWithAggregatesFilter | string | null
    IsConfigured?: IntWithAggregatesFilter | number
    Position?: IntNullableWithAggregatesFilter | number | null
  }

  export type DashboardWidgetBlockTypesWhereInput = {
    AND?: Enumerable<DashboardWidgetBlockTypesWhereInput>
    OR?: Enumerable<DashboardWidgetBlockTypesWhereInput>
    NOT?: Enumerable<DashboardWidgetBlockTypesWhereInput>
    Id?: StringFilter | string
    Name?: StringFilter | string
    Notes?: StringNullableFilter | string | null
    Category?: StringNullableFilter | string | null
    Position?: IntFilter | number
    NotSetText?: StringFilter | string
    ConfigurationRequired?: IntFilter | number
    IsEnabled?: IntFilter | number
    Icon?: StringNullableFilter | string | null
  }

  export type DashboardWidgetBlockTypesOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    Category?: SortOrder
    Position?: SortOrder
    NotSetText?: SortOrder
    ConfigurationRequired?: SortOrder
    IsEnabled?: SortOrder
    Icon?: SortOrder
  }

  export type DashboardWidgetBlockTypesWhereUniqueInput = {
    Id?: string
  }

  export type DashboardWidgetBlockTypesOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    Category?: SortOrder
    Position?: SortOrder
    NotSetText?: SortOrder
    ConfigurationRequired?: SortOrder
    IsEnabled?: SortOrder
    Icon?: SortOrder
    _count?: DashboardWidgetBlockTypesCountOrderByAggregateInput
    _avg?: DashboardWidgetBlockTypesAvgOrderByAggregateInput
    _max?: DashboardWidgetBlockTypesMaxOrderByAggregateInput
    _min?: DashboardWidgetBlockTypesMinOrderByAggregateInput
    _sum?: DashboardWidgetBlockTypesSumOrderByAggregateInput
  }

  export type DashboardWidgetBlockTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DashboardWidgetBlockTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<DashboardWidgetBlockTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DashboardWidgetBlockTypesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
    Notes?: StringNullableWithAggregatesFilter | string | null
    Category?: StringNullableWithAggregatesFilter | string | null
    Position?: IntWithAggregatesFilter | number
    NotSetText?: StringWithAggregatesFilter | string
    ConfigurationRequired?: IntWithAggregatesFilter | number
    IsEnabled?: IntWithAggregatesFilter | number
    Icon?: StringNullableWithAggregatesFilter | string | null
  }

  export type DashboardWidgetsWhereInput = {
    AND?: Enumerable<DashboardWidgetsWhereInput>
    OR?: Enumerable<DashboardWidgetsWhereInput>
    NOT?: Enumerable<DashboardWidgetsWhereInput>
    Id?: StringFilter | string
    DashboardId?: StringFilter | string
    Name?: StringFilter | string
    Notes?: StringNullableFilter | string | null
    RowId?: IntFilter | number
    ColumnId?: IntFilter | number
    ConfigData?: StringNullableFilter | string | null
    SizeX?: IntFilter | number
    SizeY?: IntFilter | number
    WidgetSettings?: StringNullableFilter | string | null
    Template?: IntFilter | number
    X?: IntNullableFilter | number | null
    Y?: IntNullableFilter | number | null
    Rows?: IntNullableFilter | number | null
    Cols?: IntNullableFilter | number | null
  }

  export type DashboardWidgetsOrderByWithRelationInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    RowId?: SortOrder
    ColumnId?: SortOrder
    ConfigData?: SortOrder
    SizeX?: SortOrder
    SizeY?: SortOrder
    WidgetSettings?: SortOrder
    Template?: SortOrder
    X?: SortOrder
    Y?: SortOrder
    Rows?: SortOrder
    Cols?: SortOrder
  }

  export type DashboardWidgetsWhereUniqueInput = {
    Id?: string
  }

  export type DashboardWidgetsOrderByWithAggregationInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    RowId?: SortOrder
    ColumnId?: SortOrder
    ConfigData?: SortOrder
    SizeX?: SortOrder
    SizeY?: SortOrder
    WidgetSettings?: SortOrder
    Template?: SortOrder
    X?: SortOrder
    Y?: SortOrder
    Rows?: SortOrder
    Cols?: SortOrder
    _count?: DashboardWidgetsCountOrderByAggregateInput
    _avg?: DashboardWidgetsAvgOrderByAggregateInput
    _max?: DashboardWidgetsMaxOrderByAggregateInput
    _min?: DashboardWidgetsMinOrderByAggregateInput
    _sum?: DashboardWidgetsSumOrderByAggregateInput
  }

  export type DashboardWidgetsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DashboardWidgetsScalarWhereWithAggregatesInput>
    OR?: Enumerable<DashboardWidgetsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DashboardWidgetsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    DashboardId?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
    Notes?: StringNullableWithAggregatesFilter | string | null
    RowId?: IntWithAggregatesFilter | number
    ColumnId?: IntWithAggregatesFilter | number
    ConfigData?: StringNullableWithAggregatesFilter | string | null
    SizeX?: IntWithAggregatesFilter | number
    SizeY?: IntWithAggregatesFilter | number
    WidgetSettings?: StringNullableWithAggregatesFilter | string | null
    Template?: IntWithAggregatesFilter | number
    X?: IntNullableWithAggregatesFilter | number | null
    Y?: IntNullableWithAggregatesFilter | number | null
    Rows?: IntNullableWithAggregatesFilter | number | null
    Cols?: IntNullableWithAggregatesFilter | number | null
  }

  export type DocumentationRequestsWhereInput = {
    AND?: Enumerable<DocumentationRequestsWhereInput>
    OR?: Enumerable<DocumentationRequestsWhereInput>
    NOT?: Enumerable<DocumentationRequestsWhereInput>
    Id?: StringFilter | string
    Repository_Id?: StringFilter | string
    User_Id?: StringFilter | string
    UserDefinedTemplate?: IntFilter | number
    InclusionList?: StringNullableFilter | string | null
    ExclusionList?: StringNullableFilter | string | null
    FileName?: StringNullableFilter | string | null
    IsCancelled?: IntFilter | number
    IsProcessed?: IntFilter | number
    Created?: DateTimeFilter | Date | string
    Modified?: DateTimeFilter | Date | string
  }

  export type DocumentationRequestsOrderByWithRelationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserDefinedTemplate?: SortOrder
    InclusionList?: SortOrder
    ExclusionList?: SortOrder
    FileName?: SortOrder
    IsCancelled?: SortOrder
    IsProcessed?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type DocumentationRequestsWhereUniqueInput = {
    Id?: string
  }

  export type DocumentationRequestsOrderByWithAggregationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserDefinedTemplate?: SortOrder
    InclusionList?: SortOrder
    ExclusionList?: SortOrder
    FileName?: SortOrder
    IsCancelled?: SortOrder
    IsProcessed?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    _count?: DocumentationRequestsCountOrderByAggregateInput
    _avg?: DocumentationRequestsAvgOrderByAggregateInput
    _max?: DocumentationRequestsMaxOrderByAggregateInput
    _min?: DocumentationRequestsMinOrderByAggregateInput
    _sum?: DocumentationRequestsSumOrderByAggregateInput
  }

  export type DocumentationRequestsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentationRequestsScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentationRequestsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentationRequestsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Repository_Id?: StringWithAggregatesFilter | string
    User_Id?: StringWithAggregatesFilter | string
    UserDefinedTemplate?: IntWithAggregatesFilter | number
    InclusionList?: StringNullableWithAggregatesFilter | string | null
    ExclusionList?: StringNullableWithAggregatesFilter | string | null
    FileName?: StringNullableWithAggregatesFilter | string | null
    IsCancelled?: IntWithAggregatesFilter | number
    IsProcessed?: IntWithAggregatesFilter | number
    Created?: DateTimeWithAggregatesFilter | Date | string
    Modified?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DomainRestrictionsWhereInput = {
    AND?: Enumerable<DomainRestrictionsWhereInput>
    OR?: Enumerable<DomainRestrictionsWhereInput>
    NOT?: Enumerable<DomainRestrictionsWhereInput>
    Id?: StringFilter | string
    Domain?: StringNullableFilter | string | null
    IsEnabled?: IntNullableFilter | number | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type DomainRestrictionsOrderByWithRelationInput = {
    Id?: SortOrder
    Domain?: SortOrder
    IsEnabled?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type DomainRestrictionsWhereUniqueInput = {
    Id?: string
  }

  export type DomainRestrictionsOrderByWithAggregationInput = {
    Id?: SortOrder
    Domain?: SortOrder
    IsEnabled?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: DomainRestrictionsCountOrderByAggregateInput
    _avg?: DomainRestrictionsAvgOrderByAggregateInput
    _max?: DomainRestrictionsMaxOrderByAggregateInput
    _min?: DomainRestrictionsMinOrderByAggregateInput
    _sum?: DomainRestrictionsSumOrderByAggregateInput
  }

  export type DomainRestrictionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DomainRestrictionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<DomainRestrictionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DomainRestrictionsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Domain?: StringNullableWithAggregatesFilter | string | null
    IsEnabled?: IntNullableWithAggregatesFilter | number | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type EAChangelogAttributesWhereInput = {
    AND?: Enumerable<EAChangelogAttributesWhereInput>
    OR?: Enumerable<EAChangelogAttributesWhereInput>
    NOT?: Enumerable<EAChangelogAttributesWhereInput>
    Id?: StringFilter | string
    EAChangelogId?: StringFilter | string
    PropertyGuid?: StringNullableFilter | string | null
    Name?: StringNullableFilter | string | null
    CurrentValue?: StringNullableFilter | string | null
    PreviousValue?: StringNullableFilter | string | null
    ActionType?: StringNullableFilter | string | null
    AttributeType?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type EAChangelogAttributesOrderByWithRelationInput = {
    Id?: SortOrder
    EAChangelogId?: SortOrder
    PropertyGuid?: SortOrder
    Name?: SortOrder
    CurrentValue?: SortOrder
    PreviousValue?: SortOrder
    ActionType?: SortOrder
    AttributeType?: SortOrder
    CreatedDate?: SortOrder
  }

  export type EAChangelogAttributesWhereUniqueInput = {
    Id?: string
  }

  export type EAChangelogAttributesOrderByWithAggregationInput = {
    Id?: SortOrder
    EAChangelogId?: SortOrder
    PropertyGuid?: SortOrder
    Name?: SortOrder
    CurrentValue?: SortOrder
    PreviousValue?: SortOrder
    ActionType?: SortOrder
    AttributeType?: SortOrder
    CreatedDate?: SortOrder
    _count?: EAChangelogAttributesCountOrderByAggregateInput
    _max?: EAChangelogAttributesMaxOrderByAggregateInput
    _min?: EAChangelogAttributesMinOrderByAggregateInput
  }

  export type EAChangelogAttributesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EAChangelogAttributesScalarWhereWithAggregatesInput>
    OR?: Enumerable<EAChangelogAttributesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EAChangelogAttributesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    EAChangelogId?: StringWithAggregatesFilter | string
    PropertyGuid?: StringNullableWithAggregatesFilter | string | null
    Name?: StringNullableWithAggregatesFilter | string | null
    CurrentValue?: StringNullableWithAggregatesFilter | string | null
    PreviousValue?: StringNullableWithAggregatesFilter | string | null
    ActionType?: StringNullableWithAggregatesFilter | string | null
    AttributeType?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type EAChangelogsWhereInput = {
    AND?: Enumerable<EAChangelogsWhereInput>
    OR?: Enumerable<EAChangelogsWhereInput>
    NOT?: Enumerable<EAChangelogsWhereInput>
    Id?: StringFilter | string
    Repository_Id?: StringNullableFilter | string | null
    ArtifactGuid?: StringFilter | string
    ArtifactType?: StringFilter | string
    ActionType?: StringFilter | string
    Revision?: BigIntNullableFilter | bigint | number | null
    CreatedDate?: DateTimeFilter | Date | string
    ModifiedDate?: DateTimeFilter | Date | string
  }

  export type EAChangelogsOrderByWithRelationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    ArtifactGuid?: SortOrder
    ArtifactType?: SortOrder
    ActionType?: SortOrder
    Revision?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type EAChangelogsWhereUniqueInput = {
    Id?: string
  }

  export type EAChangelogsOrderByWithAggregationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    ArtifactGuid?: SortOrder
    ArtifactType?: SortOrder
    ActionType?: SortOrder
    Revision?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: EAChangelogsCountOrderByAggregateInput
    _avg?: EAChangelogsAvgOrderByAggregateInput
    _max?: EAChangelogsMaxOrderByAggregateInput
    _min?: EAChangelogsMinOrderByAggregateInput
    _sum?: EAChangelogsSumOrderByAggregateInput
  }

  export type EAChangelogsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EAChangelogsScalarWhereWithAggregatesInput>
    OR?: Enumerable<EAChangelogsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EAChangelogsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Repository_Id?: StringNullableWithAggregatesFilter | string | null
    ArtifactGuid?: StringWithAggregatesFilter | string
    ArtifactType?: StringWithAggregatesFilter | string
    ActionType?: StringWithAggregatesFilter | string
    Revision?: BigIntNullableWithAggregatesFilter | bigint | number | null
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
    ModifiedDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ElementConnectorsWhereInput = {
    AND?: Enumerable<ElementConnectorsWhereInput>
    OR?: Enumerable<ElementConnectorsWhereInput>
    NOT?: Enumerable<ElementConnectorsWhereInput>
    Id?: StringFilter | string
    ElementGuid?: StringNullableFilter | string | null
    ElementType?: StringNullableFilter | string | null
    Repository_Id?: StringNullableFilter | string | null
    User_Id?: StringNullableFilter | string | null
    UserGroup_Id?: StringNullableFilter | string | null
    AccessRight_AccessRightKey?: StringNullableFilter | string | null
    InheritRight?: IntNullableFilter | number | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
    Status?: StringNullableFilter | string | null
    CreatedBy?: StringNullableFilter | string | null
    FeatureId?: StringNullableFilter | string | null
    OtherInfo?: StringNullableFilter | string | null
  }

  export type ElementConnectorsOrderByWithRelationInput = {
    Id?: SortOrder
    ElementGuid?: SortOrder
    ElementType?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    AccessRight_AccessRightKey?: SortOrder
    InheritRight?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    CreatedBy?: SortOrder
    FeatureId?: SortOrder
    OtherInfo?: SortOrder
  }

  export type ElementConnectorsWhereUniqueInput = {
    Id?: string
  }

  export type ElementConnectorsOrderByWithAggregationInput = {
    Id?: SortOrder
    ElementGuid?: SortOrder
    ElementType?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    AccessRight_AccessRightKey?: SortOrder
    InheritRight?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    CreatedBy?: SortOrder
    FeatureId?: SortOrder
    OtherInfo?: SortOrder
    _count?: ElementConnectorsCountOrderByAggregateInput
    _avg?: ElementConnectorsAvgOrderByAggregateInput
    _max?: ElementConnectorsMaxOrderByAggregateInput
    _min?: ElementConnectorsMinOrderByAggregateInput
    _sum?: ElementConnectorsSumOrderByAggregateInput
  }

  export type ElementConnectorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ElementConnectorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ElementConnectorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ElementConnectorsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    ElementGuid?: StringNullableWithAggregatesFilter | string | null
    ElementType?: StringNullableWithAggregatesFilter | string | null
    Repository_Id?: StringNullableWithAggregatesFilter | string | null
    User_Id?: StringNullableWithAggregatesFilter | string | null
    UserGroup_Id?: StringNullableWithAggregatesFilter | string | null
    AccessRight_AccessRightKey?: StringNullableWithAggregatesFilter | string | null
    InheritRight?: IntNullableWithAggregatesFilter | number | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
    CreatedBy?: StringNullableWithAggregatesFilter | string | null
    FeatureId?: StringNullableWithAggregatesFilter | string | null
    OtherInfo?: StringNullableWithAggregatesFilter | string | null
  }

  export type ExternalAppAttributeMasterWhereInput = {
    AND?: Enumerable<ExternalAppAttributeMasterWhereInput>
    OR?: Enumerable<ExternalAppAttributeMasterWhereInput>
    NOT?: Enumerable<ExternalAppAttributeMasterWhereInput>
    Id?: StringFilter | string
    ExternalAppTypeId?: StringFilter | string
    ExternalAppId?: StringFilter | string
    RepositoryId?: StringFilter | string
    Name?: StringFilter | string
    InternalName?: StringFilter | string
    ExternalName?: StringFilter | string
    HelpText?: StringNullableFilter | string | null
    MultiSelect?: IntFilter | number
    Filters?: StringNullableFilter | string | null
    ConfigData?: StringNullableFilter | string | null
    IsEnabled?: IntFilter | number
    Created?: DateTimeFilter | Date | string
    Modified?: DateTimeFilter | Date | string
    Description?: StringNullableFilter | string | null
  }

  export type ExternalAppAttributeMasterOrderByWithRelationInput = {
    Id?: SortOrder
    ExternalAppTypeId?: SortOrder
    ExternalAppId?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    InternalName?: SortOrder
    ExternalName?: SortOrder
    HelpText?: SortOrder
    MultiSelect?: SortOrder
    Filters?: SortOrder
    ConfigData?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    Description?: SortOrder
  }

  export type ExternalAppAttributeMasterWhereUniqueInput = {
    Id?: string
  }

  export type ExternalAppAttributeMasterOrderByWithAggregationInput = {
    Id?: SortOrder
    ExternalAppTypeId?: SortOrder
    ExternalAppId?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    InternalName?: SortOrder
    ExternalName?: SortOrder
    HelpText?: SortOrder
    MultiSelect?: SortOrder
    Filters?: SortOrder
    ConfigData?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    Description?: SortOrder
    _count?: ExternalAppAttributeMasterCountOrderByAggregateInput
    _avg?: ExternalAppAttributeMasterAvgOrderByAggregateInput
    _max?: ExternalAppAttributeMasterMaxOrderByAggregateInput
    _min?: ExternalAppAttributeMasterMinOrderByAggregateInput
    _sum?: ExternalAppAttributeMasterSumOrderByAggregateInput
  }

  export type ExternalAppAttributeMasterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExternalAppAttributeMasterScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExternalAppAttributeMasterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExternalAppAttributeMasterScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    ExternalAppTypeId?: StringWithAggregatesFilter | string
    ExternalAppId?: StringWithAggregatesFilter | string
    RepositoryId?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
    InternalName?: StringWithAggregatesFilter | string
    ExternalName?: StringWithAggregatesFilter | string
    HelpText?: StringNullableWithAggregatesFilter | string | null
    MultiSelect?: IntWithAggregatesFilter | number
    Filters?: StringNullableWithAggregatesFilter | string | null
    ConfigData?: StringNullableWithAggregatesFilter | string | null
    IsEnabled?: IntWithAggregatesFilter | number
    Created?: DateTimeWithAggregatesFilter | Date | string
    Modified?: DateTimeWithAggregatesFilter | Date | string
    Description?: StringNullableWithAggregatesFilter | string | null
  }

  export type ExternalAppAttributesWhereInput = {
    AND?: Enumerable<ExternalAppAttributesWhereInput>
    OR?: Enumerable<ExternalAppAttributesWhereInput>
    NOT?: Enumerable<ExternalAppAttributesWhereInput>
    Id?: StringFilter | string
    ExternalAppAttributeMasterId?: StringFilter | string
    ExternalAppProjectId?: StringFilter | string
    ArtifactId?: StringFilter | string
    InternalValue?: StringFilter | string
    ExternalValue?: StringFilter | string
    ConfigData?: StringFilter | string
    IsDeleted?: IntFilter | number
    RemoteLinkId?: StringNullableFilter | string | null
    Created?: DateTimeFilter | Date | string
    Modified?: DateTimeFilter | Date | string
  }

  export type ExternalAppAttributesOrderByWithRelationInput = {
    Id?: SortOrder
    ExternalAppAttributeMasterId?: SortOrder
    ExternalAppProjectId?: SortOrder
    ArtifactId?: SortOrder
    InternalValue?: SortOrder
    ExternalValue?: SortOrder
    ConfigData?: SortOrder
    IsDeleted?: SortOrder
    RemoteLinkId?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type ExternalAppAttributesWhereUniqueInput = {
    Id?: string
  }

  export type ExternalAppAttributesOrderByWithAggregationInput = {
    Id?: SortOrder
    ExternalAppAttributeMasterId?: SortOrder
    ExternalAppProjectId?: SortOrder
    ArtifactId?: SortOrder
    InternalValue?: SortOrder
    ExternalValue?: SortOrder
    ConfigData?: SortOrder
    IsDeleted?: SortOrder
    RemoteLinkId?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    _count?: ExternalAppAttributesCountOrderByAggregateInput
    _avg?: ExternalAppAttributesAvgOrderByAggregateInput
    _max?: ExternalAppAttributesMaxOrderByAggregateInput
    _min?: ExternalAppAttributesMinOrderByAggregateInput
    _sum?: ExternalAppAttributesSumOrderByAggregateInput
  }

  export type ExternalAppAttributesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExternalAppAttributesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExternalAppAttributesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExternalAppAttributesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    ExternalAppAttributeMasterId?: StringWithAggregatesFilter | string
    ExternalAppProjectId?: StringWithAggregatesFilter | string
    ArtifactId?: StringWithAggregatesFilter | string
    InternalValue?: StringWithAggregatesFilter | string
    ExternalValue?: StringWithAggregatesFilter | string
    ConfigData?: StringWithAggregatesFilter | string
    IsDeleted?: IntWithAggregatesFilter | number
    RemoteLinkId?: StringNullableWithAggregatesFilter | string | null
    Created?: DateTimeWithAggregatesFilter | Date | string
    Modified?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ExternalAppsWhereInput = {
    AND?: Enumerable<ExternalAppsWhereInput>
    OR?: Enumerable<ExternalAppsWhereInput>
    NOT?: Enumerable<ExternalAppsWhereInput>
    Id?: StringFilter | string
    ExternalAppTypeId?: StringNullableFilter | string | null
    ExternalAppEnvironment?: StringNullableFilter | string | null
    RepositoryId?: StringNullableFilter | string | null
    Name?: StringNullableFilter | string | null
    Description?: StringNullableFilter | string | null
    EndPointURL?: StringNullableFilter | string | null
    IsExternal?: IntNullableFilter | number | null
    ExternalPath?: StringNullableFilter | string | null
    Username?: StringNullableFilter | string | null
    Password?: StringNullableFilter | string | null
    ProjectId?: StringNullableFilter | string | null
    ProjectName?: StringNullableFilter | string | null
    ConfigData?: StringNullableFilter | string | null
    IsEnabled?: IntFilter | number
    Created?: DateTimeFilter | Date | string
    Modified?: DateTimeNullableFilter | Date | string | null
  }

  export type ExternalAppsOrderByWithRelationInput = {
    Id?: SortOrder
    ExternalAppTypeId?: SortOrder
    ExternalAppEnvironment?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    EndPointURL?: SortOrder
    IsExternal?: SortOrder
    ExternalPath?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    ProjectId?: SortOrder
    ProjectName?: SortOrder
    ConfigData?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type ExternalAppsWhereUniqueInput = {
    Id?: string
  }

  export type ExternalAppsOrderByWithAggregationInput = {
    Id?: SortOrder
    ExternalAppTypeId?: SortOrder
    ExternalAppEnvironment?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    EndPointURL?: SortOrder
    IsExternal?: SortOrder
    ExternalPath?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    ProjectId?: SortOrder
    ProjectName?: SortOrder
    ConfigData?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    _count?: ExternalAppsCountOrderByAggregateInput
    _avg?: ExternalAppsAvgOrderByAggregateInput
    _max?: ExternalAppsMaxOrderByAggregateInput
    _min?: ExternalAppsMinOrderByAggregateInput
    _sum?: ExternalAppsSumOrderByAggregateInput
  }

  export type ExternalAppsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExternalAppsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExternalAppsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExternalAppsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    ExternalAppTypeId?: StringNullableWithAggregatesFilter | string | null
    ExternalAppEnvironment?: StringNullableWithAggregatesFilter | string | null
    RepositoryId?: StringNullableWithAggregatesFilter | string | null
    Name?: StringNullableWithAggregatesFilter | string | null
    Description?: StringNullableWithAggregatesFilter | string | null
    EndPointURL?: StringNullableWithAggregatesFilter | string | null
    IsExternal?: IntNullableWithAggregatesFilter | number | null
    ExternalPath?: StringNullableWithAggregatesFilter | string | null
    Username?: StringNullableWithAggregatesFilter | string | null
    Password?: StringNullableWithAggregatesFilter | string | null
    ProjectId?: StringNullableWithAggregatesFilter | string | null
    ProjectName?: StringNullableWithAggregatesFilter | string | null
    ConfigData?: StringNullableWithAggregatesFilter | string | null
    IsEnabled?: IntWithAggregatesFilter | number
    Created?: DateTimeWithAggregatesFilter | Date | string
    Modified?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ExternalAppTypesWhereInput = {
    AND?: Enumerable<ExternalAppTypesWhereInput>
    OR?: Enumerable<ExternalAppTypesWhereInput>
    NOT?: Enumerable<ExternalAppTypesWhereInput>
    Id?: StringFilter | string
    Name?: StringNullableFilter | string | null
    Description?: StringNullableFilter | string | null
    IsExternal?: IntNullableFilter | number | null
    ExternalPath?: StringNullableFilter | string | null
    Logo?: StringNullableFilter | string | null
    Position?: IntFilter | number
    IsEnabled?: IntFilter | number
    AppContent?: StringNullableFilter | string | null
  }

  export type ExternalAppTypesOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    IsExternal?: SortOrder
    ExternalPath?: SortOrder
    Logo?: SortOrder
    Position?: SortOrder
    IsEnabled?: SortOrder
    AppContent?: SortOrder
  }

  export type ExternalAppTypesWhereUniqueInput = {
    Id?: string
  }

  export type ExternalAppTypesOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    IsExternal?: SortOrder
    ExternalPath?: SortOrder
    Logo?: SortOrder
    Position?: SortOrder
    IsEnabled?: SortOrder
    AppContent?: SortOrder
    _count?: ExternalAppTypesCountOrderByAggregateInput
    _avg?: ExternalAppTypesAvgOrderByAggregateInput
    _max?: ExternalAppTypesMaxOrderByAggregateInput
    _min?: ExternalAppTypesMinOrderByAggregateInput
    _sum?: ExternalAppTypesSumOrderByAggregateInput
  }

  export type ExternalAppTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExternalAppTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExternalAppTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExternalAppTypesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Name?: StringNullableWithAggregatesFilter | string | null
    Description?: StringNullableWithAggregatesFilter | string | null
    IsExternal?: IntNullableWithAggregatesFilter | number | null
    ExternalPath?: StringNullableWithAggregatesFilter | string | null
    Logo?: StringNullableWithAggregatesFilter | string | null
    Position?: IntWithAggregatesFilter | number
    IsEnabled?: IntWithAggregatesFilter | number
    AppContent?: StringNullableWithAggregatesFilter | string | null
  }

  export type FeaturesWhereInput = {
    AND?: Enumerable<FeaturesWhereInput>
    OR?: Enumerable<FeaturesWhereInput>
    NOT?: Enumerable<FeaturesWhereInput>
    Id?: StringFilter | string
    Name?: StringNullableFilter | string | null
    Status?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    FeatureKey?: StringNullableFilter | string | null
  }

  export type FeaturesOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    FeatureKey?: SortOrder
  }

  export type FeaturesWhereUniqueInput = {
    Id?: string
  }

  export type FeaturesOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    FeatureKey?: SortOrder
    _count?: FeaturesCountOrderByAggregateInput
    _max?: FeaturesMaxOrderByAggregateInput
    _min?: FeaturesMinOrderByAggregateInput
  }

  export type FeaturesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FeaturesScalarWhereWithAggregatesInput>
    OR?: Enumerable<FeaturesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FeaturesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Name?: StringNullableWithAggregatesFilter | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    FeatureKey?: StringNullableWithAggregatesFilter | string | null
  }

  export type FilterProfileConnectorsWhereInput = {
    AND?: Enumerable<FilterProfileConnectorsWhereInput>
    OR?: Enumerable<FilterProfileConnectorsWhereInput>
    NOT?: Enumerable<FilterProfileConnectorsWhereInput>
    Id?: StringFilter | string
    RepositoryId?: StringFilter | string
    ProfileId?: StringFilter | string
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
    CreatedBy?: StringNullableFilter | string | null
    ModifiedBy?: StringNullableFilter | string | null
  }

  export type FilterProfileConnectorsOrderByWithRelationInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    ProfileId?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
  }

  export type FilterProfileConnectorsWhereUniqueInput = {
    Id?: string
  }

  export type FilterProfileConnectorsOrderByWithAggregationInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    ProfileId?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
    _count?: FilterProfileConnectorsCountOrderByAggregateInput
    _max?: FilterProfileConnectorsMaxOrderByAggregateInput
    _min?: FilterProfileConnectorsMinOrderByAggregateInput
  }

  export type FilterProfileConnectorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FilterProfileConnectorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<FilterProfileConnectorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FilterProfileConnectorsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    RepositoryId?: StringWithAggregatesFilter | string
    ProfileId?: StringWithAggregatesFilter | string
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    CreatedBy?: StringNullableWithAggregatesFilter | string | null
    ModifiedBy?: StringNullableWithAggregatesFilter | string | null
  }

  export type FilterProfilesWhereInput = {
    AND?: Enumerable<FilterProfilesWhereInput>
    OR?: Enumerable<FilterProfilesWhereInput>
    NOT?: Enumerable<FilterProfilesWhereInput>
    Id?: StringFilter | string
    Name?: StringNullableFilter | string | null
    Type?: StringNullableFilter | string | null
    Status?: IntFilter | number
    Configuration?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
    CreatedBy?: StringNullableFilter | string | null
    ModifiedBy?: StringNullableFilter | string | null
    IsCacheEnabled?: IntNullableFilter | number | null
  }

  export type FilterProfilesOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Type?: SortOrder
    Status?: SortOrder
    Configuration?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
    IsCacheEnabled?: SortOrder
  }

  export type FilterProfilesWhereUniqueInput = {
    Id?: string
  }

  export type FilterProfilesOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Type?: SortOrder
    Status?: SortOrder
    Configuration?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
    IsCacheEnabled?: SortOrder
    _count?: FilterProfilesCountOrderByAggregateInput
    _avg?: FilterProfilesAvgOrderByAggregateInput
    _max?: FilterProfilesMaxOrderByAggregateInput
    _min?: FilterProfilesMinOrderByAggregateInput
    _sum?: FilterProfilesSumOrderByAggregateInput
  }

  export type FilterProfilesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FilterProfilesScalarWhereWithAggregatesInput>
    OR?: Enumerable<FilterProfilesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FilterProfilesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Name?: StringNullableWithAggregatesFilter | string | null
    Type?: StringNullableWithAggregatesFilter | string | null
    Status?: IntWithAggregatesFilter | number
    Configuration?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    CreatedBy?: StringNullableWithAggregatesFilter | string | null
    ModifiedBy?: StringNullableWithAggregatesFilter | string | null
    IsCacheEnabled?: IntNullableWithAggregatesFilter | number | null
  }

  export type GlobalRepositoryConfigurationsWhereInput = {
    AND?: Enumerable<GlobalRepositoryConfigurationsWhereInput>
    OR?: Enumerable<GlobalRepositoryConfigurationsWhereInput>
    NOT?: Enumerable<GlobalRepositoryConfigurationsWhereInput>
    Id?: StringFilter | string
    Name?: StringFilter | string
    IsReadOnly?: IntFilter | number
    RepositoryConfiguration?: StringNullableFilter | string | null
    AllowAllRepository?: IntFilter | number
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type GlobalRepositoryConfigurationsOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    IsReadOnly?: SortOrder
    RepositoryConfiguration?: SortOrder
    AllowAllRepository?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type GlobalRepositoryConfigurationsWhereUniqueInput = {
    Id?: string
  }

  export type GlobalRepositoryConfigurationsOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    IsReadOnly?: SortOrder
    RepositoryConfiguration?: SortOrder
    AllowAllRepository?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: GlobalRepositoryConfigurationsCountOrderByAggregateInput
    _avg?: GlobalRepositoryConfigurationsAvgOrderByAggregateInput
    _max?: GlobalRepositoryConfigurationsMaxOrderByAggregateInput
    _min?: GlobalRepositoryConfigurationsMinOrderByAggregateInput
    _sum?: GlobalRepositoryConfigurationsSumOrderByAggregateInput
  }

  export type GlobalRepositoryConfigurationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GlobalRepositoryConfigurationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<GlobalRepositoryConfigurationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GlobalRepositoryConfigurationsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
    IsReadOnly?: IntWithAggregatesFilter | number
    RepositoryConfiguration?: StringNullableWithAggregatesFilter | string | null
    AllowAllRepository?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type GroupFeaturesWhereInput = {
    AND?: Enumerable<GroupFeaturesWhereInput>
    OR?: Enumerable<GroupFeaturesWhereInput>
    NOT?: Enumerable<GroupFeaturesWhereInput>
    Id?: StringFilter | string
    UserGroup_Id?: StringNullableFilter | string | null
    Feature_Id?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    Status?: StringNullableFilter | string | null
  }

  export type GroupFeaturesOrderByWithRelationInput = {
    Id?: SortOrder
    UserGroup_Id?: SortOrder
    Feature_Id?: SortOrder
    CreatedDate?: SortOrder
    Status?: SortOrder
  }

  export type GroupFeaturesWhereUniqueInput = {
    Id?: string
  }

  export type GroupFeaturesOrderByWithAggregationInput = {
    Id?: SortOrder
    UserGroup_Id?: SortOrder
    Feature_Id?: SortOrder
    CreatedDate?: SortOrder
    Status?: SortOrder
    _count?: GroupFeaturesCountOrderByAggregateInput
    _max?: GroupFeaturesMaxOrderByAggregateInput
    _min?: GroupFeaturesMinOrderByAggregateInput
  }

  export type GroupFeaturesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GroupFeaturesScalarWhereWithAggregatesInput>
    OR?: Enumerable<GroupFeaturesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GroupFeaturesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    UserGroup_Id?: StringNullableWithAggregatesFilter | string | null
    Feature_Id?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
  }

  export type GuestSignupSettingsWhereInput = {
    AND?: Enumerable<GuestSignupSettingsWhereInput>
    OR?: Enumerable<GuestSignupSettingsWhereInput>
    NOT?: Enumerable<GuestSignupSettingsWhereInput>
    Id?: StringFilter | string
    GlobalRepoConfigId?: StringNullableFilter | string | null
    AllowAllRepository?: IntNullableFilter | number | null
    RepositoryPermissions?: StringNullableFilter | string | null
    Status?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type GuestSignupSettingsOrderByWithRelationInput = {
    Id?: SortOrder
    GlobalRepoConfigId?: SortOrder
    AllowAllRepository?: SortOrder
    RepositoryPermissions?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type GuestSignupSettingsWhereUniqueInput = {
    Id?: string
  }

  export type GuestSignupSettingsOrderByWithAggregationInput = {
    Id?: SortOrder
    GlobalRepoConfigId?: SortOrder
    AllowAllRepository?: SortOrder
    RepositoryPermissions?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: GuestSignupSettingsCountOrderByAggregateInput
    _avg?: GuestSignupSettingsAvgOrderByAggregateInput
    _max?: GuestSignupSettingsMaxOrderByAggregateInput
    _min?: GuestSignupSettingsMinOrderByAggregateInput
    _sum?: GuestSignupSettingsSumOrderByAggregateInput
  }

  export type GuestSignupSettingsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GuestSignupSettingsScalarWhereWithAggregatesInput>
    OR?: Enumerable<GuestSignupSettingsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GuestSignupSettingsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    GlobalRepoConfigId?: StringNullableWithAggregatesFilter | string | null
    AllowAllRepository?: IntNullableWithAggregatesFilter | number | null
    RepositoryPermissions?: StringNullableWithAggregatesFilter | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type IdPConnectionsWhereInput = {
    AND?: Enumerable<IdPConnectionsWhereInput>
    OR?: Enumerable<IdPConnectionsWhereInput>
    NOT?: Enumerable<IdPConnectionsWhereInput>
    Id?: StringFilter | string
    Name?: StringNullableFilter | string | null
    SigninUrl?: StringNullableFilter | string | null
    CertificatePath?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
    Status?: StringNullableFilter | string | null
    AllowAllRepository?: IntNullableFilter | number | null
    RepositoryPermissions?: StringNullableFilter | string | null
    RepositoryPermissionId?: StringNullableFilter | string | null
    IdPSource?: StringNullableFilter | string | null
    LogoutUrl?: StringNullableFilter | string | null
    IDPCertificateEncrypted?: StringNullableFilter | string | null
    SPCertificateEncrypted?: StringNullableFilter | string | null
    SPCertificatePath?: StringNullableFilter | string | null
    SPCertificatePassword?: StringNullableFilter | string | null
    GlobalRepoConfigId?: StringNullableFilter | string | null
    AttributesMapping?: StringNullableFilter | string | null
  }

  export type IdPConnectionsOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    SigninUrl?: SortOrder
    CertificatePath?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    AllowAllRepository?: SortOrder
    RepositoryPermissions?: SortOrder
    RepositoryPermissionId?: SortOrder
    IdPSource?: SortOrder
    LogoutUrl?: SortOrder
    IDPCertificateEncrypted?: SortOrder
    SPCertificateEncrypted?: SortOrder
    SPCertificatePath?: SortOrder
    SPCertificatePassword?: SortOrder
    GlobalRepoConfigId?: SortOrder
    AttributesMapping?: SortOrder
  }

  export type IdPConnectionsWhereUniqueInput = {
    Id?: string
  }

  export type IdPConnectionsOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    SigninUrl?: SortOrder
    CertificatePath?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    AllowAllRepository?: SortOrder
    RepositoryPermissions?: SortOrder
    RepositoryPermissionId?: SortOrder
    IdPSource?: SortOrder
    LogoutUrl?: SortOrder
    IDPCertificateEncrypted?: SortOrder
    SPCertificateEncrypted?: SortOrder
    SPCertificatePath?: SortOrder
    SPCertificatePassword?: SortOrder
    GlobalRepoConfigId?: SortOrder
    AttributesMapping?: SortOrder
    _count?: IdPConnectionsCountOrderByAggregateInput
    _avg?: IdPConnectionsAvgOrderByAggregateInput
    _max?: IdPConnectionsMaxOrderByAggregateInput
    _min?: IdPConnectionsMinOrderByAggregateInput
    _sum?: IdPConnectionsSumOrderByAggregateInput
  }

  export type IdPConnectionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IdPConnectionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<IdPConnectionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IdPConnectionsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Name?: StringNullableWithAggregatesFilter | string | null
    SigninUrl?: StringNullableWithAggregatesFilter | string | null
    CertificatePath?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
    AllowAllRepository?: IntNullableWithAggregatesFilter | number | null
    RepositoryPermissions?: StringNullableWithAggregatesFilter | string | null
    RepositoryPermissionId?: StringNullableWithAggregatesFilter | string | null
    IdPSource?: StringNullableWithAggregatesFilter | string | null
    LogoutUrl?: StringNullableWithAggregatesFilter | string | null
    IDPCertificateEncrypted?: StringNullableWithAggregatesFilter | string | null
    SPCertificateEncrypted?: StringNullableWithAggregatesFilter | string | null
    SPCertificatePath?: StringNullableWithAggregatesFilter | string | null
    SPCertificatePassword?: StringNullableWithAggregatesFilter | string | null
    GlobalRepoConfigId?: StringNullableWithAggregatesFilter | string | null
    AttributesMapping?: StringNullableWithAggregatesFilter | string | null
  }

  export type LDAPConnectionsWhereInput = {
    AND?: Enumerable<LDAPConnectionsWhereInput>
    OR?: Enumerable<LDAPConnectionsWhereInput>
    NOT?: Enumerable<LDAPConnectionsWhereInput>
    Id?: StringFilter | string
    Name?: StringNullableFilter | string | null
    Server?: StringNullableFilter | string | null
    Port?: IntNullableFilter | number | null
    Domain?: StringNullableFilter | string | null
    UserName?: StringNullableFilter | string | null
    Password?: StringNullableFilter | string | null
    SSL?: IntNullableFilter | number | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
    Status?: StringNullableFilter | string | null
  }

  export type LDAPConnectionsOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    Domain?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    SSL?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
  }

  export type LDAPConnectionsWhereUniqueInput = {
    Id?: string
  }

  export type LDAPConnectionsOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    Domain?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    SSL?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    _count?: LDAPConnectionsCountOrderByAggregateInput
    _avg?: LDAPConnectionsAvgOrderByAggregateInput
    _max?: LDAPConnectionsMaxOrderByAggregateInput
    _min?: LDAPConnectionsMinOrderByAggregateInput
    _sum?: LDAPConnectionsSumOrderByAggregateInput
  }

  export type LDAPConnectionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LDAPConnectionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<LDAPConnectionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LDAPConnectionsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Name?: StringNullableWithAggregatesFilter | string | null
    Server?: StringNullableWithAggregatesFilter | string | null
    Port?: IntNullableWithAggregatesFilter | number | null
    Domain?: StringNullableWithAggregatesFilter | string | null
    UserName?: StringNullableWithAggregatesFilter | string | null
    Password?: StringNullableWithAggregatesFilter | string | null
    SSL?: IntNullableWithAggregatesFilter | number | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
  }

  export type MDGProfileConnectorsWhereInput = {
    AND?: Enumerable<MDGProfileConnectorsWhereInput>
    OR?: Enumerable<MDGProfileConnectorsWhereInput>
    NOT?: Enumerable<MDGProfileConnectorsWhereInput>
    Id?: StringFilter | string
    UserGroupId?: StringNullableFilter | string | null
    ProfileId?: StringNullableFilter | string | null
    MdgId?: StringNullableFilter | string | null
    RepositoryId?: StringNullableFilter | string | null
    Status?: IntNullableFilter | number | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type MDGProfileConnectorsOrderByWithRelationInput = {
    Id?: SortOrder
    UserGroupId?: SortOrder
    ProfileId?: SortOrder
    MdgId?: SortOrder
    RepositoryId?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
  }

  export type MDGProfileConnectorsWhereUniqueInput = {
    Id?: string
  }

  export type MDGProfileConnectorsOrderByWithAggregationInput = {
    Id?: SortOrder
    UserGroupId?: SortOrder
    ProfileId?: SortOrder
    MdgId?: SortOrder
    RepositoryId?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    _count?: MDGProfileConnectorsCountOrderByAggregateInput
    _avg?: MDGProfileConnectorsAvgOrderByAggregateInput
    _max?: MDGProfileConnectorsMaxOrderByAggregateInput
    _min?: MDGProfileConnectorsMinOrderByAggregateInput
    _sum?: MDGProfileConnectorsSumOrderByAggregateInput
  }

  export type MDGProfileConnectorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MDGProfileConnectorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<MDGProfileConnectorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MDGProfileConnectorsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    UserGroupId?: StringNullableWithAggregatesFilter | string | null
    ProfileId?: StringNullableWithAggregatesFilter | string | null
    MdgId?: StringNullableWithAggregatesFilter | string | null
    RepositoryId?: StringNullableWithAggregatesFilter | string | null
    Status?: IntNullableWithAggregatesFilter | number | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type MDGTechnologiesWhereInput = {
    AND?: Enumerable<MDGTechnologiesWhereInput>
    OR?: Enumerable<MDGTechnologiesWhereInput>
    NOT?: Enumerable<MDGTechnologiesWhereInput>
    Id?: StringFilter | string
    Repository_Id?: StringFilter | string
    Name?: StringFilter | string
    InternalName?: StringNullableFilter | string | null
    Description?: StringNullableFilter | string | null
    XmlContent?: StringNullableFilter | string | null
    BuiltIn?: IntFilter | number
    IsEnabled?: IntFilter | number
    Created?: DateTimeFilter | Date | string
    Modified?: DateTimeFilter | Date | string
  }

  export type MDGTechnologiesOrderByWithRelationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    Name?: SortOrder
    InternalName?: SortOrder
    Description?: SortOrder
    XmlContent?: SortOrder
    BuiltIn?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type MDGTechnologiesWhereUniqueInput = {
    Id?: string
  }

  export type MDGTechnologiesOrderByWithAggregationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    Name?: SortOrder
    InternalName?: SortOrder
    Description?: SortOrder
    XmlContent?: SortOrder
    BuiltIn?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    _count?: MDGTechnologiesCountOrderByAggregateInput
    _avg?: MDGTechnologiesAvgOrderByAggregateInput
    _max?: MDGTechnologiesMaxOrderByAggregateInput
    _min?: MDGTechnologiesMinOrderByAggregateInput
    _sum?: MDGTechnologiesSumOrderByAggregateInput
  }

  export type MDGTechnologiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MDGTechnologiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<MDGTechnologiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MDGTechnologiesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Repository_Id?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
    InternalName?: StringNullableWithAggregatesFilter | string | null
    Description?: StringNullableWithAggregatesFilter | string | null
    XmlContent?: StringNullableWithAggregatesFilter | string | null
    BuiltIn?: IntWithAggregatesFilter | number
    IsEnabled?: IntWithAggregatesFilter | number
    Created?: DateTimeWithAggregatesFilter | Date | string
    Modified?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MenuItemProfileConnectorsWhereInput = {
    AND?: Enumerable<MenuItemProfileConnectorsWhereInput>
    OR?: Enumerable<MenuItemProfileConnectorsWhereInput>
    NOT?: Enumerable<MenuItemProfileConnectorsWhereInput>
    Id?: StringFilter | string
    Repository_Id?: StringNullableFilter | string | null
    User_Id?: StringNullableFilter | string | null
    UserGroup_Id?: StringNullableFilter | string | null
    Profile_Id?: StringNullableFilter | string | null
    Default_Profile_Id?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type MenuItemProfileConnectorsOrderByWithRelationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    Profile_Id?: SortOrder
    Default_Profile_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuItemProfileConnectorsWhereUniqueInput = {
    Id?: string
  }

  export type MenuItemProfileConnectorsOrderByWithAggregationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    Profile_Id?: SortOrder
    Default_Profile_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: MenuItemProfileConnectorsCountOrderByAggregateInput
    _max?: MenuItemProfileConnectorsMaxOrderByAggregateInput
    _min?: MenuItemProfileConnectorsMinOrderByAggregateInput
  }

  export type MenuItemProfileConnectorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MenuItemProfileConnectorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<MenuItemProfileConnectorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MenuItemProfileConnectorsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Repository_Id?: StringNullableWithAggregatesFilter | string | null
    User_Id?: StringNullableWithAggregatesFilter | string | null
    UserGroup_Id?: StringNullableWithAggregatesFilter | string | null
    Profile_Id?: StringNullableWithAggregatesFilter | string | null
    Default_Profile_Id?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type MenuItemProfilesWhereInput = {
    AND?: Enumerable<MenuItemProfilesWhereInput>
    OR?: Enumerable<MenuItemProfilesWhereInput>
    NOT?: Enumerable<MenuItemProfilesWhereInput>
    Id?: StringFilter | string
    Repository_Id?: StringNullableFilter | string | null
    Name?: StringNullableFilter | string | null
    Type?: StringNullableFilter | string | null
    Status?: IntFilter | number
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type MenuItemProfilesOrderByWithRelationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    Name?: SortOrder
    Type?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuItemProfilesWhereUniqueInput = {
    Id?: string
  }

  export type MenuItemProfilesOrderByWithAggregationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    Name?: SortOrder
    Type?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: MenuItemProfilesCountOrderByAggregateInput
    _avg?: MenuItemProfilesAvgOrderByAggregateInput
    _max?: MenuItemProfilesMaxOrderByAggregateInput
    _min?: MenuItemProfilesMinOrderByAggregateInput
    _sum?: MenuItemProfilesSumOrderByAggregateInput
  }

  export type MenuItemProfilesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MenuItemProfilesScalarWhereWithAggregatesInput>
    OR?: Enumerable<MenuItemProfilesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MenuItemProfilesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Repository_Id?: StringNullableWithAggregatesFilter | string | null
    Name?: StringNullableWithAggregatesFilter | string | null
    Type?: StringNullableWithAggregatesFilter | string | null
    Status?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type MenuItemProfileSettingsWhereInput = {
    AND?: Enumerable<MenuItemProfileSettingsWhereInput>
    OR?: Enumerable<MenuItemProfileSettingsWhereInput>
    NOT?: Enumerable<MenuItemProfileSettingsWhereInput>
    Id?: StringFilter | string
    Profile_Id?: StringNullableFilter | string | null
    MenuItemKey?: StringNullableFilter | string | null
    IsVisible?: IntNullableFilter | number | null
    IfShowOnlyContent?: IntNullableFilter | number | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type MenuItemProfileSettingsOrderByWithRelationInput = {
    Id?: SortOrder
    Profile_Id?: SortOrder
    MenuItemKey?: SortOrder
    IsVisible?: SortOrder
    IfShowOnlyContent?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuItemProfileSettingsWhereUniqueInput = {
    Id?: string
  }

  export type MenuItemProfileSettingsOrderByWithAggregationInput = {
    Id?: SortOrder
    Profile_Id?: SortOrder
    MenuItemKey?: SortOrder
    IsVisible?: SortOrder
    IfShowOnlyContent?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: MenuItemProfileSettingsCountOrderByAggregateInput
    _avg?: MenuItemProfileSettingsAvgOrderByAggregateInput
    _max?: MenuItemProfileSettingsMaxOrderByAggregateInput
    _min?: MenuItemProfileSettingsMinOrderByAggregateInput
    _sum?: MenuItemProfileSettingsSumOrderByAggregateInput
  }

  export type MenuItemProfileSettingsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MenuItemProfileSettingsScalarWhereWithAggregatesInput>
    OR?: Enumerable<MenuItemProfileSettingsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MenuItemProfileSettingsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Profile_Id?: StringNullableWithAggregatesFilter | string | null
    MenuItemKey?: StringNullableWithAggregatesFilter | string | null
    IsVisible?: IntNullableWithAggregatesFilter | number | null
    IfShowOnlyContent?: IntNullableWithAggregatesFilter | number | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type MenuViewHistoryWhereInput = {
    AND?: Enumerable<MenuViewHistoryWhereInput>
    OR?: Enumerable<MenuViewHistoryWhereInput>
    NOT?: Enumerable<MenuViewHistoryWhereInput>
    Id?: StringFilter | string
    RepositoryId?: StringNullableFilter | string | null
    UserId?: StringNullableFilter | string | null
    PageKeys?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type MenuViewHistoryOrderByWithRelationInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    UserId?: SortOrder
    PageKeys?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuViewHistoryWhereUniqueInput = {
    Id?: string
  }

  export type MenuViewHistoryOrderByWithAggregationInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    UserId?: SortOrder
    PageKeys?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: MenuViewHistoryCountOrderByAggregateInput
    _max?: MenuViewHistoryMaxOrderByAggregateInput
    _min?: MenuViewHistoryMinOrderByAggregateInput
  }

  export type MenuViewHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MenuViewHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<MenuViewHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MenuViewHistoryScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    RepositoryId?: StringNullableWithAggregatesFilter | string | null
    UserId?: StringNullableWithAggregatesFilter | string | null
    PageKeys?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type OIDCApplicationsWhereInput = {
    AND?: Enumerable<OIDCApplicationsWhereInput>
    OR?: Enumerable<OIDCApplicationsWhereInput>
    NOT?: Enumerable<OIDCApplicationsWhereInput>
    Id?: StringFilter | string
    ClientId?: StringNullableFilter | string | null
    ClientSecret?: StringNullableFilter | string | null
    ConcurrencyToken?: StringNullableFilter | string | null
    ConsentType?: StringNullableFilter | string | null
    DisplayName?: StringNullableFilter | string | null
    DisplayNames?: StringNullableFilter | string | null
    Permissions?: StringNullableFilter | string | null
    PostLogoutRedirectUris?: StringNullableFilter | string | null
    Properties?: StringNullableFilter | string | null
    RedirectUris?: StringNullableFilter | string | null
    Requirements?: StringNullableFilter | string | null
    Type?: StringNullableFilter | string | null
    OIDCAuthorizations?: OIDCAuthorizationsListRelationFilter
    OIDCTokens?: OIDCTokensListRelationFilter
  }

  export type OIDCApplicationsOrderByWithRelationInput = {
    Id?: SortOrder
    ClientId?: SortOrder
    ClientSecret?: SortOrder
    ConcurrencyToken?: SortOrder
    ConsentType?: SortOrder
    DisplayName?: SortOrder
    DisplayNames?: SortOrder
    Permissions?: SortOrder
    PostLogoutRedirectUris?: SortOrder
    Properties?: SortOrder
    RedirectUris?: SortOrder
    Requirements?: SortOrder
    Type?: SortOrder
    OIDCAuthorizations?: OIDCAuthorizationsOrderByRelationAggregateInput
    OIDCTokens?: OIDCTokensOrderByRelationAggregateInput
  }

  export type OIDCApplicationsWhereUniqueInput = {
    Id?: string
  }

  export type OIDCApplicationsOrderByWithAggregationInput = {
    Id?: SortOrder
    ClientId?: SortOrder
    ClientSecret?: SortOrder
    ConcurrencyToken?: SortOrder
    ConsentType?: SortOrder
    DisplayName?: SortOrder
    DisplayNames?: SortOrder
    Permissions?: SortOrder
    PostLogoutRedirectUris?: SortOrder
    Properties?: SortOrder
    RedirectUris?: SortOrder
    Requirements?: SortOrder
    Type?: SortOrder
    _count?: OIDCApplicationsCountOrderByAggregateInput
    _max?: OIDCApplicationsMaxOrderByAggregateInput
    _min?: OIDCApplicationsMinOrderByAggregateInput
  }

  export type OIDCApplicationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OIDCApplicationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<OIDCApplicationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OIDCApplicationsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    ClientId?: StringNullableWithAggregatesFilter | string | null
    ClientSecret?: StringNullableWithAggregatesFilter | string | null
    ConcurrencyToken?: StringNullableWithAggregatesFilter | string | null
    ConsentType?: StringNullableWithAggregatesFilter | string | null
    DisplayName?: StringNullableWithAggregatesFilter | string | null
    DisplayNames?: StringNullableWithAggregatesFilter | string | null
    Permissions?: StringNullableWithAggregatesFilter | string | null
    PostLogoutRedirectUris?: StringNullableWithAggregatesFilter | string | null
    Properties?: StringNullableWithAggregatesFilter | string | null
    RedirectUris?: StringNullableWithAggregatesFilter | string | null
    Requirements?: StringNullableWithAggregatesFilter | string | null
    Type?: StringNullableWithAggregatesFilter | string | null
  }

  export type OIDCAuthorizationsWhereInput = {
    AND?: Enumerable<OIDCAuthorizationsWhereInput>
    OR?: Enumerable<OIDCAuthorizationsWhereInput>
    NOT?: Enumerable<OIDCAuthorizationsWhereInput>
    Id?: StringFilter | string
    ApplicationId?: StringNullableFilter | string | null
    ConcurrencyToken?: StringNullableFilter | string | null
    CreationDate?: DateTimeNullableFilter | Date | string | null
    Properties?: StringNullableFilter | string | null
    Scopes?: StringNullableFilter | string | null
    Status?: StringNullableFilter | string | null
    Subject?: StringNullableFilter | string | null
    Type?: StringNullableFilter | string | null
    OIDCApplications?: XOR<OIDCApplicationsRelationFilter, OIDCApplicationsWhereInput> | null
    OIDCTokens?: OIDCTokensListRelationFilter
  }

  export type OIDCAuthorizationsOrderByWithRelationInput = {
    Id?: SortOrder
    ApplicationId?: SortOrder
    ConcurrencyToken?: SortOrder
    CreationDate?: SortOrder
    Properties?: SortOrder
    Scopes?: SortOrder
    Status?: SortOrder
    Subject?: SortOrder
    Type?: SortOrder
    OIDCApplications?: OIDCApplicationsOrderByWithRelationInput
    OIDCTokens?: OIDCTokensOrderByRelationAggregateInput
  }

  export type OIDCAuthorizationsWhereUniqueInput = {
    Id?: string
  }

  export type OIDCAuthorizationsOrderByWithAggregationInput = {
    Id?: SortOrder
    ApplicationId?: SortOrder
    ConcurrencyToken?: SortOrder
    CreationDate?: SortOrder
    Properties?: SortOrder
    Scopes?: SortOrder
    Status?: SortOrder
    Subject?: SortOrder
    Type?: SortOrder
    _count?: OIDCAuthorizationsCountOrderByAggregateInput
    _max?: OIDCAuthorizationsMaxOrderByAggregateInput
    _min?: OIDCAuthorizationsMinOrderByAggregateInput
  }

  export type OIDCAuthorizationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OIDCAuthorizationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<OIDCAuthorizationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OIDCAuthorizationsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    ApplicationId?: StringNullableWithAggregatesFilter | string | null
    ConcurrencyToken?: StringNullableWithAggregatesFilter | string | null
    CreationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Properties?: StringNullableWithAggregatesFilter | string | null
    Scopes?: StringNullableWithAggregatesFilter | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
    Subject?: StringNullableWithAggregatesFilter | string | null
    Type?: StringNullableWithAggregatesFilter | string | null
  }

  export type OIDCScopesWhereInput = {
    AND?: Enumerable<OIDCScopesWhereInput>
    OR?: Enumerable<OIDCScopesWhereInput>
    NOT?: Enumerable<OIDCScopesWhereInput>
    Id?: StringFilter | string
    ConcurrencyToken?: StringNullableFilter | string | null
    Description?: StringNullableFilter | string | null
    Descriptions?: StringNullableFilter | string | null
    DisplayName?: StringNullableFilter | string | null
    DisplayNames?: StringNullableFilter | string | null
    Name?: StringNullableFilter | string | null
    Properties?: StringNullableFilter | string | null
    Resources?: StringNullableFilter | string | null
  }

  export type OIDCScopesOrderByWithRelationInput = {
    Id?: SortOrder
    ConcurrencyToken?: SortOrder
    Description?: SortOrder
    Descriptions?: SortOrder
    DisplayName?: SortOrder
    DisplayNames?: SortOrder
    Name?: SortOrder
    Properties?: SortOrder
    Resources?: SortOrder
  }

  export type OIDCScopesWhereUniqueInput = {
    Id?: string
  }

  export type OIDCScopesOrderByWithAggregationInput = {
    Id?: SortOrder
    ConcurrencyToken?: SortOrder
    Description?: SortOrder
    Descriptions?: SortOrder
    DisplayName?: SortOrder
    DisplayNames?: SortOrder
    Name?: SortOrder
    Properties?: SortOrder
    Resources?: SortOrder
    _count?: OIDCScopesCountOrderByAggregateInput
    _max?: OIDCScopesMaxOrderByAggregateInput
    _min?: OIDCScopesMinOrderByAggregateInput
  }

  export type OIDCScopesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OIDCScopesScalarWhereWithAggregatesInput>
    OR?: Enumerable<OIDCScopesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OIDCScopesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    ConcurrencyToken?: StringNullableWithAggregatesFilter | string | null
    Description?: StringNullableWithAggregatesFilter | string | null
    Descriptions?: StringNullableWithAggregatesFilter | string | null
    DisplayName?: StringNullableWithAggregatesFilter | string | null
    DisplayNames?: StringNullableWithAggregatesFilter | string | null
    Name?: StringNullableWithAggregatesFilter | string | null
    Properties?: StringNullableWithAggregatesFilter | string | null
    Resources?: StringNullableWithAggregatesFilter | string | null
  }

  export type OIDCTokensWhereInput = {
    AND?: Enumerable<OIDCTokensWhereInput>
    OR?: Enumerable<OIDCTokensWhereInput>
    NOT?: Enumerable<OIDCTokensWhereInput>
    Id?: StringFilter | string
    ApplicationId?: StringNullableFilter | string | null
    AuthorizationId?: StringNullableFilter | string | null
    ConcurrencyToken?: StringNullableFilter | string | null
    CreationDate?: DateTimeNullableFilter | Date | string | null
    ExpirationDate?: DateTimeNullableFilter | Date | string | null
    Payload?: StringNullableFilter | string | null
    Properties?: StringNullableFilter | string | null
    RedemptionDate?: DateTimeNullableFilter | Date | string | null
    ReferenceId?: StringNullableFilter | string | null
    Status?: StringNullableFilter | string | null
    Subject?: StringNullableFilter | string | null
    Type?: StringNullableFilter | string | null
    OIDCApplications?: XOR<OIDCApplicationsRelationFilter, OIDCApplicationsWhereInput> | null
    OIDCAuthorizations?: XOR<OIDCAuthorizationsRelationFilter, OIDCAuthorizationsWhereInput> | null
  }

  export type OIDCTokensOrderByWithRelationInput = {
    Id?: SortOrder
    ApplicationId?: SortOrder
    AuthorizationId?: SortOrder
    ConcurrencyToken?: SortOrder
    CreationDate?: SortOrder
    ExpirationDate?: SortOrder
    Payload?: SortOrder
    Properties?: SortOrder
    RedemptionDate?: SortOrder
    ReferenceId?: SortOrder
    Status?: SortOrder
    Subject?: SortOrder
    Type?: SortOrder
    OIDCApplications?: OIDCApplicationsOrderByWithRelationInput
    OIDCAuthorizations?: OIDCAuthorizationsOrderByWithRelationInput
  }

  export type OIDCTokensWhereUniqueInput = {
    Id?: string
  }

  export type OIDCTokensOrderByWithAggregationInput = {
    Id?: SortOrder
    ApplicationId?: SortOrder
    AuthorizationId?: SortOrder
    ConcurrencyToken?: SortOrder
    CreationDate?: SortOrder
    ExpirationDate?: SortOrder
    Payload?: SortOrder
    Properties?: SortOrder
    RedemptionDate?: SortOrder
    ReferenceId?: SortOrder
    Status?: SortOrder
    Subject?: SortOrder
    Type?: SortOrder
    _count?: OIDCTokensCountOrderByAggregateInput
    _max?: OIDCTokensMaxOrderByAggregateInput
    _min?: OIDCTokensMinOrderByAggregateInput
  }

  export type OIDCTokensScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OIDCTokensScalarWhereWithAggregatesInput>
    OR?: Enumerable<OIDCTokensScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OIDCTokensScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    ApplicationId?: StringNullableWithAggregatesFilter | string | null
    AuthorizationId?: StringNullableWithAggregatesFilter | string | null
    ConcurrencyToken?: StringNullableWithAggregatesFilter | string | null
    CreationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ExpirationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Payload?: StringNullableWithAggregatesFilter | string | null
    Properties?: StringNullableWithAggregatesFilter | string | null
    RedemptionDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ReferenceId?: StringNullableWithAggregatesFilter | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
    Subject?: StringNullableWithAggregatesFilter | string | null
    Type?: StringNullableWithAggregatesFilter | string | null
  }

  export type ProfilesWhereInput = {
    AND?: Enumerable<ProfilesWhereInput>
    OR?: Enumerable<ProfilesWhereInput>
    NOT?: Enumerable<ProfilesWhereInput>
    Id?: StringFilter | string
    MDGTechnology_Id?: StringFilter | string
    Name?: StringFilter | string
    Description?: StringNullableFilter | string | null
    ProfileContent?: StringNullableFilter | string | null
    IsDefault?: IntFilter | number
    IsEnabled?: IntFilter | number
    Created?: DateTimeFilter | Date | string
    Modified?: DateTimeFilter | Date | string
    EnableTechnologyGroup?: IntFilter | number
    EnableInheritedGroup?: IntFilter | number
    IncludeBaseAttributes?: IntFilter | number
  }

  export type ProfilesOrderByWithRelationInput = {
    Id?: SortOrder
    MDGTechnology_Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    ProfileContent?: SortOrder
    IsDefault?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    EnableTechnologyGroup?: SortOrder
    EnableInheritedGroup?: SortOrder
    IncludeBaseAttributes?: SortOrder
  }

  export type ProfilesWhereUniqueInput = {
    Id?: string
  }

  export type ProfilesOrderByWithAggregationInput = {
    Id?: SortOrder
    MDGTechnology_Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    ProfileContent?: SortOrder
    IsDefault?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    EnableTechnologyGroup?: SortOrder
    EnableInheritedGroup?: SortOrder
    IncludeBaseAttributes?: SortOrder
    _count?: ProfilesCountOrderByAggregateInput
    _avg?: ProfilesAvgOrderByAggregateInput
    _max?: ProfilesMaxOrderByAggregateInput
    _min?: ProfilesMinOrderByAggregateInput
    _sum?: ProfilesSumOrderByAggregateInput
  }

  export type ProfilesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProfilesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProfilesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProfilesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    MDGTechnology_Id?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
    Description?: StringNullableWithAggregatesFilter | string | null
    ProfileContent?: StringNullableWithAggregatesFilter | string | null
    IsDefault?: IntWithAggregatesFilter | number
    IsEnabled?: IntWithAggregatesFilter | number
    Created?: DateTimeWithAggregatesFilter | Date | string
    Modified?: DateTimeWithAggregatesFilter | Date | string
    EnableTechnologyGroup?: IntWithAggregatesFilter | number
    EnableInheritedGroup?: IntWithAggregatesFilter | number
    IncludeBaseAttributes?: IntWithAggregatesFilter | number
  }

  export type PropertyMenuItemConnectorsWhereInput = {
    AND?: Enumerable<PropertyMenuItemConnectorsWhereInput>
    OR?: Enumerable<PropertyMenuItemConnectorsWhereInput>
    NOT?: Enumerable<PropertyMenuItemConnectorsWhereInput>
    Id?: StringFilter | string
    MenuItemKey?: StringNullableFilter | string | null
    PageType?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type PropertyMenuItemConnectorsOrderByWithRelationInput = {
    Id?: SortOrder
    MenuItemKey?: SortOrder
    PageType?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type PropertyMenuItemConnectorsWhereUniqueInput = {
    Id?: string
  }

  export type PropertyMenuItemConnectorsOrderByWithAggregationInput = {
    Id?: SortOrder
    MenuItemKey?: SortOrder
    PageType?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: PropertyMenuItemConnectorsCountOrderByAggregateInput
    _max?: PropertyMenuItemConnectorsMaxOrderByAggregateInput
    _min?: PropertyMenuItemConnectorsMinOrderByAggregateInput
  }

  export type PropertyMenuItemConnectorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PropertyMenuItemConnectorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PropertyMenuItemConnectorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PropertyMenuItemConnectorsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    MenuItemKey?: StringNullableWithAggregatesFilter | string | null
    PageType?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type PropertyMenuItemsWhereInput = {
    AND?: Enumerable<PropertyMenuItemsWhereInput>
    OR?: Enumerable<PropertyMenuItemsWhereInput>
    NOT?: Enumerable<PropertyMenuItemsWhereInput>
    Id?: StringFilter | string
    MenuItemKey?: StringNullableFilter | string | null
    Name?: StringNullableFilter | string | null
    Description?: StringNullableFilter | string | null
    IconClass?: StringFilter | string
    Position?: IntFilter | number
    Status?: IntFilter | number
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type PropertyMenuItemsOrderByWithRelationInput = {
    Id?: SortOrder
    MenuItemKey?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    IconClass?: SortOrder
    Position?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type PropertyMenuItemsWhereUniqueInput = {
    Id?: string
    Position?: number
  }

  export type PropertyMenuItemsOrderByWithAggregationInput = {
    Id?: SortOrder
    MenuItemKey?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    IconClass?: SortOrder
    Position?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: PropertyMenuItemsCountOrderByAggregateInput
    _avg?: PropertyMenuItemsAvgOrderByAggregateInput
    _max?: PropertyMenuItemsMaxOrderByAggregateInput
    _min?: PropertyMenuItemsMinOrderByAggregateInput
    _sum?: PropertyMenuItemsSumOrderByAggregateInput
  }

  export type PropertyMenuItemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PropertyMenuItemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PropertyMenuItemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PropertyMenuItemsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    MenuItemKey?: StringNullableWithAggregatesFilter | string | null
    Name?: StringNullableWithAggregatesFilter | string | null
    Description?: StringNullableWithAggregatesFilter | string | null
    IconClass?: StringWithAggregatesFilter | string
    Position?: IntWithAggregatesFilter | number
    Status?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type RepositoriesWhereInput = {
    AND?: Enumerable<RepositoriesWhereInput>
    OR?: Enumerable<RepositoriesWhereInput>
    NOT?: Enumerable<RepositoriesWhereInput>
    Id?: StringFilter | string
    Name?: StringNullableFilter | string | null
    Alias?: StringNullableFilter | string | null
    Description?: StringNullableFilter | string | null
    EAPFile?: StringNullableFilter | string | null
    IsCacheEnabled?: IntNullableFilter | number | null
    AuthRequired?: IntNullableFilter | number | null
    UserName?: StringNullableFilter | string | null
    Password?: StringNullableFilter | string | null
    IsEnabled?: IntNullableFilter | number | null
    InstanceCount?: IntNullableFilter | number | null
    Created?: DateTimeFilter | Date | string
    Modified?: DateTimeFilter | Date | string
    Status?: StringNullableFilter | string | null
    Protocol?: StringNullableFilter | string | null
    Server?: StringNullableFilter | string | null
    Port?: StringNullableFilter | string | null
    Model?: StringNullableFilter | string | null
    OslcAccessCode?: StringNullableFilter | string | null
    EAUserAuth?: IntNullableFilter | number | null
    UserIdentifier?: StringNullableFilter | string | null
    DBType?: IntNullableFilter | number | null
  }

  export type RepositoriesOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Alias?: SortOrder
    Description?: SortOrder
    EAPFile?: SortOrder
    IsCacheEnabled?: SortOrder
    AuthRequired?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    IsEnabled?: SortOrder
    InstanceCount?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    Status?: SortOrder
    Protocol?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    Model?: SortOrder
    OslcAccessCode?: SortOrder
    EAUserAuth?: SortOrder
    UserIdentifier?: SortOrder
    DBType?: SortOrder
  }

  export type RepositoriesWhereUniqueInput = {
    Id?: string
  }

  export type RepositoriesOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Alias?: SortOrder
    Description?: SortOrder
    EAPFile?: SortOrder
    IsCacheEnabled?: SortOrder
    AuthRequired?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    IsEnabled?: SortOrder
    InstanceCount?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    Status?: SortOrder
    Protocol?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    Model?: SortOrder
    OslcAccessCode?: SortOrder
    EAUserAuth?: SortOrder
    UserIdentifier?: SortOrder
    DBType?: SortOrder
    _count?: RepositoriesCountOrderByAggregateInput
    _avg?: RepositoriesAvgOrderByAggregateInput
    _max?: RepositoriesMaxOrderByAggregateInput
    _min?: RepositoriesMinOrderByAggregateInput
    _sum?: RepositoriesSumOrderByAggregateInput
  }

  export type RepositoriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RepositoriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<RepositoriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RepositoriesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Name?: StringNullableWithAggregatesFilter | string | null
    Alias?: StringNullableWithAggregatesFilter | string | null
    Description?: StringNullableWithAggregatesFilter | string | null
    EAPFile?: StringNullableWithAggregatesFilter | string | null
    IsCacheEnabled?: IntNullableWithAggregatesFilter | number | null
    AuthRequired?: IntNullableWithAggregatesFilter | number | null
    UserName?: StringNullableWithAggregatesFilter | string | null
    Password?: StringNullableWithAggregatesFilter | string | null
    IsEnabled?: IntNullableWithAggregatesFilter | number | null
    InstanceCount?: IntNullableWithAggregatesFilter | number | null
    Created?: DateTimeWithAggregatesFilter | Date | string
    Modified?: DateTimeWithAggregatesFilter | Date | string
    Status?: StringNullableWithAggregatesFilter | string | null
    Protocol?: StringNullableWithAggregatesFilter | string | null
    Server?: StringNullableWithAggregatesFilter | string | null
    Port?: StringNullableWithAggregatesFilter | string | null
    Model?: StringNullableWithAggregatesFilter | string | null
    OslcAccessCode?: StringNullableWithAggregatesFilter | string | null
    EAUserAuth?: IntNullableWithAggregatesFilter | number | null
    UserIdentifier?: StringNullableWithAggregatesFilter | string | null
    DBType?: IntNullableWithAggregatesFilter | number | null
  }

  export type RepositoryConnectorsWhereInput = {
    AND?: Enumerable<RepositoryConnectorsWhereInput>
    OR?: Enumerable<RepositoryConnectorsWhereInput>
    NOT?: Enumerable<RepositoryConnectorsWhereInput>
    Id?: StringFilter | string
    Repository_Id?: StringFilter | string
    User_Id?: StringNullableFilter | string | null
    UserGroup_Id?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
    Status?: StringNullableFilter | string | null
    Dashboard_Id?: StringNullableFilter | string | null
    EAUserAuth?: IntNullableFilter | number | null
    IsUserDefault?: IntNullableFilter | number | null
  }

  export type RepositoryConnectorsOrderByWithRelationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    Dashboard_Id?: SortOrder
    EAUserAuth?: SortOrder
    IsUserDefault?: SortOrder
  }

  export type RepositoryConnectorsWhereUniqueInput = {
    Id?: string
  }

  export type RepositoryConnectorsOrderByWithAggregationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    Dashboard_Id?: SortOrder
    EAUserAuth?: SortOrder
    IsUserDefault?: SortOrder
    _count?: RepositoryConnectorsCountOrderByAggregateInput
    _avg?: RepositoryConnectorsAvgOrderByAggregateInput
    _max?: RepositoryConnectorsMaxOrderByAggregateInput
    _min?: RepositoryConnectorsMinOrderByAggregateInput
    _sum?: RepositoryConnectorsSumOrderByAggregateInput
  }

  export type RepositoryConnectorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RepositoryConnectorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<RepositoryConnectorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RepositoryConnectorsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Repository_Id?: StringWithAggregatesFilter | string
    User_Id?: StringNullableWithAggregatesFilter | string | null
    UserGroup_Id?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
    Dashboard_Id?: StringNullableWithAggregatesFilter | string | null
    EAUserAuth?: IntNullableWithAggregatesFilter | number | null
    IsUserDefault?: IntNullableWithAggregatesFilter | number | null
  }

  export type RepositoryDBConnectionsWhereInput = {
    AND?: Enumerable<RepositoryDBConnectionsWhereInput>
    OR?: Enumerable<RepositoryDBConnectionsWhereInput>
    NOT?: Enumerable<RepositoryDBConnectionsWhereInput>
    Id?: StringFilter | string
    Repository_Id?: StringNullableFilter | string | null
    CreateElement?: IntNullableFilter | number | null
    ConnectionType?: StringNullableFilter | string | null
    ConnectionDetail?: StringNullableFilter | string | null
    DBType?: StringNullableFilter | string | null
    Server?: StringNullableFilter | string | null
    Port?: StringNullableFilter | string | null
    DBName?: StringNullableFilter | string | null
    Username?: StringNullableFilter | string | null
    Password?: StringNullableFilter | string | null
    DsnName?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type RepositoryDBConnectionsOrderByWithRelationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    CreateElement?: SortOrder
    ConnectionType?: SortOrder
    ConnectionDetail?: SortOrder
    DBType?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    DBName?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    DsnName?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type RepositoryDBConnectionsWhereUniqueInput = {
    Id?: string
  }

  export type RepositoryDBConnectionsOrderByWithAggregationInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    CreateElement?: SortOrder
    ConnectionType?: SortOrder
    ConnectionDetail?: SortOrder
    DBType?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    DBName?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    DsnName?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: RepositoryDBConnectionsCountOrderByAggregateInput
    _avg?: RepositoryDBConnectionsAvgOrderByAggregateInput
    _max?: RepositoryDBConnectionsMaxOrderByAggregateInput
    _min?: RepositoryDBConnectionsMinOrderByAggregateInput
    _sum?: RepositoryDBConnectionsSumOrderByAggregateInput
  }

  export type RepositoryDBConnectionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RepositoryDBConnectionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<RepositoryDBConnectionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RepositoryDBConnectionsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Repository_Id?: StringNullableWithAggregatesFilter | string | null
    CreateElement?: IntNullableWithAggregatesFilter | number | null
    ConnectionType?: StringNullableWithAggregatesFilter | string | null
    ConnectionDetail?: StringNullableWithAggregatesFilter | string | null
    DBType?: StringNullableWithAggregatesFilter | string | null
    Server?: StringNullableWithAggregatesFilter | string | null
    Port?: StringNullableWithAggregatesFilter | string | null
    DBName?: StringNullableWithAggregatesFilter | string | null
    Username?: StringNullableWithAggregatesFilter | string | null
    Password?: StringNullableWithAggregatesFilter | string | null
    DsnName?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type RequestLogsWhereInput = {
    AND?: Enumerable<RequestLogsWhereInput>
    OR?: Enumerable<RequestLogsWhereInput>
    NOT?: Enumerable<RequestLogsWhereInput>
    Id?: StringFilter | string
    RequestedUserId?: StringNullableFilter | string | null
    DesignatedUserId?: StringNullableFilter | string | null
    Url?: StringNullableFilter | string | null
    UrlType?: StringNullableFilter | string | null
    RequestedUserAgent?: StringNullableFilter | string | null
    RequestedUserIpAddress?: StringNullableFilter | string | null
    DesignatedUserAgent?: StringNullableFilter | string | null
    DesignatedUserIpAddress?: StringNullableFilter | string | null
    Created?: DateTimeNullableFilter | Date | string | null
    Modified?: DateTimeNullableFilter | Date | string | null
    LastVisited?: DateTimeNullableFilter | Date | string | null
    Status?: IntNullableFilter | number | null
    Validity?: DateTimeNullableFilter | Date | string | null
  }

  export type RequestLogsOrderByWithRelationInput = {
    Id?: SortOrder
    RequestedUserId?: SortOrder
    DesignatedUserId?: SortOrder
    Url?: SortOrder
    UrlType?: SortOrder
    RequestedUserAgent?: SortOrder
    RequestedUserIpAddress?: SortOrder
    DesignatedUserAgent?: SortOrder
    DesignatedUserIpAddress?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    LastVisited?: SortOrder
    Status?: SortOrder
    Validity?: SortOrder
  }

  export type RequestLogsWhereUniqueInput = {
    Id?: string
  }

  export type RequestLogsOrderByWithAggregationInput = {
    Id?: SortOrder
    RequestedUserId?: SortOrder
    DesignatedUserId?: SortOrder
    Url?: SortOrder
    UrlType?: SortOrder
    RequestedUserAgent?: SortOrder
    RequestedUserIpAddress?: SortOrder
    DesignatedUserAgent?: SortOrder
    DesignatedUserIpAddress?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    LastVisited?: SortOrder
    Status?: SortOrder
    Validity?: SortOrder
    _count?: RequestLogsCountOrderByAggregateInput
    _avg?: RequestLogsAvgOrderByAggregateInput
    _max?: RequestLogsMaxOrderByAggregateInput
    _min?: RequestLogsMinOrderByAggregateInput
    _sum?: RequestLogsSumOrderByAggregateInput
  }

  export type RequestLogsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestLogsScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestLogsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestLogsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    RequestedUserId?: StringNullableWithAggregatesFilter | string | null
    DesignatedUserId?: StringNullableWithAggregatesFilter | string | null
    Url?: StringNullableWithAggregatesFilter | string | null
    UrlType?: StringNullableWithAggregatesFilter | string | null
    RequestedUserAgent?: StringNullableWithAggregatesFilter | string | null
    RequestedUserIpAddress?: StringNullableWithAggregatesFilter | string | null
    DesignatedUserAgent?: StringNullableWithAggregatesFilter | string | null
    DesignatedUserIpAddress?: StringNullableWithAggregatesFilter | string | null
    Created?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Modified?: DateTimeNullableWithAggregatesFilter | Date | string | null
    LastVisited?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Status?: IntNullableWithAggregatesFilter | number | null
    Validity?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ReservedUsersWhereInput = {
    AND?: Enumerable<ReservedUsersWhereInput>
    OR?: Enumerable<ReservedUsersWhereInput>
    NOT?: Enumerable<ReservedUsersWhereInput>
    Id?: StringFilter | string
    User_Id?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type ReservedUsersOrderByWithRelationInput = {
    Id?: SortOrder
    User_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type ReservedUsersWhereUniqueInput = {
    Id?: string
  }

  export type ReservedUsersOrderByWithAggregationInput = {
    Id?: SortOrder
    User_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: ReservedUsersCountOrderByAggregateInput
    _max?: ReservedUsersMaxOrderByAggregateInput
    _min?: ReservedUsersMinOrderByAggregateInput
  }

  export type ReservedUsersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReservedUsersScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReservedUsersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReservedUsersScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    User_Id?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ResourceFilesWhereInput = {
    AND?: Enumerable<ResourceFilesWhereInput>
    OR?: Enumerable<ResourceFilesWhereInput>
    NOT?: Enumerable<ResourceFilesWhereInput>
    Id?: StringFilter | string
    MapItemId?: StringNullableFilter | string | null
    FileContent?: BytesNullableFilter | Buffer | null
    FilePath?: StringNullableFilter | string | null
    Extension?: StringNullableFilter | string | null
    Name?: StringNullableFilter | string | null
    ModifiedDate?: DateTimeFilter | Date | string
    CreatedDate?: DateTimeFilter | Date | string
  }

  export type ResourceFilesOrderByWithRelationInput = {
    Id?: SortOrder
    MapItemId?: SortOrder
    FileContent?: SortOrder
    FilePath?: SortOrder
    Extension?: SortOrder
    Name?: SortOrder
    ModifiedDate?: SortOrder
    CreatedDate?: SortOrder
  }

  export type ResourceFilesWhereUniqueInput = {
    Id?: string
  }

  export type ResourceFilesOrderByWithAggregationInput = {
    Id?: SortOrder
    MapItemId?: SortOrder
    FileContent?: SortOrder
    FilePath?: SortOrder
    Extension?: SortOrder
    Name?: SortOrder
    ModifiedDate?: SortOrder
    CreatedDate?: SortOrder
    _count?: ResourceFilesCountOrderByAggregateInput
    _max?: ResourceFilesMaxOrderByAggregateInput
    _min?: ResourceFilesMinOrderByAggregateInput
  }

  export type ResourceFilesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ResourceFilesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ResourceFilesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ResourceFilesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    MapItemId?: StringNullableWithAggregatesFilter | string | null
    FileContent?: BytesNullableWithAggregatesFilter | Buffer | null
    FilePath?: StringNullableWithAggregatesFilter | string | null
    Extension?: StringNullableWithAggregatesFilter | string | null
    Name?: StringNullableWithAggregatesFilter | string | null
    ModifiedDate?: DateTimeWithAggregatesFilter | Date | string
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ResourcesWhereInput = {
    AND?: Enumerable<ResourcesWhereInput>
    OR?: Enumerable<ResourcesWhereInput>
    NOT?: Enumerable<ResourcesWhereInput>
    Id?: StringFilter | string
    ResourceName?: StringNullableFilter | string | null
  }

  export type ResourcesOrderByWithRelationInput = {
    Id?: SortOrder
    ResourceName?: SortOrder
  }

  export type ResourcesWhereUniqueInput = {
    Id?: string
  }

  export type ResourcesOrderByWithAggregationInput = {
    Id?: SortOrder
    ResourceName?: SortOrder
    _count?: ResourcesCountOrderByAggregateInput
    _max?: ResourcesMaxOrderByAggregateInput
    _min?: ResourcesMinOrderByAggregateInput
  }

  export type ResourcesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ResourcesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ResourcesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ResourcesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    ResourceName?: StringNullableWithAggregatesFilter | string | null
  }

  export type ReviewProcessesWhereInput = {
    AND?: Enumerable<ReviewProcessesWhereInput>
    OR?: Enumerable<ReviewProcessesWhereInput>
    NOT?: Enumerable<ReviewProcessesWhereInput>
    Id?: StringFilter | string
    Name?: StringNullableFilter | string | null
    Notes?: StringNullableFilter | string | null
    ReviewStartDate?: DateTimeNullableFilter | Date | string | null
    ReviewEndDate?: DateTimeNullableFilter | Date | string | null
    ApproveStartDate?: DateTimeNullableFilter | Date | string | null
    ApproveEndDate?: DateTimeNullableFilter | Date | string | null
    WorkFlow?: IntNullableFilter | number | null
    AutoStatusUpdate?: IntNullableFilter | number | null
    ReviewStartType?: IntNullableFilter | number | null
    ElementRecursiveSelection?: IntNullableFilter | number | null
    ExternalUsersInvite?: IntNullableFilter | number | null
    EnableShare?: IntNullableFilter | number | null
    EmailNotification?: IntNullableFilter | number | null
    Mode?: StringNullableFilter | string | null
    Repository_Id?: StringNullableFilter | string | null
    User_Id?: StringNullableFilter | string | null
    Status?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type ReviewProcessesOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    ReviewStartDate?: SortOrder
    ReviewEndDate?: SortOrder
    ApproveStartDate?: SortOrder
    ApproveEndDate?: SortOrder
    WorkFlow?: SortOrder
    AutoStatusUpdate?: SortOrder
    ReviewStartType?: SortOrder
    ElementRecursiveSelection?: SortOrder
    ExternalUsersInvite?: SortOrder
    EnableShare?: SortOrder
    EmailNotification?: SortOrder
    Mode?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type ReviewProcessesWhereUniqueInput = {
    Id?: string
  }

  export type ReviewProcessesOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    ReviewStartDate?: SortOrder
    ReviewEndDate?: SortOrder
    ApproveStartDate?: SortOrder
    ApproveEndDate?: SortOrder
    WorkFlow?: SortOrder
    AutoStatusUpdate?: SortOrder
    ReviewStartType?: SortOrder
    ElementRecursiveSelection?: SortOrder
    ExternalUsersInvite?: SortOrder
    EnableShare?: SortOrder
    EmailNotification?: SortOrder
    Mode?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: ReviewProcessesCountOrderByAggregateInput
    _avg?: ReviewProcessesAvgOrderByAggregateInput
    _max?: ReviewProcessesMaxOrderByAggregateInput
    _min?: ReviewProcessesMinOrderByAggregateInput
    _sum?: ReviewProcessesSumOrderByAggregateInput
  }

  export type ReviewProcessesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReviewProcessesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReviewProcessesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReviewProcessesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Name?: StringNullableWithAggregatesFilter | string | null
    Notes?: StringNullableWithAggregatesFilter | string | null
    ReviewStartDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ReviewEndDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ApproveStartDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ApproveEndDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    WorkFlow?: IntNullableWithAggregatesFilter | number | null
    AutoStatusUpdate?: IntNullableWithAggregatesFilter | number | null
    ReviewStartType?: IntNullableWithAggregatesFilter | number | null
    ElementRecursiveSelection?: IntNullableWithAggregatesFilter | number | null
    ExternalUsersInvite?: IntNullableWithAggregatesFilter | number | null
    EnableShare?: IntNullableWithAggregatesFilter | number | null
    EmailNotification?: IntNullableWithAggregatesFilter | number | null
    Mode?: StringNullableWithAggregatesFilter | string | null
    Repository_Id?: StringNullableWithAggregatesFilter | string | null
    User_Id?: StringNullableWithAggregatesFilter | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type TaggedValuesWhereInput = {
    AND?: Enumerable<TaggedValuesWhereInput>
    OR?: Enumerable<TaggedValuesWhereInput>
    NOT?: Enumerable<TaggedValuesWhereInput>
    Id?: StringFilter | string
    RepositoryId?: StringFilter | string
    Name?: StringFilter | string
    Description?: StringNullableFilter | string | null
    Type?: StringFilter | string
    DefaultValue?: StringNullableFilter | string | null
    AttributeValues?: StringNullableFilter | string | null
    LowerBound?: IntNullableFilter | number | null
    UpperBound?: IntNullableFilter | number | null
    Stereotypes?: StringNullableFilter | string | null
    AppliesTo?: StringNullableFilter | string | null
    BaseStereotype?: StringNullableFilter | string | null
  }

  export type TaggedValuesOrderByWithRelationInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    Type?: SortOrder
    DefaultValue?: SortOrder
    AttributeValues?: SortOrder
    LowerBound?: SortOrder
    UpperBound?: SortOrder
    Stereotypes?: SortOrder
    AppliesTo?: SortOrder
    BaseStereotype?: SortOrder
  }

  export type TaggedValuesWhereUniqueInput = {
    Id?: string
  }

  export type TaggedValuesOrderByWithAggregationInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    Type?: SortOrder
    DefaultValue?: SortOrder
    AttributeValues?: SortOrder
    LowerBound?: SortOrder
    UpperBound?: SortOrder
    Stereotypes?: SortOrder
    AppliesTo?: SortOrder
    BaseStereotype?: SortOrder
    _count?: TaggedValuesCountOrderByAggregateInput
    _avg?: TaggedValuesAvgOrderByAggregateInput
    _max?: TaggedValuesMaxOrderByAggregateInput
    _min?: TaggedValuesMinOrderByAggregateInput
    _sum?: TaggedValuesSumOrderByAggregateInput
  }

  export type TaggedValuesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TaggedValuesScalarWhereWithAggregatesInput>
    OR?: Enumerable<TaggedValuesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TaggedValuesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    RepositoryId?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
    Description?: StringNullableWithAggregatesFilter | string | null
    Type?: StringWithAggregatesFilter | string
    DefaultValue?: StringNullableWithAggregatesFilter | string | null
    AttributeValues?: StringNullableWithAggregatesFilter | string | null
    LowerBound?: IntNullableWithAggregatesFilter | number | null
    UpperBound?: IntNullableWithAggregatesFilter | number | null
    Stereotypes?: StringNullableWithAggregatesFilter | string | null
    AppliesTo?: StringNullableWithAggregatesFilter | string | null
    BaseStereotype?: StringNullableWithAggregatesFilter | string | null
  }

  export type TraceabilityTreeProfilesWhereInput = {
    AND?: Enumerable<TraceabilityTreeProfilesWhereInput>
    OR?: Enumerable<TraceabilityTreeProfilesWhereInput>
    NOT?: Enumerable<TraceabilityTreeProfilesWhereInput>
    Id?: StringFilter | string
    ProfileName?: StringNullableFilter | string | null
    RepositoryId?: StringNullableFilter | string | null
    ElementGuid?: StringNullableFilter | string | null
    Type?: StringNullableFilter | string | null
    SteroType?: StringNullableFilter | string | null
    FQName?: StringNullableFilter | string | null
    Technology?: StringNullableFilter | string | null
    TemplateOptions?: StringNullableFilter | string | null
    User_Id?: StringNullableFilter | string | null
    Status?: IntNullableFilter | number | null
    IsApplytoAll?: IntNullableFilter | number | null
    IsApplytoType?: IntNullableFilter | number | null
    IsApplytoSteroType?: IntNullableFilter | number | null
    Created?: DateTimeNullableFilter | Date | string | null
    Modified?: DateTimeNullableFilter | Date | string | null
    ElementTypeList?: StringNullableFilter | string | null
    ConnectorTypeList?: StringNullableFilter | string | null
    FlowDirectionTypeList?: StringNullableFilter | string | null
    TreeType?: StringNullableFilter | string | null
  }

  export type TraceabilityTreeProfilesOrderByWithRelationInput = {
    Id?: SortOrder
    ProfileName?: SortOrder
    RepositoryId?: SortOrder
    ElementGuid?: SortOrder
    Type?: SortOrder
    SteroType?: SortOrder
    FQName?: SortOrder
    Technology?: SortOrder
    TemplateOptions?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    IsApplytoAll?: SortOrder
    IsApplytoType?: SortOrder
    IsApplytoSteroType?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    ElementTypeList?: SortOrder
    ConnectorTypeList?: SortOrder
    FlowDirectionTypeList?: SortOrder
    TreeType?: SortOrder
  }

  export type TraceabilityTreeProfilesWhereUniqueInput = {
    Id?: string
  }

  export type TraceabilityTreeProfilesOrderByWithAggregationInput = {
    Id?: SortOrder
    ProfileName?: SortOrder
    RepositoryId?: SortOrder
    ElementGuid?: SortOrder
    Type?: SortOrder
    SteroType?: SortOrder
    FQName?: SortOrder
    Technology?: SortOrder
    TemplateOptions?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    IsApplytoAll?: SortOrder
    IsApplytoType?: SortOrder
    IsApplytoSteroType?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    ElementTypeList?: SortOrder
    ConnectorTypeList?: SortOrder
    FlowDirectionTypeList?: SortOrder
    TreeType?: SortOrder
    _count?: TraceabilityTreeProfilesCountOrderByAggregateInput
    _avg?: TraceabilityTreeProfilesAvgOrderByAggregateInput
    _max?: TraceabilityTreeProfilesMaxOrderByAggregateInput
    _min?: TraceabilityTreeProfilesMinOrderByAggregateInput
    _sum?: TraceabilityTreeProfilesSumOrderByAggregateInput
  }

  export type TraceabilityTreeProfilesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TraceabilityTreeProfilesScalarWhereWithAggregatesInput>
    OR?: Enumerable<TraceabilityTreeProfilesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TraceabilityTreeProfilesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    ProfileName?: StringNullableWithAggregatesFilter | string | null
    RepositoryId?: StringNullableWithAggregatesFilter | string | null
    ElementGuid?: StringNullableWithAggregatesFilter | string | null
    Type?: StringNullableWithAggregatesFilter | string | null
    SteroType?: StringNullableWithAggregatesFilter | string | null
    FQName?: StringNullableWithAggregatesFilter | string | null
    Technology?: StringNullableWithAggregatesFilter | string | null
    TemplateOptions?: StringNullableWithAggregatesFilter | string | null
    User_Id?: StringNullableWithAggregatesFilter | string | null
    Status?: IntNullableWithAggregatesFilter | number | null
    IsApplytoAll?: IntNullableWithAggregatesFilter | number | null
    IsApplytoType?: IntNullableWithAggregatesFilter | number | null
    IsApplytoSteroType?: IntNullableWithAggregatesFilter | number | null
    Created?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Modified?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ElementTypeList?: StringNullableWithAggregatesFilter | string | null
    ConnectorTypeList?: StringNullableWithAggregatesFilter | string | null
    FlowDirectionTypeList?: StringNullableWithAggregatesFilter | string | null
    TreeType?: StringNullableWithAggregatesFilter | string | null
  }

  export type TraceabilityTreeViewsWhereInput = {
    AND?: Enumerable<TraceabilityTreeViewsWhereInput>
    OR?: Enumerable<TraceabilityTreeViewsWhereInput>
    NOT?: Enumerable<TraceabilityTreeViewsWhereInput>
    Id?: StringFilter | string
    RepositoryId?: StringNullableFilter | string | null
    ElementGuid?: StringNullableFilter | string | null
    TreeViewData?: StringNullableFilter | string | null
    User_Id?: StringNullableFilter | string | null
    Created?: DateTimeNullableFilter | Date | string | null
    Modified?: DateTimeNullableFilter | Date | string | null
    FilterItems?: StringNullableFilter | string | null
    Tittle?: StringNullableFilter | string | null
    Revision?: StringNullableFilter | string | null
    ViewId?: StringNullableFilter | string | null
    TemplateOptions?: StringNullableFilter | string | null
    Description?: StringNullableFilter | string | null
    NlFilterItems?: StringNullableFilter | string | null
    NlTreeData?: StringNullableFilter | string | null
    NlFilterItemStatus?: StringNullableFilter | string | null
    FilterAppliedNodeList?: StringNullableFilter | string | null
    TotForceLinks?: StringNullableFilter | string | null
  }

  export type TraceabilityTreeViewsOrderByWithRelationInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    ElementGuid?: SortOrder
    TreeViewData?: SortOrder
    User_Id?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    FilterItems?: SortOrder
    Tittle?: SortOrder
    Revision?: SortOrder
    ViewId?: SortOrder
    TemplateOptions?: SortOrder
    Description?: SortOrder
    NlFilterItems?: SortOrder
    NlTreeData?: SortOrder
    NlFilterItemStatus?: SortOrder
    FilterAppliedNodeList?: SortOrder
    TotForceLinks?: SortOrder
  }

  export type TraceabilityTreeViewsWhereUniqueInput = {
    Id?: string
  }

  export type TraceabilityTreeViewsOrderByWithAggregationInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    ElementGuid?: SortOrder
    TreeViewData?: SortOrder
    User_Id?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    FilterItems?: SortOrder
    Tittle?: SortOrder
    Revision?: SortOrder
    ViewId?: SortOrder
    TemplateOptions?: SortOrder
    Description?: SortOrder
    NlFilterItems?: SortOrder
    NlTreeData?: SortOrder
    NlFilterItemStatus?: SortOrder
    FilterAppliedNodeList?: SortOrder
    TotForceLinks?: SortOrder
    _count?: TraceabilityTreeViewsCountOrderByAggregateInput
    _max?: TraceabilityTreeViewsMaxOrderByAggregateInput
    _min?: TraceabilityTreeViewsMinOrderByAggregateInput
  }

  export type TraceabilityTreeViewsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TraceabilityTreeViewsScalarWhereWithAggregatesInput>
    OR?: Enumerable<TraceabilityTreeViewsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TraceabilityTreeViewsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    RepositoryId?: StringNullableWithAggregatesFilter | string | null
    ElementGuid?: StringNullableWithAggregatesFilter | string | null
    TreeViewData?: StringNullableWithAggregatesFilter | string | null
    User_Id?: StringNullableWithAggregatesFilter | string | null
    Created?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Modified?: DateTimeNullableWithAggregatesFilter | Date | string | null
    FilterItems?: StringNullableWithAggregatesFilter | string | null
    Tittle?: StringNullableWithAggregatesFilter | string | null
    Revision?: StringNullableWithAggregatesFilter | string | null
    ViewId?: StringNullableWithAggregatesFilter | string | null
    TemplateOptions?: StringNullableWithAggregatesFilter | string | null
    Description?: StringNullableWithAggregatesFilter | string | null
    NlFilterItems?: StringNullableWithAggregatesFilter | string | null
    NlTreeData?: StringNullableWithAggregatesFilter | string | null
    NlFilterItemStatus?: StringNullableWithAggregatesFilter | string | null
    FilterAppliedNodeList?: StringNullableWithAggregatesFilter | string | null
    TotForceLinks?: StringNullableWithAggregatesFilter | string | null
  }

  export type URLMapWhereInput = {
    AND?: Enumerable<URLMapWhereInput>
    OR?: Enumerable<URLMapWhereInput>
    NOT?: Enumerable<URLMapWhereInput>
    Id?: BigIntFilter | bigint | number
    URL?: StringFilter | string
    URLType?: StringNullableFilter | string | null
    HashCode?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
    Repository_Id?: StringNullableFilter | string | null
    LinkType?: StringNullableFilter | string | null
    MapurlId?: StringNullableFilter | string | null
  }

  export type URLMapOrderByWithRelationInput = {
    Id?: SortOrder
    URL?: SortOrder
    URLType?: SortOrder
    HashCode?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Repository_Id?: SortOrder
    LinkType?: SortOrder
    MapurlId?: SortOrder
  }

  export type URLMapWhereUniqueInput = {
    Id?: bigint | number
    HashCode?: string
  }

  export type URLMapOrderByWithAggregationInput = {
    Id?: SortOrder
    URL?: SortOrder
    URLType?: SortOrder
    HashCode?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Repository_Id?: SortOrder
    LinkType?: SortOrder
    MapurlId?: SortOrder
    _count?: URLMapCountOrderByAggregateInput
    _avg?: URLMapAvgOrderByAggregateInput
    _max?: URLMapMaxOrderByAggregateInput
    _min?: URLMapMinOrderByAggregateInput
    _sum?: URLMapSumOrderByAggregateInput
  }

  export type URLMapScalarWhereWithAggregatesInput = {
    AND?: Enumerable<URLMapScalarWhereWithAggregatesInput>
    OR?: Enumerable<URLMapScalarWhereWithAggregatesInput>
    NOT?: Enumerable<URLMapScalarWhereWithAggregatesInput>
    Id?: BigIntWithAggregatesFilter | bigint | number
    URL?: StringWithAggregatesFilter | string
    URLType?: StringNullableWithAggregatesFilter | string | null
    HashCode?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Repository_Id?: StringNullableWithAggregatesFilter | string | null
    LinkType?: StringNullableWithAggregatesFilter | string | null
    MapurlId?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserActionsWhereInput = {
    AND?: Enumerable<UserActionsWhereInput>
    OR?: Enumerable<UserActionsWhereInput>
    NOT?: Enumerable<UserActionsWhereInput>
    Id?: StringFilter | string
    ActionName?: StringNullableFilter | string | null
    Actionkey?: StringNullableFilter | string | null
    Resource_id?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
    Status?: StringNullableFilter | string | null
  }

  export type UserActionsOrderByWithRelationInput = {
    Id?: SortOrder
    ActionName?: SortOrder
    Actionkey?: SortOrder
    Resource_id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
  }

  export type UserActionsWhereUniqueInput = {
    Id?: string
  }

  export type UserActionsOrderByWithAggregationInput = {
    Id?: SortOrder
    ActionName?: SortOrder
    Actionkey?: SortOrder
    Resource_id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    _count?: UserActionsCountOrderByAggregateInput
    _max?: UserActionsMaxOrderByAggregateInput
    _min?: UserActionsMinOrderByAggregateInput
  }

  export type UserActionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserActionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserActionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserActionsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    ActionName?: StringNullableWithAggregatesFilter | string | null
    Actionkey?: StringNullableWithAggregatesFilter | string | null
    Resource_id?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserGroupConnectorsWhereInput = {
    AND?: Enumerable<UserGroupConnectorsWhereInput>
    OR?: Enumerable<UserGroupConnectorsWhereInput>
    NOT?: Enumerable<UserGroupConnectorsWhereInput>
    Id?: StringFilter | string
    UserGroup_Id?: StringNullableFilter | string | null
    User_Id?: StringNullableFilter | string | null
    Status?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type UserGroupConnectorsOrderByWithRelationInput = {
    Id?: SortOrder
    UserGroup_Id?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
  }

  export type UserGroupConnectorsWhereUniqueInput = {
    Id?: string
  }

  export type UserGroupConnectorsOrderByWithAggregationInput = {
    Id?: SortOrder
    UserGroup_Id?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    _count?: UserGroupConnectorsCountOrderByAggregateInput
    _max?: UserGroupConnectorsMaxOrderByAggregateInput
    _min?: UserGroupConnectorsMinOrderByAggregateInput
  }

  export type UserGroupConnectorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserGroupConnectorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserGroupConnectorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserGroupConnectorsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    UserGroup_Id?: StringNullableWithAggregatesFilter | string | null
    User_Id?: StringNullableWithAggregatesFilter | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserGroupsWhereInput = {
    AND?: Enumerable<UserGroupsWhereInput>
    OR?: Enumerable<UserGroupsWhereInput>
    NOT?: Enumerable<UserGroupsWhereInput>
    Id?: StringFilter | string
    GroupName?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
    EditFeatures?: IntNullableFilter | number | null
    Status?: StringNullableFilter | string | null
    UserGroups_Role_Id?: StringNullableFilter | string | null
    IsReadOnly?: IntFilter | number
  }

  export type UserGroupsOrderByWithRelationInput = {
    Id?: SortOrder
    GroupName?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    EditFeatures?: SortOrder
    Status?: SortOrder
    UserGroups_Role_Id?: SortOrder
    IsReadOnly?: SortOrder
  }

  export type UserGroupsWhereUniqueInput = {
    Id?: string
  }

  export type UserGroupsOrderByWithAggregationInput = {
    Id?: SortOrder
    GroupName?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    EditFeatures?: SortOrder
    Status?: SortOrder
    UserGroups_Role_Id?: SortOrder
    IsReadOnly?: SortOrder
    _count?: UserGroupsCountOrderByAggregateInput
    _avg?: UserGroupsAvgOrderByAggregateInput
    _max?: UserGroupsMaxOrderByAggregateInput
    _min?: UserGroupsMinOrderByAggregateInput
    _sum?: UserGroupsSumOrderByAggregateInput
  }

  export type UserGroupsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserGroupsScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserGroupsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserGroupsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    GroupName?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    EditFeatures?: IntNullableWithAggregatesFilter | number | null
    Status?: StringNullableWithAggregatesFilter | string | null
    UserGroups_Role_Id?: StringNullableWithAggregatesFilter | string | null
    IsReadOnly?: IntWithAggregatesFilter | number
  }

  export type UserIdentityClaimsWhereInput = {
    AND?: Enumerable<UserIdentityClaimsWhereInput>
    OR?: Enumerable<UserIdentityClaimsWhereInput>
    NOT?: Enumerable<UserIdentityClaimsWhereInput>
    Id?: IntFilter | number
    UserId?: StringFilter | string
    ClaimType?: StringNullableFilter | string | null
    ClaimValue?: StringNullableFilter | string | null
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type UserIdentityClaimsOrderByWithRelationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type UserIdentityClaimsWhereUniqueInput = {
    Id?: number
  }

  export type UserIdentityClaimsOrderByWithAggregationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
    _count?: UserIdentityClaimsCountOrderByAggregateInput
    _avg?: UserIdentityClaimsAvgOrderByAggregateInput
    _max?: UserIdentityClaimsMaxOrderByAggregateInput
    _min?: UserIdentityClaimsMinOrderByAggregateInput
    _sum?: UserIdentityClaimsSumOrderByAggregateInput
  }

  export type UserIdentityClaimsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserIdentityClaimsScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserIdentityClaimsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserIdentityClaimsScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    UserId?: StringWithAggregatesFilter | string
    ClaimType?: StringNullableWithAggregatesFilter | string | null
    ClaimValue?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserIdentityLoginsWhereInput = {
    AND?: Enumerable<UserIdentityLoginsWhereInput>
    OR?: Enumerable<UserIdentityLoginsWhereInput>
    NOT?: Enumerable<UserIdentityLoginsWhereInput>
    LoginProvider?: StringFilter | string
    ProviderKey?: StringFilter | string
    ProviderDisplayName?: StringNullableFilter | string | null
    UserId?: StringFilter | string
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type UserIdentityLoginsOrderByWithRelationInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrder
    UserId?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type UserIdentityLoginsWhereUniqueInput = {
    LoginProvider_ProviderKey?: UserIdentityLoginsLoginProviderProviderKeyCompoundUniqueInput
  }

  export type UserIdentityLoginsOrderByWithAggregationInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrder
    UserId?: SortOrder
    _count?: UserIdentityLoginsCountOrderByAggregateInput
    _max?: UserIdentityLoginsMaxOrderByAggregateInput
    _min?: UserIdentityLoginsMinOrderByAggregateInput
  }

  export type UserIdentityLoginsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserIdentityLoginsScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserIdentityLoginsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserIdentityLoginsScalarWhereWithAggregatesInput>
    LoginProvider?: StringWithAggregatesFilter | string
    ProviderKey?: StringWithAggregatesFilter | string
    ProviderDisplayName?: StringNullableWithAggregatesFilter | string | null
    UserId?: StringWithAggregatesFilter | string
  }

  export type UserIdentityRoleClaimsWhereInput = {
    AND?: Enumerable<UserIdentityRoleClaimsWhereInput>
    OR?: Enumerable<UserIdentityRoleClaimsWhereInput>
    NOT?: Enumerable<UserIdentityRoleClaimsWhereInput>
    Id?: IntFilter | number
    RoleId?: StringFilter | string
    ClaimType?: StringNullableFilter | string | null
    ClaimValue?: StringNullableFilter | string | null
    AppIdentityRoles?: XOR<AppIdentityRolesRelationFilter, AppIdentityRolesWhereInput>
  }

  export type UserIdentityRoleClaimsOrderByWithRelationInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
    AppIdentityRoles?: AppIdentityRolesOrderByWithRelationInput
  }

  export type UserIdentityRoleClaimsWhereUniqueInput = {
    Id?: number
  }

  export type UserIdentityRoleClaimsOrderByWithAggregationInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
    _count?: UserIdentityRoleClaimsCountOrderByAggregateInput
    _avg?: UserIdentityRoleClaimsAvgOrderByAggregateInput
    _max?: UserIdentityRoleClaimsMaxOrderByAggregateInput
    _min?: UserIdentityRoleClaimsMinOrderByAggregateInput
    _sum?: UserIdentityRoleClaimsSumOrderByAggregateInput
  }

  export type UserIdentityRoleClaimsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserIdentityRoleClaimsScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserIdentityRoleClaimsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserIdentityRoleClaimsScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    RoleId?: StringWithAggregatesFilter | string
    ClaimType?: StringNullableWithAggregatesFilter | string | null
    ClaimValue?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserIdentityRolesWhereInput = {
    AND?: Enumerable<UserIdentityRolesWhereInput>
    OR?: Enumerable<UserIdentityRolesWhereInput>
    NOT?: Enumerable<UserIdentityRolesWhereInput>
    UserId?: StringFilter | string
    RoleId?: StringFilter | string
    AppIdentityRoles?: XOR<AppIdentityRolesRelationFilter, AppIdentityRolesWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type UserIdentityRolesOrderByWithRelationInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
    AppIdentityRoles?: AppIdentityRolesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type UserIdentityRolesWhereUniqueInput = {
    UserId_RoleId?: UserIdentityRolesUserIdRoleIdCompoundUniqueInput
  }

  export type UserIdentityRolesOrderByWithAggregationInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
    _count?: UserIdentityRolesCountOrderByAggregateInput
    _max?: UserIdentityRolesMaxOrderByAggregateInput
    _min?: UserIdentityRolesMinOrderByAggregateInput
  }

  export type UserIdentityRolesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserIdentityRolesScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserIdentityRolesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserIdentityRolesScalarWhereWithAggregatesInput>
    UserId?: StringWithAggregatesFilter | string
    RoleId?: StringWithAggregatesFilter | string
  }

  export type UserIdentityTokensWhereInput = {
    AND?: Enumerable<UserIdentityTokensWhereInput>
    OR?: Enumerable<UserIdentityTokensWhereInput>
    NOT?: Enumerable<UserIdentityTokensWhereInput>
    UserId?: StringFilter | string
    LoginProvider?: StringFilter | string
    Name?: StringFilter | string
    Value?: StringNullableFilter | string | null
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type UserIdentityTokensOrderByWithRelationInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type UserIdentityTokensWhereUniqueInput = {
    UserId_LoginProvider_Name?: UserIdentityTokensUserIdLoginProviderNameCompoundUniqueInput
  }

  export type UserIdentityTokensOrderByWithAggregationInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrder
    _count?: UserIdentityTokensCountOrderByAggregateInput
    _max?: UserIdentityTokensMaxOrderByAggregateInput
    _min?: UserIdentityTokensMinOrderByAggregateInput
  }

  export type UserIdentityTokensScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserIdentityTokensScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserIdentityTokensScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserIdentityTokensScalarWhereWithAggregatesInput>
    UserId?: StringWithAggregatesFilter | string
    LoginProvider?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
    Value?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserProfileSettingWhereInput = {
    AND?: Enumerable<UserProfileSettingWhereInput>
    OR?: Enumerable<UserProfileSettingWhereInput>
    NOT?: Enumerable<UserProfileSettingWhereInput>
    Id?: StringFilter | string
    UserId?: StringNullableFilter | string | null
    RepositoryTechnologyConfiguration?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type UserProfileSettingOrderByWithRelationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RepositoryTechnologyConfiguration?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type UserProfileSettingWhereUniqueInput = {
    Id?: string
  }

  export type UserProfileSettingOrderByWithAggregationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RepositoryTechnologyConfiguration?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    _count?: UserProfileSettingCountOrderByAggregateInput
    _max?: UserProfileSettingMaxOrderByAggregateInput
    _min?: UserProfileSettingMinOrderByAggregateInput
  }

  export type UserProfileSettingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserProfileSettingScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserProfileSettingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserProfileSettingScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    UserId?: StringNullableWithAggregatesFilter | string | null
    RepositoryTechnologyConfiguration?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserRoleProfilesWhereInput = {
    AND?: Enumerable<UserRoleProfilesWhereInput>
    OR?: Enumerable<UserRoleProfilesWhereInput>
    NOT?: Enumerable<UserRoleProfilesWhereInput>
    Id?: StringFilter | string
    UserRole_Id?: StringFilter | string
    Profile_Id?: StringFilter | string
    Created?: DateTimeFilter | Date | string
    Modified?: DateTimeFilter | Date | string
  }

  export type UserRoleProfilesOrderByWithRelationInput = {
    Id?: SortOrder
    UserRole_Id?: SortOrder
    Profile_Id?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type UserRoleProfilesWhereUniqueInput = {
    Id?: string
  }

  export type UserRoleProfilesOrderByWithAggregationInput = {
    Id?: SortOrder
    UserRole_Id?: SortOrder
    Profile_Id?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    _count?: UserRoleProfilesCountOrderByAggregateInput
    _max?: UserRoleProfilesMaxOrderByAggregateInput
    _min?: UserRoleProfilesMinOrderByAggregateInput
  }

  export type UserRoleProfilesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserRoleProfilesScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserRoleProfilesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserRoleProfilesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    UserRole_Id?: StringWithAggregatesFilter | string
    Profile_Id?: StringWithAggregatesFilter | string
    Created?: DateTimeWithAggregatesFilter | Date | string
    Modified?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserRolesWhereInput = {
    AND?: Enumerable<UserRolesWhereInput>
    OR?: Enumerable<UserRolesWhereInput>
    NOT?: Enumerable<UserRolesWhereInput>
    Id?: StringFilter | string
    Name?: StringFilter | string
    Description?: StringNullableFilter | string | null
    UIEnabled?: IntFilter | number
  }

  export type UserRolesOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    UIEnabled?: SortOrder
  }

  export type UserRolesWhereUniqueInput = {
    Id?: string
  }

  export type UserRolesOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    UIEnabled?: SortOrder
    _count?: UserRolesCountOrderByAggregateInput
    _avg?: UserRolesAvgOrderByAggregateInput
    _max?: UserRolesMaxOrderByAggregateInput
    _min?: UserRolesMinOrderByAggregateInput
    _sum?: UserRolesSumOrderByAggregateInput
  }

  export type UserRolesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserRolesScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserRolesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserRolesScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
    Description?: StringNullableWithAggregatesFilter | string | null
    UIEnabled?: IntWithAggregatesFilter | number
  }

  export type UsersWhereInput = {
    AND?: Enumerable<UsersWhereInput>
    OR?: Enumerable<UsersWhereInput>
    NOT?: Enumerable<UsersWhereInput>
    Id?: StringFilter | string
    LDAPConnection_Id?: StringNullableFilter | string | null
    FirstName?: StringNullableFilter | string | null
    LastName?: StringNullableFilter | string | null
    UserRole_Id?: StringNullableFilter | string | null
    Status?: StringNullableFilter | string | null
    EmailId?: StringNullableFilter | string | null
    Password?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
    ModifiedDate?: DateTimeNullableFilter | Date | string | null
    Description?: StringNullableFilter | string | null
    ProfileImage?: StringNullableFilter | string | null
    CreatedBy?: StringNullableFilter | string | null
    ModifiedBy?: StringNullableFilter | string | null
    RegistrationMode?: StringNullableFilter | string | null
    Timezone?: StringNullableFilter | string | null
    IsPasswordSet?: IntNullableFilter | number | null
    IsAdmin?: IntNullableFilter | number | null
    ShowHelpText?: IntNullableFilter | number | null
    IdentityProvider_Id?: StringNullableFilter | string | null
    SecPhrase?: StringNullableFilter | string | null
    IsReadOnly?: IntFilter | number
    UserIdentityRole?: StringNullableFilter | string | null
    UserName?: StringNullableFilter | string | null
    NormalizedUserName?: StringNullableFilter | string | null
    Email?: StringNullableFilter | string | null
    NormalizedEmail?: StringNullableFilter | string | null
    EmailConfirmed?: BoolNullableFilter | boolean | null
    SecurityStamp?: StringNullableFilter | string | null
    ConcurrencyStamp?: StringNullableFilter | string | null
    PhoneNumber?: StringNullableFilter | string | null
    PhoneNumberConfirmed?: BoolNullableFilter | boolean | null
    PasswordHash?: StringNullableFilter | string | null
    TwoFactorEnabled?: BoolNullableFilter | boolean | null
    LockoutEnd?: DateTimeNullableFilter | Date | string | null
    LockoutEnabled?: BoolNullableFilter | boolean | null
    AccessFailedCount?: IntNullableFilter | number | null
    UserIdentityClaims?: UserIdentityClaimsListRelationFilter
    UserIdentityLogins?: UserIdentityLoginsListRelationFilter
    UserIdentityRoles?: UserIdentityRolesListRelationFilter
    UserIdentityTokens?: UserIdentityTokensListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    Id?: SortOrder
    LDAPConnection_Id?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    UserRole_Id?: SortOrder
    Status?: SortOrder
    EmailId?: SortOrder
    Password?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Description?: SortOrder
    ProfileImage?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
    RegistrationMode?: SortOrder
    Timezone?: SortOrder
    IsPasswordSet?: SortOrder
    IsAdmin?: SortOrder
    ShowHelpText?: SortOrder
    IdentityProvider_Id?: SortOrder
    SecPhrase?: SortOrder
    IsReadOnly?: SortOrder
    UserIdentityRole?: SortOrder
    UserName?: SortOrder
    NormalizedUserName?: SortOrder
    Email?: SortOrder
    NormalizedEmail?: SortOrder
    EmailConfirmed?: SortOrder
    SecurityStamp?: SortOrder
    ConcurrencyStamp?: SortOrder
    PhoneNumber?: SortOrder
    PhoneNumberConfirmed?: SortOrder
    PasswordHash?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
    UserIdentityClaims?: UserIdentityClaimsOrderByRelationAggregateInput
    UserIdentityLogins?: UserIdentityLoginsOrderByRelationAggregateInput
    UserIdentityRoles?: UserIdentityRolesOrderByRelationAggregateInput
    UserIdentityTokens?: UserIdentityTokensOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = {
    Id?: string
  }

  export type UsersOrderByWithAggregationInput = {
    Id?: SortOrder
    LDAPConnection_Id?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    UserRole_Id?: SortOrder
    Status?: SortOrder
    EmailId?: SortOrder
    Password?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Description?: SortOrder
    ProfileImage?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
    RegistrationMode?: SortOrder
    Timezone?: SortOrder
    IsPasswordSet?: SortOrder
    IsAdmin?: SortOrder
    ShowHelpText?: SortOrder
    IdentityProvider_Id?: SortOrder
    SecPhrase?: SortOrder
    IsReadOnly?: SortOrder
    UserIdentityRole?: SortOrder
    UserName?: SortOrder
    NormalizedUserName?: SortOrder
    Email?: SortOrder
    NormalizedEmail?: SortOrder
    EmailConfirmed?: SortOrder
    SecurityStamp?: SortOrder
    ConcurrencyStamp?: SortOrder
    PhoneNumber?: SortOrder
    PhoneNumberConfirmed?: SortOrder
    PasswordHash?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UsersScalarWhereWithAggregatesInput>
    OR?: Enumerable<UsersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UsersScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    LDAPConnection_Id?: StringNullableWithAggregatesFilter | string | null
    FirstName?: StringNullableWithAggregatesFilter | string | null
    LastName?: StringNullableWithAggregatesFilter | string | null
    UserRole_Id?: StringNullableWithAggregatesFilter | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
    EmailId?: StringNullableWithAggregatesFilter | string | null
    Password?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ModifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    Description?: StringNullableWithAggregatesFilter | string | null
    ProfileImage?: StringNullableWithAggregatesFilter | string | null
    CreatedBy?: StringNullableWithAggregatesFilter | string | null
    ModifiedBy?: StringNullableWithAggregatesFilter | string | null
    RegistrationMode?: StringNullableWithAggregatesFilter | string | null
    Timezone?: StringNullableWithAggregatesFilter | string | null
    IsPasswordSet?: IntNullableWithAggregatesFilter | number | null
    IsAdmin?: IntNullableWithAggregatesFilter | number | null
    ShowHelpText?: IntNullableWithAggregatesFilter | number | null
    IdentityProvider_Id?: StringNullableWithAggregatesFilter | string | null
    SecPhrase?: StringNullableWithAggregatesFilter | string | null
    IsReadOnly?: IntWithAggregatesFilter | number
    UserIdentityRole?: StringNullableWithAggregatesFilter | string | null
    UserName?: StringNullableWithAggregatesFilter | string | null
    NormalizedUserName?: StringNullableWithAggregatesFilter | string | null
    Email?: StringNullableWithAggregatesFilter | string | null
    NormalizedEmail?: StringNullableWithAggregatesFilter | string | null
    EmailConfirmed?: BoolNullableWithAggregatesFilter | boolean | null
    SecurityStamp?: StringNullableWithAggregatesFilter | string | null
    ConcurrencyStamp?: StringNullableWithAggregatesFilter | string | null
    PhoneNumber?: StringNullableWithAggregatesFilter | string | null
    PhoneNumberConfirmed?: BoolNullableWithAggregatesFilter | boolean | null
    PasswordHash?: StringNullableWithAggregatesFilter | string | null
    TwoFactorEnabled?: BoolNullableWithAggregatesFilter | boolean | null
    LockoutEnd?: DateTimeNullableWithAggregatesFilter | Date | string | null
    LockoutEnabled?: BoolNullableWithAggregatesFilter | boolean | null
    AccessFailedCount?: IntNullableWithAggregatesFilter | number | null
  }

  export type UserSessionsWhereInput = {
    AND?: Enumerable<UserSessionsWhereInput>
    OR?: Enumerable<UserSessionsWhereInput>
    NOT?: Enumerable<UserSessionsWhereInput>
    Id?: StringFilter | string
    UserId?: StringFilter | string
    IsReservedUser?: IntFilter | number
    AccessMode?: StringFilter | string
    IPAddress?: StringFilter | string
    UserAgent?: StringFilter | string
    IsActive?: IntFilter | number
    LastRequest?: DateTimeFilter | Date | string
    Created?: DateTimeFilter | Date | string
    Modified?: DateTimeFilter | Date | string
    UserDisplayName?: StringNullableFilter | string | null
    UserType?: StringNullableFilter | string | null
  }

  export type UserSessionsOrderByWithRelationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    IsReservedUser?: SortOrder
    AccessMode?: SortOrder
    IPAddress?: SortOrder
    UserAgent?: SortOrder
    IsActive?: SortOrder
    LastRequest?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    UserDisplayName?: SortOrder
    UserType?: SortOrder
  }

  export type UserSessionsWhereUniqueInput = {
    Id?: string
  }

  export type UserSessionsOrderByWithAggregationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    IsReservedUser?: SortOrder
    AccessMode?: SortOrder
    IPAddress?: SortOrder
    UserAgent?: SortOrder
    IsActive?: SortOrder
    LastRequest?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    UserDisplayName?: SortOrder
    UserType?: SortOrder
    _count?: UserSessionsCountOrderByAggregateInput
    _avg?: UserSessionsAvgOrderByAggregateInput
    _max?: UserSessionsMaxOrderByAggregateInput
    _min?: UserSessionsMinOrderByAggregateInput
    _sum?: UserSessionsSumOrderByAggregateInput
  }

  export type UserSessionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserSessionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserSessionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserSessionsScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    UserId?: StringWithAggregatesFilter | string
    IsReservedUser?: IntWithAggregatesFilter | number
    AccessMode?: StringWithAggregatesFilter | string
    IPAddress?: StringWithAggregatesFilter | string
    UserAgent?: StringWithAggregatesFilter | string
    IsActive?: IntWithAggregatesFilter | number
    LastRequest?: DateTimeWithAggregatesFilter | Date | string
    Created?: DateTimeWithAggregatesFilter | Date | string
    Modified?: DateTimeWithAggregatesFilter | Date | string
    UserDisplayName?: StringNullableWithAggregatesFilter | string | null
    UserType?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserSessionsArchiveWhereInput = {
    AND?: Enumerable<UserSessionsArchiveWhereInput>
    OR?: Enumerable<UserSessionsArchiveWhereInput>
    NOT?: Enumerable<UserSessionsArchiveWhereInput>
    Id?: StringFilter | string
    UserId?: StringFilter | string
    IsReservedUser?: IntFilter | number
    AccessMode?: StringFilter | string
    IPAddress?: StringFilter | string
    UserAgent?: StringFilter | string
    IsActive?: IntFilter | number
    LastRequest?: DateTimeFilter | Date | string
    Created?: DateTimeFilter | Date | string
    Modified?: DateTimeFilter | Date | string
    UserDisplayName?: StringNullableFilter | string | null
    UserType?: StringNullableFilter | string | null
  }

  export type UserSessionsArchiveOrderByWithRelationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    IsReservedUser?: SortOrder
    AccessMode?: SortOrder
    IPAddress?: SortOrder
    UserAgent?: SortOrder
    IsActive?: SortOrder
    LastRequest?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    UserDisplayName?: SortOrder
    UserType?: SortOrder
  }

  export type UserSessionsArchiveWhereUniqueInput = {
    Id?: string
  }

  export type UserSessionsArchiveOrderByWithAggregationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    IsReservedUser?: SortOrder
    AccessMode?: SortOrder
    IPAddress?: SortOrder
    UserAgent?: SortOrder
    IsActive?: SortOrder
    LastRequest?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    UserDisplayName?: SortOrder
    UserType?: SortOrder
    _count?: UserSessionsArchiveCountOrderByAggregateInput
    _avg?: UserSessionsArchiveAvgOrderByAggregateInput
    _max?: UserSessionsArchiveMaxOrderByAggregateInput
    _min?: UserSessionsArchiveMinOrderByAggregateInput
    _sum?: UserSessionsArchiveSumOrderByAggregateInput
  }

  export type UserSessionsArchiveScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserSessionsArchiveScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserSessionsArchiveScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserSessionsArchiveScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    UserId?: StringWithAggregatesFilter | string
    IsReservedUser?: IntWithAggregatesFilter | number
    AccessMode?: StringWithAggregatesFilter | string
    IPAddress?: StringWithAggregatesFilter | string
    UserAgent?: StringWithAggregatesFilter | string
    IsActive?: IntWithAggregatesFilter | number
    LastRequest?: DateTimeWithAggregatesFilter | Date | string
    Created?: DateTimeWithAggregatesFilter | Date | string
    Modified?: DateTimeWithAggregatesFilter | Date | string
    UserDisplayName?: StringNullableWithAggregatesFilter | string | null
    UserType?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserTokensWhereInput = {
    AND?: Enumerable<UserTokensWhereInput>
    OR?: Enumerable<UserTokensWhereInput>
    NOT?: Enumerable<UserTokensWhereInput>
    Id?: StringFilter | string
    UserId?: StringNullableFilter | string | null
    RefreshToken?: StringNullableFilter | string | null
    CreatedDate?: DateTimeNullableFilter | Date | string | null
  }

  export type UserTokensOrderByWithRelationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RefreshToken?: SortOrder
    CreatedDate?: SortOrder
  }

  export type UserTokensWhereUniqueInput = {
    Id?: string
  }

  export type UserTokensOrderByWithAggregationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RefreshToken?: SortOrder
    CreatedDate?: SortOrder
    _count?: UserTokensCountOrderByAggregateInput
    _max?: UserTokensMaxOrderByAggregateInput
    _min?: UserTokensMinOrderByAggregateInput
  }

  export type UserTokensScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserTokensScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserTokensScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserTokensScalarWhereWithAggregatesInput>
    Id?: StringWithAggregatesFilter | string
    UserId?: StringNullableWithAggregatesFilter | string | null
    RefreshToken?: StringNullableWithAggregatesFilter | string | null
    CreatedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AccessRightsCreateInput = {
    Id: string
    Name?: string | null
    AccessRightKey?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
  }

  export type AccessRightsUncheckedCreateInput = {
    Id: string
    Name?: string | null
    AccessRightKey?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
  }

  export type AccessRightsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    AccessRightKey?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessRightsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    AccessRightKey?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessRightsCreateManyInput = {
    Id: string
    Name?: string | null
    AccessRightKey?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
  }

  export type AccessRightsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    AccessRightKey?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessRightsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    AccessRightKey?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppIdentityRolesCreateInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    UserIdentityRoleClaims?: UserIdentityRoleClaimsCreateNestedManyWithoutAppIdentityRolesInput
    UserIdentityRoles?: UserIdentityRolesCreateNestedManyWithoutAppIdentityRolesInput
  }

  export type AppIdentityRolesUncheckedCreateInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    UserIdentityRoleClaims?: UserIdentityRoleClaimsUncheckedCreateNestedManyWithoutAppIdentityRolesInput
    UserIdentityRoles?: UserIdentityRolesUncheckedCreateNestedManyWithoutAppIdentityRolesInput
  }

  export type AppIdentityRolesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    UserIdentityRoleClaims?: UserIdentityRoleClaimsUpdateManyWithoutAppIdentityRolesInput
    UserIdentityRoles?: UserIdentityRolesUpdateManyWithoutAppIdentityRolesInput
  }

  export type AppIdentityRolesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    UserIdentityRoleClaims?: UserIdentityRoleClaimsUncheckedUpdateManyWithoutAppIdentityRolesInput
    UserIdentityRoles?: UserIdentityRolesUncheckedUpdateManyWithoutAppIdentityRolesInput
  }

  export type AppIdentityRolesCreateManyInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
  }

  export type AppIdentityRolesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppIdentityRolesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppStreamConfigurationsCreateInput = {
    Id: string
    RegionEndPoint: number
    FleetName: string
    StackName: string
    ApplicationID: string
    AuthenticationType: number
    URLValidityTime?: number | null
    AWSConfigurationsId: string
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type AppStreamConfigurationsUncheckedCreateInput = {
    Id: string
    RegionEndPoint: number
    FleetName: string
    StackName: string
    ApplicationID: string
    AuthenticationType: number
    URLValidityTime?: number | null
    AWSConfigurationsId: string
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type AppStreamConfigurationsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RegionEndPoint?: IntFieldUpdateOperationsInput | number
    FleetName?: StringFieldUpdateOperationsInput | string
    StackName?: StringFieldUpdateOperationsInput | string
    ApplicationID?: StringFieldUpdateOperationsInput | string
    AuthenticationType?: IntFieldUpdateOperationsInput | number
    URLValidityTime?: NullableIntFieldUpdateOperationsInput | number | null
    AWSConfigurationsId?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppStreamConfigurationsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RegionEndPoint?: IntFieldUpdateOperationsInput | number
    FleetName?: StringFieldUpdateOperationsInput | string
    StackName?: StringFieldUpdateOperationsInput | string
    ApplicationID?: StringFieldUpdateOperationsInput | string
    AuthenticationType?: IntFieldUpdateOperationsInput | number
    URLValidityTime?: NullableIntFieldUpdateOperationsInput | number | null
    AWSConfigurationsId?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppStreamConfigurationsCreateManyInput = {
    Id: string
    RegionEndPoint: number
    FleetName: string
    StackName: string
    ApplicationID: string
    AuthenticationType: number
    URLValidityTime?: number | null
    AWSConfigurationsId: string
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type AppStreamConfigurationsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RegionEndPoint?: IntFieldUpdateOperationsInput | number
    FleetName?: StringFieldUpdateOperationsInput | string
    StackName?: StringFieldUpdateOperationsInput | string
    ApplicationID?: StringFieldUpdateOperationsInput | string
    AuthenticationType?: IntFieldUpdateOperationsInput | number
    URLValidityTime?: NullableIntFieldUpdateOperationsInput | number | null
    AWSConfigurationsId?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppStreamConfigurationsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RegionEndPoint?: IntFieldUpdateOperationsInput | number
    FleetName?: StringFieldUpdateOperationsInput | string
    StackName?: StringFieldUpdateOperationsInput | string
    ApplicationID?: StringFieldUpdateOperationsInput | string
    AuthenticationType?: IntFieldUpdateOperationsInput | number
    URLValidityTime?: NullableIntFieldUpdateOperationsInput | number | null
    AWSConfigurationsId?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppStreamUserConnectorsCreateInput = {
    Id: string
    AppStreamARN: string
    AppStreamUserName?: string | null
    AppStreamEmailId: string
    AppStreamConfiguration_Id: string
    User_Id: string
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type AppStreamUserConnectorsUncheckedCreateInput = {
    Id: string
    AppStreamARN: string
    AppStreamUserName?: string | null
    AppStreamEmailId: string
    AppStreamConfiguration_Id: string
    User_Id: string
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type AppStreamUserConnectorsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    AppStreamARN?: StringFieldUpdateOperationsInput | string
    AppStreamUserName?: NullableStringFieldUpdateOperationsInput | string | null
    AppStreamEmailId?: StringFieldUpdateOperationsInput | string
    AppStreamConfiguration_Id?: StringFieldUpdateOperationsInput | string
    User_Id?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppStreamUserConnectorsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    AppStreamARN?: StringFieldUpdateOperationsInput | string
    AppStreamUserName?: NullableStringFieldUpdateOperationsInput | string | null
    AppStreamEmailId?: StringFieldUpdateOperationsInput | string
    AppStreamConfiguration_Id?: StringFieldUpdateOperationsInput | string
    User_Id?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppStreamUserConnectorsCreateManyInput = {
    Id: string
    AppStreamARN: string
    AppStreamUserName?: string | null
    AppStreamEmailId: string
    AppStreamConfiguration_Id: string
    User_Id: string
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type AppStreamUserConnectorsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    AppStreamARN?: StringFieldUpdateOperationsInput | string
    AppStreamUserName?: NullableStringFieldUpdateOperationsInput | string | null
    AppStreamEmailId?: StringFieldUpdateOperationsInput | string
    AppStreamConfiguration_Id?: StringFieldUpdateOperationsInput | string
    User_Id?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppStreamUserConnectorsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    AppStreamARN?: StringFieldUpdateOperationsInput | string
    AppStreamUserName?: NullableStringFieldUpdateOperationsInput | string | null
    AppStreamEmailId?: StringFieldUpdateOperationsInput | string
    AppStreamConfiguration_Id?: StringFieldUpdateOperationsInput | string
    User_Id?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditEntitiesCreateInput = {
    Id: string
    Type?: string | null
    ActionBy?: string | null
    Details?: string | null
    CreatedDate?: Date | string | null
    UserAgent?: string | null
    IPAddress?: string | null
  }

  export type AuditEntitiesUncheckedCreateInput = {
    Id: string
    Type?: string | null
    ActionBy?: string | null
    Details?: string | null
    CreatedDate?: Date | string | null
    UserAgent?: string | null
    IPAddress?: string | null
  }

  export type AuditEntitiesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    ActionBy?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    IPAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditEntitiesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    ActionBy?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    IPAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditEntitiesCreateManyInput = {
    Id: string
    Type?: string | null
    ActionBy?: string | null
    Details?: string | null
    CreatedDate?: Date | string | null
    UserAgent?: string | null
    IPAddress?: string | null
  }

  export type AuditEntitiesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    ActionBy?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    IPAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditEntitiesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    ActionBy?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    IPAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogsCreateInput = {
    Id: string
    Resource?: string | null
    Resource_Id?: string | null
    UserAction_Actionkey?: string | null
    UserType?: string | null
    Repository_Id?: string | null
    ActionBy?: string | null
    Details?: string | null
    CreatedDate?: Date | string | null
    UserAgent?: string | null
    IPAddress?: string | null
  }

  export type AuditLogsUncheckedCreateInput = {
    Id: string
    Resource?: string | null
    Resource_Id?: string | null
    UserAction_Actionkey?: string | null
    UserType?: string | null
    Repository_Id?: string | null
    ActionBy?: string | null
    Details?: string | null
    CreatedDate?: Date | string | null
    UserAgent?: string | null
    IPAddress?: string | null
  }

  export type AuditLogsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Resource?: NullableStringFieldUpdateOperationsInput | string | null
    Resource_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserAction_Actionkey?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    ActionBy?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    IPAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Resource?: NullableStringFieldUpdateOperationsInput | string | null
    Resource_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserAction_Actionkey?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    ActionBy?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    IPAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogsCreateManyInput = {
    Id: string
    Resource?: string | null
    Resource_Id?: string | null
    UserAction_Actionkey?: string | null
    UserType?: string | null
    Repository_Id?: string | null
    ActionBy?: string | null
    Details?: string | null
    CreatedDate?: Date | string | null
    UserAgent?: string | null
    IPAddress?: string | null
  }

  export type AuditLogsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Resource?: NullableStringFieldUpdateOperationsInput | string | null
    Resource_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserAction_Actionkey?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    ActionBy?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    IPAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Resource?: NullableStringFieldUpdateOperationsInput | string | null
    Resource_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserAction_Actionkey?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    ActionBy?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    IPAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AWSConfigurationsCreateInput = {
    Id: string
    AccessKey: string
    Secretkey: string
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type AWSConfigurationsUncheckedCreateInput = {
    Id: string
    AccessKey: string
    Secretkey: string
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type AWSConfigurationsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    AccessKey?: StringFieldUpdateOperationsInput | string
    Secretkey?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AWSConfigurationsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    AccessKey?: StringFieldUpdateOperationsInput | string
    Secretkey?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AWSConfigurationsCreateManyInput = {
    Id: string
    AccessKey: string
    Secretkey: string
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type AWSConfigurationsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    AccessKey?: StringFieldUpdateOperationsInput | string
    Secretkey?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AWSConfigurationsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    AccessKey?: StringFieldUpdateOperationsInput | string
    Secretkey?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CreateElementNotificationsCreateInput = {
    Id: string
    Repository_Id: string
    EnableNotification?: number | null
    User_Id?: string | null
    UserGroup_Id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type CreateElementNotificationsUncheckedCreateInput = {
    Id: string
    Repository_Id: string
    EnableNotification?: number | null
    User_Id?: string | null
    UserGroup_Id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type CreateElementNotificationsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    EnableNotification?: NullableIntFieldUpdateOperationsInput | number | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CreateElementNotificationsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    EnableNotification?: NullableIntFieldUpdateOperationsInput | number | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CreateElementNotificationsCreateManyInput = {
    Id: string
    Repository_Id: string
    EnableNotification?: number | null
    User_Id?: string | null
    UserGroup_Id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type CreateElementNotificationsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    EnableNotification?: NullableIntFieldUpdateOperationsInput | number | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CreateElementNotificationsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    EnableNotification?: NullableIntFieldUpdateOperationsInput | number | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DashboardReviewUserRolesCreateInput = {
    Id: string
    DashboardId: string
    UserRole: string
  }

  export type DashboardReviewUserRolesUncheckedCreateInput = {
    Id: string
    DashboardId: string
    UserRole: string
  }

  export type DashboardReviewUserRolesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    UserRole?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardReviewUserRolesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    UserRole?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardReviewUserRolesCreateManyInput = {
    Id: string
    DashboardId: string
    UserRole: string
  }

  export type DashboardReviewUserRolesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    UserRole?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardReviewUserRolesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    UserRole?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardsCreateInput = {
    Id: string
    RepositoryId: string
    Name: string
    Notes?: string | null
    Logo?: string | null
    IsEnabled: number
    CreatedBy: string
    Created: Date | string
    Modified: Date | string
    IsDefault?: number | null
    DisplayDescription?: number
    Type?: string | null
    UserType?: string | null
    DashboardSettings?: string | null
    Template?: number
  }

  export type DashboardsUncheckedCreateInput = {
    Id: string
    RepositoryId: string
    Name: string
    Notes?: string | null
    Logo?: string | null
    IsEnabled: number
    CreatedBy: string
    Created: Date | string
    Modified: Date | string
    IsDefault?: number | null
    DisplayDescription?: number
    Type?: string | null
    UserType?: string | null
    DashboardSettings?: string | null
    Template?: number
  }

  export type DashboardsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Logo?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: IntFieldUpdateOperationsInput | number
    CreatedBy?: StringFieldUpdateOperationsInput | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDefault?: NullableIntFieldUpdateOperationsInput | number | null
    DisplayDescription?: IntFieldUpdateOperationsInput | number
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
    DashboardSettings?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: IntFieldUpdateOperationsInput | number
  }

  export type DashboardsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Logo?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: IntFieldUpdateOperationsInput | number
    CreatedBy?: StringFieldUpdateOperationsInput | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDefault?: NullableIntFieldUpdateOperationsInput | number | null
    DisplayDescription?: IntFieldUpdateOperationsInput | number
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
    DashboardSettings?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: IntFieldUpdateOperationsInput | number
  }

  export type DashboardsCreateManyInput = {
    Id: string
    RepositoryId: string
    Name: string
    Notes?: string | null
    Logo?: string | null
    IsEnabled: number
    CreatedBy: string
    Created: Date | string
    Modified: Date | string
    IsDefault?: number | null
    DisplayDescription?: number
    Type?: string | null
    UserType?: string | null
    DashboardSettings?: string | null
    Template?: number
  }

  export type DashboardsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Logo?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: IntFieldUpdateOperationsInput | number
    CreatedBy?: StringFieldUpdateOperationsInput | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDefault?: NullableIntFieldUpdateOperationsInput | number | null
    DisplayDescription?: IntFieldUpdateOperationsInput | number
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
    DashboardSettings?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: IntFieldUpdateOperationsInput | number
  }

  export type DashboardsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Logo?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: IntFieldUpdateOperationsInput | number
    CreatedBy?: StringFieldUpdateOperationsInput | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDefault?: NullableIntFieldUpdateOperationsInput | number | null
    DisplayDescription?: IntFieldUpdateOperationsInput | number
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
    DashboardSettings?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: IntFieldUpdateOperationsInput | number
  }

  export type DashboardUserDefaultCreateInput = {
    Id: string
    UserId: string
    RepositoryId: string
    DashboardId: string
    Type?: string | null
  }

  export type DashboardUserDefaultUncheckedCreateInput = {
    Id: string
    UserId: string
    RepositoryId: string
    DashboardId: string
    Type?: string | null
  }

  export type DashboardUserDefaultUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardUserDefaultUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardUserDefaultCreateManyInput = {
    Id: string
    UserId: string
    RepositoryId: string
    DashboardId: string
    Type?: string | null
  }

  export type DashboardUserDefaultUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardUserDefaultUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardUserGroupsCreateInput = {
    Id: string
    DashboardId: string
    UserGroupId: string
  }

  export type DashboardUserGroupsUncheckedCreateInput = {
    Id: string
    DashboardId: string
    UserGroupId: string
  }

  export type DashboardUserGroupsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    UserGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardUserGroupsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    UserGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardUserGroupsCreateManyInput = {
    Id: string
    DashboardId: string
    UserGroupId: string
  }

  export type DashboardUserGroupsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    UserGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardUserGroupsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    UserGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardUsersCreateInput = {
    Id: string
    DashboardId: string
    UserId: string
  }

  export type DashboardUsersUncheckedCreateInput = {
    Id: string
    DashboardId: string
    UserId: string
  }

  export type DashboardUsersUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardUsersUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardUsersCreateManyInput = {
    Id: string
    DashboardId: string
    UserId: string
  }

  export type DashboardUsersUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardUsersUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardWidgetBlocksCreateInput = {
    Id: string
    DashboardWidgetId: string
    DashboardWidgetBlockTypeId: string
    Title?: string | null
    Notes?: string | null
    EAArtifactGuid?: string | null
    IsConfigured: number
    Position?: number | null
  }

  export type DashboardWidgetBlocksUncheckedCreateInput = {
    Id: string
    DashboardWidgetId: string
    DashboardWidgetBlockTypeId: string
    Title?: string | null
    Notes?: string | null
    EAArtifactGuid?: string | null
    IsConfigured: number
    Position?: number | null
  }

  export type DashboardWidgetBlocksUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardWidgetId?: StringFieldUpdateOperationsInput | string
    DashboardWidgetBlockTypeId?: StringFieldUpdateOperationsInput | string
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    EAArtifactGuid?: NullableStringFieldUpdateOperationsInput | string | null
    IsConfigured?: IntFieldUpdateOperationsInput | number
    Position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DashboardWidgetBlocksUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardWidgetId?: StringFieldUpdateOperationsInput | string
    DashboardWidgetBlockTypeId?: StringFieldUpdateOperationsInput | string
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    EAArtifactGuid?: NullableStringFieldUpdateOperationsInput | string | null
    IsConfigured?: IntFieldUpdateOperationsInput | number
    Position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DashboardWidgetBlocksCreateManyInput = {
    Id: string
    DashboardWidgetId: string
    DashboardWidgetBlockTypeId: string
    Title?: string | null
    Notes?: string | null
    EAArtifactGuid?: string | null
    IsConfigured: number
    Position?: number | null
  }

  export type DashboardWidgetBlocksUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardWidgetId?: StringFieldUpdateOperationsInput | string
    DashboardWidgetBlockTypeId?: StringFieldUpdateOperationsInput | string
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    EAArtifactGuid?: NullableStringFieldUpdateOperationsInput | string | null
    IsConfigured?: IntFieldUpdateOperationsInput | number
    Position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DashboardWidgetBlocksUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardWidgetId?: StringFieldUpdateOperationsInput | string
    DashboardWidgetBlockTypeId?: StringFieldUpdateOperationsInput | string
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    EAArtifactGuid?: NullableStringFieldUpdateOperationsInput | string | null
    IsConfigured?: IntFieldUpdateOperationsInput | number
    Position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DashboardWidgetBlockTypesCreateInput = {
    Id: string
    Name: string
    Notes?: string | null
    Category?: string | null
    Position: number
    NotSetText: string
    ConfigurationRequired: number
    IsEnabled: number
    Icon?: string | null
  }

  export type DashboardWidgetBlockTypesUncheckedCreateInput = {
    Id: string
    Name: string
    Notes?: string | null
    Category?: string | null
    Position: number
    NotSetText: string
    ConfigurationRequired: number
    IsEnabled: number
    Icon?: string | null
  }

  export type DashboardWidgetBlockTypesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: NullableStringFieldUpdateOperationsInput | string | null
    Position?: IntFieldUpdateOperationsInput | number
    NotSetText?: StringFieldUpdateOperationsInput | string
    ConfigurationRequired?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardWidgetBlockTypesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: NullableStringFieldUpdateOperationsInput | string | null
    Position?: IntFieldUpdateOperationsInput | number
    NotSetText?: StringFieldUpdateOperationsInput | string
    ConfigurationRequired?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardWidgetBlockTypesCreateManyInput = {
    Id: string
    Name: string
    Notes?: string | null
    Category?: string | null
    Position: number
    NotSetText: string
    ConfigurationRequired: number
    IsEnabled: number
    Icon?: string | null
  }

  export type DashboardWidgetBlockTypesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: NullableStringFieldUpdateOperationsInput | string | null
    Position?: IntFieldUpdateOperationsInput | number
    NotSetText?: StringFieldUpdateOperationsInput | string
    ConfigurationRequired?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardWidgetBlockTypesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: NullableStringFieldUpdateOperationsInput | string | null
    Position?: IntFieldUpdateOperationsInput | number
    NotSetText?: StringFieldUpdateOperationsInput | string
    ConfigurationRequired?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardWidgetsCreateInput = {
    Id: string
    DashboardId: string
    Name: string
    Notes?: string | null
    RowId: number
    ColumnId: number
    ConfigData?: string | null
    SizeX?: number
    SizeY?: number
    WidgetSettings?: string | null
    Template?: number
    X?: number | null
    Y?: number | null
    Rows?: number | null
    Cols?: number | null
  }

  export type DashboardWidgetsUncheckedCreateInput = {
    Id: string
    DashboardId: string
    Name: string
    Notes?: string | null
    RowId: number
    ColumnId: number
    ConfigData?: string | null
    SizeX?: number
    SizeY?: number
    WidgetSettings?: string | null
    Template?: number
    X?: number | null
    Y?: number | null
    Rows?: number | null
    Cols?: number | null
  }

  export type DashboardWidgetsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    RowId?: IntFieldUpdateOperationsInput | number
    ColumnId?: IntFieldUpdateOperationsInput | number
    ConfigData?: NullableStringFieldUpdateOperationsInput | string | null
    SizeX?: IntFieldUpdateOperationsInput | number
    SizeY?: IntFieldUpdateOperationsInput | number
    WidgetSettings?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: IntFieldUpdateOperationsInput | number
    X?: NullableIntFieldUpdateOperationsInput | number | null
    Y?: NullableIntFieldUpdateOperationsInput | number | null
    Rows?: NullableIntFieldUpdateOperationsInput | number | null
    Cols?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DashboardWidgetsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    RowId?: IntFieldUpdateOperationsInput | number
    ColumnId?: IntFieldUpdateOperationsInput | number
    ConfigData?: NullableStringFieldUpdateOperationsInput | string | null
    SizeX?: IntFieldUpdateOperationsInput | number
    SizeY?: IntFieldUpdateOperationsInput | number
    WidgetSettings?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: IntFieldUpdateOperationsInput | number
    X?: NullableIntFieldUpdateOperationsInput | number | null
    Y?: NullableIntFieldUpdateOperationsInput | number | null
    Rows?: NullableIntFieldUpdateOperationsInput | number | null
    Cols?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DashboardWidgetsCreateManyInput = {
    Id: string
    DashboardId: string
    Name: string
    Notes?: string | null
    RowId: number
    ColumnId: number
    ConfigData?: string | null
    SizeX?: number
    SizeY?: number
    WidgetSettings?: string | null
    Template?: number
    X?: number | null
    Y?: number | null
    Rows?: number | null
    Cols?: number | null
  }

  export type DashboardWidgetsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    RowId?: IntFieldUpdateOperationsInput | number
    ColumnId?: IntFieldUpdateOperationsInput | number
    ConfigData?: NullableStringFieldUpdateOperationsInput | string | null
    SizeX?: IntFieldUpdateOperationsInput | number
    SizeY?: IntFieldUpdateOperationsInput | number
    WidgetSettings?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: IntFieldUpdateOperationsInput | number
    X?: NullableIntFieldUpdateOperationsInput | number | null
    Y?: NullableIntFieldUpdateOperationsInput | number | null
    Rows?: NullableIntFieldUpdateOperationsInput | number | null
    Cols?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DashboardWidgetsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    DashboardId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    RowId?: IntFieldUpdateOperationsInput | number
    ColumnId?: IntFieldUpdateOperationsInput | number
    ConfigData?: NullableStringFieldUpdateOperationsInput | string | null
    SizeX?: IntFieldUpdateOperationsInput | number
    SizeY?: IntFieldUpdateOperationsInput | number
    WidgetSettings?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: IntFieldUpdateOperationsInput | number
    X?: NullableIntFieldUpdateOperationsInput | number | null
    Y?: NullableIntFieldUpdateOperationsInput | number | null
    Rows?: NullableIntFieldUpdateOperationsInput | number | null
    Cols?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DocumentationRequestsCreateInput = {
    Id: string
    Repository_Id: string
    User_Id: string
    UserDefinedTemplate: number
    InclusionList?: string | null
    ExclusionList?: string | null
    FileName?: string | null
    IsCancelled: number
    IsProcessed: number
    Created: Date | string
    Modified: Date | string
  }

  export type DocumentationRequestsUncheckedCreateInput = {
    Id: string
    Repository_Id: string
    User_Id: string
    UserDefinedTemplate: number
    InclusionList?: string | null
    ExclusionList?: string | null
    FileName?: string | null
    IsCancelled: number
    IsProcessed: number
    Created: Date | string
    Modified: Date | string
  }

  export type DocumentationRequestsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    User_Id?: StringFieldUpdateOperationsInput | string
    UserDefinedTemplate?: IntFieldUpdateOperationsInput | number
    InclusionList?: NullableStringFieldUpdateOperationsInput | string | null
    ExclusionList?: NullableStringFieldUpdateOperationsInput | string | null
    FileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsCancelled?: IntFieldUpdateOperationsInput | number
    IsProcessed?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentationRequestsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    User_Id?: StringFieldUpdateOperationsInput | string
    UserDefinedTemplate?: IntFieldUpdateOperationsInput | number
    InclusionList?: NullableStringFieldUpdateOperationsInput | string | null
    ExclusionList?: NullableStringFieldUpdateOperationsInput | string | null
    FileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsCancelled?: IntFieldUpdateOperationsInput | number
    IsProcessed?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentationRequestsCreateManyInput = {
    Id: string
    Repository_Id: string
    User_Id: string
    UserDefinedTemplate: number
    InclusionList?: string | null
    ExclusionList?: string | null
    FileName?: string | null
    IsCancelled: number
    IsProcessed: number
    Created: Date | string
    Modified: Date | string
  }

  export type DocumentationRequestsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    User_Id?: StringFieldUpdateOperationsInput | string
    UserDefinedTemplate?: IntFieldUpdateOperationsInput | number
    InclusionList?: NullableStringFieldUpdateOperationsInput | string | null
    ExclusionList?: NullableStringFieldUpdateOperationsInput | string | null
    FileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsCancelled?: IntFieldUpdateOperationsInput | number
    IsProcessed?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentationRequestsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    User_Id?: StringFieldUpdateOperationsInput | string
    UserDefinedTemplate?: IntFieldUpdateOperationsInput | number
    InclusionList?: NullableStringFieldUpdateOperationsInput | string | null
    ExclusionList?: NullableStringFieldUpdateOperationsInput | string | null
    FileName?: NullableStringFieldUpdateOperationsInput | string | null
    IsCancelled?: IntFieldUpdateOperationsInput | number
    IsProcessed?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainRestrictionsCreateInput = {
    Id: string
    Domain?: string | null
    IsEnabled?: number | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type DomainRestrictionsUncheckedCreateInput = {
    Id: string
    Domain?: string | null
    IsEnabled?: number | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type DomainRestrictionsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Domain?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DomainRestrictionsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Domain?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DomainRestrictionsCreateManyInput = {
    Id: string
    Domain?: string | null
    IsEnabled?: number | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type DomainRestrictionsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Domain?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DomainRestrictionsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Domain?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EAChangelogAttributesCreateInput = {
    Id: string
    EAChangelogId: string
    PropertyGuid?: string | null
    Name?: string | null
    CurrentValue?: string | null
    PreviousValue?: string | null
    ActionType?: string | null
    AttributeType?: string | null
    CreatedDate?: Date | string | null
  }

  export type EAChangelogAttributesUncheckedCreateInput = {
    Id: string
    EAChangelogId: string
    PropertyGuid?: string | null
    Name?: string | null
    CurrentValue?: string | null
    PreviousValue?: string | null
    ActionType?: string | null
    AttributeType?: string | null
    CreatedDate?: Date | string | null
  }

  export type EAChangelogAttributesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    EAChangelogId?: StringFieldUpdateOperationsInput | string
    PropertyGuid?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    CurrentValue?: NullableStringFieldUpdateOperationsInput | string | null
    PreviousValue?: NullableStringFieldUpdateOperationsInput | string | null
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    AttributeType?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EAChangelogAttributesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    EAChangelogId?: StringFieldUpdateOperationsInput | string
    PropertyGuid?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    CurrentValue?: NullableStringFieldUpdateOperationsInput | string | null
    PreviousValue?: NullableStringFieldUpdateOperationsInput | string | null
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    AttributeType?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EAChangelogAttributesCreateManyInput = {
    Id: string
    EAChangelogId: string
    PropertyGuid?: string | null
    Name?: string | null
    CurrentValue?: string | null
    PreviousValue?: string | null
    ActionType?: string | null
    AttributeType?: string | null
    CreatedDate?: Date | string | null
  }

  export type EAChangelogAttributesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    EAChangelogId?: StringFieldUpdateOperationsInput | string
    PropertyGuid?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    CurrentValue?: NullableStringFieldUpdateOperationsInput | string | null
    PreviousValue?: NullableStringFieldUpdateOperationsInput | string | null
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    AttributeType?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EAChangelogAttributesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    EAChangelogId?: StringFieldUpdateOperationsInput | string
    PropertyGuid?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    CurrentValue?: NullableStringFieldUpdateOperationsInput | string | null
    PreviousValue?: NullableStringFieldUpdateOperationsInput | string | null
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    AttributeType?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EAChangelogsCreateInput = {
    Id: string
    Repository_Id?: string | null
    ArtifactGuid: string
    ArtifactType: string
    ActionType: string
    Revision?: bigint | number | null
    CreatedDate: Date | string
    ModifiedDate: Date | string
  }

  export type EAChangelogsUncheckedCreateInput = {
    Id: string
    Repository_Id?: string | null
    ArtifactGuid: string
    ArtifactType: string
    ActionType: string
    Revision?: bigint | number | null
    CreatedDate: Date | string
    ModifiedDate: Date | string
  }

  export type EAChangelogsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    ArtifactGuid?: StringFieldUpdateOperationsInput | string
    ArtifactType?: StringFieldUpdateOperationsInput | string
    ActionType?: StringFieldUpdateOperationsInput | string
    Revision?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EAChangelogsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    ArtifactGuid?: StringFieldUpdateOperationsInput | string
    ArtifactType?: StringFieldUpdateOperationsInput | string
    ActionType?: StringFieldUpdateOperationsInput | string
    Revision?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EAChangelogsCreateManyInput = {
    Id: string
    Repository_Id?: string | null
    ArtifactGuid: string
    ArtifactType: string
    ActionType: string
    Revision?: bigint | number | null
    CreatedDate: Date | string
    ModifiedDate: Date | string
  }

  export type EAChangelogsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    ArtifactGuid?: StringFieldUpdateOperationsInput | string
    ArtifactType?: StringFieldUpdateOperationsInput | string
    ActionType?: StringFieldUpdateOperationsInput | string
    Revision?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EAChangelogsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    ArtifactGuid?: StringFieldUpdateOperationsInput | string
    ArtifactType?: StringFieldUpdateOperationsInput | string
    ActionType?: StringFieldUpdateOperationsInput | string
    Revision?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementConnectorsCreateInput = {
    Id: string
    ElementGuid?: string | null
    ElementType?: string | null
    Repository_Id?: string | null
    User_Id?: string | null
    UserGroup_Id?: string | null
    AccessRight_AccessRightKey?: string | null
    InheritRight?: number | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
    CreatedBy?: string | null
    FeatureId?: string | null
    OtherInfo?: string | null
  }

  export type ElementConnectorsUncheckedCreateInput = {
    Id: string
    ElementGuid?: string | null
    ElementType?: string | null
    Repository_Id?: string | null
    User_Id?: string | null
    UserGroup_Id?: string | null
    AccessRight_AccessRightKey?: string | null
    InheritRight?: number | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
    CreatedBy?: string | null
    FeatureId?: string | null
    OtherInfo?: string | null
  }

  export type ElementConnectorsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ElementGuid?: NullableStringFieldUpdateOperationsInput | string | null
    ElementType?: NullableStringFieldUpdateOperationsInput | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    AccessRight_AccessRightKey?: NullableStringFieldUpdateOperationsInput | string | null
    InheritRight?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    FeatureId?: NullableStringFieldUpdateOperationsInput | string | null
    OtherInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ElementConnectorsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ElementGuid?: NullableStringFieldUpdateOperationsInput | string | null
    ElementType?: NullableStringFieldUpdateOperationsInput | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    AccessRight_AccessRightKey?: NullableStringFieldUpdateOperationsInput | string | null
    InheritRight?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    FeatureId?: NullableStringFieldUpdateOperationsInput | string | null
    OtherInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ElementConnectorsCreateManyInput = {
    Id: string
    ElementGuid?: string | null
    ElementType?: string | null
    Repository_Id?: string | null
    User_Id?: string | null
    UserGroup_Id?: string | null
    AccessRight_AccessRightKey?: string | null
    InheritRight?: number | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
    CreatedBy?: string | null
    FeatureId?: string | null
    OtherInfo?: string | null
  }

  export type ElementConnectorsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ElementGuid?: NullableStringFieldUpdateOperationsInput | string | null
    ElementType?: NullableStringFieldUpdateOperationsInput | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    AccessRight_AccessRightKey?: NullableStringFieldUpdateOperationsInput | string | null
    InheritRight?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    FeatureId?: NullableStringFieldUpdateOperationsInput | string | null
    OtherInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ElementConnectorsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ElementGuid?: NullableStringFieldUpdateOperationsInput | string | null
    ElementType?: NullableStringFieldUpdateOperationsInput | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    AccessRight_AccessRightKey?: NullableStringFieldUpdateOperationsInput | string | null
    InheritRight?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    FeatureId?: NullableStringFieldUpdateOperationsInput | string | null
    OtherInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExternalAppAttributeMasterCreateInput = {
    Id: string
    ExternalAppTypeId: string
    ExternalAppId: string
    RepositoryId: string
    Name: string
    InternalName: string
    ExternalName: string
    HelpText?: string | null
    MultiSelect: number
    Filters?: string | null
    ConfigData?: string | null
    IsEnabled: number
    Created: Date | string
    Modified: Date | string
    Description?: string | null
  }

  export type ExternalAppAttributeMasterUncheckedCreateInput = {
    Id: string
    ExternalAppTypeId: string
    ExternalAppId: string
    RepositoryId: string
    Name: string
    InternalName: string
    ExternalName: string
    HelpText?: string | null
    MultiSelect: number
    Filters?: string | null
    ConfigData?: string | null
    IsEnabled: number
    Created: Date | string
    Modified: Date | string
    Description?: string | null
  }

  export type ExternalAppAttributeMasterUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ExternalAppTypeId?: StringFieldUpdateOperationsInput | string
    ExternalAppId?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    InternalName?: StringFieldUpdateOperationsInput | string
    ExternalName?: StringFieldUpdateOperationsInput | string
    HelpText?: NullableStringFieldUpdateOperationsInput | string | null
    MultiSelect?: IntFieldUpdateOperationsInput | number
    Filters?: NullableStringFieldUpdateOperationsInput | string | null
    ConfigData?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExternalAppAttributeMasterUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ExternalAppTypeId?: StringFieldUpdateOperationsInput | string
    ExternalAppId?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    InternalName?: StringFieldUpdateOperationsInput | string
    ExternalName?: StringFieldUpdateOperationsInput | string
    HelpText?: NullableStringFieldUpdateOperationsInput | string | null
    MultiSelect?: IntFieldUpdateOperationsInput | number
    Filters?: NullableStringFieldUpdateOperationsInput | string | null
    ConfigData?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExternalAppAttributeMasterCreateManyInput = {
    Id: string
    ExternalAppTypeId: string
    ExternalAppId: string
    RepositoryId: string
    Name: string
    InternalName: string
    ExternalName: string
    HelpText?: string | null
    MultiSelect: number
    Filters?: string | null
    ConfigData?: string | null
    IsEnabled: number
    Created: Date | string
    Modified: Date | string
    Description?: string | null
  }

  export type ExternalAppAttributeMasterUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ExternalAppTypeId?: StringFieldUpdateOperationsInput | string
    ExternalAppId?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    InternalName?: StringFieldUpdateOperationsInput | string
    ExternalName?: StringFieldUpdateOperationsInput | string
    HelpText?: NullableStringFieldUpdateOperationsInput | string | null
    MultiSelect?: IntFieldUpdateOperationsInput | number
    Filters?: NullableStringFieldUpdateOperationsInput | string | null
    ConfigData?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExternalAppAttributeMasterUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ExternalAppTypeId?: StringFieldUpdateOperationsInput | string
    ExternalAppId?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    InternalName?: StringFieldUpdateOperationsInput | string
    ExternalName?: StringFieldUpdateOperationsInput | string
    HelpText?: NullableStringFieldUpdateOperationsInput | string | null
    MultiSelect?: IntFieldUpdateOperationsInput | number
    Filters?: NullableStringFieldUpdateOperationsInput | string | null
    ConfigData?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExternalAppAttributesCreateInput = {
    Id: string
    ExternalAppAttributeMasterId: string
    ExternalAppProjectId: string
    ArtifactId: string
    InternalValue: string
    ExternalValue: string
    ConfigData: string
    IsDeleted?: number
    RemoteLinkId?: string | null
    Created: Date | string
    Modified: Date | string
  }

  export type ExternalAppAttributesUncheckedCreateInput = {
    Id: string
    ExternalAppAttributeMasterId: string
    ExternalAppProjectId: string
    ArtifactId: string
    InternalValue: string
    ExternalValue: string
    ConfigData: string
    IsDeleted?: number
    RemoteLinkId?: string | null
    Created: Date | string
    Modified: Date | string
  }

  export type ExternalAppAttributesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ExternalAppAttributeMasterId?: StringFieldUpdateOperationsInput | string
    ExternalAppProjectId?: StringFieldUpdateOperationsInput | string
    ArtifactId?: StringFieldUpdateOperationsInput | string
    InternalValue?: StringFieldUpdateOperationsInput | string
    ExternalValue?: StringFieldUpdateOperationsInput | string
    ConfigData?: StringFieldUpdateOperationsInput | string
    IsDeleted?: IntFieldUpdateOperationsInput | number
    RemoteLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAppAttributesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ExternalAppAttributeMasterId?: StringFieldUpdateOperationsInput | string
    ExternalAppProjectId?: StringFieldUpdateOperationsInput | string
    ArtifactId?: StringFieldUpdateOperationsInput | string
    InternalValue?: StringFieldUpdateOperationsInput | string
    ExternalValue?: StringFieldUpdateOperationsInput | string
    ConfigData?: StringFieldUpdateOperationsInput | string
    IsDeleted?: IntFieldUpdateOperationsInput | number
    RemoteLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAppAttributesCreateManyInput = {
    Id: string
    ExternalAppAttributeMasterId: string
    ExternalAppProjectId: string
    ArtifactId: string
    InternalValue: string
    ExternalValue: string
    ConfigData: string
    IsDeleted?: number
    RemoteLinkId?: string | null
    Created: Date | string
    Modified: Date | string
  }

  export type ExternalAppAttributesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ExternalAppAttributeMasterId?: StringFieldUpdateOperationsInput | string
    ExternalAppProjectId?: StringFieldUpdateOperationsInput | string
    ArtifactId?: StringFieldUpdateOperationsInput | string
    InternalValue?: StringFieldUpdateOperationsInput | string
    ExternalValue?: StringFieldUpdateOperationsInput | string
    ConfigData?: StringFieldUpdateOperationsInput | string
    IsDeleted?: IntFieldUpdateOperationsInput | number
    RemoteLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAppAttributesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ExternalAppAttributeMasterId?: StringFieldUpdateOperationsInput | string
    ExternalAppProjectId?: StringFieldUpdateOperationsInput | string
    ArtifactId?: StringFieldUpdateOperationsInput | string
    InternalValue?: StringFieldUpdateOperationsInput | string
    ExternalValue?: StringFieldUpdateOperationsInput | string
    ConfigData?: StringFieldUpdateOperationsInput | string
    IsDeleted?: IntFieldUpdateOperationsInput | number
    RemoteLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAppsCreateInput = {
    Id: string
    ExternalAppTypeId?: string | null
    ExternalAppEnvironment?: string | null
    RepositoryId?: string | null
    Name?: string | null
    Description?: string | null
    EndPointURL?: string | null
    IsExternal?: number | null
    ExternalPath?: string | null
    Username?: string | null
    Password?: string | null
    ProjectId?: string | null
    ProjectName?: string | null
    ConfigData?: string | null
    IsEnabled: number
    Created: Date | string
    Modified?: Date | string | null
  }

  export type ExternalAppsUncheckedCreateInput = {
    Id: string
    ExternalAppTypeId?: string | null
    ExternalAppEnvironment?: string | null
    RepositoryId?: string | null
    Name?: string | null
    Description?: string | null
    EndPointURL?: string | null
    IsExternal?: number | null
    ExternalPath?: string | null
    Username?: string | null
    Password?: string | null
    ProjectId?: string | null
    ProjectName?: string | null
    ConfigData?: string | null
    IsEnabled: number
    Created: Date | string
    Modified?: Date | string | null
  }

  export type ExternalAppsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ExternalAppTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ExternalAppEnvironment?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    EndPointURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsExternal?: NullableIntFieldUpdateOperationsInput | number | null
    ExternalPath?: NullableStringFieldUpdateOperationsInput | string | null
    Username?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ProjectName?: NullableStringFieldUpdateOperationsInput | string | null
    ConfigData?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExternalAppsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ExternalAppTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ExternalAppEnvironment?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    EndPointURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsExternal?: NullableIntFieldUpdateOperationsInput | number | null
    ExternalPath?: NullableStringFieldUpdateOperationsInput | string | null
    Username?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ProjectName?: NullableStringFieldUpdateOperationsInput | string | null
    ConfigData?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExternalAppsCreateManyInput = {
    Id: string
    ExternalAppTypeId?: string | null
    ExternalAppEnvironment?: string | null
    RepositoryId?: string | null
    Name?: string | null
    Description?: string | null
    EndPointURL?: string | null
    IsExternal?: number | null
    ExternalPath?: string | null
    Username?: string | null
    Password?: string | null
    ProjectId?: string | null
    ProjectName?: string | null
    ConfigData?: string | null
    IsEnabled: number
    Created: Date | string
    Modified?: Date | string | null
  }

  export type ExternalAppsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ExternalAppTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ExternalAppEnvironment?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    EndPointURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsExternal?: NullableIntFieldUpdateOperationsInput | number | null
    ExternalPath?: NullableStringFieldUpdateOperationsInput | string | null
    Username?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ProjectName?: NullableStringFieldUpdateOperationsInput | string | null
    ConfigData?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExternalAppsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ExternalAppTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ExternalAppEnvironment?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    EndPointURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsExternal?: NullableIntFieldUpdateOperationsInput | number | null
    ExternalPath?: NullableStringFieldUpdateOperationsInput | string | null
    Username?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ProjectName?: NullableStringFieldUpdateOperationsInput | string | null
    ConfigData?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExternalAppTypesCreateInput = {
    Id: string
    Name?: string | null
    Description?: string | null
    IsExternal?: number | null
    ExternalPath?: string | null
    Logo?: string | null
    Position: number
    IsEnabled: number
    AppContent?: string | null
  }

  export type ExternalAppTypesUncheckedCreateInput = {
    Id: string
    Name?: string | null
    Description?: string | null
    IsExternal?: number | null
    ExternalPath?: string | null
    Logo?: string | null
    Position: number
    IsEnabled: number
    AppContent?: string | null
  }

  export type ExternalAppTypesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsExternal?: NullableIntFieldUpdateOperationsInput | number | null
    ExternalPath?: NullableStringFieldUpdateOperationsInput | string | null
    Logo?: NullableStringFieldUpdateOperationsInput | string | null
    Position?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    AppContent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExternalAppTypesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsExternal?: NullableIntFieldUpdateOperationsInput | number | null
    ExternalPath?: NullableStringFieldUpdateOperationsInput | string | null
    Logo?: NullableStringFieldUpdateOperationsInput | string | null
    Position?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    AppContent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExternalAppTypesCreateManyInput = {
    Id: string
    Name?: string | null
    Description?: string | null
    IsExternal?: number | null
    ExternalPath?: string | null
    Logo?: string | null
    Position: number
    IsEnabled: number
    AppContent?: string | null
  }

  export type ExternalAppTypesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsExternal?: NullableIntFieldUpdateOperationsInput | number | null
    ExternalPath?: NullableStringFieldUpdateOperationsInput | string | null
    Logo?: NullableStringFieldUpdateOperationsInput | string | null
    Position?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    AppContent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExternalAppTypesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsExternal?: NullableIntFieldUpdateOperationsInput | number | null
    ExternalPath?: NullableStringFieldUpdateOperationsInput | string | null
    Logo?: NullableStringFieldUpdateOperationsInput | string | null
    Position?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    AppContent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeaturesCreateInput = {
    Id: string
    Name?: string | null
    Status?: string | null
    CreatedDate?: Date | string | null
    FeatureKey?: string | null
  }

  export type FeaturesUncheckedCreateInput = {
    Id: string
    Name?: string | null
    Status?: string | null
    CreatedDate?: Date | string | null
    FeatureKey?: string | null
  }

  export type FeaturesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FeatureKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeaturesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FeatureKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeaturesCreateManyInput = {
    Id: string
    Name?: string | null
    Status?: string | null
    CreatedDate?: Date | string | null
    FeatureKey?: string | null
  }

  export type FeaturesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FeatureKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeaturesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FeatureKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FilterProfileConnectorsCreateInput = {
    Id: string
    RepositoryId: string
    ProfileId: string
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
  }

  export type FilterProfileConnectorsUncheckedCreateInput = {
    Id: string
    RepositoryId: string
    ProfileId: string
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
  }

  export type FilterProfileConnectorsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    ProfileId?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FilterProfileConnectorsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    ProfileId?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FilterProfileConnectorsCreateManyInput = {
    Id: string
    RepositoryId: string
    ProfileId: string
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
  }

  export type FilterProfileConnectorsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    ProfileId?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FilterProfileConnectorsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    ProfileId?: StringFieldUpdateOperationsInput | string
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FilterProfilesCreateInput = {
    Id: string
    Name?: string | null
    Type?: string | null
    Status: number
    Configuration?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    IsCacheEnabled?: number | null
  }

  export type FilterProfilesUncheckedCreateInput = {
    Id: string
    Name?: string | null
    Type?: string | null
    Status: number
    Configuration?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    IsCacheEnabled?: number | null
  }

  export type FilterProfilesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: IntFieldUpdateOperationsInput | number
    Configuration?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    IsCacheEnabled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FilterProfilesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: IntFieldUpdateOperationsInput | number
    Configuration?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    IsCacheEnabled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FilterProfilesCreateManyInput = {
    Id: string
    Name?: string | null
    Type?: string | null
    Status: number
    Configuration?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    IsCacheEnabled?: number | null
  }

  export type FilterProfilesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: IntFieldUpdateOperationsInput | number
    Configuration?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    IsCacheEnabled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FilterProfilesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: IntFieldUpdateOperationsInput | number
    Configuration?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    IsCacheEnabled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GlobalRepositoryConfigurationsCreateInput = {
    Id: string
    Name: string
    IsReadOnly: number
    RepositoryConfiguration?: string | null
    AllowAllRepository: number
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type GlobalRepositoryConfigurationsUncheckedCreateInput = {
    Id: string
    Name: string
    IsReadOnly: number
    RepositoryConfiguration?: string | null
    AllowAllRepository: number
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type GlobalRepositoryConfigurationsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    RepositoryConfiguration?: NullableStringFieldUpdateOperationsInput | string | null
    AllowAllRepository?: IntFieldUpdateOperationsInput | number
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GlobalRepositoryConfigurationsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    RepositoryConfiguration?: NullableStringFieldUpdateOperationsInput | string | null
    AllowAllRepository?: IntFieldUpdateOperationsInput | number
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GlobalRepositoryConfigurationsCreateManyInput = {
    Id: string
    Name: string
    IsReadOnly: number
    RepositoryConfiguration?: string | null
    AllowAllRepository: number
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type GlobalRepositoryConfigurationsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    RepositoryConfiguration?: NullableStringFieldUpdateOperationsInput | string | null
    AllowAllRepository?: IntFieldUpdateOperationsInput | number
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GlobalRepositoryConfigurationsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    RepositoryConfiguration?: NullableStringFieldUpdateOperationsInput | string | null
    AllowAllRepository?: IntFieldUpdateOperationsInput | number
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupFeaturesCreateInput = {
    Id: string
    UserGroup_Id?: string | null
    Feature_Id?: string | null
    CreatedDate?: Date | string | null
    Status?: string | null
  }

  export type GroupFeaturesUncheckedCreateInput = {
    Id: string
    UserGroup_Id?: string | null
    Feature_Id?: string | null
    CreatedDate?: Date | string | null
    Status?: string | null
  }

  export type GroupFeaturesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Feature_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupFeaturesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Feature_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupFeaturesCreateManyInput = {
    Id: string
    UserGroup_Id?: string | null
    Feature_Id?: string | null
    CreatedDate?: Date | string | null
    Status?: string | null
  }

  export type GroupFeaturesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Feature_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupFeaturesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Feature_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuestSignupSettingsCreateInput = {
    Id: string
    GlobalRepoConfigId?: string | null
    AllowAllRepository?: number | null
    RepositoryPermissions?: string | null
    Status?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type GuestSignupSettingsUncheckedCreateInput = {
    Id: string
    GlobalRepoConfigId?: string | null
    AllowAllRepository?: number | null
    RepositoryPermissions?: string | null
    Status?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type GuestSignupSettingsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    GlobalRepoConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    AllowAllRepository?: NullableIntFieldUpdateOperationsInput | number | null
    RepositoryPermissions?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuestSignupSettingsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    GlobalRepoConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    AllowAllRepository?: NullableIntFieldUpdateOperationsInput | number | null
    RepositoryPermissions?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuestSignupSettingsCreateManyInput = {
    Id: string
    GlobalRepoConfigId?: string | null
    AllowAllRepository?: number | null
    RepositoryPermissions?: string | null
    Status?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type GuestSignupSettingsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    GlobalRepoConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    AllowAllRepository?: NullableIntFieldUpdateOperationsInput | number | null
    RepositoryPermissions?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuestSignupSettingsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    GlobalRepoConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    AllowAllRepository?: NullableIntFieldUpdateOperationsInput | number | null
    RepositoryPermissions?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IdPConnectionsCreateInput = {
    Id: string
    Name?: string | null
    SigninUrl?: string | null
    CertificatePath?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
    AllowAllRepository?: number | null
    RepositoryPermissions?: string | null
    RepositoryPermissionId?: string | null
    IdPSource?: string | null
    LogoutUrl?: string | null
    IDPCertificateEncrypted?: string | null
    SPCertificateEncrypted?: string | null
    SPCertificatePath?: string | null
    SPCertificatePassword?: string | null
    GlobalRepoConfigId?: string | null
    AttributesMapping?: string | null
  }

  export type IdPConnectionsUncheckedCreateInput = {
    Id: string
    Name?: string | null
    SigninUrl?: string | null
    CertificatePath?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
    AllowAllRepository?: number | null
    RepositoryPermissions?: string | null
    RepositoryPermissionId?: string | null
    IdPSource?: string | null
    LogoutUrl?: string | null
    IDPCertificateEncrypted?: string | null
    SPCertificateEncrypted?: string | null
    SPCertificatePath?: string | null
    SPCertificatePassword?: string | null
    GlobalRepoConfigId?: string | null
    AttributesMapping?: string | null
  }

  export type IdPConnectionsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    SigninUrl?: NullableStringFieldUpdateOperationsInput | string | null
    CertificatePath?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    AllowAllRepository?: NullableIntFieldUpdateOperationsInput | number | null
    RepositoryPermissions?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryPermissionId?: NullableStringFieldUpdateOperationsInput | string | null
    IdPSource?: NullableStringFieldUpdateOperationsInput | string | null
    LogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    IDPCertificateEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    SPCertificateEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    SPCertificatePath?: NullableStringFieldUpdateOperationsInput | string | null
    SPCertificatePassword?: NullableStringFieldUpdateOperationsInput | string | null
    GlobalRepoConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    AttributesMapping?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IdPConnectionsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    SigninUrl?: NullableStringFieldUpdateOperationsInput | string | null
    CertificatePath?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    AllowAllRepository?: NullableIntFieldUpdateOperationsInput | number | null
    RepositoryPermissions?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryPermissionId?: NullableStringFieldUpdateOperationsInput | string | null
    IdPSource?: NullableStringFieldUpdateOperationsInput | string | null
    LogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    IDPCertificateEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    SPCertificateEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    SPCertificatePath?: NullableStringFieldUpdateOperationsInput | string | null
    SPCertificatePassword?: NullableStringFieldUpdateOperationsInput | string | null
    GlobalRepoConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    AttributesMapping?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IdPConnectionsCreateManyInput = {
    Id: string
    Name?: string | null
    SigninUrl?: string | null
    CertificatePath?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
    AllowAllRepository?: number | null
    RepositoryPermissions?: string | null
    RepositoryPermissionId?: string | null
    IdPSource?: string | null
    LogoutUrl?: string | null
    IDPCertificateEncrypted?: string | null
    SPCertificateEncrypted?: string | null
    SPCertificatePath?: string | null
    SPCertificatePassword?: string | null
    GlobalRepoConfigId?: string | null
    AttributesMapping?: string | null
  }

  export type IdPConnectionsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    SigninUrl?: NullableStringFieldUpdateOperationsInput | string | null
    CertificatePath?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    AllowAllRepository?: NullableIntFieldUpdateOperationsInput | number | null
    RepositoryPermissions?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryPermissionId?: NullableStringFieldUpdateOperationsInput | string | null
    IdPSource?: NullableStringFieldUpdateOperationsInput | string | null
    LogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    IDPCertificateEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    SPCertificateEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    SPCertificatePath?: NullableStringFieldUpdateOperationsInput | string | null
    SPCertificatePassword?: NullableStringFieldUpdateOperationsInput | string | null
    GlobalRepoConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    AttributesMapping?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IdPConnectionsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    SigninUrl?: NullableStringFieldUpdateOperationsInput | string | null
    CertificatePath?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    AllowAllRepository?: NullableIntFieldUpdateOperationsInput | number | null
    RepositoryPermissions?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryPermissionId?: NullableStringFieldUpdateOperationsInput | string | null
    IdPSource?: NullableStringFieldUpdateOperationsInput | string | null
    LogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    IDPCertificateEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    SPCertificateEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    SPCertificatePath?: NullableStringFieldUpdateOperationsInput | string | null
    SPCertificatePassword?: NullableStringFieldUpdateOperationsInput | string | null
    GlobalRepoConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    AttributesMapping?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LDAPConnectionsCreateInput = {
    Id: string
    Name?: string | null
    Server?: string | null
    Port?: number | null
    Domain?: string | null
    UserName?: string | null
    Password?: string | null
    SSL?: number | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
  }

  export type LDAPConnectionsUncheckedCreateInput = {
    Id: string
    Name?: string | null
    Server?: string | null
    Port?: number | null
    Domain?: string | null
    UserName?: string | null
    Password?: string | null
    SSL?: number | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
  }

  export type LDAPConnectionsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Server?: NullableStringFieldUpdateOperationsInput | string | null
    Port?: NullableIntFieldUpdateOperationsInput | number | null
    Domain?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    SSL?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LDAPConnectionsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Server?: NullableStringFieldUpdateOperationsInput | string | null
    Port?: NullableIntFieldUpdateOperationsInput | number | null
    Domain?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    SSL?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LDAPConnectionsCreateManyInput = {
    Id: string
    Name?: string | null
    Server?: string | null
    Port?: number | null
    Domain?: string | null
    UserName?: string | null
    Password?: string | null
    SSL?: number | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
  }

  export type LDAPConnectionsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Server?: NullableStringFieldUpdateOperationsInput | string | null
    Port?: NullableIntFieldUpdateOperationsInput | number | null
    Domain?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    SSL?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LDAPConnectionsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Server?: NullableStringFieldUpdateOperationsInput | string | null
    Port?: NullableIntFieldUpdateOperationsInput | number | null
    Domain?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    SSL?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MDGProfileConnectorsCreateInput = {
    Id: string
    UserGroupId?: string | null
    ProfileId?: string | null
    MdgId?: string | null
    RepositoryId?: string | null
    Status?: number | null
    CreatedDate?: Date | string | null
  }

  export type MDGProfileConnectorsUncheckedCreateInput = {
    Id: string
    UserGroupId?: string | null
    ProfileId?: string | null
    MdgId?: string | null
    RepositoryId?: string | null
    Status?: number | null
    CreatedDate?: Date | string | null
  }

  export type MDGProfileConnectorsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    MdgId?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MDGProfileConnectorsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    MdgId?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MDGProfileConnectorsCreateManyInput = {
    Id: string
    UserGroupId?: string | null
    ProfileId?: string | null
    MdgId?: string | null
    RepositoryId?: string | null
    Status?: number | null
    CreatedDate?: Date | string | null
  }

  export type MDGProfileConnectorsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    MdgId?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MDGProfileConnectorsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    MdgId?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MDGTechnologiesCreateInput = {
    Id: string
    Repository_Id: string
    Name: string
    InternalName?: string | null
    Description?: string | null
    XmlContent?: string | null
    BuiltIn?: number
    IsEnabled?: number
    Created?: Date | string
    Modified?: Date | string
  }

  export type MDGTechnologiesUncheckedCreateInput = {
    Id: string
    Repository_Id: string
    Name: string
    InternalName?: string | null
    Description?: string | null
    XmlContent?: string | null
    BuiltIn?: number
    IsEnabled?: number
    Created?: Date | string
    Modified?: Date | string
  }

  export type MDGTechnologiesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    InternalName?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    XmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    BuiltIn?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MDGTechnologiesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    InternalName?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    XmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    BuiltIn?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MDGTechnologiesCreateManyInput = {
    Id: string
    Repository_Id: string
    Name: string
    InternalName?: string | null
    Description?: string | null
    XmlContent?: string | null
    BuiltIn?: number
    IsEnabled?: number
    Created?: Date | string
    Modified?: Date | string
  }

  export type MDGTechnologiesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    InternalName?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    XmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    BuiltIn?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MDGTechnologiesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    InternalName?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    XmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    BuiltIn?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemProfileConnectorsCreateInput = {
    Id: string
    Repository_Id?: string | null
    User_Id?: string | null
    UserGroup_Id?: string | null
    Profile_Id?: string | null
    Default_Profile_Id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type MenuItemProfileConnectorsUncheckedCreateInput = {
    Id: string
    Repository_Id?: string | null
    User_Id?: string | null
    UserGroup_Id?: string | null
    Profile_Id?: string | null
    Default_Profile_Id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type MenuItemProfileConnectorsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Profile_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Default_Profile_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuItemProfileConnectorsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Profile_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Default_Profile_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuItemProfileConnectorsCreateManyInput = {
    Id: string
    Repository_Id?: string | null
    User_Id?: string | null
    UserGroup_Id?: string | null
    Profile_Id?: string | null
    Default_Profile_Id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type MenuItemProfileConnectorsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Profile_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Default_Profile_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuItemProfileConnectorsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Profile_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Default_Profile_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuItemProfilesCreateInput = {
    Id: string
    Repository_Id?: string | null
    Name?: string | null
    Type?: string | null
    Status?: number
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type MenuItemProfilesUncheckedCreateInput = {
    Id: string
    Repository_Id?: string | null
    Name?: string | null
    Type?: string | null
    Status?: number
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type MenuItemProfilesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: IntFieldUpdateOperationsInput | number
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuItemProfilesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: IntFieldUpdateOperationsInput | number
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuItemProfilesCreateManyInput = {
    Id: string
    Repository_Id?: string | null
    Name?: string | null
    Type?: string | null
    Status?: number
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type MenuItemProfilesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: IntFieldUpdateOperationsInput | number
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuItemProfilesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: IntFieldUpdateOperationsInput | number
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuItemProfileSettingsCreateInput = {
    Id: string
    Profile_Id?: string | null
    MenuItemKey?: string | null
    IsVisible?: number | null
    IfShowOnlyContent?: number | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type MenuItemProfileSettingsUncheckedCreateInput = {
    Id: string
    Profile_Id?: string | null
    MenuItemKey?: string | null
    IsVisible?: number | null
    IfShowOnlyContent?: number | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type MenuItemProfileSettingsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Profile_Id?: NullableStringFieldUpdateOperationsInput | string | null
    MenuItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    IsVisible?: NullableIntFieldUpdateOperationsInput | number | null
    IfShowOnlyContent?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuItemProfileSettingsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Profile_Id?: NullableStringFieldUpdateOperationsInput | string | null
    MenuItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    IsVisible?: NullableIntFieldUpdateOperationsInput | number | null
    IfShowOnlyContent?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuItemProfileSettingsCreateManyInput = {
    Id: string
    Profile_Id?: string | null
    MenuItemKey?: string | null
    IsVisible?: number | null
    IfShowOnlyContent?: number | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type MenuItemProfileSettingsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Profile_Id?: NullableStringFieldUpdateOperationsInput | string | null
    MenuItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    IsVisible?: NullableIntFieldUpdateOperationsInput | number | null
    IfShowOnlyContent?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuItemProfileSettingsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Profile_Id?: NullableStringFieldUpdateOperationsInput | string | null
    MenuItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    IsVisible?: NullableIntFieldUpdateOperationsInput | number | null
    IfShowOnlyContent?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuViewHistoryCreateInput = {
    Id: string
    RepositoryId?: string | null
    UserId?: string | null
    PageKeys?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type MenuViewHistoryUncheckedCreateInput = {
    Id: string
    RepositoryId?: string | null
    UserId?: string | null
    PageKeys?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type MenuViewHistoryUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    PageKeys?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuViewHistoryUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    PageKeys?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuViewHistoryCreateManyInput = {
    Id: string
    RepositoryId?: string | null
    UserId?: string | null
    PageKeys?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type MenuViewHistoryUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    PageKeys?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuViewHistoryUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    PageKeys?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OIDCApplicationsCreateInput = {
    Id: string
    ClientId?: string | null
    ClientSecret?: string | null
    ConcurrencyToken?: string | null
    ConsentType?: string | null
    DisplayName?: string | null
    DisplayNames?: string | null
    Permissions?: string | null
    PostLogoutRedirectUris?: string | null
    Properties?: string | null
    RedirectUris?: string | null
    Requirements?: string | null
    Type?: string | null
    OIDCAuthorizations?: OIDCAuthorizationsCreateNestedManyWithoutOIDCApplicationsInput
    OIDCTokens?: OIDCTokensCreateNestedManyWithoutOIDCApplicationsInput
  }

  export type OIDCApplicationsUncheckedCreateInput = {
    Id: string
    ClientId?: string | null
    ClientSecret?: string | null
    ConcurrencyToken?: string | null
    ConsentType?: string | null
    DisplayName?: string | null
    DisplayNames?: string | null
    Permissions?: string | null
    PostLogoutRedirectUris?: string | null
    Properties?: string | null
    RedirectUris?: string | null
    Requirements?: string | null
    Type?: string | null
    OIDCAuthorizations?: OIDCAuthorizationsUncheckedCreateNestedManyWithoutOIDCApplicationsInput
    OIDCTokens?: OIDCTokensUncheckedCreateNestedManyWithoutOIDCApplicationsInput
  }

  export type OIDCApplicationsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ClientId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    ConsentType?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayNames?: NullableStringFieldUpdateOperationsInput | string | null
    Permissions?: NullableStringFieldUpdateOperationsInput | string | null
    PostLogoutRedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Requirements?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCAuthorizations?: OIDCAuthorizationsUpdateManyWithoutOIDCApplicationsInput
    OIDCTokens?: OIDCTokensUpdateManyWithoutOIDCApplicationsInput
  }

  export type OIDCApplicationsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ClientId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    ConsentType?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayNames?: NullableStringFieldUpdateOperationsInput | string | null
    Permissions?: NullableStringFieldUpdateOperationsInput | string | null
    PostLogoutRedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Requirements?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCAuthorizations?: OIDCAuthorizationsUncheckedUpdateManyWithoutOIDCApplicationsInput
    OIDCTokens?: OIDCTokensUncheckedUpdateManyWithoutOIDCApplicationsInput
  }

  export type OIDCApplicationsCreateManyInput = {
    Id: string
    ClientId?: string | null
    ClientSecret?: string | null
    ConcurrencyToken?: string | null
    ConsentType?: string | null
    DisplayName?: string | null
    DisplayNames?: string | null
    Permissions?: string | null
    PostLogoutRedirectUris?: string | null
    Properties?: string | null
    RedirectUris?: string | null
    Requirements?: string | null
    Type?: string | null
  }

  export type OIDCApplicationsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ClientId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    ConsentType?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayNames?: NullableStringFieldUpdateOperationsInput | string | null
    Permissions?: NullableStringFieldUpdateOperationsInput | string | null
    PostLogoutRedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Requirements?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OIDCApplicationsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ClientId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    ConsentType?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayNames?: NullableStringFieldUpdateOperationsInput | string | null
    Permissions?: NullableStringFieldUpdateOperationsInput | string | null
    PostLogoutRedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Requirements?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OIDCAuthorizationsCreateInput = {
    Id: string
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    Properties?: string | null
    Scopes?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
    OIDCApplications?: OIDCApplicationsCreateNestedOneWithoutOIDCAuthorizationsInput
    OIDCTokens?: OIDCTokensCreateNestedManyWithoutOIDCAuthorizationsInput
  }

  export type OIDCAuthorizationsUncheckedCreateInput = {
    Id: string
    ApplicationId?: string | null
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    Properties?: string | null
    Scopes?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
    OIDCTokens?: OIDCTokensUncheckedCreateNestedManyWithoutOIDCAuthorizationsInput
  }

  export type OIDCAuthorizationsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    Scopes?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCApplications?: OIDCApplicationsUpdateOneWithoutOIDCAuthorizationsInput
    OIDCTokens?: OIDCTokensUpdateManyWithoutOIDCAuthorizationsInput
  }

  export type OIDCAuthorizationsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ApplicationId?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    Scopes?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCTokens?: OIDCTokensUncheckedUpdateManyWithoutOIDCAuthorizationsInput
  }

  export type OIDCAuthorizationsCreateManyInput = {
    Id: string
    ApplicationId?: string | null
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    Properties?: string | null
    Scopes?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
  }

  export type OIDCAuthorizationsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    Scopes?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OIDCAuthorizationsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ApplicationId?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    Scopes?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OIDCScopesCreateInput = {
    Id: string
    ConcurrencyToken?: string | null
    Description?: string | null
    Descriptions?: string | null
    DisplayName?: string | null
    DisplayNames?: string | null
    Name?: string | null
    Properties?: string | null
    Resources?: string | null
  }

  export type OIDCScopesUncheckedCreateInput = {
    Id: string
    ConcurrencyToken?: string | null
    Description?: string | null
    Descriptions?: string | null
    DisplayName?: string | null
    DisplayNames?: string | null
    Name?: string | null
    Properties?: string | null
    Resources?: string | null
  }

  export type OIDCScopesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayNames?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    Resources?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OIDCScopesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayNames?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    Resources?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OIDCScopesCreateManyInput = {
    Id: string
    ConcurrencyToken?: string | null
    Description?: string | null
    Descriptions?: string | null
    DisplayName?: string | null
    DisplayNames?: string | null
    Name?: string | null
    Properties?: string | null
    Resources?: string | null
  }

  export type OIDCScopesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayNames?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    Resources?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OIDCScopesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayNames?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    Resources?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OIDCTokensCreateInput = {
    Id: string
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    ExpirationDate?: Date | string | null
    Payload?: string | null
    Properties?: string | null
    RedemptionDate?: Date | string | null
    ReferenceId?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
    OIDCApplications?: OIDCApplicationsCreateNestedOneWithoutOIDCTokensInput
    OIDCAuthorizations?: OIDCAuthorizationsCreateNestedOneWithoutOIDCTokensInput
  }

  export type OIDCTokensUncheckedCreateInput = {
    Id: string
    ApplicationId?: string | null
    AuthorizationId?: string | null
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    ExpirationDate?: Date | string | null
    Payload?: string | null
    Properties?: string | null
    RedemptionDate?: Date | string | null
    ReferenceId?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
  }

  export type OIDCTokensUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Payload?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedemptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCApplications?: OIDCApplicationsUpdateOneWithoutOIDCTokensInput
    OIDCAuthorizations?: OIDCAuthorizationsUpdateOneWithoutOIDCTokensInput
  }

  export type OIDCTokensUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ApplicationId?: NullableStringFieldUpdateOperationsInput | string | null
    AuthorizationId?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Payload?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedemptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OIDCTokensCreateManyInput = {
    Id: string
    ApplicationId?: string | null
    AuthorizationId?: string | null
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    ExpirationDate?: Date | string | null
    Payload?: string | null
    Properties?: string | null
    RedemptionDate?: Date | string | null
    ReferenceId?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
  }

  export type OIDCTokensUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Payload?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedemptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OIDCTokensUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ApplicationId?: NullableStringFieldUpdateOperationsInput | string | null
    AuthorizationId?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Payload?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedemptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfilesCreateInput = {
    Id: string
    MDGTechnology_Id: string
    Name: string
    Description?: string | null
    ProfileContent?: string | null
    IsDefault: number
    IsEnabled?: number
    Created?: Date | string
    Modified?: Date | string
    EnableTechnologyGroup?: number
    EnableInheritedGroup?: number
    IncludeBaseAttributes?: number
  }

  export type ProfilesUncheckedCreateInput = {
    Id: string
    MDGTechnology_Id: string
    Name: string
    Description?: string | null
    ProfileContent?: string | null
    IsDefault: number
    IsEnabled?: number
    Created?: Date | string
    Modified?: Date | string
    EnableTechnologyGroup?: number
    EnableInheritedGroup?: number
    IncludeBaseAttributes?: number
  }

  export type ProfilesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MDGTechnology_Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileContent?: NullableStringFieldUpdateOperationsInput | string | null
    IsDefault?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    EnableTechnologyGroup?: IntFieldUpdateOperationsInput | number
    EnableInheritedGroup?: IntFieldUpdateOperationsInput | number
    IncludeBaseAttributes?: IntFieldUpdateOperationsInput | number
  }

  export type ProfilesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MDGTechnology_Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileContent?: NullableStringFieldUpdateOperationsInput | string | null
    IsDefault?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    EnableTechnologyGroup?: IntFieldUpdateOperationsInput | number
    EnableInheritedGroup?: IntFieldUpdateOperationsInput | number
    IncludeBaseAttributes?: IntFieldUpdateOperationsInput | number
  }

  export type ProfilesCreateManyInput = {
    Id: string
    MDGTechnology_Id: string
    Name: string
    Description?: string | null
    ProfileContent?: string | null
    IsDefault: number
    IsEnabled?: number
    Created?: Date | string
    Modified?: Date | string
    EnableTechnologyGroup?: number
    EnableInheritedGroup?: number
    IncludeBaseAttributes?: number
  }

  export type ProfilesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MDGTechnology_Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileContent?: NullableStringFieldUpdateOperationsInput | string | null
    IsDefault?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    EnableTechnologyGroup?: IntFieldUpdateOperationsInput | number
    EnableInheritedGroup?: IntFieldUpdateOperationsInput | number
    IncludeBaseAttributes?: IntFieldUpdateOperationsInput | number
  }

  export type ProfilesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MDGTechnology_Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileContent?: NullableStringFieldUpdateOperationsInput | string | null
    IsDefault?: IntFieldUpdateOperationsInput | number
    IsEnabled?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    EnableTechnologyGroup?: IntFieldUpdateOperationsInput | number
    EnableInheritedGroup?: IntFieldUpdateOperationsInput | number
    IncludeBaseAttributes?: IntFieldUpdateOperationsInput | number
  }

  export type PropertyMenuItemConnectorsCreateInput = {
    Id: string
    MenuItemKey?: string | null
    PageType?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type PropertyMenuItemConnectorsUncheckedCreateInput = {
    Id: string
    MenuItemKey?: string | null
    PageType?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type PropertyMenuItemConnectorsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MenuItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    PageType?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyMenuItemConnectorsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MenuItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    PageType?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyMenuItemConnectorsCreateManyInput = {
    Id: string
    MenuItemKey?: string | null
    PageType?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type PropertyMenuItemConnectorsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MenuItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    PageType?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyMenuItemConnectorsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MenuItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    PageType?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyMenuItemsCreateInput = {
    Id: string
    MenuItemKey?: string | null
    Name?: string | null
    Description?: string | null
    IconClass: string
    Position: number
    Status?: number
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type PropertyMenuItemsUncheckedCreateInput = {
    Id: string
    MenuItemKey?: string | null
    Name?: string | null
    Description?: string | null
    IconClass: string
    Position: number
    Status?: number
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type PropertyMenuItemsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MenuItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IconClass?: StringFieldUpdateOperationsInput | string
    Position?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyMenuItemsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MenuItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IconClass?: StringFieldUpdateOperationsInput | string
    Position?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyMenuItemsCreateManyInput = {
    Id: string
    MenuItemKey?: string | null
    Name?: string | null
    Description?: string | null
    IconClass: string
    Position: number
    Status?: number
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type PropertyMenuItemsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MenuItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IconClass?: StringFieldUpdateOperationsInput | string
    Position?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyMenuItemsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MenuItemKey?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IconClass?: StringFieldUpdateOperationsInput | string
    Position?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RepositoriesCreateInput = {
    Id: string
    Name?: string | null
    Alias?: string | null
    Description?: string | null
    EAPFile?: string | null
    IsCacheEnabled?: number | null
    AuthRequired?: number | null
    UserName?: string | null
    Password?: string | null
    IsEnabled?: number | null
    InstanceCount?: number | null
    Created: Date | string
    Modified: Date | string
    Status?: string | null
    Protocol?: string | null
    Server?: string | null
    Port?: string | null
    Model?: string | null
    OslcAccessCode?: string | null
    EAUserAuth?: number | null
    UserIdentifier?: string | null
    DBType?: number | null
  }

  export type RepositoriesUncheckedCreateInput = {
    Id: string
    Name?: string | null
    Alias?: string | null
    Description?: string | null
    EAPFile?: string | null
    IsCacheEnabled?: number | null
    AuthRequired?: number | null
    UserName?: string | null
    Password?: string | null
    IsEnabled?: number | null
    InstanceCount?: number | null
    Created: Date | string
    Modified: Date | string
    Status?: string | null
    Protocol?: string | null
    Server?: string | null
    Port?: string | null
    Model?: string | null
    OslcAccessCode?: string | null
    EAUserAuth?: number | null
    UserIdentifier?: string | null
    DBType?: number | null
  }

  export type RepositoriesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Alias?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    EAPFile?: NullableStringFieldUpdateOperationsInput | string | null
    IsCacheEnabled?: NullableIntFieldUpdateOperationsInput | number | null
    AuthRequired?: NullableIntFieldUpdateOperationsInput | number | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: NullableIntFieldUpdateOperationsInput | number | null
    InstanceCount?: NullableIntFieldUpdateOperationsInput | number | null
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Protocol?: NullableStringFieldUpdateOperationsInput | string | null
    Server?: NullableStringFieldUpdateOperationsInput | string | null
    Port?: NullableStringFieldUpdateOperationsInput | string | null
    Model?: NullableStringFieldUpdateOperationsInput | string | null
    OslcAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    EAUserAuth?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    DBType?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepositoriesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Alias?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    EAPFile?: NullableStringFieldUpdateOperationsInput | string | null
    IsCacheEnabled?: NullableIntFieldUpdateOperationsInput | number | null
    AuthRequired?: NullableIntFieldUpdateOperationsInput | number | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: NullableIntFieldUpdateOperationsInput | number | null
    InstanceCount?: NullableIntFieldUpdateOperationsInput | number | null
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Protocol?: NullableStringFieldUpdateOperationsInput | string | null
    Server?: NullableStringFieldUpdateOperationsInput | string | null
    Port?: NullableStringFieldUpdateOperationsInput | string | null
    Model?: NullableStringFieldUpdateOperationsInput | string | null
    OslcAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    EAUserAuth?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    DBType?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepositoriesCreateManyInput = {
    Id: string
    Name?: string | null
    Alias?: string | null
    Description?: string | null
    EAPFile?: string | null
    IsCacheEnabled?: number | null
    AuthRequired?: number | null
    UserName?: string | null
    Password?: string | null
    IsEnabled?: number | null
    InstanceCount?: number | null
    Created: Date | string
    Modified: Date | string
    Status?: string | null
    Protocol?: string | null
    Server?: string | null
    Port?: string | null
    Model?: string | null
    OslcAccessCode?: string | null
    EAUserAuth?: number | null
    UserIdentifier?: string | null
    DBType?: number | null
  }

  export type RepositoriesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Alias?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    EAPFile?: NullableStringFieldUpdateOperationsInput | string | null
    IsCacheEnabled?: NullableIntFieldUpdateOperationsInput | number | null
    AuthRequired?: NullableIntFieldUpdateOperationsInput | number | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: NullableIntFieldUpdateOperationsInput | number | null
    InstanceCount?: NullableIntFieldUpdateOperationsInput | number | null
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Protocol?: NullableStringFieldUpdateOperationsInput | string | null
    Server?: NullableStringFieldUpdateOperationsInput | string | null
    Port?: NullableStringFieldUpdateOperationsInput | string | null
    Model?: NullableStringFieldUpdateOperationsInput | string | null
    OslcAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    EAUserAuth?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    DBType?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepositoriesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Alias?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    EAPFile?: NullableStringFieldUpdateOperationsInput | string | null
    IsCacheEnabled?: NullableIntFieldUpdateOperationsInput | number | null
    AuthRequired?: NullableIntFieldUpdateOperationsInput | number | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    IsEnabled?: NullableIntFieldUpdateOperationsInput | number | null
    InstanceCount?: NullableIntFieldUpdateOperationsInput | number | null
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Protocol?: NullableStringFieldUpdateOperationsInput | string | null
    Server?: NullableStringFieldUpdateOperationsInput | string | null
    Port?: NullableStringFieldUpdateOperationsInput | string | null
    Model?: NullableStringFieldUpdateOperationsInput | string | null
    OslcAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    EAUserAuth?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    DBType?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepositoryConnectorsCreateInput = {
    Id: string
    Repository_Id: string
    User_Id?: string | null
    UserGroup_Id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
    Dashboard_Id?: string | null
    EAUserAuth?: number | null
    IsUserDefault?: number | null
  }

  export type RepositoryConnectorsUncheckedCreateInput = {
    Id: string
    Repository_Id: string
    User_Id?: string | null
    UserGroup_Id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
    Dashboard_Id?: string | null
    EAUserAuth?: number | null
    IsUserDefault?: number | null
  }

  export type RepositoryConnectorsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Dashboard_Id?: NullableStringFieldUpdateOperationsInput | string | null
    EAUserAuth?: NullableIntFieldUpdateOperationsInput | number | null
    IsUserDefault?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepositoryConnectorsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Dashboard_Id?: NullableStringFieldUpdateOperationsInput | string | null
    EAUserAuth?: NullableIntFieldUpdateOperationsInput | number | null
    IsUserDefault?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepositoryConnectorsCreateManyInput = {
    Id: string
    Repository_Id: string
    User_Id?: string | null
    UserGroup_Id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
    Dashboard_Id?: string | null
    EAUserAuth?: number | null
    IsUserDefault?: number | null
  }

  export type RepositoryConnectorsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Dashboard_Id?: NullableStringFieldUpdateOperationsInput | string | null
    EAUserAuth?: NullableIntFieldUpdateOperationsInput | number | null
    IsUserDefault?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepositoryConnectorsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: StringFieldUpdateOperationsInput | string
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Dashboard_Id?: NullableStringFieldUpdateOperationsInput | string | null
    EAUserAuth?: NullableIntFieldUpdateOperationsInput | number | null
    IsUserDefault?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepositoryDBConnectionsCreateInput = {
    Id: string
    Repository_Id?: string | null
    CreateElement?: number | null
    ConnectionType?: string | null
    ConnectionDetail?: string | null
    DBType?: string | null
    Server?: string | null
    Port?: string | null
    DBName?: string | null
    Username?: string | null
    Password?: string | null
    DsnName?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type RepositoryDBConnectionsUncheckedCreateInput = {
    Id: string
    Repository_Id?: string | null
    CreateElement?: number | null
    ConnectionType?: string | null
    ConnectionDetail?: string | null
    DBType?: string | null
    Server?: string | null
    Port?: string | null
    DBName?: string | null
    Username?: string | null
    Password?: string | null
    DsnName?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type RepositoryDBConnectionsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreateElement?: NullableIntFieldUpdateOperationsInput | number | null
    ConnectionType?: NullableStringFieldUpdateOperationsInput | string | null
    ConnectionDetail?: NullableStringFieldUpdateOperationsInput | string | null
    DBType?: NullableStringFieldUpdateOperationsInput | string | null
    Server?: NullableStringFieldUpdateOperationsInput | string | null
    Port?: NullableStringFieldUpdateOperationsInput | string | null
    DBName?: NullableStringFieldUpdateOperationsInput | string | null
    Username?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    DsnName?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RepositoryDBConnectionsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreateElement?: NullableIntFieldUpdateOperationsInput | number | null
    ConnectionType?: NullableStringFieldUpdateOperationsInput | string | null
    ConnectionDetail?: NullableStringFieldUpdateOperationsInput | string | null
    DBType?: NullableStringFieldUpdateOperationsInput | string | null
    Server?: NullableStringFieldUpdateOperationsInput | string | null
    Port?: NullableStringFieldUpdateOperationsInput | string | null
    DBName?: NullableStringFieldUpdateOperationsInput | string | null
    Username?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    DsnName?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RepositoryDBConnectionsCreateManyInput = {
    Id: string
    Repository_Id?: string | null
    CreateElement?: number | null
    ConnectionType?: string | null
    ConnectionDetail?: string | null
    DBType?: string | null
    Server?: string | null
    Port?: string | null
    DBName?: string | null
    Username?: string | null
    Password?: string | null
    DsnName?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type RepositoryDBConnectionsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreateElement?: NullableIntFieldUpdateOperationsInput | number | null
    ConnectionType?: NullableStringFieldUpdateOperationsInput | string | null
    ConnectionDetail?: NullableStringFieldUpdateOperationsInput | string | null
    DBType?: NullableStringFieldUpdateOperationsInput | string | null
    Server?: NullableStringFieldUpdateOperationsInput | string | null
    Port?: NullableStringFieldUpdateOperationsInput | string | null
    DBName?: NullableStringFieldUpdateOperationsInput | string | null
    Username?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    DsnName?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RepositoryDBConnectionsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreateElement?: NullableIntFieldUpdateOperationsInput | number | null
    ConnectionType?: NullableStringFieldUpdateOperationsInput | string | null
    ConnectionDetail?: NullableStringFieldUpdateOperationsInput | string | null
    DBType?: NullableStringFieldUpdateOperationsInput | string | null
    Server?: NullableStringFieldUpdateOperationsInput | string | null
    Port?: NullableStringFieldUpdateOperationsInput | string | null
    DBName?: NullableStringFieldUpdateOperationsInput | string | null
    Username?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    DsnName?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequestLogsCreateInput = {
    Id: string
    RequestedUserId?: string | null
    DesignatedUserId?: string | null
    Url?: string | null
    UrlType?: string | null
    RequestedUserAgent?: string | null
    RequestedUserIpAddress?: string | null
    DesignatedUserAgent?: string | null
    DesignatedUserIpAddress?: string | null
    Created?: Date | string | null
    Modified?: Date | string | null
    LastVisited?: Date | string | null
    Status?: number | null
    Validity?: Date | string | null
  }

  export type RequestLogsUncheckedCreateInput = {
    Id: string
    RequestedUserId?: string | null
    DesignatedUserId?: string | null
    Url?: string | null
    UrlType?: string | null
    RequestedUserAgent?: string | null
    RequestedUserIpAddress?: string | null
    DesignatedUserAgent?: string | null
    DesignatedUserIpAddress?: string | null
    Created?: Date | string | null
    Modified?: Date | string | null
    LastVisited?: Date | string | null
    Status?: number | null
    Validity?: Date | string | null
  }

  export type RequestLogsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RequestedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    DesignatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    Url?: NullableStringFieldUpdateOperationsInput | string | null
    UrlType?: NullableStringFieldUpdateOperationsInput | string | null
    RequestedUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    RequestedUserIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    DesignatedUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    DesignatedUserIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVisited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    Validity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequestLogsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RequestedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    DesignatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    Url?: NullableStringFieldUpdateOperationsInput | string | null
    UrlType?: NullableStringFieldUpdateOperationsInput | string | null
    RequestedUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    RequestedUserIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    DesignatedUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    DesignatedUserIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVisited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    Validity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequestLogsCreateManyInput = {
    Id: string
    RequestedUserId?: string | null
    DesignatedUserId?: string | null
    Url?: string | null
    UrlType?: string | null
    RequestedUserAgent?: string | null
    RequestedUserIpAddress?: string | null
    DesignatedUserAgent?: string | null
    DesignatedUserIpAddress?: string | null
    Created?: Date | string | null
    Modified?: Date | string | null
    LastVisited?: Date | string | null
    Status?: number | null
    Validity?: Date | string | null
  }

  export type RequestLogsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RequestedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    DesignatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    Url?: NullableStringFieldUpdateOperationsInput | string | null
    UrlType?: NullableStringFieldUpdateOperationsInput | string | null
    RequestedUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    RequestedUserIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    DesignatedUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    DesignatedUserIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVisited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    Validity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequestLogsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RequestedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    DesignatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    Url?: NullableStringFieldUpdateOperationsInput | string | null
    UrlType?: NullableStringFieldUpdateOperationsInput | string | null
    RequestedUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    RequestedUserIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    DesignatedUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    DesignatedUserIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    Created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVisited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    Validity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservedUsersCreateInput = {
    Id: string
    User_Id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type ReservedUsersUncheckedCreateInput = {
    Id: string
    User_Id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type ReservedUsersUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservedUsersUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservedUsersCreateManyInput = {
    Id: string
    User_Id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type ReservedUsersUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservedUsersUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResourceFilesCreateInput = {
    Id: string
    MapItemId?: string | null
    FileContent?: Buffer | null
    FilePath?: string | null
    Extension?: string | null
    Name?: string | null
    ModifiedDate: Date | string
    CreatedDate: Date | string
  }

  export type ResourceFilesUncheckedCreateInput = {
    Id: string
    MapItemId?: string | null
    FileContent?: Buffer | null
    FilePath?: string | null
    Extension?: string | null
    Name?: string | null
    ModifiedDate: Date | string
    CreatedDate: Date | string
  }

  export type ResourceFilesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MapItemId?: NullableStringFieldUpdateOperationsInput | string | null
    FileContent?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    Extension?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceFilesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MapItemId?: NullableStringFieldUpdateOperationsInput | string | null
    FileContent?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    Extension?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceFilesCreateManyInput = {
    Id: string
    MapItemId?: string | null
    FileContent?: Buffer | null
    FilePath?: string | null
    Extension?: string | null
    Name?: string | null
    ModifiedDate: Date | string
    CreatedDate: Date | string
  }

  export type ResourceFilesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MapItemId?: NullableStringFieldUpdateOperationsInput | string | null
    FileContent?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    Extension?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceFilesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    MapItemId?: NullableStringFieldUpdateOperationsInput | string | null
    FileContent?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    Extension?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourcesCreateInput = {
    Id: string
    ResourceName?: string | null
  }

  export type ResourcesUncheckedCreateInput = {
    Id: string
    ResourceName?: string | null
  }

  export type ResourcesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ResourceName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResourcesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ResourceName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResourcesCreateManyInput = {
    Id: string
    ResourceName?: string | null
  }

  export type ResourcesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ResourceName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResourcesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ResourceName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewProcessesCreateInput = {
    Id: string
    Name?: string | null
    Notes?: string | null
    ReviewStartDate?: Date | string | null
    ReviewEndDate?: Date | string | null
    ApproveStartDate?: Date | string | null
    ApproveEndDate?: Date | string | null
    WorkFlow?: number | null
    AutoStatusUpdate?: number | null
    ReviewStartType?: number | null
    ElementRecursiveSelection?: number | null
    ExternalUsersInvite?: number | null
    EnableShare?: number | null
    EmailNotification?: number | null
    Mode?: string | null
    Repository_Id?: string | null
    User_Id?: string | null
    Status?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type ReviewProcessesUncheckedCreateInput = {
    Id: string
    Name?: string | null
    Notes?: string | null
    ReviewStartDate?: Date | string | null
    ReviewEndDate?: Date | string | null
    ApproveStartDate?: Date | string | null
    ApproveEndDate?: Date | string | null
    WorkFlow?: number | null
    AutoStatusUpdate?: number | null
    ReviewStartType?: number | null
    ElementRecursiveSelection?: number | null
    ExternalUsersInvite?: number | null
    EnableShare?: number | null
    EmailNotification?: number | null
    Mode?: string | null
    Repository_Id?: string | null
    User_Id?: string | null
    Status?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type ReviewProcessesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    ReviewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReviewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ApproveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ApproveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WorkFlow?: NullableIntFieldUpdateOperationsInput | number | null
    AutoStatusUpdate?: NullableIntFieldUpdateOperationsInput | number | null
    ReviewStartType?: NullableIntFieldUpdateOperationsInput | number | null
    ElementRecursiveSelection?: NullableIntFieldUpdateOperationsInput | number | null
    ExternalUsersInvite?: NullableIntFieldUpdateOperationsInput | number | null
    EnableShare?: NullableIntFieldUpdateOperationsInput | number | null
    EmailNotification?: NullableIntFieldUpdateOperationsInput | number | null
    Mode?: NullableStringFieldUpdateOperationsInput | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewProcessesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    ReviewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReviewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ApproveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ApproveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WorkFlow?: NullableIntFieldUpdateOperationsInput | number | null
    AutoStatusUpdate?: NullableIntFieldUpdateOperationsInput | number | null
    ReviewStartType?: NullableIntFieldUpdateOperationsInput | number | null
    ElementRecursiveSelection?: NullableIntFieldUpdateOperationsInput | number | null
    ExternalUsersInvite?: NullableIntFieldUpdateOperationsInput | number | null
    EnableShare?: NullableIntFieldUpdateOperationsInput | number | null
    EmailNotification?: NullableIntFieldUpdateOperationsInput | number | null
    Mode?: NullableStringFieldUpdateOperationsInput | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewProcessesCreateManyInput = {
    Id: string
    Name?: string | null
    Notes?: string | null
    ReviewStartDate?: Date | string | null
    ReviewEndDate?: Date | string | null
    ApproveStartDate?: Date | string | null
    ApproveEndDate?: Date | string | null
    WorkFlow?: number | null
    AutoStatusUpdate?: number | null
    ReviewStartType?: number | null
    ElementRecursiveSelection?: number | null
    ExternalUsersInvite?: number | null
    EnableShare?: number | null
    EmailNotification?: number | null
    Mode?: string | null
    Repository_Id?: string | null
    User_Id?: string | null
    Status?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type ReviewProcessesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    ReviewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReviewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ApproveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ApproveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WorkFlow?: NullableIntFieldUpdateOperationsInput | number | null
    AutoStatusUpdate?: NullableIntFieldUpdateOperationsInput | number | null
    ReviewStartType?: NullableIntFieldUpdateOperationsInput | number | null
    ElementRecursiveSelection?: NullableIntFieldUpdateOperationsInput | number | null
    ExternalUsersInvite?: NullableIntFieldUpdateOperationsInput | number | null
    EnableShare?: NullableIntFieldUpdateOperationsInput | number | null
    EmailNotification?: NullableIntFieldUpdateOperationsInput | number | null
    Mode?: NullableStringFieldUpdateOperationsInput | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewProcessesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    ReviewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReviewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ApproveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ApproveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WorkFlow?: NullableIntFieldUpdateOperationsInput | number | null
    AutoStatusUpdate?: NullableIntFieldUpdateOperationsInput | number | null
    ReviewStartType?: NullableIntFieldUpdateOperationsInput | number | null
    ElementRecursiveSelection?: NullableIntFieldUpdateOperationsInput | number | null
    ExternalUsersInvite?: NullableIntFieldUpdateOperationsInput | number | null
    EnableShare?: NullableIntFieldUpdateOperationsInput | number | null
    EmailNotification?: NullableIntFieldUpdateOperationsInput | number | null
    Mode?: NullableStringFieldUpdateOperationsInput | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaggedValuesCreateInput = {
    Id: string
    RepositoryId: string
    Name: string
    Description?: string | null
    Type: string
    DefaultValue?: string | null
    AttributeValues?: string | null
    LowerBound?: number | null
    UpperBound?: number | null
    Stereotypes?: string | null
    AppliesTo?: string | null
    BaseStereotype?: string | null
  }

  export type TaggedValuesUncheckedCreateInput = {
    Id: string
    RepositoryId: string
    Name: string
    Description?: string | null
    Type: string
    DefaultValue?: string | null
    AttributeValues?: string | null
    LowerBound?: number | null
    UpperBound?: number | null
    Stereotypes?: string | null
    AppliesTo?: string | null
    BaseStereotype?: string | null
  }

  export type TaggedValuesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: StringFieldUpdateOperationsInput | string
    DefaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    AttributeValues?: NullableStringFieldUpdateOperationsInput | string | null
    LowerBound?: NullableIntFieldUpdateOperationsInput | number | null
    UpperBound?: NullableIntFieldUpdateOperationsInput | number | null
    Stereotypes?: NullableStringFieldUpdateOperationsInput | string | null
    AppliesTo?: NullableStringFieldUpdateOperationsInput | string | null
    BaseStereotype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaggedValuesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: StringFieldUpdateOperationsInput | string
    DefaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    AttributeValues?: NullableStringFieldUpdateOperationsInput | string | null
    LowerBound?: NullableIntFieldUpdateOperationsInput | number | null
    UpperBound?: NullableIntFieldUpdateOperationsInput | number | null
    Stereotypes?: NullableStringFieldUpdateOperationsInput | string | null
    AppliesTo?: NullableStringFieldUpdateOperationsInput | string | null
    BaseStereotype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaggedValuesCreateManyInput = {
    Id: string
    RepositoryId: string
    Name: string
    Description?: string | null
    Type: string
    DefaultValue?: string | null
    AttributeValues?: string | null
    LowerBound?: number | null
    UpperBound?: number | null
    Stereotypes?: string | null
    AppliesTo?: string | null
    BaseStereotype?: string | null
  }

  export type TaggedValuesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: StringFieldUpdateOperationsInput | string
    DefaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    AttributeValues?: NullableStringFieldUpdateOperationsInput | string | null
    LowerBound?: NullableIntFieldUpdateOperationsInput | number | null
    UpperBound?: NullableIntFieldUpdateOperationsInput | number | null
    Stereotypes?: NullableStringFieldUpdateOperationsInput | string | null
    AppliesTo?: NullableStringFieldUpdateOperationsInput | string | null
    BaseStereotype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaggedValuesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: StringFieldUpdateOperationsInput | string
    DefaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    AttributeValues?: NullableStringFieldUpdateOperationsInput | string | null
    LowerBound?: NullableIntFieldUpdateOperationsInput | number | null
    UpperBound?: NullableIntFieldUpdateOperationsInput | number | null
    Stereotypes?: NullableStringFieldUpdateOperationsInput | string | null
    AppliesTo?: NullableStringFieldUpdateOperationsInput | string | null
    BaseStereotype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TraceabilityTreeProfilesCreateInput = {
    Id: string
    ProfileName?: string | null
    RepositoryId?: string | null
    ElementGuid?: string | null
    Type?: string | null
    SteroType?: string | null
    FQName?: string | null
    Technology?: string | null
    TemplateOptions?: string | null
    User_Id?: string | null
    Status?: number | null
    IsApplytoAll?: number | null
    IsApplytoType?: number | null
    IsApplytoSteroType?: number | null
    Created?: Date | string | null
    Modified?: Date | string | null
    ElementTypeList?: string | null
    ConnectorTypeList?: string | null
    FlowDirectionTypeList?: string | null
    TreeType?: string | null
  }

  export type TraceabilityTreeProfilesUncheckedCreateInput = {
    Id: string
    ProfileName?: string | null
    RepositoryId?: string | null
    ElementGuid?: string | null
    Type?: string | null
    SteroType?: string | null
    FQName?: string | null
    Technology?: string | null
    TemplateOptions?: string | null
    User_Id?: string | null
    Status?: number | null
    IsApplytoAll?: number | null
    IsApplytoType?: number | null
    IsApplytoSteroType?: number | null
    Created?: Date | string | null
    Modified?: Date | string | null
    ElementTypeList?: string | null
    ConnectorTypeList?: string | null
    FlowDirectionTypeList?: string | null
    TreeType?: string | null
  }

  export type TraceabilityTreeProfilesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ProfileName?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ElementGuid?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    SteroType?: NullableStringFieldUpdateOperationsInput | string | null
    FQName?: NullableStringFieldUpdateOperationsInput | string | null
    Technology?: NullableStringFieldUpdateOperationsInput | string | null
    TemplateOptions?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    IsApplytoAll?: NullableIntFieldUpdateOperationsInput | number | null
    IsApplytoType?: NullableIntFieldUpdateOperationsInput | number | null
    IsApplytoSteroType?: NullableIntFieldUpdateOperationsInput | number | null
    Created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ElementTypeList?: NullableStringFieldUpdateOperationsInput | string | null
    ConnectorTypeList?: NullableStringFieldUpdateOperationsInput | string | null
    FlowDirectionTypeList?: NullableStringFieldUpdateOperationsInput | string | null
    TreeType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TraceabilityTreeProfilesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ProfileName?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ElementGuid?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    SteroType?: NullableStringFieldUpdateOperationsInput | string | null
    FQName?: NullableStringFieldUpdateOperationsInput | string | null
    Technology?: NullableStringFieldUpdateOperationsInput | string | null
    TemplateOptions?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    IsApplytoAll?: NullableIntFieldUpdateOperationsInput | number | null
    IsApplytoType?: NullableIntFieldUpdateOperationsInput | number | null
    IsApplytoSteroType?: NullableIntFieldUpdateOperationsInput | number | null
    Created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ElementTypeList?: NullableStringFieldUpdateOperationsInput | string | null
    ConnectorTypeList?: NullableStringFieldUpdateOperationsInput | string | null
    FlowDirectionTypeList?: NullableStringFieldUpdateOperationsInput | string | null
    TreeType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TraceabilityTreeProfilesCreateManyInput = {
    Id: string
    ProfileName?: string | null
    RepositoryId?: string | null
    ElementGuid?: string | null
    Type?: string | null
    SteroType?: string | null
    FQName?: string | null
    Technology?: string | null
    TemplateOptions?: string | null
    User_Id?: string | null
    Status?: number | null
    IsApplytoAll?: number | null
    IsApplytoType?: number | null
    IsApplytoSteroType?: number | null
    Created?: Date | string | null
    Modified?: Date | string | null
    ElementTypeList?: string | null
    ConnectorTypeList?: string | null
    FlowDirectionTypeList?: string | null
    TreeType?: string | null
  }

  export type TraceabilityTreeProfilesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ProfileName?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ElementGuid?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    SteroType?: NullableStringFieldUpdateOperationsInput | string | null
    FQName?: NullableStringFieldUpdateOperationsInput | string | null
    Technology?: NullableStringFieldUpdateOperationsInput | string | null
    TemplateOptions?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    IsApplytoAll?: NullableIntFieldUpdateOperationsInput | number | null
    IsApplytoType?: NullableIntFieldUpdateOperationsInput | number | null
    IsApplytoSteroType?: NullableIntFieldUpdateOperationsInput | number | null
    Created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ElementTypeList?: NullableStringFieldUpdateOperationsInput | string | null
    ConnectorTypeList?: NullableStringFieldUpdateOperationsInput | string | null
    FlowDirectionTypeList?: NullableStringFieldUpdateOperationsInput | string | null
    TreeType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TraceabilityTreeProfilesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ProfileName?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ElementGuid?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    SteroType?: NullableStringFieldUpdateOperationsInput | string | null
    FQName?: NullableStringFieldUpdateOperationsInput | string | null
    Technology?: NullableStringFieldUpdateOperationsInput | string | null
    TemplateOptions?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    IsApplytoAll?: NullableIntFieldUpdateOperationsInput | number | null
    IsApplytoType?: NullableIntFieldUpdateOperationsInput | number | null
    IsApplytoSteroType?: NullableIntFieldUpdateOperationsInput | number | null
    Created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ElementTypeList?: NullableStringFieldUpdateOperationsInput | string | null
    ConnectorTypeList?: NullableStringFieldUpdateOperationsInput | string | null
    FlowDirectionTypeList?: NullableStringFieldUpdateOperationsInput | string | null
    TreeType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TraceabilityTreeViewsCreateInput = {
    Id: string
    RepositoryId?: string | null
    ElementGuid?: string | null
    TreeViewData?: string | null
    User_Id?: string | null
    Created?: Date | string | null
    Modified?: Date | string | null
    FilterItems?: string | null
    Tittle?: string | null
    Revision?: string | null
    ViewId?: string | null
    TemplateOptions?: string | null
    Description?: string | null
    NlFilterItems?: string | null
    NlTreeData?: string | null
    NlFilterItemStatus?: string | null
    FilterAppliedNodeList?: string | null
    TotForceLinks?: string | null
  }

  export type TraceabilityTreeViewsUncheckedCreateInput = {
    Id: string
    RepositoryId?: string | null
    ElementGuid?: string | null
    TreeViewData?: string | null
    User_Id?: string | null
    Created?: Date | string | null
    Modified?: Date | string | null
    FilterItems?: string | null
    Tittle?: string | null
    Revision?: string | null
    ViewId?: string | null
    TemplateOptions?: string | null
    Description?: string | null
    NlFilterItems?: string | null
    NlTreeData?: string | null
    NlFilterItemStatus?: string | null
    FilterAppliedNodeList?: string | null
    TotForceLinks?: string | null
  }

  export type TraceabilityTreeViewsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ElementGuid?: NullableStringFieldUpdateOperationsInput | string | null
    TreeViewData?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FilterItems?: NullableStringFieldUpdateOperationsInput | string | null
    Tittle?: NullableStringFieldUpdateOperationsInput | string | null
    Revision?: NullableStringFieldUpdateOperationsInput | string | null
    ViewId?: NullableStringFieldUpdateOperationsInput | string | null
    TemplateOptions?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    NlFilterItems?: NullableStringFieldUpdateOperationsInput | string | null
    NlTreeData?: NullableStringFieldUpdateOperationsInput | string | null
    NlFilterItemStatus?: NullableStringFieldUpdateOperationsInput | string | null
    FilterAppliedNodeList?: NullableStringFieldUpdateOperationsInput | string | null
    TotForceLinks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TraceabilityTreeViewsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ElementGuid?: NullableStringFieldUpdateOperationsInput | string | null
    TreeViewData?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FilterItems?: NullableStringFieldUpdateOperationsInput | string | null
    Tittle?: NullableStringFieldUpdateOperationsInput | string | null
    Revision?: NullableStringFieldUpdateOperationsInput | string | null
    ViewId?: NullableStringFieldUpdateOperationsInput | string | null
    TemplateOptions?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    NlFilterItems?: NullableStringFieldUpdateOperationsInput | string | null
    NlTreeData?: NullableStringFieldUpdateOperationsInput | string | null
    NlFilterItemStatus?: NullableStringFieldUpdateOperationsInput | string | null
    FilterAppliedNodeList?: NullableStringFieldUpdateOperationsInput | string | null
    TotForceLinks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TraceabilityTreeViewsCreateManyInput = {
    Id: string
    RepositoryId?: string | null
    ElementGuid?: string | null
    TreeViewData?: string | null
    User_Id?: string | null
    Created?: Date | string | null
    Modified?: Date | string | null
    FilterItems?: string | null
    Tittle?: string | null
    Revision?: string | null
    ViewId?: string | null
    TemplateOptions?: string | null
    Description?: string | null
    NlFilterItems?: string | null
    NlTreeData?: string | null
    NlFilterItemStatus?: string | null
    FilterAppliedNodeList?: string | null
    TotForceLinks?: string | null
  }

  export type TraceabilityTreeViewsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ElementGuid?: NullableStringFieldUpdateOperationsInput | string | null
    TreeViewData?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FilterItems?: NullableStringFieldUpdateOperationsInput | string | null
    Tittle?: NullableStringFieldUpdateOperationsInput | string | null
    Revision?: NullableStringFieldUpdateOperationsInput | string | null
    ViewId?: NullableStringFieldUpdateOperationsInput | string | null
    TemplateOptions?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    NlFilterItems?: NullableStringFieldUpdateOperationsInput | string | null
    NlTreeData?: NullableStringFieldUpdateOperationsInput | string | null
    NlFilterItemStatus?: NullableStringFieldUpdateOperationsInput | string | null
    FilterAppliedNodeList?: NullableStringFieldUpdateOperationsInput | string | null
    TotForceLinks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TraceabilityTreeViewsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    RepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ElementGuid?: NullableStringFieldUpdateOperationsInput | string | null
    TreeViewData?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FilterItems?: NullableStringFieldUpdateOperationsInput | string | null
    Tittle?: NullableStringFieldUpdateOperationsInput | string | null
    Revision?: NullableStringFieldUpdateOperationsInput | string | null
    ViewId?: NullableStringFieldUpdateOperationsInput | string | null
    TemplateOptions?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    NlFilterItems?: NullableStringFieldUpdateOperationsInput | string | null
    NlTreeData?: NullableStringFieldUpdateOperationsInput | string | null
    NlFilterItemStatus?: NullableStringFieldUpdateOperationsInput | string | null
    FilterAppliedNodeList?: NullableStringFieldUpdateOperationsInput | string | null
    TotForceLinks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type URLMapCreateInput = {
    Id: bigint | number
    URL: string
    URLType?: string | null
    HashCode?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Repository_Id?: string | null
    LinkType?: string | null
    MapurlId?: string | null
  }

  export type URLMapUncheckedCreateInput = {
    Id: bigint | number
    URL: string
    URLType?: string | null
    HashCode?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Repository_Id?: string | null
    LinkType?: string | null
    MapurlId?: string | null
  }

  export type URLMapUpdateInput = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    URL?: StringFieldUpdateOperationsInput | string
    URLType?: NullableStringFieldUpdateOperationsInput | string | null
    HashCode?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    LinkType?: NullableStringFieldUpdateOperationsInput | string | null
    MapurlId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type URLMapUncheckedUpdateInput = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    URL?: StringFieldUpdateOperationsInput | string
    URLType?: NullableStringFieldUpdateOperationsInput | string | null
    HashCode?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    LinkType?: NullableStringFieldUpdateOperationsInput | string | null
    MapurlId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type URLMapCreateManyInput = {
    Id: bigint | number
    URL: string
    URLType?: string | null
    HashCode?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Repository_Id?: string | null
    LinkType?: string | null
    MapurlId?: string | null
  }

  export type URLMapUpdateManyMutationInput = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    URL?: StringFieldUpdateOperationsInput | string
    URLType?: NullableStringFieldUpdateOperationsInput | string | null
    HashCode?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    LinkType?: NullableStringFieldUpdateOperationsInput | string | null
    MapurlId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type URLMapUncheckedUpdateManyInput = {
    Id?: BigIntFieldUpdateOperationsInput | bigint | number
    URL?: StringFieldUpdateOperationsInput | string
    URLType?: NullableStringFieldUpdateOperationsInput | string | null
    HashCode?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Repository_Id?: NullableStringFieldUpdateOperationsInput | string | null
    LinkType?: NullableStringFieldUpdateOperationsInput | string | null
    MapurlId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserActionsCreateInput = {
    Id: string
    ActionName?: string | null
    Actionkey?: string | null
    Resource_id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
  }

  export type UserActionsUncheckedCreateInput = {
    Id: string
    ActionName?: string | null
    Actionkey?: string | null
    Resource_id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
  }

  export type UserActionsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ActionName?: NullableStringFieldUpdateOperationsInput | string | null
    Actionkey?: NullableStringFieldUpdateOperationsInput | string | null
    Resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserActionsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ActionName?: NullableStringFieldUpdateOperationsInput | string | null
    Actionkey?: NullableStringFieldUpdateOperationsInput | string | null
    Resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserActionsCreateManyInput = {
    Id: string
    ActionName?: string | null
    Actionkey?: string | null
    Resource_id?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Status?: string | null
  }

  export type UserActionsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ActionName?: NullableStringFieldUpdateOperationsInput | string | null
    Actionkey?: NullableStringFieldUpdateOperationsInput | string | null
    Resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserActionsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ActionName?: NullableStringFieldUpdateOperationsInput | string | null
    Actionkey?: NullableStringFieldUpdateOperationsInput | string | null
    Resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserGroupConnectorsCreateInput = {
    Id: string
    UserGroup_Id?: string | null
    User_Id?: string | null
    Status?: string | null
    CreatedDate?: Date | string | null
  }

  export type UserGroupConnectorsUncheckedCreateInput = {
    Id: string
    UserGroup_Id?: string | null
    User_Id?: string | null
    Status?: string | null
    CreatedDate?: Date | string | null
  }

  export type UserGroupConnectorsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserGroupConnectorsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserGroupConnectorsCreateManyInput = {
    Id: string
    UserGroup_Id?: string | null
    User_Id?: string | null
    Status?: string | null
    CreatedDate?: Date | string | null
  }

  export type UserGroupConnectorsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserGroupConnectorsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserGroup_Id?: NullableStringFieldUpdateOperationsInput | string | null
    User_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserGroupsCreateInput = {
    Id: string
    GroupName?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    EditFeatures?: number | null
    Status?: string | null
    UserGroups_Role_Id?: string | null
    IsReadOnly?: number
  }

  export type UserGroupsUncheckedCreateInput = {
    Id: string
    GroupName?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    EditFeatures?: number | null
    Status?: string | null
    UserGroups_Role_Id?: string | null
    IsReadOnly?: number
  }

  export type UserGroupsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    GroupName?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EditFeatures?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroups_Role_Id?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
  }

  export type UserGroupsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    GroupName?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EditFeatures?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroups_Role_Id?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
  }

  export type UserGroupsCreateManyInput = {
    Id: string
    GroupName?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    EditFeatures?: number | null
    Status?: string | null
    UserGroups_Role_Id?: string | null
    IsReadOnly?: number
  }

  export type UserGroupsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    GroupName?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EditFeatures?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroups_Role_Id?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
  }

  export type UserGroupsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    GroupName?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EditFeatures?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    UserGroups_Role_Id?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
  }

  export type UserIdentityClaimsCreateInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
    Users: UsersCreateNestedOneWithoutUserIdentityClaimsInput
  }

  export type UserIdentityClaimsUncheckedCreateInput = {
    Id?: number
    UserId: string
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type UserIdentityClaimsUpdateInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
    Users?: UsersUpdateOneRequiredWithoutUserIdentityClaimsInput
  }

  export type UserIdentityClaimsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: StringFieldUpdateOperationsInput | string
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityClaimsCreateManyInput = {
    UserId: string
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type UserIdentityClaimsUpdateManyMutationInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityClaimsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: StringFieldUpdateOperationsInput | string
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityLoginsCreateInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
    Users: UsersCreateNestedOneWithoutUserIdentityLoginsInput
  }

  export type UserIdentityLoginsUncheckedCreateInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
    UserId: string
  }

  export type UserIdentityLoginsUpdateInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    Users?: UsersUpdateOneRequiredWithoutUserIdentityLoginsInput
  }

  export type UserIdentityLoginsUncheckedUpdateInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type UserIdentityLoginsCreateManyInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
    UserId: string
  }

  export type UserIdentityLoginsUpdateManyMutationInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityLoginsUncheckedUpdateManyInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type UserIdentityRoleClaimsCreateInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
    AppIdentityRoles: AppIdentityRolesCreateNestedOneWithoutUserIdentityRoleClaimsInput
  }

  export type UserIdentityRoleClaimsUncheckedCreateInput = {
    Id?: number
    RoleId: string
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type UserIdentityRoleClaimsUpdateInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
    AppIdentityRoles?: AppIdentityRolesUpdateOneRequiredWithoutUserIdentityRoleClaimsInput
  }

  export type UserIdentityRoleClaimsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    RoleId?: StringFieldUpdateOperationsInput | string
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityRoleClaimsCreateManyInput = {
    RoleId: string
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type UserIdentityRoleClaimsUpdateManyMutationInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityRoleClaimsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    RoleId?: StringFieldUpdateOperationsInput | string
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityRolesCreateInput = {
    AppIdentityRoles: AppIdentityRolesCreateNestedOneWithoutUserIdentityRolesInput
    Users: UsersCreateNestedOneWithoutUserIdentityRolesInput
  }

  export type UserIdentityRolesUncheckedCreateInput = {
    UserId: string
    RoleId: string
  }

  export type UserIdentityRolesUpdateInput = {
    AppIdentityRoles?: AppIdentityRolesUpdateOneRequiredWithoutUserIdentityRolesInput
    Users?: UsersUpdateOneRequiredWithoutUserIdentityRolesInput
  }

  export type UserIdentityRolesUncheckedUpdateInput = {
    UserId?: StringFieldUpdateOperationsInput | string
    RoleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserIdentityRolesCreateManyInput = {
    UserId: string
    RoleId: string
  }

  export type UserIdentityRolesUpdateManyMutationInput = {

  }

  export type UserIdentityRolesUncheckedUpdateManyInput = {
    UserId?: StringFieldUpdateOperationsInput | string
    RoleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserIdentityTokensCreateInput = {
    LoginProvider: string
    Name: string
    Value?: string | null
    Users: UsersCreateNestedOneWithoutUserIdentityTokensInput
  }

  export type UserIdentityTokensUncheckedCreateInput = {
    UserId: string
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type UserIdentityTokensUpdateInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
    Users?: UsersUpdateOneRequiredWithoutUserIdentityTokensInput
  }

  export type UserIdentityTokensUncheckedUpdateInput = {
    UserId?: StringFieldUpdateOperationsInput | string
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityTokensCreateManyInput = {
    UserId: string
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type UserIdentityTokensUpdateManyMutationInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityTokensUncheckedUpdateManyInput = {
    UserId?: StringFieldUpdateOperationsInput | string
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProfileSettingCreateInput = {
    Id: string
    UserId?: string | null
    RepositoryTechnologyConfiguration?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type UserProfileSettingUncheckedCreateInput = {
    Id: string
    UserId?: string | null
    RepositoryTechnologyConfiguration?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type UserProfileSettingUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryTechnologyConfiguration?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileSettingUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryTechnologyConfiguration?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileSettingCreateManyInput = {
    Id: string
    UserId?: string | null
    RepositoryTechnologyConfiguration?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
  }

  export type UserProfileSettingUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryTechnologyConfiguration?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileSettingUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    RepositoryTechnologyConfiguration?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRoleProfilesCreateInput = {
    Id: string
    UserRole_Id: string
    Profile_Id: string
    Created: Date | string
    Modified: Date | string
  }

  export type UserRoleProfilesUncheckedCreateInput = {
    Id: string
    UserRole_Id: string
    Profile_Id: string
    Created: Date | string
    Modified: Date | string
  }

  export type UserRoleProfilesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserRole_Id?: StringFieldUpdateOperationsInput | string
    Profile_Id?: StringFieldUpdateOperationsInput | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleProfilesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserRole_Id?: StringFieldUpdateOperationsInput | string
    Profile_Id?: StringFieldUpdateOperationsInput | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleProfilesCreateManyInput = {
    Id: string
    UserRole_Id: string
    Profile_Id: string
    Created: Date | string
    Modified: Date | string
  }

  export type UserRoleProfilesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserRole_Id?: StringFieldUpdateOperationsInput | string
    Profile_Id?: StringFieldUpdateOperationsInput | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleProfilesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserRole_Id?: StringFieldUpdateOperationsInput | string
    Profile_Id?: StringFieldUpdateOperationsInput | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRolesCreateInput = {
    Id: string
    Name: string
    Description?: string | null
    UIEnabled: number
  }

  export type UserRolesUncheckedCreateInput = {
    Id: string
    Name: string
    Description?: string | null
    UIEnabled: number
  }

  export type UserRolesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    UIEnabled?: IntFieldUpdateOperationsInput | number
  }

  export type UserRolesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    UIEnabled?: IntFieldUpdateOperationsInput | number
  }

  export type UserRolesCreateManyInput = {
    Id: string
    Name: string
    Description?: string | null
    UIEnabled: number
  }

  export type UserRolesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    UIEnabled?: IntFieldUpdateOperationsInput | number
  }

  export type UserRolesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    UIEnabled?: IntFieldUpdateOperationsInput | number
  }

  export type UsersCreateInput = {
    Id: string
    LDAPConnection_Id?: string | null
    FirstName?: string | null
    LastName?: string | null
    UserRole_Id?: string | null
    Status?: string | null
    EmailId?: string | null
    Password?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Description?: string | null
    ProfileImage?: string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    RegistrationMode?: string | null
    Timezone?: string | null
    IsPasswordSet?: number | null
    IsAdmin?: number | null
    ShowHelpText?: number | null
    IdentityProvider_Id?: string | null
    SecPhrase?: string | null
    IsReadOnly?: number
    UserIdentityRole?: string | null
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed?: boolean | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed?: boolean | null
    PasswordHash?: string | null
    TwoFactorEnabled?: boolean | null
    LockoutEnd?: Date | string | null
    LockoutEnabled?: boolean | null
    AccessFailedCount?: number | null
    UserIdentityClaims?: UserIdentityClaimsCreateNestedManyWithoutUsersInput
    UserIdentityLogins?: UserIdentityLoginsCreateNestedManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesCreateNestedManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    Id: string
    LDAPConnection_Id?: string | null
    FirstName?: string | null
    LastName?: string | null
    UserRole_Id?: string | null
    Status?: string | null
    EmailId?: string | null
    Password?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Description?: string | null
    ProfileImage?: string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    RegistrationMode?: string | null
    Timezone?: string | null
    IsPasswordSet?: number | null
    IsAdmin?: number | null
    ShowHelpText?: number | null
    IdentityProvider_Id?: string | null
    SecPhrase?: string | null
    IsReadOnly?: number
    UserIdentityRole?: string | null
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed?: boolean | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed?: boolean | null
    PasswordHash?: string | null
    TwoFactorEnabled?: boolean | null
    LockoutEnd?: Date | string | null
    LockoutEnabled?: boolean | null
    AccessFailedCount?: number | null
    UserIdentityClaims?: UserIdentityClaimsUncheckedCreateNestedManyWithoutUsersInput
    UserIdentityLogins?: UserIdentityLoginsUncheckedCreateNestedManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesUncheckedCreateNestedManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    LDAPConnection_Id?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    UserRole_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    EmailId?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationMode?: NullableStringFieldUpdateOperationsInput | string | null
    Timezone?: NullableStringFieldUpdateOperationsInput | string | null
    IsPasswordSet?: NullableIntFieldUpdateOperationsInput | number | null
    IsAdmin?: NullableIntFieldUpdateOperationsInput | number | null
    ShowHelpText?: NullableIntFieldUpdateOperationsInput | number | null
    IdentityProvider_Id?: NullableStringFieldUpdateOperationsInput | string | null
    SecPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    UserIdentityRole?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    TwoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AccessFailedCount?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentityClaims?: UserIdentityClaimsUpdateManyWithoutUsersInput
    UserIdentityLogins?: UserIdentityLoginsUpdateManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesUpdateManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensUpdateManyWithoutUsersInput
  }

  export type UsersUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    LDAPConnection_Id?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    UserRole_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    EmailId?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationMode?: NullableStringFieldUpdateOperationsInput | string | null
    Timezone?: NullableStringFieldUpdateOperationsInput | string | null
    IsPasswordSet?: NullableIntFieldUpdateOperationsInput | number | null
    IsAdmin?: NullableIntFieldUpdateOperationsInput | number | null
    ShowHelpText?: NullableIntFieldUpdateOperationsInput | number | null
    IdentityProvider_Id?: NullableStringFieldUpdateOperationsInput | string | null
    SecPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    UserIdentityRole?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    TwoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AccessFailedCount?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentityClaims?: UserIdentityClaimsUncheckedUpdateManyWithoutUsersInput
    UserIdentityLogins?: UserIdentityLoginsUncheckedUpdateManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesUncheckedUpdateManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensUncheckedUpdateManyWithoutUsersInput
  }

  export type UsersCreateManyInput = {
    Id: string
    LDAPConnection_Id?: string | null
    FirstName?: string | null
    LastName?: string | null
    UserRole_Id?: string | null
    Status?: string | null
    EmailId?: string | null
    Password?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Description?: string | null
    ProfileImage?: string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    RegistrationMode?: string | null
    Timezone?: string | null
    IsPasswordSet?: number | null
    IsAdmin?: number | null
    ShowHelpText?: number | null
    IdentityProvider_Id?: string | null
    SecPhrase?: string | null
    IsReadOnly?: number
    UserIdentityRole?: string | null
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed?: boolean | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed?: boolean | null
    PasswordHash?: string | null
    TwoFactorEnabled?: boolean | null
    LockoutEnd?: Date | string | null
    LockoutEnabled?: boolean | null
    AccessFailedCount?: number | null
  }

  export type UsersUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    LDAPConnection_Id?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    UserRole_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    EmailId?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationMode?: NullableStringFieldUpdateOperationsInput | string | null
    Timezone?: NullableStringFieldUpdateOperationsInput | string | null
    IsPasswordSet?: NullableIntFieldUpdateOperationsInput | number | null
    IsAdmin?: NullableIntFieldUpdateOperationsInput | number | null
    ShowHelpText?: NullableIntFieldUpdateOperationsInput | number | null
    IdentityProvider_Id?: NullableStringFieldUpdateOperationsInput | string | null
    SecPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    UserIdentityRole?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    TwoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AccessFailedCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsersUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    LDAPConnection_Id?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    UserRole_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    EmailId?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationMode?: NullableStringFieldUpdateOperationsInput | string | null
    Timezone?: NullableStringFieldUpdateOperationsInput | string | null
    IsPasswordSet?: NullableIntFieldUpdateOperationsInput | number | null
    IsAdmin?: NullableIntFieldUpdateOperationsInput | number | null
    ShowHelpText?: NullableIntFieldUpdateOperationsInput | number | null
    IdentityProvider_Id?: NullableStringFieldUpdateOperationsInput | string | null
    SecPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    UserIdentityRole?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    TwoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AccessFailedCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserSessionsCreateInput = {
    Id: string
    UserId: string
    IsReservedUser: number
    AccessMode: string
    IPAddress: string
    UserAgent: string
    IsActive: number
    LastRequest: Date | string
    Created: Date | string
    Modified: Date | string
    UserDisplayName?: string | null
    UserType?: string | null
  }

  export type UserSessionsUncheckedCreateInput = {
    Id: string
    UserId: string
    IsReservedUser: number
    AccessMode: string
    IPAddress: string
    UserAgent: string
    IsActive: number
    LastRequest: Date | string
    Created: Date | string
    Modified: Date | string
    UserDisplayName?: string | null
    UserType?: string | null
  }

  export type UserSessionsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    IsReservedUser?: IntFieldUpdateOperationsInput | number
    AccessMode?: StringFieldUpdateOperationsInput | string
    IPAddress?: StringFieldUpdateOperationsInput | string
    UserAgent?: StringFieldUpdateOperationsInput | string
    IsActive?: IntFieldUpdateOperationsInput | number
    LastRequest?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    UserDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    IsReservedUser?: IntFieldUpdateOperationsInput | number
    AccessMode?: StringFieldUpdateOperationsInput | string
    IPAddress?: StringFieldUpdateOperationsInput | string
    UserAgent?: StringFieldUpdateOperationsInput | string
    IsActive?: IntFieldUpdateOperationsInput | number
    LastRequest?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    UserDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionsCreateManyInput = {
    Id: string
    UserId: string
    IsReservedUser: number
    AccessMode: string
    IPAddress: string
    UserAgent: string
    IsActive: number
    LastRequest: Date | string
    Created: Date | string
    Modified: Date | string
    UserDisplayName?: string | null
    UserType?: string | null
  }

  export type UserSessionsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    IsReservedUser?: IntFieldUpdateOperationsInput | number
    AccessMode?: StringFieldUpdateOperationsInput | string
    IPAddress?: StringFieldUpdateOperationsInput | string
    UserAgent?: StringFieldUpdateOperationsInput | string
    IsActive?: IntFieldUpdateOperationsInput | number
    LastRequest?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    UserDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    IsReservedUser?: IntFieldUpdateOperationsInput | number
    AccessMode?: StringFieldUpdateOperationsInput | string
    IPAddress?: StringFieldUpdateOperationsInput | string
    UserAgent?: StringFieldUpdateOperationsInput | string
    IsActive?: IntFieldUpdateOperationsInput | number
    LastRequest?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    UserDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionsArchiveCreateInput = {
    Id: string
    UserId: string
    IsReservedUser: number
    AccessMode: string
    IPAddress: string
    UserAgent: string
    IsActive: number
    LastRequest: Date | string
    Created: Date | string
    Modified: Date | string
    UserDisplayName?: string | null
    UserType?: string | null
  }

  export type UserSessionsArchiveUncheckedCreateInput = {
    Id: string
    UserId: string
    IsReservedUser: number
    AccessMode: string
    IPAddress: string
    UserAgent: string
    IsActive: number
    LastRequest: Date | string
    Created: Date | string
    Modified: Date | string
    UserDisplayName?: string | null
    UserType?: string | null
  }

  export type UserSessionsArchiveUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    IsReservedUser?: IntFieldUpdateOperationsInput | number
    AccessMode?: StringFieldUpdateOperationsInput | string
    IPAddress?: StringFieldUpdateOperationsInput | string
    UserAgent?: StringFieldUpdateOperationsInput | string
    IsActive?: IntFieldUpdateOperationsInput | number
    LastRequest?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    UserDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionsArchiveUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    IsReservedUser?: IntFieldUpdateOperationsInput | number
    AccessMode?: StringFieldUpdateOperationsInput | string
    IPAddress?: StringFieldUpdateOperationsInput | string
    UserAgent?: StringFieldUpdateOperationsInput | string
    IsActive?: IntFieldUpdateOperationsInput | number
    LastRequest?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    UserDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionsArchiveCreateManyInput = {
    Id: string
    UserId: string
    IsReservedUser: number
    AccessMode: string
    IPAddress: string
    UserAgent: string
    IsActive: number
    LastRequest: Date | string
    Created: Date | string
    Modified: Date | string
    UserDisplayName?: string | null
    UserType?: string | null
  }

  export type UserSessionsArchiveUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    IsReservedUser?: IntFieldUpdateOperationsInput | number
    AccessMode?: StringFieldUpdateOperationsInput | string
    IPAddress?: StringFieldUpdateOperationsInput | string
    UserAgent?: StringFieldUpdateOperationsInput | string
    IsActive?: IntFieldUpdateOperationsInput | number
    LastRequest?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    UserDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionsArchiveUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: StringFieldUpdateOperationsInput | string
    IsReservedUser?: IntFieldUpdateOperationsInput | number
    AccessMode?: StringFieldUpdateOperationsInput | string
    IPAddress?: StringFieldUpdateOperationsInput | string
    UserAgent?: StringFieldUpdateOperationsInput | string
    IsActive?: IntFieldUpdateOperationsInput | number
    LastRequest?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Modified?: DateTimeFieldUpdateOperationsInput | Date | string
    UserDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserTokensCreateInput = {
    Id: string
    UserId?: string | null
    RefreshToken?: string | null
    CreatedDate?: Date | string | null
  }

  export type UserTokensUncheckedCreateInput = {
    Id: string
    UserId?: string | null
    RefreshToken?: string | null
    CreatedDate?: Date | string | null
  }

  export type UserTokensUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    RefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserTokensUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    RefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserTokensCreateManyInput = {
    Id: string
    UserId?: string | null
    RefreshToken?: string | null
    CreatedDate?: Date | string | null
  }

  export type UserTokensUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    RefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserTokensUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    RefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type AccessRightsCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    AccessRightKey?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
  }

  export type AccessRightsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    AccessRightKey?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
  }

  export type AccessRightsMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    AccessRightKey?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type UserIdentityRoleClaimsListRelationFilter = {
    every?: UserIdentityRoleClaimsWhereInput
    some?: UserIdentityRoleClaimsWhereInput
    none?: UserIdentityRoleClaimsWhereInput
  }

  export type UserIdentityRolesListRelationFilter = {
    every?: UserIdentityRolesWhereInput
    some?: UserIdentityRolesWhereInput
    none?: UserIdentityRolesWhereInput
  }

  export type UserIdentityRoleClaimsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserIdentityRolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppIdentityRolesCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    NormalizedName?: SortOrder
    ConcurrencyStamp?: SortOrder
  }

  export type AppIdentityRolesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    NormalizedName?: SortOrder
    ConcurrencyStamp?: SortOrder
  }

  export type AppIdentityRolesMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    NormalizedName?: SortOrder
    ConcurrencyStamp?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type AppStreamConfigurationsCountOrderByAggregateInput = {
    Id?: SortOrder
    RegionEndPoint?: SortOrder
    FleetName?: SortOrder
    StackName?: SortOrder
    ApplicationID?: SortOrder
    AuthenticationType?: SortOrder
    URLValidityTime?: SortOrder
    AWSConfigurationsId?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type AppStreamConfigurationsAvgOrderByAggregateInput = {
    RegionEndPoint?: SortOrder
    AuthenticationType?: SortOrder
    URLValidityTime?: SortOrder
  }

  export type AppStreamConfigurationsMaxOrderByAggregateInput = {
    Id?: SortOrder
    RegionEndPoint?: SortOrder
    FleetName?: SortOrder
    StackName?: SortOrder
    ApplicationID?: SortOrder
    AuthenticationType?: SortOrder
    URLValidityTime?: SortOrder
    AWSConfigurationsId?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type AppStreamConfigurationsMinOrderByAggregateInput = {
    Id?: SortOrder
    RegionEndPoint?: SortOrder
    FleetName?: SortOrder
    StackName?: SortOrder
    ApplicationID?: SortOrder
    AuthenticationType?: SortOrder
    URLValidityTime?: SortOrder
    AWSConfigurationsId?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type AppStreamConfigurationsSumOrderByAggregateInput = {
    RegionEndPoint?: SortOrder
    AuthenticationType?: SortOrder
    URLValidityTime?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type AppStreamUserConnectorsCountOrderByAggregateInput = {
    Id?: SortOrder
    AppStreamARN?: SortOrder
    AppStreamUserName?: SortOrder
    AppStreamEmailId?: SortOrder
    AppStreamConfiguration_Id?: SortOrder
    User_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type AppStreamUserConnectorsMaxOrderByAggregateInput = {
    Id?: SortOrder
    AppStreamARN?: SortOrder
    AppStreamUserName?: SortOrder
    AppStreamEmailId?: SortOrder
    AppStreamConfiguration_Id?: SortOrder
    User_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type AppStreamUserConnectorsMinOrderByAggregateInput = {
    Id?: SortOrder
    AppStreamARN?: SortOrder
    AppStreamUserName?: SortOrder
    AppStreamEmailId?: SortOrder
    AppStreamConfiguration_Id?: SortOrder
    User_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type AuditEntitiesCountOrderByAggregateInput = {
    Id?: SortOrder
    Type?: SortOrder
    ActionBy?: SortOrder
    Details?: SortOrder
    CreatedDate?: SortOrder
    UserAgent?: SortOrder
    IPAddress?: SortOrder
  }

  export type AuditEntitiesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Type?: SortOrder
    ActionBy?: SortOrder
    Details?: SortOrder
    CreatedDate?: SortOrder
    UserAgent?: SortOrder
    IPAddress?: SortOrder
  }

  export type AuditEntitiesMinOrderByAggregateInput = {
    Id?: SortOrder
    Type?: SortOrder
    ActionBy?: SortOrder
    Details?: SortOrder
    CreatedDate?: SortOrder
    UserAgent?: SortOrder
    IPAddress?: SortOrder
  }

  export type AuditLogsCountOrderByAggregateInput = {
    Id?: SortOrder
    Resource?: SortOrder
    Resource_Id?: SortOrder
    UserAction_Actionkey?: SortOrder
    UserType?: SortOrder
    Repository_Id?: SortOrder
    ActionBy?: SortOrder
    Details?: SortOrder
    CreatedDate?: SortOrder
    UserAgent?: SortOrder
    IPAddress?: SortOrder
  }

  export type AuditLogsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Resource?: SortOrder
    Resource_Id?: SortOrder
    UserAction_Actionkey?: SortOrder
    UserType?: SortOrder
    Repository_Id?: SortOrder
    ActionBy?: SortOrder
    Details?: SortOrder
    CreatedDate?: SortOrder
    UserAgent?: SortOrder
    IPAddress?: SortOrder
  }

  export type AuditLogsMinOrderByAggregateInput = {
    Id?: SortOrder
    Resource?: SortOrder
    Resource_Id?: SortOrder
    UserAction_Actionkey?: SortOrder
    UserType?: SortOrder
    Repository_Id?: SortOrder
    ActionBy?: SortOrder
    Details?: SortOrder
    CreatedDate?: SortOrder
    UserAgent?: SortOrder
    IPAddress?: SortOrder
  }

  export type AWSConfigurationsCountOrderByAggregateInput = {
    Id?: SortOrder
    AccessKey?: SortOrder
    Secretkey?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type AWSConfigurationsMaxOrderByAggregateInput = {
    Id?: SortOrder
    AccessKey?: SortOrder
    Secretkey?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type AWSConfigurationsMinOrderByAggregateInput = {
    Id?: SortOrder
    AccessKey?: SortOrder
    Secretkey?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type CreateElementNotificationsCountOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    EnableNotification?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type CreateElementNotificationsAvgOrderByAggregateInput = {
    EnableNotification?: SortOrder
  }

  export type CreateElementNotificationsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    EnableNotification?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type CreateElementNotificationsMinOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    EnableNotification?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type CreateElementNotificationsSumOrderByAggregateInput = {
    EnableNotification?: SortOrder
  }

  export type DashboardReviewUserRolesCountOrderByAggregateInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserRole?: SortOrder
  }

  export type DashboardReviewUserRolesMaxOrderByAggregateInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserRole?: SortOrder
  }

  export type DashboardReviewUserRolesMinOrderByAggregateInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserRole?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DashboardsCountOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    Logo?: SortOrder
    IsEnabled?: SortOrder
    CreatedBy?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    IsDefault?: SortOrder
    DisplayDescription?: SortOrder
    Type?: SortOrder
    UserType?: SortOrder
    DashboardSettings?: SortOrder
    Template?: SortOrder
  }

  export type DashboardsAvgOrderByAggregateInput = {
    IsEnabled?: SortOrder
    IsDefault?: SortOrder
    DisplayDescription?: SortOrder
    Template?: SortOrder
  }

  export type DashboardsMaxOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    Logo?: SortOrder
    IsEnabled?: SortOrder
    CreatedBy?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    IsDefault?: SortOrder
    DisplayDescription?: SortOrder
    Type?: SortOrder
    UserType?: SortOrder
    DashboardSettings?: SortOrder
    Template?: SortOrder
  }

  export type DashboardsMinOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    Logo?: SortOrder
    IsEnabled?: SortOrder
    CreatedBy?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    IsDefault?: SortOrder
    DisplayDescription?: SortOrder
    Type?: SortOrder
    UserType?: SortOrder
    DashboardSettings?: SortOrder
    Template?: SortOrder
  }

  export type DashboardsSumOrderByAggregateInput = {
    IsEnabled?: SortOrder
    IsDefault?: SortOrder
    DisplayDescription?: SortOrder
    Template?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DashboardUserDefaultCountOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RepositoryId?: SortOrder
    DashboardId?: SortOrder
    Type?: SortOrder
  }

  export type DashboardUserDefaultMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RepositoryId?: SortOrder
    DashboardId?: SortOrder
    Type?: SortOrder
  }

  export type DashboardUserDefaultMinOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RepositoryId?: SortOrder
    DashboardId?: SortOrder
    Type?: SortOrder
  }

  export type DashboardUserGroupsCountOrderByAggregateInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserGroupId?: SortOrder
  }

  export type DashboardUserGroupsMaxOrderByAggregateInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserGroupId?: SortOrder
  }

  export type DashboardUserGroupsMinOrderByAggregateInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserGroupId?: SortOrder
  }

  export type DashboardUsersCountOrderByAggregateInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserId?: SortOrder
  }

  export type DashboardUsersMaxOrderByAggregateInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserId?: SortOrder
  }

  export type DashboardUsersMinOrderByAggregateInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    UserId?: SortOrder
  }

  export type DashboardWidgetBlocksCountOrderByAggregateInput = {
    Id?: SortOrder
    DashboardWidgetId?: SortOrder
    DashboardWidgetBlockTypeId?: SortOrder
    Title?: SortOrder
    Notes?: SortOrder
    EAArtifactGuid?: SortOrder
    IsConfigured?: SortOrder
    Position?: SortOrder
  }

  export type DashboardWidgetBlocksAvgOrderByAggregateInput = {
    IsConfigured?: SortOrder
    Position?: SortOrder
  }

  export type DashboardWidgetBlocksMaxOrderByAggregateInput = {
    Id?: SortOrder
    DashboardWidgetId?: SortOrder
    DashboardWidgetBlockTypeId?: SortOrder
    Title?: SortOrder
    Notes?: SortOrder
    EAArtifactGuid?: SortOrder
    IsConfigured?: SortOrder
    Position?: SortOrder
  }

  export type DashboardWidgetBlocksMinOrderByAggregateInput = {
    Id?: SortOrder
    DashboardWidgetId?: SortOrder
    DashboardWidgetBlockTypeId?: SortOrder
    Title?: SortOrder
    Notes?: SortOrder
    EAArtifactGuid?: SortOrder
    IsConfigured?: SortOrder
    Position?: SortOrder
  }

  export type DashboardWidgetBlocksSumOrderByAggregateInput = {
    IsConfigured?: SortOrder
    Position?: SortOrder
  }

  export type DashboardWidgetBlockTypesCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    Category?: SortOrder
    Position?: SortOrder
    NotSetText?: SortOrder
    ConfigurationRequired?: SortOrder
    IsEnabled?: SortOrder
    Icon?: SortOrder
  }

  export type DashboardWidgetBlockTypesAvgOrderByAggregateInput = {
    Position?: SortOrder
    ConfigurationRequired?: SortOrder
    IsEnabled?: SortOrder
  }

  export type DashboardWidgetBlockTypesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    Category?: SortOrder
    Position?: SortOrder
    NotSetText?: SortOrder
    ConfigurationRequired?: SortOrder
    IsEnabled?: SortOrder
    Icon?: SortOrder
  }

  export type DashboardWidgetBlockTypesMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    Category?: SortOrder
    Position?: SortOrder
    NotSetText?: SortOrder
    ConfigurationRequired?: SortOrder
    IsEnabled?: SortOrder
    Icon?: SortOrder
  }

  export type DashboardWidgetBlockTypesSumOrderByAggregateInput = {
    Position?: SortOrder
    ConfigurationRequired?: SortOrder
    IsEnabled?: SortOrder
  }

  export type DashboardWidgetsCountOrderByAggregateInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    RowId?: SortOrder
    ColumnId?: SortOrder
    ConfigData?: SortOrder
    SizeX?: SortOrder
    SizeY?: SortOrder
    WidgetSettings?: SortOrder
    Template?: SortOrder
    X?: SortOrder
    Y?: SortOrder
    Rows?: SortOrder
    Cols?: SortOrder
  }

  export type DashboardWidgetsAvgOrderByAggregateInput = {
    RowId?: SortOrder
    ColumnId?: SortOrder
    SizeX?: SortOrder
    SizeY?: SortOrder
    Template?: SortOrder
    X?: SortOrder
    Y?: SortOrder
    Rows?: SortOrder
    Cols?: SortOrder
  }

  export type DashboardWidgetsMaxOrderByAggregateInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    RowId?: SortOrder
    ColumnId?: SortOrder
    ConfigData?: SortOrder
    SizeX?: SortOrder
    SizeY?: SortOrder
    WidgetSettings?: SortOrder
    Template?: SortOrder
    X?: SortOrder
    Y?: SortOrder
    Rows?: SortOrder
    Cols?: SortOrder
  }

  export type DashboardWidgetsMinOrderByAggregateInput = {
    Id?: SortOrder
    DashboardId?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    RowId?: SortOrder
    ColumnId?: SortOrder
    ConfigData?: SortOrder
    SizeX?: SortOrder
    SizeY?: SortOrder
    WidgetSettings?: SortOrder
    Template?: SortOrder
    X?: SortOrder
    Y?: SortOrder
    Rows?: SortOrder
    Cols?: SortOrder
  }

  export type DashboardWidgetsSumOrderByAggregateInput = {
    RowId?: SortOrder
    ColumnId?: SortOrder
    SizeX?: SortOrder
    SizeY?: SortOrder
    Template?: SortOrder
    X?: SortOrder
    Y?: SortOrder
    Rows?: SortOrder
    Cols?: SortOrder
  }

  export type DocumentationRequestsCountOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserDefinedTemplate?: SortOrder
    InclusionList?: SortOrder
    ExclusionList?: SortOrder
    FileName?: SortOrder
    IsCancelled?: SortOrder
    IsProcessed?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type DocumentationRequestsAvgOrderByAggregateInput = {
    UserDefinedTemplate?: SortOrder
    IsCancelled?: SortOrder
    IsProcessed?: SortOrder
  }

  export type DocumentationRequestsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserDefinedTemplate?: SortOrder
    InclusionList?: SortOrder
    ExclusionList?: SortOrder
    FileName?: SortOrder
    IsCancelled?: SortOrder
    IsProcessed?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type DocumentationRequestsMinOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserDefinedTemplate?: SortOrder
    InclusionList?: SortOrder
    ExclusionList?: SortOrder
    FileName?: SortOrder
    IsCancelled?: SortOrder
    IsProcessed?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type DocumentationRequestsSumOrderByAggregateInput = {
    UserDefinedTemplate?: SortOrder
    IsCancelled?: SortOrder
    IsProcessed?: SortOrder
  }

  export type DomainRestrictionsCountOrderByAggregateInput = {
    Id?: SortOrder
    Domain?: SortOrder
    IsEnabled?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type DomainRestrictionsAvgOrderByAggregateInput = {
    IsEnabled?: SortOrder
  }

  export type DomainRestrictionsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Domain?: SortOrder
    IsEnabled?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type DomainRestrictionsMinOrderByAggregateInput = {
    Id?: SortOrder
    Domain?: SortOrder
    IsEnabled?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type DomainRestrictionsSumOrderByAggregateInput = {
    IsEnabled?: SortOrder
  }

  export type EAChangelogAttributesCountOrderByAggregateInput = {
    Id?: SortOrder
    EAChangelogId?: SortOrder
    PropertyGuid?: SortOrder
    Name?: SortOrder
    CurrentValue?: SortOrder
    PreviousValue?: SortOrder
    ActionType?: SortOrder
    AttributeType?: SortOrder
    CreatedDate?: SortOrder
  }

  export type EAChangelogAttributesMaxOrderByAggregateInput = {
    Id?: SortOrder
    EAChangelogId?: SortOrder
    PropertyGuid?: SortOrder
    Name?: SortOrder
    CurrentValue?: SortOrder
    PreviousValue?: SortOrder
    ActionType?: SortOrder
    AttributeType?: SortOrder
    CreatedDate?: SortOrder
  }

  export type EAChangelogAttributesMinOrderByAggregateInput = {
    Id?: SortOrder
    EAChangelogId?: SortOrder
    PropertyGuid?: SortOrder
    Name?: SortOrder
    CurrentValue?: SortOrder
    PreviousValue?: SortOrder
    ActionType?: SortOrder
    AttributeType?: SortOrder
    CreatedDate?: SortOrder
  }

  export type BigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type EAChangelogsCountOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    ArtifactGuid?: SortOrder
    ArtifactType?: SortOrder
    ActionType?: SortOrder
    Revision?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type EAChangelogsAvgOrderByAggregateInput = {
    Revision?: SortOrder
  }

  export type EAChangelogsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    ArtifactGuid?: SortOrder
    ArtifactType?: SortOrder
    ActionType?: SortOrder
    Revision?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type EAChangelogsMinOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    ArtifactGuid?: SortOrder
    ArtifactType?: SortOrder
    ActionType?: SortOrder
    Revision?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type EAChangelogsSumOrderByAggregateInput = {
    Revision?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type ElementConnectorsCountOrderByAggregateInput = {
    Id?: SortOrder
    ElementGuid?: SortOrder
    ElementType?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    AccessRight_AccessRightKey?: SortOrder
    InheritRight?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    CreatedBy?: SortOrder
    FeatureId?: SortOrder
    OtherInfo?: SortOrder
  }

  export type ElementConnectorsAvgOrderByAggregateInput = {
    InheritRight?: SortOrder
  }

  export type ElementConnectorsMaxOrderByAggregateInput = {
    Id?: SortOrder
    ElementGuid?: SortOrder
    ElementType?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    AccessRight_AccessRightKey?: SortOrder
    InheritRight?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    CreatedBy?: SortOrder
    FeatureId?: SortOrder
    OtherInfo?: SortOrder
  }

  export type ElementConnectorsMinOrderByAggregateInput = {
    Id?: SortOrder
    ElementGuid?: SortOrder
    ElementType?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    AccessRight_AccessRightKey?: SortOrder
    InheritRight?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    CreatedBy?: SortOrder
    FeatureId?: SortOrder
    OtherInfo?: SortOrder
  }

  export type ElementConnectorsSumOrderByAggregateInput = {
    InheritRight?: SortOrder
  }

  export type ExternalAppAttributeMasterCountOrderByAggregateInput = {
    Id?: SortOrder
    ExternalAppTypeId?: SortOrder
    ExternalAppId?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    InternalName?: SortOrder
    ExternalName?: SortOrder
    HelpText?: SortOrder
    MultiSelect?: SortOrder
    Filters?: SortOrder
    ConfigData?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    Description?: SortOrder
  }

  export type ExternalAppAttributeMasterAvgOrderByAggregateInput = {
    MultiSelect?: SortOrder
    IsEnabled?: SortOrder
  }

  export type ExternalAppAttributeMasterMaxOrderByAggregateInput = {
    Id?: SortOrder
    ExternalAppTypeId?: SortOrder
    ExternalAppId?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    InternalName?: SortOrder
    ExternalName?: SortOrder
    HelpText?: SortOrder
    MultiSelect?: SortOrder
    Filters?: SortOrder
    ConfigData?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    Description?: SortOrder
  }

  export type ExternalAppAttributeMasterMinOrderByAggregateInput = {
    Id?: SortOrder
    ExternalAppTypeId?: SortOrder
    ExternalAppId?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    InternalName?: SortOrder
    ExternalName?: SortOrder
    HelpText?: SortOrder
    MultiSelect?: SortOrder
    Filters?: SortOrder
    ConfigData?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    Description?: SortOrder
  }

  export type ExternalAppAttributeMasterSumOrderByAggregateInput = {
    MultiSelect?: SortOrder
    IsEnabled?: SortOrder
  }

  export type ExternalAppAttributesCountOrderByAggregateInput = {
    Id?: SortOrder
    ExternalAppAttributeMasterId?: SortOrder
    ExternalAppProjectId?: SortOrder
    ArtifactId?: SortOrder
    InternalValue?: SortOrder
    ExternalValue?: SortOrder
    ConfigData?: SortOrder
    IsDeleted?: SortOrder
    RemoteLinkId?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type ExternalAppAttributesAvgOrderByAggregateInput = {
    IsDeleted?: SortOrder
  }

  export type ExternalAppAttributesMaxOrderByAggregateInput = {
    Id?: SortOrder
    ExternalAppAttributeMasterId?: SortOrder
    ExternalAppProjectId?: SortOrder
    ArtifactId?: SortOrder
    InternalValue?: SortOrder
    ExternalValue?: SortOrder
    ConfigData?: SortOrder
    IsDeleted?: SortOrder
    RemoteLinkId?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type ExternalAppAttributesMinOrderByAggregateInput = {
    Id?: SortOrder
    ExternalAppAttributeMasterId?: SortOrder
    ExternalAppProjectId?: SortOrder
    ArtifactId?: SortOrder
    InternalValue?: SortOrder
    ExternalValue?: SortOrder
    ConfigData?: SortOrder
    IsDeleted?: SortOrder
    RemoteLinkId?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type ExternalAppAttributesSumOrderByAggregateInput = {
    IsDeleted?: SortOrder
  }

  export type ExternalAppsCountOrderByAggregateInput = {
    Id?: SortOrder
    ExternalAppTypeId?: SortOrder
    ExternalAppEnvironment?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    EndPointURL?: SortOrder
    IsExternal?: SortOrder
    ExternalPath?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    ProjectId?: SortOrder
    ProjectName?: SortOrder
    ConfigData?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type ExternalAppsAvgOrderByAggregateInput = {
    IsExternal?: SortOrder
    IsEnabled?: SortOrder
  }

  export type ExternalAppsMaxOrderByAggregateInput = {
    Id?: SortOrder
    ExternalAppTypeId?: SortOrder
    ExternalAppEnvironment?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    EndPointURL?: SortOrder
    IsExternal?: SortOrder
    ExternalPath?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    ProjectId?: SortOrder
    ProjectName?: SortOrder
    ConfigData?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type ExternalAppsMinOrderByAggregateInput = {
    Id?: SortOrder
    ExternalAppTypeId?: SortOrder
    ExternalAppEnvironment?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    EndPointURL?: SortOrder
    IsExternal?: SortOrder
    ExternalPath?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    ProjectId?: SortOrder
    ProjectName?: SortOrder
    ConfigData?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type ExternalAppsSumOrderByAggregateInput = {
    IsExternal?: SortOrder
    IsEnabled?: SortOrder
  }

  export type ExternalAppTypesCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    IsExternal?: SortOrder
    ExternalPath?: SortOrder
    Logo?: SortOrder
    Position?: SortOrder
    IsEnabled?: SortOrder
    AppContent?: SortOrder
  }

  export type ExternalAppTypesAvgOrderByAggregateInput = {
    IsExternal?: SortOrder
    Position?: SortOrder
    IsEnabled?: SortOrder
  }

  export type ExternalAppTypesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    IsExternal?: SortOrder
    ExternalPath?: SortOrder
    Logo?: SortOrder
    Position?: SortOrder
    IsEnabled?: SortOrder
    AppContent?: SortOrder
  }

  export type ExternalAppTypesMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    IsExternal?: SortOrder
    ExternalPath?: SortOrder
    Logo?: SortOrder
    Position?: SortOrder
    IsEnabled?: SortOrder
    AppContent?: SortOrder
  }

  export type ExternalAppTypesSumOrderByAggregateInput = {
    IsExternal?: SortOrder
    Position?: SortOrder
    IsEnabled?: SortOrder
  }

  export type FeaturesCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    FeatureKey?: SortOrder
  }

  export type FeaturesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    FeatureKey?: SortOrder
  }

  export type FeaturesMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    FeatureKey?: SortOrder
  }

  export type FilterProfileConnectorsCountOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    ProfileId?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
  }

  export type FilterProfileConnectorsMaxOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    ProfileId?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
  }

  export type FilterProfileConnectorsMinOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    ProfileId?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
  }

  export type FilterProfilesCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Type?: SortOrder
    Status?: SortOrder
    Configuration?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
    IsCacheEnabled?: SortOrder
  }

  export type FilterProfilesAvgOrderByAggregateInput = {
    Status?: SortOrder
    IsCacheEnabled?: SortOrder
  }

  export type FilterProfilesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Type?: SortOrder
    Status?: SortOrder
    Configuration?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
    IsCacheEnabled?: SortOrder
  }

  export type FilterProfilesMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Type?: SortOrder
    Status?: SortOrder
    Configuration?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
    IsCacheEnabled?: SortOrder
  }

  export type FilterProfilesSumOrderByAggregateInput = {
    Status?: SortOrder
    IsCacheEnabled?: SortOrder
  }

  export type GlobalRepositoryConfigurationsCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    IsReadOnly?: SortOrder
    RepositoryConfiguration?: SortOrder
    AllowAllRepository?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type GlobalRepositoryConfigurationsAvgOrderByAggregateInput = {
    IsReadOnly?: SortOrder
    AllowAllRepository?: SortOrder
  }

  export type GlobalRepositoryConfigurationsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    IsReadOnly?: SortOrder
    RepositoryConfiguration?: SortOrder
    AllowAllRepository?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type GlobalRepositoryConfigurationsMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    IsReadOnly?: SortOrder
    RepositoryConfiguration?: SortOrder
    AllowAllRepository?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type GlobalRepositoryConfigurationsSumOrderByAggregateInput = {
    IsReadOnly?: SortOrder
    AllowAllRepository?: SortOrder
  }

  export type GroupFeaturesCountOrderByAggregateInput = {
    Id?: SortOrder
    UserGroup_Id?: SortOrder
    Feature_Id?: SortOrder
    CreatedDate?: SortOrder
    Status?: SortOrder
  }

  export type GroupFeaturesMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserGroup_Id?: SortOrder
    Feature_Id?: SortOrder
    CreatedDate?: SortOrder
    Status?: SortOrder
  }

  export type GroupFeaturesMinOrderByAggregateInput = {
    Id?: SortOrder
    UserGroup_Id?: SortOrder
    Feature_Id?: SortOrder
    CreatedDate?: SortOrder
    Status?: SortOrder
  }

  export type GuestSignupSettingsCountOrderByAggregateInput = {
    Id?: SortOrder
    GlobalRepoConfigId?: SortOrder
    AllowAllRepository?: SortOrder
    RepositoryPermissions?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type GuestSignupSettingsAvgOrderByAggregateInput = {
    AllowAllRepository?: SortOrder
  }

  export type GuestSignupSettingsMaxOrderByAggregateInput = {
    Id?: SortOrder
    GlobalRepoConfigId?: SortOrder
    AllowAllRepository?: SortOrder
    RepositoryPermissions?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type GuestSignupSettingsMinOrderByAggregateInput = {
    Id?: SortOrder
    GlobalRepoConfigId?: SortOrder
    AllowAllRepository?: SortOrder
    RepositoryPermissions?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type GuestSignupSettingsSumOrderByAggregateInput = {
    AllowAllRepository?: SortOrder
  }

  export type IdPConnectionsCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    SigninUrl?: SortOrder
    CertificatePath?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    AllowAllRepository?: SortOrder
    RepositoryPermissions?: SortOrder
    RepositoryPermissionId?: SortOrder
    IdPSource?: SortOrder
    LogoutUrl?: SortOrder
    IDPCertificateEncrypted?: SortOrder
    SPCertificateEncrypted?: SortOrder
    SPCertificatePath?: SortOrder
    SPCertificatePassword?: SortOrder
    GlobalRepoConfigId?: SortOrder
    AttributesMapping?: SortOrder
  }

  export type IdPConnectionsAvgOrderByAggregateInput = {
    AllowAllRepository?: SortOrder
  }

  export type IdPConnectionsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    SigninUrl?: SortOrder
    CertificatePath?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    AllowAllRepository?: SortOrder
    RepositoryPermissions?: SortOrder
    RepositoryPermissionId?: SortOrder
    IdPSource?: SortOrder
    LogoutUrl?: SortOrder
    IDPCertificateEncrypted?: SortOrder
    SPCertificateEncrypted?: SortOrder
    SPCertificatePath?: SortOrder
    SPCertificatePassword?: SortOrder
    GlobalRepoConfigId?: SortOrder
    AttributesMapping?: SortOrder
  }

  export type IdPConnectionsMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    SigninUrl?: SortOrder
    CertificatePath?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    AllowAllRepository?: SortOrder
    RepositoryPermissions?: SortOrder
    RepositoryPermissionId?: SortOrder
    IdPSource?: SortOrder
    LogoutUrl?: SortOrder
    IDPCertificateEncrypted?: SortOrder
    SPCertificateEncrypted?: SortOrder
    SPCertificatePath?: SortOrder
    SPCertificatePassword?: SortOrder
    GlobalRepoConfigId?: SortOrder
    AttributesMapping?: SortOrder
  }

  export type IdPConnectionsSumOrderByAggregateInput = {
    AllowAllRepository?: SortOrder
  }

  export type LDAPConnectionsCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    Domain?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    SSL?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
  }

  export type LDAPConnectionsAvgOrderByAggregateInput = {
    Port?: SortOrder
    SSL?: SortOrder
  }

  export type LDAPConnectionsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    Domain?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    SSL?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
  }

  export type LDAPConnectionsMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    Domain?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    SSL?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
  }

  export type LDAPConnectionsSumOrderByAggregateInput = {
    Port?: SortOrder
    SSL?: SortOrder
  }

  export type MDGProfileConnectorsCountOrderByAggregateInput = {
    Id?: SortOrder
    UserGroupId?: SortOrder
    ProfileId?: SortOrder
    MdgId?: SortOrder
    RepositoryId?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
  }

  export type MDGProfileConnectorsAvgOrderByAggregateInput = {
    Status?: SortOrder
  }

  export type MDGProfileConnectorsMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserGroupId?: SortOrder
    ProfileId?: SortOrder
    MdgId?: SortOrder
    RepositoryId?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
  }

  export type MDGProfileConnectorsMinOrderByAggregateInput = {
    Id?: SortOrder
    UserGroupId?: SortOrder
    ProfileId?: SortOrder
    MdgId?: SortOrder
    RepositoryId?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
  }

  export type MDGProfileConnectorsSumOrderByAggregateInput = {
    Status?: SortOrder
  }

  export type MDGTechnologiesCountOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    Name?: SortOrder
    InternalName?: SortOrder
    Description?: SortOrder
    XmlContent?: SortOrder
    BuiltIn?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type MDGTechnologiesAvgOrderByAggregateInput = {
    BuiltIn?: SortOrder
    IsEnabled?: SortOrder
  }

  export type MDGTechnologiesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    Name?: SortOrder
    InternalName?: SortOrder
    Description?: SortOrder
    XmlContent?: SortOrder
    BuiltIn?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type MDGTechnologiesMinOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    Name?: SortOrder
    InternalName?: SortOrder
    Description?: SortOrder
    XmlContent?: SortOrder
    BuiltIn?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type MDGTechnologiesSumOrderByAggregateInput = {
    BuiltIn?: SortOrder
    IsEnabled?: SortOrder
  }

  export type MenuItemProfileConnectorsCountOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    Profile_Id?: SortOrder
    Default_Profile_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuItemProfileConnectorsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    Profile_Id?: SortOrder
    Default_Profile_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuItemProfileConnectorsMinOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    Profile_Id?: SortOrder
    Default_Profile_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuItemProfilesCountOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    Name?: SortOrder
    Type?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuItemProfilesAvgOrderByAggregateInput = {
    Status?: SortOrder
  }

  export type MenuItemProfilesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    Name?: SortOrder
    Type?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuItemProfilesMinOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    Name?: SortOrder
    Type?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuItemProfilesSumOrderByAggregateInput = {
    Status?: SortOrder
  }

  export type MenuItemProfileSettingsCountOrderByAggregateInput = {
    Id?: SortOrder
    Profile_Id?: SortOrder
    MenuItemKey?: SortOrder
    IsVisible?: SortOrder
    IfShowOnlyContent?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuItemProfileSettingsAvgOrderByAggregateInput = {
    IsVisible?: SortOrder
    IfShowOnlyContent?: SortOrder
  }

  export type MenuItemProfileSettingsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Profile_Id?: SortOrder
    MenuItemKey?: SortOrder
    IsVisible?: SortOrder
    IfShowOnlyContent?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuItemProfileSettingsMinOrderByAggregateInput = {
    Id?: SortOrder
    Profile_Id?: SortOrder
    MenuItemKey?: SortOrder
    IsVisible?: SortOrder
    IfShowOnlyContent?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuItemProfileSettingsSumOrderByAggregateInput = {
    IsVisible?: SortOrder
    IfShowOnlyContent?: SortOrder
  }

  export type MenuViewHistoryCountOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    UserId?: SortOrder
    PageKeys?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuViewHistoryMaxOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    UserId?: SortOrder
    PageKeys?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type MenuViewHistoryMinOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    UserId?: SortOrder
    PageKeys?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type OIDCAuthorizationsListRelationFilter = {
    every?: OIDCAuthorizationsWhereInput
    some?: OIDCAuthorizationsWhereInput
    none?: OIDCAuthorizationsWhereInput
  }

  export type OIDCTokensListRelationFilter = {
    every?: OIDCTokensWhereInput
    some?: OIDCTokensWhereInput
    none?: OIDCTokensWhereInput
  }

  export type OIDCAuthorizationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OIDCTokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OIDCApplicationsCountOrderByAggregateInput = {
    Id?: SortOrder
    ClientId?: SortOrder
    ClientSecret?: SortOrder
    ConcurrencyToken?: SortOrder
    ConsentType?: SortOrder
    DisplayName?: SortOrder
    DisplayNames?: SortOrder
    Permissions?: SortOrder
    PostLogoutRedirectUris?: SortOrder
    Properties?: SortOrder
    RedirectUris?: SortOrder
    Requirements?: SortOrder
    Type?: SortOrder
  }

  export type OIDCApplicationsMaxOrderByAggregateInput = {
    Id?: SortOrder
    ClientId?: SortOrder
    ClientSecret?: SortOrder
    ConcurrencyToken?: SortOrder
    ConsentType?: SortOrder
    DisplayName?: SortOrder
    DisplayNames?: SortOrder
    Permissions?: SortOrder
    PostLogoutRedirectUris?: SortOrder
    Properties?: SortOrder
    RedirectUris?: SortOrder
    Requirements?: SortOrder
    Type?: SortOrder
  }

  export type OIDCApplicationsMinOrderByAggregateInput = {
    Id?: SortOrder
    ClientId?: SortOrder
    ClientSecret?: SortOrder
    ConcurrencyToken?: SortOrder
    ConsentType?: SortOrder
    DisplayName?: SortOrder
    DisplayNames?: SortOrder
    Permissions?: SortOrder
    PostLogoutRedirectUris?: SortOrder
    Properties?: SortOrder
    RedirectUris?: SortOrder
    Requirements?: SortOrder
    Type?: SortOrder
  }

  export type OIDCApplicationsRelationFilter = {
    is?: OIDCApplicationsWhereInput | null
    isNot?: OIDCApplicationsWhereInput | null
  }

  export type OIDCAuthorizationsCountOrderByAggregateInput = {
    Id?: SortOrder
    ApplicationId?: SortOrder
    ConcurrencyToken?: SortOrder
    CreationDate?: SortOrder
    Properties?: SortOrder
    Scopes?: SortOrder
    Status?: SortOrder
    Subject?: SortOrder
    Type?: SortOrder
  }

  export type OIDCAuthorizationsMaxOrderByAggregateInput = {
    Id?: SortOrder
    ApplicationId?: SortOrder
    ConcurrencyToken?: SortOrder
    CreationDate?: SortOrder
    Properties?: SortOrder
    Scopes?: SortOrder
    Status?: SortOrder
    Subject?: SortOrder
    Type?: SortOrder
  }

  export type OIDCAuthorizationsMinOrderByAggregateInput = {
    Id?: SortOrder
    ApplicationId?: SortOrder
    ConcurrencyToken?: SortOrder
    CreationDate?: SortOrder
    Properties?: SortOrder
    Scopes?: SortOrder
    Status?: SortOrder
    Subject?: SortOrder
    Type?: SortOrder
  }

  export type OIDCScopesCountOrderByAggregateInput = {
    Id?: SortOrder
    ConcurrencyToken?: SortOrder
    Description?: SortOrder
    Descriptions?: SortOrder
    DisplayName?: SortOrder
    DisplayNames?: SortOrder
    Name?: SortOrder
    Properties?: SortOrder
    Resources?: SortOrder
  }

  export type OIDCScopesMaxOrderByAggregateInput = {
    Id?: SortOrder
    ConcurrencyToken?: SortOrder
    Description?: SortOrder
    Descriptions?: SortOrder
    DisplayName?: SortOrder
    DisplayNames?: SortOrder
    Name?: SortOrder
    Properties?: SortOrder
    Resources?: SortOrder
  }

  export type OIDCScopesMinOrderByAggregateInput = {
    Id?: SortOrder
    ConcurrencyToken?: SortOrder
    Description?: SortOrder
    Descriptions?: SortOrder
    DisplayName?: SortOrder
    DisplayNames?: SortOrder
    Name?: SortOrder
    Properties?: SortOrder
    Resources?: SortOrder
  }

  export type OIDCAuthorizationsRelationFilter = {
    is?: OIDCAuthorizationsWhereInput | null
    isNot?: OIDCAuthorizationsWhereInput | null
  }

  export type OIDCTokensCountOrderByAggregateInput = {
    Id?: SortOrder
    ApplicationId?: SortOrder
    AuthorizationId?: SortOrder
    ConcurrencyToken?: SortOrder
    CreationDate?: SortOrder
    ExpirationDate?: SortOrder
    Payload?: SortOrder
    Properties?: SortOrder
    RedemptionDate?: SortOrder
    ReferenceId?: SortOrder
    Status?: SortOrder
    Subject?: SortOrder
    Type?: SortOrder
  }

  export type OIDCTokensMaxOrderByAggregateInput = {
    Id?: SortOrder
    ApplicationId?: SortOrder
    AuthorizationId?: SortOrder
    ConcurrencyToken?: SortOrder
    CreationDate?: SortOrder
    ExpirationDate?: SortOrder
    Payload?: SortOrder
    Properties?: SortOrder
    RedemptionDate?: SortOrder
    ReferenceId?: SortOrder
    Status?: SortOrder
    Subject?: SortOrder
    Type?: SortOrder
  }

  export type OIDCTokensMinOrderByAggregateInput = {
    Id?: SortOrder
    ApplicationId?: SortOrder
    AuthorizationId?: SortOrder
    ConcurrencyToken?: SortOrder
    CreationDate?: SortOrder
    ExpirationDate?: SortOrder
    Payload?: SortOrder
    Properties?: SortOrder
    RedemptionDate?: SortOrder
    ReferenceId?: SortOrder
    Status?: SortOrder
    Subject?: SortOrder
    Type?: SortOrder
  }

  export type ProfilesCountOrderByAggregateInput = {
    Id?: SortOrder
    MDGTechnology_Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    ProfileContent?: SortOrder
    IsDefault?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    EnableTechnologyGroup?: SortOrder
    EnableInheritedGroup?: SortOrder
    IncludeBaseAttributes?: SortOrder
  }

  export type ProfilesAvgOrderByAggregateInput = {
    IsDefault?: SortOrder
    IsEnabled?: SortOrder
    EnableTechnologyGroup?: SortOrder
    EnableInheritedGroup?: SortOrder
    IncludeBaseAttributes?: SortOrder
  }

  export type ProfilesMaxOrderByAggregateInput = {
    Id?: SortOrder
    MDGTechnology_Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    ProfileContent?: SortOrder
    IsDefault?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    EnableTechnologyGroup?: SortOrder
    EnableInheritedGroup?: SortOrder
    IncludeBaseAttributes?: SortOrder
  }

  export type ProfilesMinOrderByAggregateInput = {
    Id?: SortOrder
    MDGTechnology_Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    ProfileContent?: SortOrder
    IsDefault?: SortOrder
    IsEnabled?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    EnableTechnologyGroup?: SortOrder
    EnableInheritedGroup?: SortOrder
    IncludeBaseAttributes?: SortOrder
  }

  export type ProfilesSumOrderByAggregateInput = {
    IsDefault?: SortOrder
    IsEnabled?: SortOrder
    EnableTechnologyGroup?: SortOrder
    EnableInheritedGroup?: SortOrder
    IncludeBaseAttributes?: SortOrder
  }

  export type PropertyMenuItemConnectorsCountOrderByAggregateInput = {
    Id?: SortOrder
    MenuItemKey?: SortOrder
    PageType?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type PropertyMenuItemConnectorsMaxOrderByAggregateInput = {
    Id?: SortOrder
    MenuItemKey?: SortOrder
    PageType?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type PropertyMenuItemConnectorsMinOrderByAggregateInput = {
    Id?: SortOrder
    MenuItemKey?: SortOrder
    PageType?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type PropertyMenuItemsCountOrderByAggregateInput = {
    Id?: SortOrder
    MenuItemKey?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    IconClass?: SortOrder
    Position?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type PropertyMenuItemsAvgOrderByAggregateInput = {
    Position?: SortOrder
    Status?: SortOrder
  }

  export type PropertyMenuItemsMaxOrderByAggregateInput = {
    Id?: SortOrder
    MenuItemKey?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    IconClass?: SortOrder
    Position?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type PropertyMenuItemsMinOrderByAggregateInput = {
    Id?: SortOrder
    MenuItemKey?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    IconClass?: SortOrder
    Position?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type PropertyMenuItemsSumOrderByAggregateInput = {
    Position?: SortOrder
    Status?: SortOrder
  }

  export type RepositoriesCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Alias?: SortOrder
    Description?: SortOrder
    EAPFile?: SortOrder
    IsCacheEnabled?: SortOrder
    AuthRequired?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    IsEnabled?: SortOrder
    InstanceCount?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    Status?: SortOrder
    Protocol?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    Model?: SortOrder
    OslcAccessCode?: SortOrder
    EAUserAuth?: SortOrder
    UserIdentifier?: SortOrder
    DBType?: SortOrder
  }

  export type RepositoriesAvgOrderByAggregateInput = {
    IsCacheEnabled?: SortOrder
    AuthRequired?: SortOrder
    IsEnabled?: SortOrder
    InstanceCount?: SortOrder
    EAUserAuth?: SortOrder
    DBType?: SortOrder
  }

  export type RepositoriesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Alias?: SortOrder
    Description?: SortOrder
    EAPFile?: SortOrder
    IsCacheEnabled?: SortOrder
    AuthRequired?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    IsEnabled?: SortOrder
    InstanceCount?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    Status?: SortOrder
    Protocol?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    Model?: SortOrder
    OslcAccessCode?: SortOrder
    EAUserAuth?: SortOrder
    UserIdentifier?: SortOrder
    DBType?: SortOrder
  }

  export type RepositoriesMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Alias?: SortOrder
    Description?: SortOrder
    EAPFile?: SortOrder
    IsCacheEnabled?: SortOrder
    AuthRequired?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    IsEnabled?: SortOrder
    InstanceCount?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    Status?: SortOrder
    Protocol?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    Model?: SortOrder
    OslcAccessCode?: SortOrder
    EAUserAuth?: SortOrder
    UserIdentifier?: SortOrder
    DBType?: SortOrder
  }

  export type RepositoriesSumOrderByAggregateInput = {
    IsCacheEnabled?: SortOrder
    AuthRequired?: SortOrder
    IsEnabled?: SortOrder
    InstanceCount?: SortOrder
    EAUserAuth?: SortOrder
    DBType?: SortOrder
  }

  export type RepositoryConnectorsCountOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    Dashboard_Id?: SortOrder
    EAUserAuth?: SortOrder
    IsUserDefault?: SortOrder
  }

  export type RepositoryConnectorsAvgOrderByAggregateInput = {
    EAUserAuth?: SortOrder
    IsUserDefault?: SortOrder
  }

  export type RepositoryConnectorsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    Dashboard_Id?: SortOrder
    EAUserAuth?: SortOrder
    IsUserDefault?: SortOrder
  }

  export type RepositoryConnectorsMinOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    UserGroup_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
    Dashboard_Id?: SortOrder
    EAUserAuth?: SortOrder
    IsUserDefault?: SortOrder
  }

  export type RepositoryConnectorsSumOrderByAggregateInput = {
    EAUserAuth?: SortOrder
    IsUserDefault?: SortOrder
  }

  export type RepositoryDBConnectionsCountOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    CreateElement?: SortOrder
    ConnectionType?: SortOrder
    ConnectionDetail?: SortOrder
    DBType?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    DBName?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    DsnName?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type RepositoryDBConnectionsAvgOrderByAggregateInput = {
    CreateElement?: SortOrder
  }

  export type RepositoryDBConnectionsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    CreateElement?: SortOrder
    ConnectionType?: SortOrder
    ConnectionDetail?: SortOrder
    DBType?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    DBName?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    DsnName?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type RepositoryDBConnectionsMinOrderByAggregateInput = {
    Id?: SortOrder
    Repository_Id?: SortOrder
    CreateElement?: SortOrder
    ConnectionType?: SortOrder
    ConnectionDetail?: SortOrder
    DBType?: SortOrder
    Server?: SortOrder
    Port?: SortOrder
    DBName?: SortOrder
    Username?: SortOrder
    Password?: SortOrder
    DsnName?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type RepositoryDBConnectionsSumOrderByAggregateInput = {
    CreateElement?: SortOrder
  }

  export type RequestLogsCountOrderByAggregateInput = {
    Id?: SortOrder
    RequestedUserId?: SortOrder
    DesignatedUserId?: SortOrder
    Url?: SortOrder
    UrlType?: SortOrder
    RequestedUserAgent?: SortOrder
    RequestedUserIpAddress?: SortOrder
    DesignatedUserAgent?: SortOrder
    DesignatedUserIpAddress?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    LastVisited?: SortOrder
    Status?: SortOrder
    Validity?: SortOrder
  }

  export type RequestLogsAvgOrderByAggregateInput = {
    Status?: SortOrder
  }

  export type RequestLogsMaxOrderByAggregateInput = {
    Id?: SortOrder
    RequestedUserId?: SortOrder
    DesignatedUserId?: SortOrder
    Url?: SortOrder
    UrlType?: SortOrder
    RequestedUserAgent?: SortOrder
    RequestedUserIpAddress?: SortOrder
    DesignatedUserAgent?: SortOrder
    DesignatedUserIpAddress?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    LastVisited?: SortOrder
    Status?: SortOrder
    Validity?: SortOrder
  }

  export type RequestLogsMinOrderByAggregateInput = {
    Id?: SortOrder
    RequestedUserId?: SortOrder
    DesignatedUserId?: SortOrder
    Url?: SortOrder
    UrlType?: SortOrder
    RequestedUserAgent?: SortOrder
    RequestedUserIpAddress?: SortOrder
    DesignatedUserAgent?: SortOrder
    DesignatedUserIpAddress?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    LastVisited?: SortOrder
    Status?: SortOrder
    Validity?: SortOrder
  }

  export type RequestLogsSumOrderByAggregateInput = {
    Status?: SortOrder
  }

  export type ReservedUsersCountOrderByAggregateInput = {
    Id?: SortOrder
    User_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type ReservedUsersMaxOrderByAggregateInput = {
    Id?: SortOrder
    User_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type ReservedUsersMinOrderByAggregateInput = {
    Id?: SortOrder
    User_Id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type BytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type ResourceFilesCountOrderByAggregateInput = {
    Id?: SortOrder
    MapItemId?: SortOrder
    FileContent?: SortOrder
    FilePath?: SortOrder
    Extension?: SortOrder
    Name?: SortOrder
    ModifiedDate?: SortOrder
    CreatedDate?: SortOrder
  }

  export type ResourceFilesMaxOrderByAggregateInput = {
    Id?: SortOrder
    MapItemId?: SortOrder
    FileContent?: SortOrder
    FilePath?: SortOrder
    Extension?: SortOrder
    Name?: SortOrder
    ModifiedDate?: SortOrder
    CreatedDate?: SortOrder
  }

  export type ResourceFilesMinOrderByAggregateInput = {
    Id?: SortOrder
    MapItemId?: SortOrder
    FileContent?: SortOrder
    FilePath?: SortOrder
    Extension?: SortOrder
    Name?: SortOrder
    ModifiedDate?: SortOrder
    CreatedDate?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type ResourcesCountOrderByAggregateInput = {
    Id?: SortOrder
    ResourceName?: SortOrder
  }

  export type ResourcesMaxOrderByAggregateInput = {
    Id?: SortOrder
    ResourceName?: SortOrder
  }

  export type ResourcesMinOrderByAggregateInput = {
    Id?: SortOrder
    ResourceName?: SortOrder
  }

  export type ReviewProcessesCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    ReviewStartDate?: SortOrder
    ReviewEndDate?: SortOrder
    ApproveStartDate?: SortOrder
    ApproveEndDate?: SortOrder
    WorkFlow?: SortOrder
    AutoStatusUpdate?: SortOrder
    ReviewStartType?: SortOrder
    ElementRecursiveSelection?: SortOrder
    ExternalUsersInvite?: SortOrder
    EnableShare?: SortOrder
    EmailNotification?: SortOrder
    Mode?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type ReviewProcessesAvgOrderByAggregateInput = {
    WorkFlow?: SortOrder
    AutoStatusUpdate?: SortOrder
    ReviewStartType?: SortOrder
    ElementRecursiveSelection?: SortOrder
    ExternalUsersInvite?: SortOrder
    EnableShare?: SortOrder
    EmailNotification?: SortOrder
  }

  export type ReviewProcessesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    ReviewStartDate?: SortOrder
    ReviewEndDate?: SortOrder
    ApproveStartDate?: SortOrder
    ApproveEndDate?: SortOrder
    WorkFlow?: SortOrder
    AutoStatusUpdate?: SortOrder
    ReviewStartType?: SortOrder
    ElementRecursiveSelection?: SortOrder
    ExternalUsersInvite?: SortOrder
    EnableShare?: SortOrder
    EmailNotification?: SortOrder
    Mode?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type ReviewProcessesMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Notes?: SortOrder
    ReviewStartDate?: SortOrder
    ReviewEndDate?: SortOrder
    ApproveStartDate?: SortOrder
    ApproveEndDate?: SortOrder
    WorkFlow?: SortOrder
    AutoStatusUpdate?: SortOrder
    ReviewStartType?: SortOrder
    ElementRecursiveSelection?: SortOrder
    ExternalUsersInvite?: SortOrder
    EnableShare?: SortOrder
    EmailNotification?: SortOrder
    Mode?: SortOrder
    Repository_Id?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type ReviewProcessesSumOrderByAggregateInput = {
    WorkFlow?: SortOrder
    AutoStatusUpdate?: SortOrder
    ReviewStartType?: SortOrder
    ElementRecursiveSelection?: SortOrder
    ExternalUsersInvite?: SortOrder
    EnableShare?: SortOrder
    EmailNotification?: SortOrder
  }

  export type TaggedValuesCountOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    Type?: SortOrder
    DefaultValue?: SortOrder
    AttributeValues?: SortOrder
    LowerBound?: SortOrder
    UpperBound?: SortOrder
    Stereotypes?: SortOrder
    AppliesTo?: SortOrder
    BaseStereotype?: SortOrder
  }

  export type TaggedValuesAvgOrderByAggregateInput = {
    LowerBound?: SortOrder
    UpperBound?: SortOrder
  }

  export type TaggedValuesMaxOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    Type?: SortOrder
    DefaultValue?: SortOrder
    AttributeValues?: SortOrder
    LowerBound?: SortOrder
    UpperBound?: SortOrder
    Stereotypes?: SortOrder
    AppliesTo?: SortOrder
    BaseStereotype?: SortOrder
  }

  export type TaggedValuesMinOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    Type?: SortOrder
    DefaultValue?: SortOrder
    AttributeValues?: SortOrder
    LowerBound?: SortOrder
    UpperBound?: SortOrder
    Stereotypes?: SortOrder
    AppliesTo?: SortOrder
    BaseStereotype?: SortOrder
  }

  export type TaggedValuesSumOrderByAggregateInput = {
    LowerBound?: SortOrder
    UpperBound?: SortOrder
  }

  export type TraceabilityTreeProfilesCountOrderByAggregateInput = {
    Id?: SortOrder
    ProfileName?: SortOrder
    RepositoryId?: SortOrder
    ElementGuid?: SortOrder
    Type?: SortOrder
    SteroType?: SortOrder
    FQName?: SortOrder
    Technology?: SortOrder
    TemplateOptions?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    IsApplytoAll?: SortOrder
    IsApplytoType?: SortOrder
    IsApplytoSteroType?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    ElementTypeList?: SortOrder
    ConnectorTypeList?: SortOrder
    FlowDirectionTypeList?: SortOrder
    TreeType?: SortOrder
  }

  export type TraceabilityTreeProfilesAvgOrderByAggregateInput = {
    Status?: SortOrder
    IsApplytoAll?: SortOrder
    IsApplytoType?: SortOrder
    IsApplytoSteroType?: SortOrder
  }

  export type TraceabilityTreeProfilesMaxOrderByAggregateInput = {
    Id?: SortOrder
    ProfileName?: SortOrder
    RepositoryId?: SortOrder
    ElementGuid?: SortOrder
    Type?: SortOrder
    SteroType?: SortOrder
    FQName?: SortOrder
    Technology?: SortOrder
    TemplateOptions?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    IsApplytoAll?: SortOrder
    IsApplytoType?: SortOrder
    IsApplytoSteroType?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    ElementTypeList?: SortOrder
    ConnectorTypeList?: SortOrder
    FlowDirectionTypeList?: SortOrder
    TreeType?: SortOrder
  }

  export type TraceabilityTreeProfilesMinOrderByAggregateInput = {
    Id?: SortOrder
    ProfileName?: SortOrder
    RepositoryId?: SortOrder
    ElementGuid?: SortOrder
    Type?: SortOrder
    SteroType?: SortOrder
    FQName?: SortOrder
    Technology?: SortOrder
    TemplateOptions?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    IsApplytoAll?: SortOrder
    IsApplytoType?: SortOrder
    IsApplytoSteroType?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    ElementTypeList?: SortOrder
    ConnectorTypeList?: SortOrder
    FlowDirectionTypeList?: SortOrder
    TreeType?: SortOrder
  }

  export type TraceabilityTreeProfilesSumOrderByAggregateInput = {
    Status?: SortOrder
    IsApplytoAll?: SortOrder
    IsApplytoType?: SortOrder
    IsApplytoSteroType?: SortOrder
  }

  export type TraceabilityTreeViewsCountOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    ElementGuid?: SortOrder
    TreeViewData?: SortOrder
    User_Id?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    FilterItems?: SortOrder
    Tittle?: SortOrder
    Revision?: SortOrder
    ViewId?: SortOrder
    TemplateOptions?: SortOrder
    Description?: SortOrder
    NlFilterItems?: SortOrder
    NlTreeData?: SortOrder
    NlFilterItemStatus?: SortOrder
    FilterAppliedNodeList?: SortOrder
    TotForceLinks?: SortOrder
  }

  export type TraceabilityTreeViewsMaxOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    ElementGuid?: SortOrder
    TreeViewData?: SortOrder
    User_Id?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    FilterItems?: SortOrder
    Tittle?: SortOrder
    Revision?: SortOrder
    ViewId?: SortOrder
    TemplateOptions?: SortOrder
    Description?: SortOrder
    NlFilterItems?: SortOrder
    NlTreeData?: SortOrder
    NlFilterItemStatus?: SortOrder
    FilterAppliedNodeList?: SortOrder
    TotForceLinks?: SortOrder
  }

  export type TraceabilityTreeViewsMinOrderByAggregateInput = {
    Id?: SortOrder
    RepositoryId?: SortOrder
    ElementGuid?: SortOrder
    TreeViewData?: SortOrder
    User_Id?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    FilterItems?: SortOrder
    Tittle?: SortOrder
    Revision?: SortOrder
    ViewId?: SortOrder
    TemplateOptions?: SortOrder
    Description?: SortOrder
    NlFilterItems?: SortOrder
    NlTreeData?: SortOrder
    NlFilterItemStatus?: SortOrder
    FilterAppliedNodeList?: SortOrder
    TotForceLinks?: SortOrder
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type URLMapCountOrderByAggregateInput = {
    Id?: SortOrder
    URL?: SortOrder
    URLType?: SortOrder
    HashCode?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Repository_Id?: SortOrder
    LinkType?: SortOrder
    MapurlId?: SortOrder
  }

  export type URLMapAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type URLMapMaxOrderByAggregateInput = {
    Id?: SortOrder
    URL?: SortOrder
    URLType?: SortOrder
    HashCode?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Repository_Id?: SortOrder
    LinkType?: SortOrder
    MapurlId?: SortOrder
  }

  export type URLMapMinOrderByAggregateInput = {
    Id?: SortOrder
    URL?: SortOrder
    URLType?: SortOrder
    HashCode?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Repository_Id?: SortOrder
    LinkType?: SortOrder
    MapurlId?: SortOrder
  }

  export type URLMapSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type UserActionsCountOrderByAggregateInput = {
    Id?: SortOrder
    ActionName?: SortOrder
    Actionkey?: SortOrder
    Resource_id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
  }

  export type UserActionsMaxOrderByAggregateInput = {
    Id?: SortOrder
    ActionName?: SortOrder
    Actionkey?: SortOrder
    Resource_id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
  }

  export type UserActionsMinOrderByAggregateInput = {
    Id?: SortOrder
    ActionName?: SortOrder
    Actionkey?: SortOrder
    Resource_id?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Status?: SortOrder
  }

  export type UserGroupConnectorsCountOrderByAggregateInput = {
    Id?: SortOrder
    UserGroup_Id?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
  }

  export type UserGroupConnectorsMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserGroup_Id?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
  }

  export type UserGroupConnectorsMinOrderByAggregateInput = {
    Id?: SortOrder
    UserGroup_Id?: SortOrder
    User_Id?: SortOrder
    Status?: SortOrder
    CreatedDate?: SortOrder
  }

  export type UserGroupsCountOrderByAggregateInput = {
    Id?: SortOrder
    GroupName?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    EditFeatures?: SortOrder
    Status?: SortOrder
    UserGroups_Role_Id?: SortOrder
    IsReadOnly?: SortOrder
  }

  export type UserGroupsAvgOrderByAggregateInput = {
    EditFeatures?: SortOrder
    IsReadOnly?: SortOrder
  }

  export type UserGroupsMaxOrderByAggregateInput = {
    Id?: SortOrder
    GroupName?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    EditFeatures?: SortOrder
    Status?: SortOrder
    UserGroups_Role_Id?: SortOrder
    IsReadOnly?: SortOrder
  }

  export type UserGroupsMinOrderByAggregateInput = {
    Id?: SortOrder
    GroupName?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    EditFeatures?: SortOrder
    Status?: SortOrder
    UserGroups_Role_Id?: SortOrder
    IsReadOnly?: SortOrder
  }

  export type UserGroupsSumOrderByAggregateInput = {
    EditFeatures?: SortOrder
    IsReadOnly?: SortOrder
  }

  export type UsersRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type UserIdentityClaimsCountOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type UserIdentityClaimsAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type UserIdentityClaimsMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type UserIdentityClaimsMinOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type UserIdentityClaimsSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type UserIdentityLoginsLoginProviderProviderKeyCompoundUniqueInput = {
    LoginProvider: string
    ProviderKey: string
  }

  export type UserIdentityLoginsCountOrderByAggregateInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrder
    UserId?: SortOrder
  }

  export type UserIdentityLoginsMaxOrderByAggregateInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrder
    UserId?: SortOrder
  }

  export type UserIdentityLoginsMinOrderByAggregateInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrder
    UserId?: SortOrder
  }

  export type AppIdentityRolesRelationFilter = {
    is?: AppIdentityRolesWhereInput
    isNot?: AppIdentityRolesWhereInput
  }

  export type UserIdentityRoleClaimsCountOrderByAggregateInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type UserIdentityRoleClaimsAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type UserIdentityRoleClaimsMaxOrderByAggregateInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type UserIdentityRoleClaimsMinOrderByAggregateInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type UserIdentityRoleClaimsSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type UserIdentityRolesUserIdRoleIdCompoundUniqueInput = {
    UserId: string
    RoleId: string
  }

  export type UserIdentityRolesCountOrderByAggregateInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
  }

  export type UserIdentityRolesMaxOrderByAggregateInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
  }

  export type UserIdentityRolesMinOrderByAggregateInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
  }

  export type UserIdentityTokensUserIdLoginProviderNameCompoundUniqueInput = {
    UserId: string
    LoginProvider: string
    Name: string
  }

  export type UserIdentityTokensCountOrderByAggregateInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrder
  }

  export type UserIdentityTokensMaxOrderByAggregateInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrder
  }

  export type UserIdentityTokensMinOrderByAggregateInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrder
  }

  export type UserProfileSettingCountOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RepositoryTechnologyConfiguration?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type UserProfileSettingMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RepositoryTechnologyConfiguration?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type UserProfileSettingMinOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RepositoryTechnologyConfiguration?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
  }

  export type UserRoleProfilesCountOrderByAggregateInput = {
    Id?: SortOrder
    UserRole_Id?: SortOrder
    Profile_Id?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type UserRoleProfilesMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserRole_Id?: SortOrder
    Profile_Id?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type UserRoleProfilesMinOrderByAggregateInput = {
    Id?: SortOrder
    UserRole_Id?: SortOrder
    Profile_Id?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
  }

  export type UserRolesCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    UIEnabled?: SortOrder
  }

  export type UserRolesAvgOrderByAggregateInput = {
    UIEnabled?: SortOrder
  }

  export type UserRolesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    UIEnabled?: SortOrder
  }

  export type UserRolesMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    UIEnabled?: SortOrder
  }

  export type UserRolesSumOrderByAggregateInput = {
    UIEnabled?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type UserIdentityClaimsListRelationFilter = {
    every?: UserIdentityClaimsWhereInput
    some?: UserIdentityClaimsWhereInput
    none?: UserIdentityClaimsWhereInput
  }

  export type UserIdentityLoginsListRelationFilter = {
    every?: UserIdentityLoginsWhereInput
    some?: UserIdentityLoginsWhereInput
    none?: UserIdentityLoginsWhereInput
  }

  export type UserIdentityTokensListRelationFilter = {
    every?: UserIdentityTokensWhereInput
    some?: UserIdentityTokensWhereInput
    none?: UserIdentityTokensWhereInput
  }

  export type UserIdentityClaimsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserIdentityLoginsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserIdentityTokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    Id?: SortOrder
    LDAPConnection_Id?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    UserRole_Id?: SortOrder
    Status?: SortOrder
    EmailId?: SortOrder
    Password?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Description?: SortOrder
    ProfileImage?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
    RegistrationMode?: SortOrder
    Timezone?: SortOrder
    IsPasswordSet?: SortOrder
    IsAdmin?: SortOrder
    ShowHelpText?: SortOrder
    IdentityProvider_Id?: SortOrder
    SecPhrase?: SortOrder
    IsReadOnly?: SortOrder
    UserIdentityRole?: SortOrder
    UserName?: SortOrder
    NormalizedUserName?: SortOrder
    Email?: SortOrder
    NormalizedEmail?: SortOrder
    EmailConfirmed?: SortOrder
    SecurityStamp?: SortOrder
    ConcurrencyStamp?: SortOrder
    PhoneNumber?: SortOrder
    PhoneNumberConfirmed?: SortOrder
    PasswordHash?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    IsPasswordSet?: SortOrder
    IsAdmin?: SortOrder
    ShowHelpText?: SortOrder
    IsReadOnly?: SortOrder
    AccessFailedCount?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    Id?: SortOrder
    LDAPConnection_Id?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    UserRole_Id?: SortOrder
    Status?: SortOrder
    EmailId?: SortOrder
    Password?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Description?: SortOrder
    ProfileImage?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
    RegistrationMode?: SortOrder
    Timezone?: SortOrder
    IsPasswordSet?: SortOrder
    IsAdmin?: SortOrder
    ShowHelpText?: SortOrder
    IdentityProvider_Id?: SortOrder
    SecPhrase?: SortOrder
    IsReadOnly?: SortOrder
    UserIdentityRole?: SortOrder
    UserName?: SortOrder
    NormalizedUserName?: SortOrder
    Email?: SortOrder
    NormalizedEmail?: SortOrder
    EmailConfirmed?: SortOrder
    SecurityStamp?: SortOrder
    ConcurrencyStamp?: SortOrder
    PhoneNumber?: SortOrder
    PhoneNumberConfirmed?: SortOrder
    PasswordHash?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    Id?: SortOrder
    LDAPConnection_Id?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    UserRole_Id?: SortOrder
    Status?: SortOrder
    EmailId?: SortOrder
    Password?: SortOrder
    CreatedDate?: SortOrder
    ModifiedDate?: SortOrder
    Description?: SortOrder
    ProfileImage?: SortOrder
    CreatedBy?: SortOrder
    ModifiedBy?: SortOrder
    RegistrationMode?: SortOrder
    Timezone?: SortOrder
    IsPasswordSet?: SortOrder
    IsAdmin?: SortOrder
    ShowHelpText?: SortOrder
    IdentityProvider_Id?: SortOrder
    SecPhrase?: SortOrder
    IsReadOnly?: SortOrder
    UserIdentityRole?: SortOrder
    UserName?: SortOrder
    NormalizedUserName?: SortOrder
    Email?: SortOrder
    NormalizedEmail?: SortOrder
    EmailConfirmed?: SortOrder
    SecurityStamp?: SortOrder
    ConcurrencyStamp?: SortOrder
    PhoneNumber?: SortOrder
    PhoneNumberConfirmed?: SortOrder
    PasswordHash?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    IsPasswordSet?: SortOrder
    IsAdmin?: SortOrder
    ShowHelpText?: SortOrder
    IsReadOnly?: SortOrder
    AccessFailedCount?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type UserSessionsCountOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    IsReservedUser?: SortOrder
    AccessMode?: SortOrder
    IPAddress?: SortOrder
    UserAgent?: SortOrder
    IsActive?: SortOrder
    LastRequest?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    UserDisplayName?: SortOrder
    UserType?: SortOrder
  }

  export type UserSessionsAvgOrderByAggregateInput = {
    IsReservedUser?: SortOrder
    IsActive?: SortOrder
  }

  export type UserSessionsMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    IsReservedUser?: SortOrder
    AccessMode?: SortOrder
    IPAddress?: SortOrder
    UserAgent?: SortOrder
    IsActive?: SortOrder
    LastRequest?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    UserDisplayName?: SortOrder
    UserType?: SortOrder
  }

  export type UserSessionsMinOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    IsReservedUser?: SortOrder
    AccessMode?: SortOrder
    IPAddress?: SortOrder
    UserAgent?: SortOrder
    IsActive?: SortOrder
    LastRequest?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    UserDisplayName?: SortOrder
    UserType?: SortOrder
  }

  export type UserSessionsSumOrderByAggregateInput = {
    IsReservedUser?: SortOrder
    IsActive?: SortOrder
  }

  export type UserSessionsArchiveCountOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    IsReservedUser?: SortOrder
    AccessMode?: SortOrder
    IPAddress?: SortOrder
    UserAgent?: SortOrder
    IsActive?: SortOrder
    LastRequest?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    UserDisplayName?: SortOrder
    UserType?: SortOrder
  }

  export type UserSessionsArchiveAvgOrderByAggregateInput = {
    IsReservedUser?: SortOrder
    IsActive?: SortOrder
  }

  export type UserSessionsArchiveMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    IsReservedUser?: SortOrder
    AccessMode?: SortOrder
    IPAddress?: SortOrder
    UserAgent?: SortOrder
    IsActive?: SortOrder
    LastRequest?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    UserDisplayName?: SortOrder
    UserType?: SortOrder
  }

  export type UserSessionsArchiveMinOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    IsReservedUser?: SortOrder
    AccessMode?: SortOrder
    IPAddress?: SortOrder
    UserAgent?: SortOrder
    IsActive?: SortOrder
    LastRequest?: SortOrder
    Created?: SortOrder
    Modified?: SortOrder
    UserDisplayName?: SortOrder
    UserType?: SortOrder
  }

  export type UserSessionsArchiveSumOrderByAggregateInput = {
    IsReservedUser?: SortOrder
    IsActive?: SortOrder
  }

  export type UserTokensCountOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RefreshToken?: SortOrder
    CreatedDate?: SortOrder
  }

  export type UserTokensMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RefreshToken?: SortOrder
    CreatedDate?: SortOrder
  }

  export type UserTokensMinOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    RefreshToken?: SortOrder
    CreatedDate?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserIdentityRoleClaimsCreateNestedManyWithoutAppIdentityRolesInput = {
    create?: XOR<Enumerable<UserIdentityRoleClaimsCreateWithoutAppIdentityRolesInput>, Enumerable<UserIdentityRoleClaimsUncheckedCreateWithoutAppIdentityRolesInput>>
    connectOrCreate?: Enumerable<UserIdentityRoleClaimsCreateOrConnectWithoutAppIdentityRolesInput>
    createMany?: UserIdentityRoleClaimsCreateManyAppIdentityRolesInputEnvelope
    connect?: Enumerable<UserIdentityRoleClaimsWhereUniqueInput>
  }

  export type UserIdentityRolesCreateNestedManyWithoutAppIdentityRolesInput = {
    create?: XOR<Enumerable<UserIdentityRolesCreateWithoutAppIdentityRolesInput>, Enumerable<UserIdentityRolesUncheckedCreateWithoutAppIdentityRolesInput>>
    connectOrCreate?: Enumerable<UserIdentityRolesCreateOrConnectWithoutAppIdentityRolesInput>
    createMany?: UserIdentityRolesCreateManyAppIdentityRolesInputEnvelope
    connect?: Enumerable<UserIdentityRolesWhereUniqueInput>
  }

  export type UserIdentityRoleClaimsUncheckedCreateNestedManyWithoutAppIdentityRolesInput = {
    create?: XOR<Enumerable<UserIdentityRoleClaimsCreateWithoutAppIdentityRolesInput>, Enumerable<UserIdentityRoleClaimsUncheckedCreateWithoutAppIdentityRolesInput>>
    connectOrCreate?: Enumerable<UserIdentityRoleClaimsCreateOrConnectWithoutAppIdentityRolesInput>
    createMany?: UserIdentityRoleClaimsCreateManyAppIdentityRolesInputEnvelope
    connect?: Enumerable<UserIdentityRoleClaimsWhereUniqueInput>
  }

  export type UserIdentityRolesUncheckedCreateNestedManyWithoutAppIdentityRolesInput = {
    create?: XOR<Enumerable<UserIdentityRolesCreateWithoutAppIdentityRolesInput>, Enumerable<UserIdentityRolesUncheckedCreateWithoutAppIdentityRolesInput>>
    connectOrCreate?: Enumerable<UserIdentityRolesCreateOrConnectWithoutAppIdentityRolesInput>
    createMany?: UserIdentityRolesCreateManyAppIdentityRolesInputEnvelope
    connect?: Enumerable<UserIdentityRolesWhereUniqueInput>
  }

  export type UserIdentityRoleClaimsUpdateManyWithoutAppIdentityRolesInput = {
    create?: XOR<Enumerable<UserIdentityRoleClaimsCreateWithoutAppIdentityRolesInput>, Enumerable<UserIdentityRoleClaimsUncheckedCreateWithoutAppIdentityRolesInput>>
    connectOrCreate?: Enumerable<UserIdentityRoleClaimsCreateOrConnectWithoutAppIdentityRolesInput>
    upsert?: Enumerable<UserIdentityRoleClaimsUpsertWithWhereUniqueWithoutAppIdentityRolesInput>
    createMany?: UserIdentityRoleClaimsCreateManyAppIdentityRolesInputEnvelope
    set?: Enumerable<UserIdentityRoleClaimsWhereUniqueInput>
    disconnect?: Enumerable<UserIdentityRoleClaimsWhereUniqueInput>
    delete?: Enumerable<UserIdentityRoleClaimsWhereUniqueInput>
    connect?: Enumerable<UserIdentityRoleClaimsWhereUniqueInput>
    update?: Enumerable<UserIdentityRoleClaimsUpdateWithWhereUniqueWithoutAppIdentityRolesInput>
    updateMany?: Enumerable<UserIdentityRoleClaimsUpdateManyWithWhereWithoutAppIdentityRolesInput>
    deleteMany?: Enumerable<UserIdentityRoleClaimsScalarWhereInput>
  }

  export type UserIdentityRolesUpdateManyWithoutAppIdentityRolesInput = {
    create?: XOR<Enumerable<UserIdentityRolesCreateWithoutAppIdentityRolesInput>, Enumerable<UserIdentityRolesUncheckedCreateWithoutAppIdentityRolesInput>>
    connectOrCreate?: Enumerable<UserIdentityRolesCreateOrConnectWithoutAppIdentityRolesInput>
    upsert?: Enumerable<UserIdentityRolesUpsertWithWhereUniqueWithoutAppIdentityRolesInput>
    createMany?: UserIdentityRolesCreateManyAppIdentityRolesInputEnvelope
    set?: Enumerable<UserIdentityRolesWhereUniqueInput>
    disconnect?: Enumerable<UserIdentityRolesWhereUniqueInput>
    delete?: Enumerable<UserIdentityRolesWhereUniqueInput>
    connect?: Enumerable<UserIdentityRolesWhereUniqueInput>
    update?: Enumerable<UserIdentityRolesUpdateWithWhereUniqueWithoutAppIdentityRolesInput>
    updateMany?: Enumerable<UserIdentityRolesUpdateManyWithWhereWithoutAppIdentityRolesInput>
    deleteMany?: Enumerable<UserIdentityRolesScalarWhereInput>
  }

  export type UserIdentityRoleClaimsUncheckedUpdateManyWithoutAppIdentityRolesInput = {
    create?: XOR<Enumerable<UserIdentityRoleClaimsCreateWithoutAppIdentityRolesInput>, Enumerable<UserIdentityRoleClaimsUncheckedCreateWithoutAppIdentityRolesInput>>
    connectOrCreate?: Enumerable<UserIdentityRoleClaimsCreateOrConnectWithoutAppIdentityRolesInput>
    upsert?: Enumerable<UserIdentityRoleClaimsUpsertWithWhereUniqueWithoutAppIdentityRolesInput>
    createMany?: UserIdentityRoleClaimsCreateManyAppIdentityRolesInputEnvelope
    set?: Enumerable<UserIdentityRoleClaimsWhereUniqueInput>
    disconnect?: Enumerable<UserIdentityRoleClaimsWhereUniqueInput>
    delete?: Enumerable<UserIdentityRoleClaimsWhereUniqueInput>
    connect?: Enumerable<UserIdentityRoleClaimsWhereUniqueInput>
    update?: Enumerable<UserIdentityRoleClaimsUpdateWithWhereUniqueWithoutAppIdentityRolesInput>
    updateMany?: Enumerable<UserIdentityRoleClaimsUpdateManyWithWhereWithoutAppIdentityRolesInput>
    deleteMany?: Enumerable<UserIdentityRoleClaimsScalarWhereInput>
  }

  export type UserIdentityRolesUncheckedUpdateManyWithoutAppIdentityRolesInput = {
    create?: XOR<Enumerable<UserIdentityRolesCreateWithoutAppIdentityRolesInput>, Enumerable<UserIdentityRolesUncheckedCreateWithoutAppIdentityRolesInput>>
    connectOrCreate?: Enumerable<UserIdentityRolesCreateOrConnectWithoutAppIdentityRolesInput>
    upsert?: Enumerable<UserIdentityRolesUpsertWithWhereUniqueWithoutAppIdentityRolesInput>
    createMany?: UserIdentityRolesCreateManyAppIdentityRolesInputEnvelope
    set?: Enumerable<UserIdentityRolesWhereUniqueInput>
    disconnect?: Enumerable<UserIdentityRolesWhereUniqueInput>
    delete?: Enumerable<UserIdentityRolesWhereUniqueInput>
    connect?: Enumerable<UserIdentityRolesWhereUniqueInput>
    update?: Enumerable<UserIdentityRolesUpdateWithWhereUniqueWithoutAppIdentityRolesInput>
    updateMany?: Enumerable<UserIdentityRolesUpdateManyWithWhereWithoutAppIdentityRolesInput>
    deleteMany?: Enumerable<UserIdentityRolesScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type OIDCAuthorizationsCreateNestedManyWithoutOIDCApplicationsInput = {
    create?: XOR<Enumerable<OIDCAuthorizationsCreateWithoutOIDCApplicationsInput>, Enumerable<OIDCAuthorizationsUncheckedCreateWithoutOIDCApplicationsInput>>
    connectOrCreate?: Enumerable<OIDCAuthorizationsCreateOrConnectWithoutOIDCApplicationsInput>
    createMany?: OIDCAuthorizationsCreateManyOIDCApplicationsInputEnvelope
    connect?: Enumerable<OIDCAuthorizationsWhereUniqueInput>
  }

  export type OIDCTokensCreateNestedManyWithoutOIDCApplicationsInput = {
    create?: XOR<Enumerable<OIDCTokensCreateWithoutOIDCApplicationsInput>, Enumerable<OIDCTokensUncheckedCreateWithoutOIDCApplicationsInput>>
    connectOrCreate?: Enumerable<OIDCTokensCreateOrConnectWithoutOIDCApplicationsInput>
    createMany?: OIDCTokensCreateManyOIDCApplicationsInputEnvelope
    connect?: Enumerable<OIDCTokensWhereUniqueInput>
  }

  export type OIDCAuthorizationsUncheckedCreateNestedManyWithoutOIDCApplicationsInput = {
    create?: XOR<Enumerable<OIDCAuthorizationsCreateWithoutOIDCApplicationsInput>, Enumerable<OIDCAuthorizationsUncheckedCreateWithoutOIDCApplicationsInput>>
    connectOrCreate?: Enumerable<OIDCAuthorizationsCreateOrConnectWithoutOIDCApplicationsInput>
    createMany?: OIDCAuthorizationsCreateManyOIDCApplicationsInputEnvelope
    connect?: Enumerable<OIDCAuthorizationsWhereUniqueInput>
  }

  export type OIDCTokensUncheckedCreateNestedManyWithoutOIDCApplicationsInput = {
    create?: XOR<Enumerable<OIDCTokensCreateWithoutOIDCApplicationsInput>, Enumerable<OIDCTokensUncheckedCreateWithoutOIDCApplicationsInput>>
    connectOrCreate?: Enumerable<OIDCTokensCreateOrConnectWithoutOIDCApplicationsInput>
    createMany?: OIDCTokensCreateManyOIDCApplicationsInputEnvelope
    connect?: Enumerable<OIDCTokensWhereUniqueInput>
  }

  export type OIDCAuthorizationsUpdateManyWithoutOIDCApplicationsInput = {
    create?: XOR<Enumerable<OIDCAuthorizationsCreateWithoutOIDCApplicationsInput>, Enumerable<OIDCAuthorizationsUncheckedCreateWithoutOIDCApplicationsInput>>
    connectOrCreate?: Enumerable<OIDCAuthorizationsCreateOrConnectWithoutOIDCApplicationsInput>
    upsert?: Enumerable<OIDCAuthorizationsUpsertWithWhereUniqueWithoutOIDCApplicationsInput>
    createMany?: OIDCAuthorizationsCreateManyOIDCApplicationsInputEnvelope
    set?: Enumerable<OIDCAuthorizationsWhereUniqueInput>
    disconnect?: Enumerable<OIDCAuthorizationsWhereUniqueInput>
    delete?: Enumerable<OIDCAuthorizationsWhereUniqueInput>
    connect?: Enumerable<OIDCAuthorizationsWhereUniqueInput>
    update?: Enumerable<OIDCAuthorizationsUpdateWithWhereUniqueWithoutOIDCApplicationsInput>
    updateMany?: Enumerable<OIDCAuthorizationsUpdateManyWithWhereWithoutOIDCApplicationsInput>
    deleteMany?: Enumerable<OIDCAuthorizationsScalarWhereInput>
  }

  export type OIDCTokensUpdateManyWithoutOIDCApplicationsInput = {
    create?: XOR<Enumerable<OIDCTokensCreateWithoutOIDCApplicationsInput>, Enumerable<OIDCTokensUncheckedCreateWithoutOIDCApplicationsInput>>
    connectOrCreate?: Enumerable<OIDCTokensCreateOrConnectWithoutOIDCApplicationsInput>
    upsert?: Enumerable<OIDCTokensUpsertWithWhereUniqueWithoutOIDCApplicationsInput>
    createMany?: OIDCTokensCreateManyOIDCApplicationsInputEnvelope
    set?: Enumerable<OIDCTokensWhereUniqueInput>
    disconnect?: Enumerable<OIDCTokensWhereUniqueInput>
    delete?: Enumerable<OIDCTokensWhereUniqueInput>
    connect?: Enumerable<OIDCTokensWhereUniqueInput>
    update?: Enumerable<OIDCTokensUpdateWithWhereUniqueWithoutOIDCApplicationsInput>
    updateMany?: Enumerable<OIDCTokensUpdateManyWithWhereWithoutOIDCApplicationsInput>
    deleteMany?: Enumerable<OIDCTokensScalarWhereInput>
  }

  export type OIDCAuthorizationsUncheckedUpdateManyWithoutOIDCApplicationsInput = {
    create?: XOR<Enumerable<OIDCAuthorizationsCreateWithoutOIDCApplicationsInput>, Enumerable<OIDCAuthorizationsUncheckedCreateWithoutOIDCApplicationsInput>>
    connectOrCreate?: Enumerable<OIDCAuthorizationsCreateOrConnectWithoutOIDCApplicationsInput>
    upsert?: Enumerable<OIDCAuthorizationsUpsertWithWhereUniqueWithoutOIDCApplicationsInput>
    createMany?: OIDCAuthorizationsCreateManyOIDCApplicationsInputEnvelope
    set?: Enumerable<OIDCAuthorizationsWhereUniqueInput>
    disconnect?: Enumerable<OIDCAuthorizationsWhereUniqueInput>
    delete?: Enumerable<OIDCAuthorizationsWhereUniqueInput>
    connect?: Enumerable<OIDCAuthorizationsWhereUniqueInput>
    update?: Enumerable<OIDCAuthorizationsUpdateWithWhereUniqueWithoutOIDCApplicationsInput>
    updateMany?: Enumerable<OIDCAuthorizationsUpdateManyWithWhereWithoutOIDCApplicationsInput>
    deleteMany?: Enumerable<OIDCAuthorizationsScalarWhereInput>
  }

  export type OIDCTokensUncheckedUpdateManyWithoutOIDCApplicationsInput = {
    create?: XOR<Enumerable<OIDCTokensCreateWithoutOIDCApplicationsInput>, Enumerable<OIDCTokensUncheckedCreateWithoutOIDCApplicationsInput>>
    connectOrCreate?: Enumerable<OIDCTokensCreateOrConnectWithoutOIDCApplicationsInput>
    upsert?: Enumerable<OIDCTokensUpsertWithWhereUniqueWithoutOIDCApplicationsInput>
    createMany?: OIDCTokensCreateManyOIDCApplicationsInputEnvelope
    set?: Enumerable<OIDCTokensWhereUniqueInput>
    disconnect?: Enumerable<OIDCTokensWhereUniqueInput>
    delete?: Enumerable<OIDCTokensWhereUniqueInput>
    connect?: Enumerable<OIDCTokensWhereUniqueInput>
    update?: Enumerable<OIDCTokensUpdateWithWhereUniqueWithoutOIDCApplicationsInput>
    updateMany?: Enumerable<OIDCTokensUpdateManyWithWhereWithoutOIDCApplicationsInput>
    deleteMany?: Enumerable<OIDCTokensScalarWhereInput>
  }

  export type OIDCApplicationsCreateNestedOneWithoutOIDCAuthorizationsInput = {
    create?: XOR<OIDCApplicationsCreateWithoutOIDCAuthorizationsInput, OIDCApplicationsUncheckedCreateWithoutOIDCAuthorizationsInput>
    connectOrCreate?: OIDCApplicationsCreateOrConnectWithoutOIDCAuthorizationsInput
    connect?: OIDCApplicationsWhereUniqueInput
  }

  export type OIDCTokensCreateNestedManyWithoutOIDCAuthorizationsInput = {
    create?: XOR<Enumerable<OIDCTokensCreateWithoutOIDCAuthorizationsInput>, Enumerable<OIDCTokensUncheckedCreateWithoutOIDCAuthorizationsInput>>
    connectOrCreate?: Enumerable<OIDCTokensCreateOrConnectWithoutOIDCAuthorizationsInput>
    createMany?: OIDCTokensCreateManyOIDCAuthorizationsInputEnvelope
    connect?: Enumerable<OIDCTokensWhereUniqueInput>
  }

  export type OIDCTokensUncheckedCreateNestedManyWithoutOIDCAuthorizationsInput = {
    create?: XOR<Enumerable<OIDCTokensCreateWithoutOIDCAuthorizationsInput>, Enumerable<OIDCTokensUncheckedCreateWithoutOIDCAuthorizationsInput>>
    connectOrCreate?: Enumerable<OIDCTokensCreateOrConnectWithoutOIDCAuthorizationsInput>
    createMany?: OIDCTokensCreateManyOIDCAuthorizationsInputEnvelope
    connect?: Enumerable<OIDCTokensWhereUniqueInput>
  }

  export type OIDCApplicationsUpdateOneWithoutOIDCAuthorizationsInput = {
    create?: XOR<OIDCApplicationsCreateWithoutOIDCAuthorizationsInput, OIDCApplicationsUncheckedCreateWithoutOIDCAuthorizationsInput>
    connectOrCreate?: OIDCApplicationsCreateOrConnectWithoutOIDCAuthorizationsInput
    upsert?: OIDCApplicationsUpsertWithoutOIDCAuthorizationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: OIDCApplicationsWhereUniqueInput
    update?: XOR<OIDCApplicationsUpdateWithoutOIDCAuthorizationsInput, OIDCApplicationsUncheckedUpdateWithoutOIDCAuthorizationsInput>
  }

  export type OIDCTokensUpdateManyWithoutOIDCAuthorizationsInput = {
    create?: XOR<Enumerable<OIDCTokensCreateWithoutOIDCAuthorizationsInput>, Enumerable<OIDCTokensUncheckedCreateWithoutOIDCAuthorizationsInput>>
    connectOrCreate?: Enumerable<OIDCTokensCreateOrConnectWithoutOIDCAuthorizationsInput>
    upsert?: Enumerable<OIDCTokensUpsertWithWhereUniqueWithoutOIDCAuthorizationsInput>
    createMany?: OIDCTokensCreateManyOIDCAuthorizationsInputEnvelope
    set?: Enumerable<OIDCTokensWhereUniqueInput>
    disconnect?: Enumerable<OIDCTokensWhereUniqueInput>
    delete?: Enumerable<OIDCTokensWhereUniqueInput>
    connect?: Enumerable<OIDCTokensWhereUniqueInput>
    update?: Enumerable<OIDCTokensUpdateWithWhereUniqueWithoutOIDCAuthorizationsInput>
    updateMany?: Enumerable<OIDCTokensUpdateManyWithWhereWithoutOIDCAuthorizationsInput>
    deleteMany?: Enumerable<OIDCTokensScalarWhereInput>
  }

  export type OIDCTokensUncheckedUpdateManyWithoutOIDCAuthorizationsInput = {
    create?: XOR<Enumerable<OIDCTokensCreateWithoutOIDCAuthorizationsInput>, Enumerable<OIDCTokensUncheckedCreateWithoutOIDCAuthorizationsInput>>
    connectOrCreate?: Enumerable<OIDCTokensCreateOrConnectWithoutOIDCAuthorizationsInput>
    upsert?: Enumerable<OIDCTokensUpsertWithWhereUniqueWithoutOIDCAuthorizationsInput>
    createMany?: OIDCTokensCreateManyOIDCAuthorizationsInputEnvelope
    set?: Enumerable<OIDCTokensWhereUniqueInput>
    disconnect?: Enumerable<OIDCTokensWhereUniqueInput>
    delete?: Enumerable<OIDCTokensWhereUniqueInput>
    connect?: Enumerable<OIDCTokensWhereUniqueInput>
    update?: Enumerable<OIDCTokensUpdateWithWhereUniqueWithoutOIDCAuthorizationsInput>
    updateMany?: Enumerable<OIDCTokensUpdateManyWithWhereWithoutOIDCAuthorizationsInput>
    deleteMany?: Enumerable<OIDCTokensScalarWhereInput>
  }

  export type OIDCApplicationsCreateNestedOneWithoutOIDCTokensInput = {
    create?: XOR<OIDCApplicationsCreateWithoutOIDCTokensInput, OIDCApplicationsUncheckedCreateWithoutOIDCTokensInput>
    connectOrCreate?: OIDCApplicationsCreateOrConnectWithoutOIDCTokensInput
    connect?: OIDCApplicationsWhereUniqueInput
  }

  export type OIDCAuthorizationsCreateNestedOneWithoutOIDCTokensInput = {
    create?: XOR<OIDCAuthorizationsCreateWithoutOIDCTokensInput, OIDCAuthorizationsUncheckedCreateWithoutOIDCTokensInput>
    connectOrCreate?: OIDCAuthorizationsCreateOrConnectWithoutOIDCTokensInput
    connect?: OIDCAuthorizationsWhereUniqueInput
  }

  export type OIDCApplicationsUpdateOneWithoutOIDCTokensInput = {
    create?: XOR<OIDCApplicationsCreateWithoutOIDCTokensInput, OIDCApplicationsUncheckedCreateWithoutOIDCTokensInput>
    connectOrCreate?: OIDCApplicationsCreateOrConnectWithoutOIDCTokensInput
    upsert?: OIDCApplicationsUpsertWithoutOIDCTokensInput
    disconnect?: boolean
    delete?: boolean
    connect?: OIDCApplicationsWhereUniqueInput
    update?: XOR<OIDCApplicationsUpdateWithoutOIDCTokensInput, OIDCApplicationsUncheckedUpdateWithoutOIDCTokensInput>
  }

  export type OIDCAuthorizationsUpdateOneWithoutOIDCTokensInput = {
    create?: XOR<OIDCAuthorizationsCreateWithoutOIDCTokensInput, OIDCAuthorizationsUncheckedCreateWithoutOIDCTokensInput>
    connectOrCreate?: OIDCAuthorizationsCreateOrConnectWithoutOIDCTokensInput
    upsert?: OIDCAuthorizationsUpsertWithoutOIDCTokensInput
    disconnect?: boolean
    delete?: boolean
    connect?: OIDCAuthorizationsWhereUniqueInput
    update?: XOR<OIDCAuthorizationsUpdateWithoutOIDCTokensInput, OIDCAuthorizationsUncheckedUpdateWithoutOIDCTokensInput>
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UsersCreateNestedOneWithoutUserIdentityClaimsInput = {
    create?: XOR<UsersCreateWithoutUserIdentityClaimsInput, UsersUncheckedCreateWithoutUserIdentityClaimsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserIdentityClaimsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutUserIdentityClaimsInput = {
    create?: XOR<UsersCreateWithoutUserIdentityClaimsInput, UsersUncheckedCreateWithoutUserIdentityClaimsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserIdentityClaimsInput
    upsert?: UsersUpsertWithoutUserIdentityClaimsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<UsersUpdateWithoutUserIdentityClaimsInput, UsersUncheckedUpdateWithoutUserIdentityClaimsInput>
  }

  export type UsersCreateNestedOneWithoutUserIdentityLoginsInput = {
    create?: XOR<UsersCreateWithoutUserIdentityLoginsInput, UsersUncheckedCreateWithoutUserIdentityLoginsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserIdentityLoginsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutUserIdentityLoginsInput = {
    create?: XOR<UsersCreateWithoutUserIdentityLoginsInput, UsersUncheckedCreateWithoutUserIdentityLoginsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserIdentityLoginsInput
    upsert?: UsersUpsertWithoutUserIdentityLoginsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<UsersUpdateWithoutUserIdentityLoginsInput, UsersUncheckedUpdateWithoutUserIdentityLoginsInput>
  }

  export type AppIdentityRolesCreateNestedOneWithoutUserIdentityRoleClaimsInput = {
    create?: XOR<AppIdentityRolesCreateWithoutUserIdentityRoleClaimsInput, AppIdentityRolesUncheckedCreateWithoutUserIdentityRoleClaimsInput>
    connectOrCreate?: AppIdentityRolesCreateOrConnectWithoutUserIdentityRoleClaimsInput
    connect?: AppIdentityRolesWhereUniqueInput
  }

  export type AppIdentityRolesUpdateOneRequiredWithoutUserIdentityRoleClaimsInput = {
    create?: XOR<AppIdentityRolesCreateWithoutUserIdentityRoleClaimsInput, AppIdentityRolesUncheckedCreateWithoutUserIdentityRoleClaimsInput>
    connectOrCreate?: AppIdentityRolesCreateOrConnectWithoutUserIdentityRoleClaimsInput
    upsert?: AppIdentityRolesUpsertWithoutUserIdentityRoleClaimsInput
    connect?: AppIdentityRolesWhereUniqueInput
    update?: XOR<AppIdentityRolesUpdateWithoutUserIdentityRoleClaimsInput, AppIdentityRolesUncheckedUpdateWithoutUserIdentityRoleClaimsInput>
  }

  export type AppIdentityRolesCreateNestedOneWithoutUserIdentityRolesInput = {
    create?: XOR<AppIdentityRolesCreateWithoutUserIdentityRolesInput, AppIdentityRolesUncheckedCreateWithoutUserIdentityRolesInput>
    connectOrCreate?: AppIdentityRolesCreateOrConnectWithoutUserIdentityRolesInput
    connect?: AppIdentityRolesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutUserIdentityRolesInput = {
    create?: XOR<UsersCreateWithoutUserIdentityRolesInput, UsersUncheckedCreateWithoutUserIdentityRolesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserIdentityRolesInput
    connect?: UsersWhereUniqueInput
  }

  export type AppIdentityRolesUpdateOneRequiredWithoutUserIdentityRolesInput = {
    create?: XOR<AppIdentityRolesCreateWithoutUserIdentityRolesInput, AppIdentityRolesUncheckedCreateWithoutUserIdentityRolesInput>
    connectOrCreate?: AppIdentityRolesCreateOrConnectWithoutUserIdentityRolesInput
    upsert?: AppIdentityRolesUpsertWithoutUserIdentityRolesInput
    connect?: AppIdentityRolesWhereUniqueInput
    update?: XOR<AppIdentityRolesUpdateWithoutUserIdentityRolesInput, AppIdentityRolesUncheckedUpdateWithoutUserIdentityRolesInput>
  }

  export type UsersUpdateOneRequiredWithoutUserIdentityRolesInput = {
    create?: XOR<UsersCreateWithoutUserIdentityRolesInput, UsersUncheckedCreateWithoutUserIdentityRolesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserIdentityRolesInput
    upsert?: UsersUpsertWithoutUserIdentityRolesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<UsersUpdateWithoutUserIdentityRolesInput, UsersUncheckedUpdateWithoutUserIdentityRolesInput>
  }

  export type UsersCreateNestedOneWithoutUserIdentityTokensInput = {
    create?: XOR<UsersCreateWithoutUserIdentityTokensInput, UsersUncheckedCreateWithoutUserIdentityTokensInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserIdentityTokensInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutUserIdentityTokensInput = {
    create?: XOR<UsersCreateWithoutUserIdentityTokensInput, UsersUncheckedCreateWithoutUserIdentityTokensInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserIdentityTokensInput
    upsert?: UsersUpsertWithoutUserIdentityTokensInput
    connect?: UsersWhereUniqueInput
    update?: XOR<UsersUpdateWithoutUserIdentityTokensInput, UsersUncheckedUpdateWithoutUserIdentityTokensInput>
  }

  export type UserIdentityClaimsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityClaimsCreateWithoutUsersInput>, Enumerable<UserIdentityClaimsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityClaimsCreateOrConnectWithoutUsersInput>
    createMany?: UserIdentityClaimsCreateManyUsersInputEnvelope
    connect?: Enumerable<UserIdentityClaimsWhereUniqueInput>
  }

  export type UserIdentityLoginsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityLoginsCreateWithoutUsersInput>, Enumerable<UserIdentityLoginsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityLoginsCreateOrConnectWithoutUsersInput>
    createMany?: UserIdentityLoginsCreateManyUsersInputEnvelope
    connect?: Enumerable<UserIdentityLoginsWhereUniqueInput>
  }

  export type UserIdentityRolesCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityRolesCreateWithoutUsersInput>, Enumerable<UserIdentityRolesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityRolesCreateOrConnectWithoutUsersInput>
    createMany?: UserIdentityRolesCreateManyUsersInputEnvelope
    connect?: Enumerable<UserIdentityRolesWhereUniqueInput>
  }

  export type UserIdentityTokensCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityTokensCreateWithoutUsersInput>, Enumerable<UserIdentityTokensUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityTokensCreateOrConnectWithoutUsersInput>
    createMany?: UserIdentityTokensCreateManyUsersInputEnvelope
    connect?: Enumerable<UserIdentityTokensWhereUniqueInput>
  }

  export type UserIdentityClaimsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityClaimsCreateWithoutUsersInput>, Enumerable<UserIdentityClaimsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityClaimsCreateOrConnectWithoutUsersInput>
    createMany?: UserIdentityClaimsCreateManyUsersInputEnvelope
    connect?: Enumerable<UserIdentityClaimsWhereUniqueInput>
  }

  export type UserIdentityLoginsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityLoginsCreateWithoutUsersInput>, Enumerable<UserIdentityLoginsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityLoginsCreateOrConnectWithoutUsersInput>
    createMany?: UserIdentityLoginsCreateManyUsersInputEnvelope
    connect?: Enumerable<UserIdentityLoginsWhereUniqueInput>
  }

  export type UserIdentityRolesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityRolesCreateWithoutUsersInput>, Enumerable<UserIdentityRolesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityRolesCreateOrConnectWithoutUsersInput>
    createMany?: UserIdentityRolesCreateManyUsersInputEnvelope
    connect?: Enumerable<UserIdentityRolesWhereUniqueInput>
  }

  export type UserIdentityTokensUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityTokensCreateWithoutUsersInput>, Enumerable<UserIdentityTokensUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityTokensCreateOrConnectWithoutUsersInput>
    createMany?: UserIdentityTokensCreateManyUsersInputEnvelope
    connect?: Enumerable<UserIdentityTokensWhereUniqueInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserIdentityClaimsUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityClaimsCreateWithoutUsersInput>, Enumerable<UserIdentityClaimsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityClaimsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<UserIdentityClaimsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: UserIdentityClaimsCreateManyUsersInputEnvelope
    set?: Enumerable<UserIdentityClaimsWhereUniqueInput>
    disconnect?: Enumerable<UserIdentityClaimsWhereUniqueInput>
    delete?: Enumerable<UserIdentityClaimsWhereUniqueInput>
    connect?: Enumerable<UserIdentityClaimsWhereUniqueInput>
    update?: Enumerable<UserIdentityClaimsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<UserIdentityClaimsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<UserIdentityClaimsScalarWhereInput>
  }

  export type UserIdentityLoginsUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityLoginsCreateWithoutUsersInput>, Enumerable<UserIdentityLoginsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityLoginsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<UserIdentityLoginsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: UserIdentityLoginsCreateManyUsersInputEnvelope
    set?: Enumerable<UserIdentityLoginsWhereUniqueInput>
    disconnect?: Enumerable<UserIdentityLoginsWhereUniqueInput>
    delete?: Enumerable<UserIdentityLoginsWhereUniqueInput>
    connect?: Enumerable<UserIdentityLoginsWhereUniqueInput>
    update?: Enumerable<UserIdentityLoginsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<UserIdentityLoginsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<UserIdentityLoginsScalarWhereInput>
  }

  export type UserIdentityRolesUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityRolesCreateWithoutUsersInput>, Enumerable<UserIdentityRolesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityRolesCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<UserIdentityRolesUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: UserIdentityRolesCreateManyUsersInputEnvelope
    set?: Enumerable<UserIdentityRolesWhereUniqueInput>
    disconnect?: Enumerable<UserIdentityRolesWhereUniqueInput>
    delete?: Enumerable<UserIdentityRolesWhereUniqueInput>
    connect?: Enumerable<UserIdentityRolesWhereUniqueInput>
    update?: Enumerable<UserIdentityRolesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<UserIdentityRolesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<UserIdentityRolesScalarWhereInput>
  }

  export type UserIdentityTokensUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityTokensCreateWithoutUsersInput>, Enumerable<UserIdentityTokensUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityTokensCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<UserIdentityTokensUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: UserIdentityTokensCreateManyUsersInputEnvelope
    set?: Enumerable<UserIdentityTokensWhereUniqueInput>
    disconnect?: Enumerable<UserIdentityTokensWhereUniqueInput>
    delete?: Enumerable<UserIdentityTokensWhereUniqueInput>
    connect?: Enumerable<UserIdentityTokensWhereUniqueInput>
    update?: Enumerable<UserIdentityTokensUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<UserIdentityTokensUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<UserIdentityTokensScalarWhereInput>
  }

  export type UserIdentityClaimsUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityClaimsCreateWithoutUsersInput>, Enumerable<UserIdentityClaimsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityClaimsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<UserIdentityClaimsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: UserIdentityClaimsCreateManyUsersInputEnvelope
    set?: Enumerable<UserIdentityClaimsWhereUniqueInput>
    disconnect?: Enumerable<UserIdentityClaimsWhereUniqueInput>
    delete?: Enumerable<UserIdentityClaimsWhereUniqueInput>
    connect?: Enumerable<UserIdentityClaimsWhereUniqueInput>
    update?: Enumerable<UserIdentityClaimsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<UserIdentityClaimsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<UserIdentityClaimsScalarWhereInput>
  }

  export type UserIdentityLoginsUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityLoginsCreateWithoutUsersInput>, Enumerable<UserIdentityLoginsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityLoginsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<UserIdentityLoginsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: UserIdentityLoginsCreateManyUsersInputEnvelope
    set?: Enumerable<UserIdentityLoginsWhereUniqueInput>
    disconnect?: Enumerable<UserIdentityLoginsWhereUniqueInput>
    delete?: Enumerable<UserIdentityLoginsWhereUniqueInput>
    connect?: Enumerable<UserIdentityLoginsWhereUniqueInput>
    update?: Enumerable<UserIdentityLoginsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<UserIdentityLoginsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<UserIdentityLoginsScalarWhereInput>
  }

  export type UserIdentityRolesUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityRolesCreateWithoutUsersInput>, Enumerable<UserIdentityRolesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityRolesCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<UserIdentityRolesUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: UserIdentityRolesCreateManyUsersInputEnvelope
    set?: Enumerable<UserIdentityRolesWhereUniqueInput>
    disconnect?: Enumerable<UserIdentityRolesWhereUniqueInput>
    delete?: Enumerable<UserIdentityRolesWhereUniqueInput>
    connect?: Enumerable<UserIdentityRolesWhereUniqueInput>
    update?: Enumerable<UserIdentityRolesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<UserIdentityRolesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<UserIdentityRolesScalarWhereInput>
  }

  export type UserIdentityTokensUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserIdentityTokensCreateWithoutUsersInput>, Enumerable<UserIdentityTokensUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserIdentityTokensCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<UserIdentityTokensUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: UserIdentityTokensCreateManyUsersInputEnvelope
    set?: Enumerable<UserIdentityTokensWhereUniqueInput>
    disconnect?: Enumerable<UserIdentityTokensWhereUniqueInput>
    delete?: Enumerable<UserIdentityTokensWhereUniqueInput>
    connect?: Enumerable<UserIdentityTokensWhereUniqueInput>
    update?: Enumerable<UserIdentityTokensUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<UserIdentityTokensUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<UserIdentityTokensScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type NestedBytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type UserIdentityRoleClaimsCreateWithoutAppIdentityRolesInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type UserIdentityRoleClaimsUncheckedCreateWithoutAppIdentityRolesInput = {
    Id?: number
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type UserIdentityRoleClaimsCreateOrConnectWithoutAppIdentityRolesInput = {
    where: UserIdentityRoleClaimsWhereUniqueInput
    create: XOR<UserIdentityRoleClaimsCreateWithoutAppIdentityRolesInput, UserIdentityRoleClaimsUncheckedCreateWithoutAppIdentityRolesInput>
  }

  export type UserIdentityRoleClaimsCreateManyAppIdentityRolesInputEnvelope = {
    data: Enumerable<UserIdentityRoleClaimsCreateManyAppIdentityRolesInput>
  }

  export type UserIdentityRolesCreateWithoutAppIdentityRolesInput = {
    Users: UsersCreateNestedOneWithoutUserIdentityRolesInput
  }

  export type UserIdentityRolesUncheckedCreateWithoutAppIdentityRolesInput = {
    UserId: string
  }

  export type UserIdentityRolesCreateOrConnectWithoutAppIdentityRolesInput = {
    where: UserIdentityRolesWhereUniqueInput
    create: XOR<UserIdentityRolesCreateWithoutAppIdentityRolesInput, UserIdentityRolesUncheckedCreateWithoutAppIdentityRolesInput>
  }

  export type UserIdentityRolesCreateManyAppIdentityRolesInputEnvelope = {
    data: Enumerable<UserIdentityRolesCreateManyAppIdentityRolesInput>
  }

  export type UserIdentityRoleClaimsUpsertWithWhereUniqueWithoutAppIdentityRolesInput = {
    where: UserIdentityRoleClaimsWhereUniqueInput
    update: XOR<UserIdentityRoleClaimsUpdateWithoutAppIdentityRolesInput, UserIdentityRoleClaimsUncheckedUpdateWithoutAppIdentityRolesInput>
    create: XOR<UserIdentityRoleClaimsCreateWithoutAppIdentityRolesInput, UserIdentityRoleClaimsUncheckedCreateWithoutAppIdentityRolesInput>
  }

  export type UserIdentityRoleClaimsUpdateWithWhereUniqueWithoutAppIdentityRolesInput = {
    where: UserIdentityRoleClaimsWhereUniqueInput
    data: XOR<UserIdentityRoleClaimsUpdateWithoutAppIdentityRolesInput, UserIdentityRoleClaimsUncheckedUpdateWithoutAppIdentityRolesInput>
  }

  export type UserIdentityRoleClaimsUpdateManyWithWhereWithoutAppIdentityRolesInput = {
    where: UserIdentityRoleClaimsScalarWhereInput
    data: XOR<UserIdentityRoleClaimsUpdateManyMutationInput, UserIdentityRoleClaimsUncheckedUpdateManyWithoutUserIdentityRoleClaimsInput>
  }

  export type UserIdentityRoleClaimsScalarWhereInput = {
    AND?: Enumerable<UserIdentityRoleClaimsScalarWhereInput>
    OR?: Enumerable<UserIdentityRoleClaimsScalarWhereInput>
    NOT?: Enumerable<UserIdentityRoleClaimsScalarWhereInput>
    Id?: IntFilter | number
    RoleId?: StringFilter | string
    ClaimType?: StringNullableFilter | string | null
    ClaimValue?: StringNullableFilter | string | null
  }

  export type UserIdentityRolesUpsertWithWhereUniqueWithoutAppIdentityRolesInput = {
    where: UserIdentityRolesWhereUniqueInput
    update: XOR<UserIdentityRolesUpdateWithoutAppIdentityRolesInput, UserIdentityRolesUncheckedUpdateWithoutAppIdentityRolesInput>
    create: XOR<UserIdentityRolesCreateWithoutAppIdentityRolesInput, UserIdentityRolesUncheckedCreateWithoutAppIdentityRolesInput>
  }

  export type UserIdentityRolesUpdateWithWhereUniqueWithoutAppIdentityRolesInput = {
    where: UserIdentityRolesWhereUniqueInput
    data: XOR<UserIdentityRolesUpdateWithoutAppIdentityRolesInput, UserIdentityRolesUncheckedUpdateWithoutAppIdentityRolesInput>
  }

  export type UserIdentityRolesUpdateManyWithWhereWithoutAppIdentityRolesInput = {
    where: UserIdentityRolesScalarWhereInput
    data: XOR<UserIdentityRolesUpdateManyMutationInput, UserIdentityRolesUncheckedUpdateManyWithoutUserIdentityRolesInput>
  }

  export type UserIdentityRolesScalarWhereInput = {
    AND?: Enumerable<UserIdentityRolesScalarWhereInput>
    OR?: Enumerable<UserIdentityRolesScalarWhereInput>
    NOT?: Enumerable<UserIdentityRolesScalarWhereInput>
    UserId?: StringFilter | string
    RoleId?: StringFilter | string
  }

  export type OIDCAuthorizationsCreateWithoutOIDCApplicationsInput = {
    Id: string
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    Properties?: string | null
    Scopes?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
    OIDCTokens?: OIDCTokensCreateNestedManyWithoutOIDCAuthorizationsInput
  }

  export type OIDCAuthorizationsUncheckedCreateWithoutOIDCApplicationsInput = {
    Id: string
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    Properties?: string | null
    Scopes?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
    OIDCTokens?: OIDCTokensUncheckedCreateNestedManyWithoutOIDCAuthorizationsInput
  }

  export type OIDCAuthorizationsCreateOrConnectWithoutOIDCApplicationsInput = {
    where: OIDCAuthorizationsWhereUniqueInput
    create: XOR<OIDCAuthorizationsCreateWithoutOIDCApplicationsInput, OIDCAuthorizationsUncheckedCreateWithoutOIDCApplicationsInput>
  }

  export type OIDCAuthorizationsCreateManyOIDCApplicationsInputEnvelope = {
    data: Enumerable<OIDCAuthorizationsCreateManyOIDCApplicationsInput>
  }

  export type OIDCTokensCreateWithoutOIDCApplicationsInput = {
    Id: string
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    ExpirationDate?: Date | string | null
    Payload?: string | null
    Properties?: string | null
    RedemptionDate?: Date | string | null
    ReferenceId?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
    OIDCAuthorizations?: OIDCAuthorizationsCreateNestedOneWithoutOIDCTokensInput
  }

  export type OIDCTokensUncheckedCreateWithoutOIDCApplicationsInput = {
    Id: string
    AuthorizationId?: string | null
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    ExpirationDate?: Date | string | null
    Payload?: string | null
    Properties?: string | null
    RedemptionDate?: Date | string | null
    ReferenceId?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
  }

  export type OIDCTokensCreateOrConnectWithoutOIDCApplicationsInput = {
    where: OIDCTokensWhereUniqueInput
    create: XOR<OIDCTokensCreateWithoutOIDCApplicationsInput, OIDCTokensUncheckedCreateWithoutOIDCApplicationsInput>
  }

  export type OIDCTokensCreateManyOIDCApplicationsInputEnvelope = {
    data: Enumerable<OIDCTokensCreateManyOIDCApplicationsInput>
  }

  export type OIDCAuthorizationsUpsertWithWhereUniqueWithoutOIDCApplicationsInput = {
    where: OIDCAuthorizationsWhereUniqueInput
    update: XOR<OIDCAuthorizationsUpdateWithoutOIDCApplicationsInput, OIDCAuthorizationsUncheckedUpdateWithoutOIDCApplicationsInput>
    create: XOR<OIDCAuthorizationsCreateWithoutOIDCApplicationsInput, OIDCAuthorizationsUncheckedCreateWithoutOIDCApplicationsInput>
  }

  export type OIDCAuthorizationsUpdateWithWhereUniqueWithoutOIDCApplicationsInput = {
    where: OIDCAuthorizationsWhereUniqueInput
    data: XOR<OIDCAuthorizationsUpdateWithoutOIDCApplicationsInput, OIDCAuthorizationsUncheckedUpdateWithoutOIDCApplicationsInput>
  }

  export type OIDCAuthorizationsUpdateManyWithWhereWithoutOIDCApplicationsInput = {
    where: OIDCAuthorizationsScalarWhereInput
    data: XOR<OIDCAuthorizationsUpdateManyMutationInput, OIDCAuthorizationsUncheckedUpdateManyWithoutOIDCAuthorizationsInput>
  }

  export type OIDCAuthorizationsScalarWhereInput = {
    AND?: Enumerable<OIDCAuthorizationsScalarWhereInput>
    OR?: Enumerable<OIDCAuthorizationsScalarWhereInput>
    NOT?: Enumerable<OIDCAuthorizationsScalarWhereInput>
    Id?: StringFilter | string
    ApplicationId?: StringNullableFilter | string | null
    ConcurrencyToken?: StringNullableFilter | string | null
    CreationDate?: DateTimeNullableFilter | Date | string | null
    Properties?: StringNullableFilter | string | null
    Scopes?: StringNullableFilter | string | null
    Status?: StringNullableFilter | string | null
    Subject?: StringNullableFilter | string | null
    Type?: StringNullableFilter | string | null
  }

  export type OIDCTokensUpsertWithWhereUniqueWithoutOIDCApplicationsInput = {
    where: OIDCTokensWhereUniqueInput
    update: XOR<OIDCTokensUpdateWithoutOIDCApplicationsInput, OIDCTokensUncheckedUpdateWithoutOIDCApplicationsInput>
    create: XOR<OIDCTokensCreateWithoutOIDCApplicationsInput, OIDCTokensUncheckedCreateWithoutOIDCApplicationsInput>
  }

  export type OIDCTokensUpdateWithWhereUniqueWithoutOIDCApplicationsInput = {
    where: OIDCTokensWhereUniqueInput
    data: XOR<OIDCTokensUpdateWithoutOIDCApplicationsInput, OIDCTokensUncheckedUpdateWithoutOIDCApplicationsInput>
  }

  export type OIDCTokensUpdateManyWithWhereWithoutOIDCApplicationsInput = {
    where: OIDCTokensScalarWhereInput
    data: XOR<OIDCTokensUpdateManyMutationInput, OIDCTokensUncheckedUpdateManyWithoutOIDCTokensInput>
  }

  export type OIDCTokensScalarWhereInput = {
    AND?: Enumerable<OIDCTokensScalarWhereInput>
    OR?: Enumerable<OIDCTokensScalarWhereInput>
    NOT?: Enumerable<OIDCTokensScalarWhereInput>
    Id?: StringFilter | string
    ApplicationId?: StringNullableFilter | string | null
    AuthorizationId?: StringNullableFilter | string | null
    ConcurrencyToken?: StringNullableFilter | string | null
    CreationDate?: DateTimeNullableFilter | Date | string | null
    ExpirationDate?: DateTimeNullableFilter | Date | string | null
    Payload?: StringNullableFilter | string | null
    Properties?: StringNullableFilter | string | null
    RedemptionDate?: DateTimeNullableFilter | Date | string | null
    ReferenceId?: StringNullableFilter | string | null
    Status?: StringNullableFilter | string | null
    Subject?: StringNullableFilter | string | null
    Type?: StringNullableFilter | string | null
  }

  export type OIDCApplicationsCreateWithoutOIDCAuthorizationsInput = {
    Id: string
    ClientId?: string | null
    ClientSecret?: string | null
    ConcurrencyToken?: string | null
    ConsentType?: string | null
    DisplayName?: string | null
    DisplayNames?: string | null
    Permissions?: string | null
    PostLogoutRedirectUris?: string | null
    Properties?: string | null
    RedirectUris?: string | null
    Requirements?: string | null
    Type?: string | null
    OIDCTokens?: OIDCTokensCreateNestedManyWithoutOIDCApplicationsInput
  }

  export type OIDCApplicationsUncheckedCreateWithoutOIDCAuthorizationsInput = {
    Id: string
    ClientId?: string | null
    ClientSecret?: string | null
    ConcurrencyToken?: string | null
    ConsentType?: string | null
    DisplayName?: string | null
    DisplayNames?: string | null
    Permissions?: string | null
    PostLogoutRedirectUris?: string | null
    Properties?: string | null
    RedirectUris?: string | null
    Requirements?: string | null
    Type?: string | null
    OIDCTokens?: OIDCTokensUncheckedCreateNestedManyWithoutOIDCApplicationsInput
  }

  export type OIDCApplicationsCreateOrConnectWithoutOIDCAuthorizationsInput = {
    where: OIDCApplicationsWhereUniqueInput
    create: XOR<OIDCApplicationsCreateWithoutOIDCAuthorizationsInput, OIDCApplicationsUncheckedCreateWithoutOIDCAuthorizationsInput>
  }

  export type OIDCTokensCreateWithoutOIDCAuthorizationsInput = {
    Id: string
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    ExpirationDate?: Date | string | null
    Payload?: string | null
    Properties?: string | null
    RedemptionDate?: Date | string | null
    ReferenceId?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
    OIDCApplications?: OIDCApplicationsCreateNestedOneWithoutOIDCTokensInput
  }

  export type OIDCTokensUncheckedCreateWithoutOIDCAuthorizationsInput = {
    Id: string
    ApplicationId?: string | null
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    ExpirationDate?: Date | string | null
    Payload?: string | null
    Properties?: string | null
    RedemptionDate?: Date | string | null
    ReferenceId?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
  }

  export type OIDCTokensCreateOrConnectWithoutOIDCAuthorizationsInput = {
    where: OIDCTokensWhereUniqueInput
    create: XOR<OIDCTokensCreateWithoutOIDCAuthorizationsInput, OIDCTokensUncheckedCreateWithoutOIDCAuthorizationsInput>
  }

  export type OIDCTokensCreateManyOIDCAuthorizationsInputEnvelope = {
    data: Enumerable<OIDCTokensCreateManyOIDCAuthorizationsInput>
  }

  export type OIDCApplicationsUpsertWithoutOIDCAuthorizationsInput = {
    update: XOR<OIDCApplicationsUpdateWithoutOIDCAuthorizationsInput, OIDCApplicationsUncheckedUpdateWithoutOIDCAuthorizationsInput>
    create: XOR<OIDCApplicationsCreateWithoutOIDCAuthorizationsInput, OIDCApplicationsUncheckedCreateWithoutOIDCAuthorizationsInput>
  }

  export type OIDCApplicationsUpdateWithoutOIDCAuthorizationsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ClientId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    ConsentType?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayNames?: NullableStringFieldUpdateOperationsInput | string | null
    Permissions?: NullableStringFieldUpdateOperationsInput | string | null
    PostLogoutRedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Requirements?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCTokens?: OIDCTokensUpdateManyWithoutOIDCApplicationsInput
  }

  export type OIDCApplicationsUncheckedUpdateWithoutOIDCAuthorizationsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ClientId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    ConsentType?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayNames?: NullableStringFieldUpdateOperationsInput | string | null
    Permissions?: NullableStringFieldUpdateOperationsInput | string | null
    PostLogoutRedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Requirements?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCTokens?: OIDCTokensUncheckedUpdateManyWithoutOIDCApplicationsInput
  }

  export type OIDCTokensUpsertWithWhereUniqueWithoutOIDCAuthorizationsInput = {
    where: OIDCTokensWhereUniqueInput
    update: XOR<OIDCTokensUpdateWithoutOIDCAuthorizationsInput, OIDCTokensUncheckedUpdateWithoutOIDCAuthorizationsInput>
    create: XOR<OIDCTokensCreateWithoutOIDCAuthorizationsInput, OIDCTokensUncheckedCreateWithoutOIDCAuthorizationsInput>
  }

  export type OIDCTokensUpdateWithWhereUniqueWithoutOIDCAuthorizationsInput = {
    where: OIDCTokensWhereUniqueInput
    data: XOR<OIDCTokensUpdateWithoutOIDCAuthorizationsInput, OIDCTokensUncheckedUpdateWithoutOIDCAuthorizationsInput>
  }

  export type OIDCTokensUpdateManyWithWhereWithoutOIDCAuthorizationsInput = {
    where: OIDCTokensScalarWhereInput
    data: XOR<OIDCTokensUpdateManyMutationInput, OIDCTokensUncheckedUpdateManyWithoutOIDCTokensInput>
  }

  export type OIDCApplicationsCreateWithoutOIDCTokensInput = {
    Id: string
    ClientId?: string | null
    ClientSecret?: string | null
    ConcurrencyToken?: string | null
    ConsentType?: string | null
    DisplayName?: string | null
    DisplayNames?: string | null
    Permissions?: string | null
    PostLogoutRedirectUris?: string | null
    Properties?: string | null
    RedirectUris?: string | null
    Requirements?: string | null
    Type?: string | null
    OIDCAuthorizations?: OIDCAuthorizationsCreateNestedManyWithoutOIDCApplicationsInput
  }

  export type OIDCApplicationsUncheckedCreateWithoutOIDCTokensInput = {
    Id: string
    ClientId?: string | null
    ClientSecret?: string | null
    ConcurrencyToken?: string | null
    ConsentType?: string | null
    DisplayName?: string | null
    DisplayNames?: string | null
    Permissions?: string | null
    PostLogoutRedirectUris?: string | null
    Properties?: string | null
    RedirectUris?: string | null
    Requirements?: string | null
    Type?: string | null
    OIDCAuthorizations?: OIDCAuthorizationsUncheckedCreateNestedManyWithoutOIDCApplicationsInput
  }

  export type OIDCApplicationsCreateOrConnectWithoutOIDCTokensInput = {
    where: OIDCApplicationsWhereUniqueInput
    create: XOR<OIDCApplicationsCreateWithoutOIDCTokensInput, OIDCApplicationsUncheckedCreateWithoutOIDCTokensInput>
  }

  export type OIDCAuthorizationsCreateWithoutOIDCTokensInput = {
    Id: string
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    Properties?: string | null
    Scopes?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
    OIDCApplications?: OIDCApplicationsCreateNestedOneWithoutOIDCAuthorizationsInput
  }

  export type OIDCAuthorizationsUncheckedCreateWithoutOIDCTokensInput = {
    Id: string
    ApplicationId?: string | null
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    Properties?: string | null
    Scopes?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
  }

  export type OIDCAuthorizationsCreateOrConnectWithoutOIDCTokensInput = {
    where: OIDCAuthorizationsWhereUniqueInput
    create: XOR<OIDCAuthorizationsCreateWithoutOIDCTokensInput, OIDCAuthorizationsUncheckedCreateWithoutOIDCTokensInput>
  }

  export type OIDCApplicationsUpsertWithoutOIDCTokensInput = {
    update: XOR<OIDCApplicationsUpdateWithoutOIDCTokensInput, OIDCApplicationsUncheckedUpdateWithoutOIDCTokensInput>
    create: XOR<OIDCApplicationsCreateWithoutOIDCTokensInput, OIDCApplicationsUncheckedCreateWithoutOIDCTokensInput>
  }

  export type OIDCApplicationsUpdateWithoutOIDCTokensInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ClientId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    ConsentType?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayNames?: NullableStringFieldUpdateOperationsInput | string | null
    Permissions?: NullableStringFieldUpdateOperationsInput | string | null
    PostLogoutRedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Requirements?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCAuthorizations?: OIDCAuthorizationsUpdateManyWithoutOIDCApplicationsInput
  }

  export type OIDCApplicationsUncheckedUpdateWithoutOIDCTokensInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ClientId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    ConsentType?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayNames?: NullableStringFieldUpdateOperationsInput | string | null
    Permissions?: NullableStringFieldUpdateOperationsInput | string | null
    PostLogoutRedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedirectUris?: NullableStringFieldUpdateOperationsInput | string | null
    Requirements?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCAuthorizations?: OIDCAuthorizationsUncheckedUpdateManyWithoutOIDCApplicationsInput
  }

  export type OIDCAuthorizationsUpsertWithoutOIDCTokensInput = {
    update: XOR<OIDCAuthorizationsUpdateWithoutOIDCTokensInput, OIDCAuthorizationsUncheckedUpdateWithoutOIDCTokensInput>
    create: XOR<OIDCAuthorizationsCreateWithoutOIDCTokensInput, OIDCAuthorizationsUncheckedCreateWithoutOIDCTokensInput>
  }

  export type OIDCAuthorizationsUpdateWithoutOIDCTokensInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    Scopes?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCApplications?: OIDCApplicationsUpdateOneWithoutOIDCAuthorizationsInput
  }

  export type OIDCAuthorizationsUncheckedUpdateWithoutOIDCTokensInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ApplicationId?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    Scopes?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersCreateWithoutUserIdentityClaimsInput = {
    Id: string
    LDAPConnection_Id?: string | null
    FirstName?: string | null
    LastName?: string | null
    UserRole_Id?: string | null
    Status?: string | null
    EmailId?: string | null
    Password?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Description?: string | null
    ProfileImage?: string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    RegistrationMode?: string | null
    Timezone?: string | null
    IsPasswordSet?: number | null
    IsAdmin?: number | null
    ShowHelpText?: number | null
    IdentityProvider_Id?: string | null
    SecPhrase?: string | null
    IsReadOnly?: number
    UserIdentityRole?: string | null
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed?: boolean | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed?: boolean | null
    PasswordHash?: string | null
    TwoFactorEnabled?: boolean | null
    LockoutEnd?: Date | string | null
    LockoutEnabled?: boolean | null
    AccessFailedCount?: number | null
    UserIdentityLogins?: UserIdentityLoginsCreateNestedManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesCreateNestedManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUserIdentityClaimsInput = {
    Id: string
    LDAPConnection_Id?: string | null
    FirstName?: string | null
    LastName?: string | null
    UserRole_Id?: string | null
    Status?: string | null
    EmailId?: string | null
    Password?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Description?: string | null
    ProfileImage?: string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    RegistrationMode?: string | null
    Timezone?: string | null
    IsPasswordSet?: number | null
    IsAdmin?: number | null
    ShowHelpText?: number | null
    IdentityProvider_Id?: string | null
    SecPhrase?: string | null
    IsReadOnly?: number
    UserIdentityRole?: string | null
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed?: boolean | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed?: boolean | null
    PasswordHash?: string | null
    TwoFactorEnabled?: boolean | null
    LockoutEnd?: Date | string | null
    LockoutEnabled?: boolean | null
    AccessFailedCount?: number | null
    UserIdentityLogins?: UserIdentityLoginsUncheckedCreateNestedManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesUncheckedCreateNestedManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUserIdentityClaimsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserIdentityClaimsInput, UsersUncheckedCreateWithoutUserIdentityClaimsInput>
  }

  export type UsersUpsertWithoutUserIdentityClaimsInput = {
    update: XOR<UsersUpdateWithoutUserIdentityClaimsInput, UsersUncheckedUpdateWithoutUserIdentityClaimsInput>
    create: XOR<UsersCreateWithoutUserIdentityClaimsInput, UsersUncheckedCreateWithoutUserIdentityClaimsInput>
  }

  export type UsersUpdateWithoutUserIdentityClaimsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    LDAPConnection_Id?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    UserRole_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    EmailId?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationMode?: NullableStringFieldUpdateOperationsInput | string | null
    Timezone?: NullableStringFieldUpdateOperationsInput | string | null
    IsPasswordSet?: NullableIntFieldUpdateOperationsInput | number | null
    IsAdmin?: NullableIntFieldUpdateOperationsInput | number | null
    ShowHelpText?: NullableIntFieldUpdateOperationsInput | number | null
    IdentityProvider_Id?: NullableStringFieldUpdateOperationsInput | string | null
    SecPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    UserIdentityRole?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    TwoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AccessFailedCount?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentityLogins?: UserIdentityLoginsUpdateManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesUpdateManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensUpdateManyWithoutUsersInput
  }

  export type UsersUncheckedUpdateWithoutUserIdentityClaimsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    LDAPConnection_Id?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    UserRole_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    EmailId?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationMode?: NullableStringFieldUpdateOperationsInput | string | null
    Timezone?: NullableStringFieldUpdateOperationsInput | string | null
    IsPasswordSet?: NullableIntFieldUpdateOperationsInput | number | null
    IsAdmin?: NullableIntFieldUpdateOperationsInput | number | null
    ShowHelpText?: NullableIntFieldUpdateOperationsInput | number | null
    IdentityProvider_Id?: NullableStringFieldUpdateOperationsInput | string | null
    SecPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    UserIdentityRole?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    TwoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AccessFailedCount?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentityLogins?: UserIdentityLoginsUncheckedUpdateManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesUncheckedUpdateManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensUncheckedUpdateManyWithoutUsersInput
  }

  export type UsersCreateWithoutUserIdentityLoginsInput = {
    Id: string
    LDAPConnection_Id?: string | null
    FirstName?: string | null
    LastName?: string | null
    UserRole_Id?: string | null
    Status?: string | null
    EmailId?: string | null
    Password?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Description?: string | null
    ProfileImage?: string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    RegistrationMode?: string | null
    Timezone?: string | null
    IsPasswordSet?: number | null
    IsAdmin?: number | null
    ShowHelpText?: number | null
    IdentityProvider_Id?: string | null
    SecPhrase?: string | null
    IsReadOnly?: number
    UserIdentityRole?: string | null
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed?: boolean | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed?: boolean | null
    PasswordHash?: string | null
    TwoFactorEnabled?: boolean | null
    LockoutEnd?: Date | string | null
    LockoutEnabled?: boolean | null
    AccessFailedCount?: number | null
    UserIdentityClaims?: UserIdentityClaimsCreateNestedManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesCreateNestedManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUserIdentityLoginsInput = {
    Id: string
    LDAPConnection_Id?: string | null
    FirstName?: string | null
    LastName?: string | null
    UserRole_Id?: string | null
    Status?: string | null
    EmailId?: string | null
    Password?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Description?: string | null
    ProfileImage?: string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    RegistrationMode?: string | null
    Timezone?: string | null
    IsPasswordSet?: number | null
    IsAdmin?: number | null
    ShowHelpText?: number | null
    IdentityProvider_Id?: string | null
    SecPhrase?: string | null
    IsReadOnly?: number
    UserIdentityRole?: string | null
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed?: boolean | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed?: boolean | null
    PasswordHash?: string | null
    TwoFactorEnabled?: boolean | null
    LockoutEnd?: Date | string | null
    LockoutEnabled?: boolean | null
    AccessFailedCount?: number | null
    UserIdentityClaims?: UserIdentityClaimsUncheckedCreateNestedManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesUncheckedCreateNestedManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUserIdentityLoginsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserIdentityLoginsInput, UsersUncheckedCreateWithoutUserIdentityLoginsInput>
  }

  export type UsersUpsertWithoutUserIdentityLoginsInput = {
    update: XOR<UsersUpdateWithoutUserIdentityLoginsInput, UsersUncheckedUpdateWithoutUserIdentityLoginsInput>
    create: XOR<UsersCreateWithoutUserIdentityLoginsInput, UsersUncheckedCreateWithoutUserIdentityLoginsInput>
  }

  export type UsersUpdateWithoutUserIdentityLoginsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    LDAPConnection_Id?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    UserRole_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    EmailId?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationMode?: NullableStringFieldUpdateOperationsInput | string | null
    Timezone?: NullableStringFieldUpdateOperationsInput | string | null
    IsPasswordSet?: NullableIntFieldUpdateOperationsInput | number | null
    IsAdmin?: NullableIntFieldUpdateOperationsInput | number | null
    ShowHelpText?: NullableIntFieldUpdateOperationsInput | number | null
    IdentityProvider_Id?: NullableStringFieldUpdateOperationsInput | string | null
    SecPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    UserIdentityRole?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    TwoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AccessFailedCount?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentityClaims?: UserIdentityClaimsUpdateManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesUpdateManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensUpdateManyWithoutUsersInput
  }

  export type UsersUncheckedUpdateWithoutUserIdentityLoginsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    LDAPConnection_Id?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    UserRole_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    EmailId?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationMode?: NullableStringFieldUpdateOperationsInput | string | null
    Timezone?: NullableStringFieldUpdateOperationsInput | string | null
    IsPasswordSet?: NullableIntFieldUpdateOperationsInput | number | null
    IsAdmin?: NullableIntFieldUpdateOperationsInput | number | null
    ShowHelpText?: NullableIntFieldUpdateOperationsInput | number | null
    IdentityProvider_Id?: NullableStringFieldUpdateOperationsInput | string | null
    SecPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    UserIdentityRole?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    TwoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AccessFailedCount?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentityClaims?: UserIdentityClaimsUncheckedUpdateManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesUncheckedUpdateManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensUncheckedUpdateManyWithoutUsersInput
  }

  export type AppIdentityRolesCreateWithoutUserIdentityRoleClaimsInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    UserIdentityRoles?: UserIdentityRolesCreateNestedManyWithoutAppIdentityRolesInput
  }

  export type AppIdentityRolesUncheckedCreateWithoutUserIdentityRoleClaimsInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    UserIdentityRoles?: UserIdentityRolesUncheckedCreateNestedManyWithoutAppIdentityRolesInput
  }

  export type AppIdentityRolesCreateOrConnectWithoutUserIdentityRoleClaimsInput = {
    where: AppIdentityRolesWhereUniqueInput
    create: XOR<AppIdentityRolesCreateWithoutUserIdentityRoleClaimsInput, AppIdentityRolesUncheckedCreateWithoutUserIdentityRoleClaimsInput>
  }

  export type AppIdentityRolesUpsertWithoutUserIdentityRoleClaimsInput = {
    update: XOR<AppIdentityRolesUpdateWithoutUserIdentityRoleClaimsInput, AppIdentityRolesUncheckedUpdateWithoutUserIdentityRoleClaimsInput>
    create: XOR<AppIdentityRolesCreateWithoutUserIdentityRoleClaimsInput, AppIdentityRolesUncheckedCreateWithoutUserIdentityRoleClaimsInput>
  }

  export type AppIdentityRolesUpdateWithoutUserIdentityRoleClaimsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    UserIdentityRoles?: UserIdentityRolesUpdateManyWithoutAppIdentityRolesInput
  }

  export type AppIdentityRolesUncheckedUpdateWithoutUserIdentityRoleClaimsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    UserIdentityRoles?: UserIdentityRolesUncheckedUpdateManyWithoutAppIdentityRolesInput
  }

  export type AppIdentityRolesCreateWithoutUserIdentityRolesInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    UserIdentityRoleClaims?: UserIdentityRoleClaimsCreateNestedManyWithoutAppIdentityRolesInput
  }

  export type AppIdentityRolesUncheckedCreateWithoutUserIdentityRolesInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    UserIdentityRoleClaims?: UserIdentityRoleClaimsUncheckedCreateNestedManyWithoutAppIdentityRolesInput
  }

  export type AppIdentityRolesCreateOrConnectWithoutUserIdentityRolesInput = {
    where: AppIdentityRolesWhereUniqueInput
    create: XOR<AppIdentityRolesCreateWithoutUserIdentityRolesInput, AppIdentityRolesUncheckedCreateWithoutUserIdentityRolesInput>
  }

  export type UsersCreateWithoutUserIdentityRolesInput = {
    Id: string
    LDAPConnection_Id?: string | null
    FirstName?: string | null
    LastName?: string | null
    UserRole_Id?: string | null
    Status?: string | null
    EmailId?: string | null
    Password?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Description?: string | null
    ProfileImage?: string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    RegistrationMode?: string | null
    Timezone?: string | null
    IsPasswordSet?: number | null
    IsAdmin?: number | null
    ShowHelpText?: number | null
    IdentityProvider_Id?: string | null
    SecPhrase?: string | null
    IsReadOnly?: number
    UserIdentityRole?: string | null
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed?: boolean | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed?: boolean | null
    PasswordHash?: string | null
    TwoFactorEnabled?: boolean | null
    LockoutEnd?: Date | string | null
    LockoutEnabled?: boolean | null
    AccessFailedCount?: number | null
    UserIdentityClaims?: UserIdentityClaimsCreateNestedManyWithoutUsersInput
    UserIdentityLogins?: UserIdentityLoginsCreateNestedManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUserIdentityRolesInput = {
    Id: string
    LDAPConnection_Id?: string | null
    FirstName?: string | null
    LastName?: string | null
    UserRole_Id?: string | null
    Status?: string | null
    EmailId?: string | null
    Password?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Description?: string | null
    ProfileImage?: string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    RegistrationMode?: string | null
    Timezone?: string | null
    IsPasswordSet?: number | null
    IsAdmin?: number | null
    ShowHelpText?: number | null
    IdentityProvider_Id?: string | null
    SecPhrase?: string | null
    IsReadOnly?: number
    UserIdentityRole?: string | null
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed?: boolean | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed?: boolean | null
    PasswordHash?: string | null
    TwoFactorEnabled?: boolean | null
    LockoutEnd?: Date | string | null
    LockoutEnabled?: boolean | null
    AccessFailedCount?: number | null
    UserIdentityClaims?: UserIdentityClaimsUncheckedCreateNestedManyWithoutUsersInput
    UserIdentityLogins?: UserIdentityLoginsUncheckedCreateNestedManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUserIdentityRolesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserIdentityRolesInput, UsersUncheckedCreateWithoutUserIdentityRolesInput>
  }

  export type AppIdentityRolesUpsertWithoutUserIdentityRolesInput = {
    update: XOR<AppIdentityRolesUpdateWithoutUserIdentityRolesInput, AppIdentityRolesUncheckedUpdateWithoutUserIdentityRolesInput>
    create: XOR<AppIdentityRolesCreateWithoutUserIdentityRolesInput, AppIdentityRolesUncheckedCreateWithoutUserIdentityRolesInput>
  }

  export type AppIdentityRolesUpdateWithoutUserIdentityRolesInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    UserIdentityRoleClaims?: UserIdentityRoleClaimsUpdateManyWithoutAppIdentityRolesInput
  }

  export type AppIdentityRolesUncheckedUpdateWithoutUserIdentityRolesInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    UserIdentityRoleClaims?: UserIdentityRoleClaimsUncheckedUpdateManyWithoutAppIdentityRolesInput
  }

  export type UsersUpsertWithoutUserIdentityRolesInput = {
    update: XOR<UsersUpdateWithoutUserIdentityRolesInput, UsersUncheckedUpdateWithoutUserIdentityRolesInput>
    create: XOR<UsersCreateWithoutUserIdentityRolesInput, UsersUncheckedCreateWithoutUserIdentityRolesInput>
  }

  export type UsersUpdateWithoutUserIdentityRolesInput = {
    Id?: StringFieldUpdateOperationsInput | string
    LDAPConnection_Id?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    UserRole_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    EmailId?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationMode?: NullableStringFieldUpdateOperationsInput | string | null
    Timezone?: NullableStringFieldUpdateOperationsInput | string | null
    IsPasswordSet?: NullableIntFieldUpdateOperationsInput | number | null
    IsAdmin?: NullableIntFieldUpdateOperationsInput | number | null
    ShowHelpText?: NullableIntFieldUpdateOperationsInput | number | null
    IdentityProvider_Id?: NullableStringFieldUpdateOperationsInput | string | null
    SecPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    UserIdentityRole?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    TwoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AccessFailedCount?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentityClaims?: UserIdentityClaimsUpdateManyWithoutUsersInput
    UserIdentityLogins?: UserIdentityLoginsUpdateManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensUpdateManyWithoutUsersInput
  }

  export type UsersUncheckedUpdateWithoutUserIdentityRolesInput = {
    Id?: StringFieldUpdateOperationsInput | string
    LDAPConnection_Id?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    UserRole_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    EmailId?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationMode?: NullableStringFieldUpdateOperationsInput | string | null
    Timezone?: NullableStringFieldUpdateOperationsInput | string | null
    IsPasswordSet?: NullableIntFieldUpdateOperationsInput | number | null
    IsAdmin?: NullableIntFieldUpdateOperationsInput | number | null
    ShowHelpText?: NullableIntFieldUpdateOperationsInput | number | null
    IdentityProvider_Id?: NullableStringFieldUpdateOperationsInput | string | null
    SecPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    UserIdentityRole?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    TwoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AccessFailedCount?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentityClaims?: UserIdentityClaimsUncheckedUpdateManyWithoutUsersInput
    UserIdentityLogins?: UserIdentityLoginsUncheckedUpdateManyWithoutUsersInput
    UserIdentityTokens?: UserIdentityTokensUncheckedUpdateManyWithoutUsersInput
  }

  export type UsersCreateWithoutUserIdentityTokensInput = {
    Id: string
    LDAPConnection_Id?: string | null
    FirstName?: string | null
    LastName?: string | null
    UserRole_Id?: string | null
    Status?: string | null
    EmailId?: string | null
    Password?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Description?: string | null
    ProfileImage?: string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    RegistrationMode?: string | null
    Timezone?: string | null
    IsPasswordSet?: number | null
    IsAdmin?: number | null
    ShowHelpText?: number | null
    IdentityProvider_Id?: string | null
    SecPhrase?: string | null
    IsReadOnly?: number
    UserIdentityRole?: string | null
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed?: boolean | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed?: boolean | null
    PasswordHash?: string | null
    TwoFactorEnabled?: boolean | null
    LockoutEnd?: Date | string | null
    LockoutEnabled?: boolean | null
    AccessFailedCount?: number | null
    UserIdentityClaims?: UserIdentityClaimsCreateNestedManyWithoutUsersInput
    UserIdentityLogins?: UserIdentityLoginsCreateNestedManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUserIdentityTokensInput = {
    Id: string
    LDAPConnection_Id?: string | null
    FirstName?: string | null
    LastName?: string | null
    UserRole_Id?: string | null
    Status?: string | null
    EmailId?: string | null
    Password?: string | null
    CreatedDate?: Date | string | null
    ModifiedDate?: Date | string | null
    Description?: string | null
    ProfileImage?: string | null
    CreatedBy?: string | null
    ModifiedBy?: string | null
    RegistrationMode?: string | null
    Timezone?: string | null
    IsPasswordSet?: number | null
    IsAdmin?: number | null
    ShowHelpText?: number | null
    IdentityProvider_Id?: string | null
    SecPhrase?: string | null
    IsReadOnly?: number
    UserIdentityRole?: string | null
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed?: boolean | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed?: boolean | null
    PasswordHash?: string | null
    TwoFactorEnabled?: boolean | null
    LockoutEnd?: Date | string | null
    LockoutEnabled?: boolean | null
    AccessFailedCount?: number | null
    UserIdentityClaims?: UserIdentityClaimsUncheckedCreateNestedManyWithoutUsersInput
    UserIdentityLogins?: UserIdentityLoginsUncheckedCreateNestedManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUserIdentityTokensInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserIdentityTokensInput, UsersUncheckedCreateWithoutUserIdentityTokensInput>
  }

  export type UsersUpsertWithoutUserIdentityTokensInput = {
    update: XOR<UsersUpdateWithoutUserIdentityTokensInput, UsersUncheckedUpdateWithoutUserIdentityTokensInput>
    create: XOR<UsersCreateWithoutUserIdentityTokensInput, UsersUncheckedCreateWithoutUserIdentityTokensInput>
  }

  export type UsersUpdateWithoutUserIdentityTokensInput = {
    Id?: StringFieldUpdateOperationsInput | string
    LDAPConnection_Id?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    UserRole_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    EmailId?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationMode?: NullableStringFieldUpdateOperationsInput | string | null
    Timezone?: NullableStringFieldUpdateOperationsInput | string | null
    IsPasswordSet?: NullableIntFieldUpdateOperationsInput | number | null
    IsAdmin?: NullableIntFieldUpdateOperationsInput | number | null
    ShowHelpText?: NullableIntFieldUpdateOperationsInput | number | null
    IdentityProvider_Id?: NullableStringFieldUpdateOperationsInput | string | null
    SecPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    UserIdentityRole?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    TwoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AccessFailedCount?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentityClaims?: UserIdentityClaimsUpdateManyWithoutUsersInput
    UserIdentityLogins?: UserIdentityLoginsUpdateManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesUpdateManyWithoutUsersInput
  }

  export type UsersUncheckedUpdateWithoutUserIdentityTokensInput = {
    Id?: StringFieldUpdateOperationsInput | string
    LDAPConnection_Id?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    UserRole_Id?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    EmailId?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationMode?: NullableStringFieldUpdateOperationsInput | string | null
    Timezone?: NullableStringFieldUpdateOperationsInput | string | null
    IsPasswordSet?: NullableIntFieldUpdateOperationsInput | number | null
    IsAdmin?: NullableIntFieldUpdateOperationsInput | number | null
    ShowHelpText?: NullableIntFieldUpdateOperationsInput | number | null
    IdentityProvider_Id?: NullableStringFieldUpdateOperationsInput | string | null
    SecPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    IsReadOnly?: IntFieldUpdateOperationsInput | number
    UserIdentityRole?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    TwoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AccessFailedCount?: NullableIntFieldUpdateOperationsInput | number | null
    UserIdentityClaims?: UserIdentityClaimsUncheckedUpdateManyWithoutUsersInput
    UserIdentityLogins?: UserIdentityLoginsUncheckedUpdateManyWithoutUsersInput
    UserIdentityRoles?: UserIdentityRolesUncheckedUpdateManyWithoutUsersInput
  }

  export type UserIdentityClaimsCreateWithoutUsersInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type UserIdentityClaimsUncheckedCreateWithoutUsersInput = {
    Id?: number
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type UserIdentityClaimsCreateOrConnectWithoutUsersInput = {
    where: UserIdentityClaimsWhereUniqueInput
    create: XOR<UserIdentityClaimsCreateWithoutUsersInput, UserIdentityClaimsUncheckedCreateWithoutUsersInput>
  }

  export type UserIdentityClaimsCreateManyUsersInputEnvelope = {
    data: Enumerable<UserIdentityClaimsCreateManyUsersInput>
  }

  export type UserIdentityLoginsCreateWithoutUsersInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
  }

  export type UserIdentityLoginsUncheckedCreateWithoutUsersInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
  }

  export type UserIdentityLoginsCreateOrConnectWithoutUsersInput = {
    where: UserIdentityLoginsWhereUniqueInput
    create: XOR<UserIdentityLoginsCreateWithoutUsersInput, UserIdentityLoginsUncheckedCreateWithoutUsersInput>
  }

  export type UserIdentityLoginsCreateManyUsersInputEnvelope = {
    data: Enumerable<UserIdentityLoginsCreateManyUsersInput>
  }

  export type UserIdentityRolesCreateWithoutUsersInput = {
    AppIdentityRoles: AppIdentityRolesCreateNestedOneWithoutUserIdentityRolesInput
  }

  export type UserIdentityRolesUncheckedCreateWithoutUsersInput = {
    RoleId: string
  }

  export type UserIdentityRolesCreateOrConnectWithoutUsersInput = {
    where: UserIdentityRolesWhereUniqueInput
    create: XOR<UserIdentityRolesCreateWithoutUsersInput, UserIdentityRolesUncheckedCreateWithoutUsersInput>
  }

  export type UserIdentityRolesCreateManyUsersInputEnvelope = {
    data: Enumerable<UserIdentityRolesCreateManyUsersInput>
  }

  export type UserIdentityTokensCreateWithoutUsersInput = {
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type UserIdentityTokensUncheckedCreateWithoutUsersInput = {
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type UserIdentityTokensCreateOrConnectWithoutUsersInput = {
    where: UserIdentityTokensWhereUniqueInput
    create: XOR<UserIdentityTokensCreateWithoutUsersInput, UserIdentityTokensUncheckedCreateWithoutUsersInput>
  }

  export type UserIdentityTokensCreateManyUsersInputEnvelope = {
    data: Enumerable<UserIdentityTokensCreateManyUsersInput>
  }

  export type UserIdentityClaimsUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserIdentityClaimsWhereUniqueInput
    update: XOR<UserIdentityClaimsUpdateWithoutUsersInput, UserIdentityClaimsUncheckedUpdateWithoutUsersInput>
    create: XOR<UserIdentityClaimsCreateWithoutUsersInput, UserIdentityClaimsUncheckedCreateWithoutUsersInput>
  }

  export type UserIdentityClaimsUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserIdentityClaimsWhereUniqueInput
    data: XOR<UserIdentityClaimsUpdateWithoutUsersInput, UserIdentityClaimsUncheckedUpdateWithoutUsersInput>
  }

  export type UserIdentityClaimsUpdateManyWithWhereWithoutUsersInput = {
    where: UserIdentityClaimsScalarWhereInput
    data: XOR<UserIdentityClaimsUpdateManyMutationInput, UserIdentityClaimsUncheckedUpdateManyWithoutUserIdentityClaimsInput>
  }

  export type UserIdentityClaimsScalarWhereInput = {
    AND?: Enumerable<UserIdentityClaimsScalarWhereInput>
    OR?: Enumerable<UserIdentityClaimsScalarWhereInput>
    NOT?: Enumerable<UserIdentityClaimsScalarWhereInput>
    Id?: IntFilter | number
    UserId?: StringFilter | string
    ClaimType?: StringNullableFilter | string | null
    ClaimValue?: StringNullableFilter | string | null
  }

  export type UserIdentityLoginsUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserIdentityLoginsWhereUniqueInput
    update: XOR<UserIdentityLoginsUpdateWithoutUsersInput, UserIdentityLoginsUncheckedUpdateWithoutUsersInput>
    create: XOR<UserIdentityLoginsCreateWithoutUsersInput, UserIdentityLoginsUncheckedCreateWithoutUsersInput>
  }

  export type UserIdentityLoginsUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserIdentityLoginsWhereUniqueInput
    data: XOR<UserIdentityLoginsUpdateWithoutUsersInput, UserIdentityLoginsUncheckedUpdateWithoutUsersInput>
  }

  export type UserIdentityLoginsUpdateManyWithWhereWithoutUsersInput = {
    where: UserIdentityLoginsScalarWhereInput
    data: XOR<UserIdentityLoginsUpdateManyMutationInput, UserIdentityLoginsUncheckedUpdateManyWithoutUserIdentityLoginsInput>
  }

  export type UserIdentityLoginsScalarWhereInput = {
    AND?: Enumerable<UserIdentityLoginsScalarWhereInput>
    OR?: Enumerable<UserIdentityLoginsScalarWhereInput>
    NOT?: Enumerable<UserIdentityLoginsScalarWhereInput>
    LoginProvider?: StringFilter | string
    ProviderKey?: StringFilter | string
    ProviderDisplayName?: StringNullableFilter | string | null
    UserId?: StringFilter | string
  }

  export type UserIdentityRolesUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserIdentityRolesWhereUniqueInput
    update: XOR<UserIdentityRolesUpdateWithoutUsersInput, UserIdentityRolesUncheckedUpdateWithoutUsersInput>
    create: XOR<UserIdentityRolesCreateWithoutUsersInput, UserIdentityRolesUncheckedCreateWithoutUsersInput>
  }

  export type UserIdentityRolesUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserIdentityRolesWhereUniqueInput
    data: XOR<UserIdentityRolesUpdateWithoutUsersInput, UserIdentityRolesUncheckedUpdateWithoutUsersInput>
  }

  export type UserIdentityRolesUpdateManyWithWhereWithoutUsersInput = {
    where: UserIdentityRolesScalarWhereInput
    data: XOR<UserIdentityRolesUpdateManyMutationInput, UserIdentityRolesUncheckedUpdateManyWithoutUserIdentityRolesInput>
  }

  export type UserIdentityTokensUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserIdentityTokensWhereUniqueInput
    update: XOR<UserIdentityTokensUpdateWithoutUsersInput, UserIdentityTokensUncheckedUpdateWithoutUsersInput>
    create: XOR<UserIdentityTokensCreateWithoutUsersInput, UserIdentityTokensUncheckedCreateWithoutUsersInput>
  }

  export type UserIdentityTokensUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserIdentityTokensWhereUniqueInput
    data: XOR<UserIdentityTokensUpdateWithoutUsersInput, UserIdentityTokensUncheckedUpdateWithoutUsersInput>
  }

  export type UserIdentityTokensUpdateManyWithWhereWithoutUsersInput = {
    where: UserIdentityTokensScalarWhereInput
    data: XOR<UserIdentityTokensUpdateManyMutationInput, UserIdentityTokensUncheckedUpdateManyWithoutUserIdentityTokensInput>
  }

  export type UserIdentityTokensScalarWhereInput = {
    AND?: Enumerable<UserIdentityTokensScalarWhereInput>
    OR?: Enumerable<UserIdentityTokensScalarWhereInput>
    NOT?: Enumerable<UserIdentityTokensScalarWhereInput>
    UserId?: StringFilter | string
    LoginProvider?: StringFilter | string
    Name?: StringFilter | string
    Value?: StringNullableFilter | string | null
  }

  export type UserIdentityRoleClaimsCreateManyAppIdentityRolesInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type UserIdentityRolesCreateManyAppIdentityRolesInput = {
    UserId: string
  }

  export type UserIdentityRoleClaimsUpdateWithoutAppIdentityRolesInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityRoleClaimsUncheckedUpdateWithoutAppIdentityRolesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityRoleClaimsUncheckedUpdateManyWithoutUserIdentityRoleClaimsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityRolesUpdateWithoutAppIdentityRolesInput = {
    Users?: UsersUpdateOneRequiredWithoutUserIdentityRolesInput
  }

  export type UserIdentityRolesUncheckedUpdateWithoutAppIdentityRolesInput = {
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type UserIdentityRolesUncheckedUpdateManyWithoutUserIdentityRolesInput = {
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type OIDCAuthorizationsCreateManyOIDCApplicationsInput = {
    Id: string
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    Properties?: string | null
    Scopes?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
  }

  export type OIDCTokensCreateManyOIDCApplicationsInput = {
    Id: string
    AuthorizationId?: string | null
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    ExpirationDate?: Date | string | null
    Payload?: string | null
    Properties?: string | null
    RedemptionDate?: Date | string | null
    ReferenceId?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
  }

  export type OIDCAuthorizationsUpdateWithoutOIDCApplicationsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    Scopes?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCTokens?: OIDCTokensUpdateManyWithoutOIDCAuthorizationsInput
  }

  export type OIDCAuthorizationsUncheckedUpdateWithoutOIDCApplicationsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    Scopes?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCTokens?: OIDCTokensUncheckedUpdateManyWithoutOIDCAuthorizationsInput
  }

  export type OIDCAuthorizationsUncheckedUpdateManyWithoutOIDCAuthorizationsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    Scopes?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OIDCTokensUpdateWithoutOIDCApplicationsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Payload?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedemptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCAuthorizations?: OIDCAuthorizationsUpdateOneWithoutOIDCTokensInput
  }

  export type OIDCTokensUncheckedUpdateWithoutOIDCApplicationsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    AuthorizationId?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Payload?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedemptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OIDCTokensUncheckedUpdateManyWithoutOIDCTokensInput = {
    Id?: StringFieldUpdateOperationsInput | string
    AuthorizationId?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Payload?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedemptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OIDCTokensCreateManyOIDCAuthorizationsInput = {
    Id: string
    ApplicationId?: string | null
    ConcurrencyToken?: string | null
    CreationDate?: Date | string | null
    ExpirationDate?: Date | string | null
    Payload?: string | null
    Properties?: string | null
    RedemptionDate?: Date | string | null
    ReferenceId?: string | null
    Status?: string | null
    Subject?: string | null
    Type?: string | null
  }

  export type OIDCTokensUpdateWithoutOIDCAuthorizationsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Payload?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedemptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    OIDCApplications?: OIDCApplicationsUpdateOneWithoutOIDCTokensInput
  }

  export type OIDCTokensUncheckedUpdateWithoutOIDCAuthorizationsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    ApplicationId?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyToken?: NullableStringFieldUpdateOperationsInput | string | null
    CreationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Payload?: NullableStringFieldUpdateOperationsInput | string | null
    Properties?: NullableStringFieldUpdateOperationsInput | string | null
    RedemptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityClaimsCreateManyUsersInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type UserIdentityLoginsCreateManyUsersInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
  }

  export type UserIdentityRolesCreateManyUsersInput = {
    RoleId: string
  }

  export type UserIdentityTokensCreateManyUsersInput = {
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type UserIdentityClaimsUpdateWithoutUsersInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityClaimsUncheckedUpdateWithoutUsersInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityClaimsUncheckedUpdateManyWithoutUserIdentityClaimsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityLoginsUpdateWithoutUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityLoginsUncheckedUpdateWithoutUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityLoginsUncheckedUpdateManyWithoutUserIdentityLoginsInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityRolesUpdateWithoutUsersInput = {
    AppIdentityRoles?: AppIdentityRolesUpdateOneRequiredWithoutUserIdentityRolesInput
  }

  export type UserIdentityRolesUncheckedUpdateWithoutUsersInput = {
    RoleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserIdentityTokensUpdateWithoutUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityTokensUncheckedUpdateWithoutUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIdentityTokensUncheckedUpdateManyWithoutUserIdentityTokensInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}